(function () {
  'use strict';

  // 2014-20 - ntop.org
  Date.prototype.format = function (format) { //author: meizz
          var o = {
                  "M+": this.getMonth() + 1, //month
                  "d+": this.getDate(),    //day
                  "h+": this.getHours(),   //hour
                  "m+": this.getMinutes(), //minute
                  "s+": this.getSeconds(), //second
                  "q+": Math.floor((this.getMonth() + 3) / 3),  //quarter
                  "S": this.getMilliseconds() //millisecond
          };

          if (/(y+)/.test(format)) format = format.replace(RegExp.$1,
                  (this.getFullYear() + "").substr(4 - RegExp.$1.length));
          for (var k in o) if (new RegExp("(" + k + ")").test(format))
                  format = format.replace(RegExp.$1,
                          RegExp.$1.length == 1 ? o[k] :
                                  ("00" + o[k]).substr(("" + o[k]).length));
          return format;
  };

  // Extended disable function 
  jQuery.fn.extend({
          disable: function (state) {
                  return this.each(function () {
                          var $this = $(this);
                          if ($this.is('input, button, textarea, select'))
                                  this.disabled = state;
                          else
                                  $this.toggleClass('disabled', state);
                  });
          }
  });

  const NTOPNG_MIN_VISUAL_VALUE = 0.005;

  const REGEXES = {
          ipv4: String.raw`^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`,
          ipv6: String.raw`^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]):){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*)$`,
          domainName: String.raw`^([a-zA-Z]([a-zA-Z]|[0-9])?\.[a-zA-Z]{2,13}|[a-zA-Z0-9]([\-_.a-zA-Z0-9]{1,61}[a-zA-Z0-9])?\.[a-zA-Z]{2,13}|[a-zA-Z0-9]([\-_.a-zA-Z0-9]{1,61}[a-zA-Z0-9])?\.[a-zA-Z]{2,30}\.[a-zA-Z]{2,3})$`,
          port: String.raw`^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$`,
          latency: String.raw`^([0-9]*[.])?[0-9]+$`,
          url: String.raw`^(https?\:\/\/[^\/\s]+(\/.*)?)$`,
          emailUrl: String.raw`^smtps?:\/\/[\-a-zA-Z0-9:.]{1,256}$`,
          macAddress: String.raw`^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$`,
          hostname: String.raw`^(?!\s*$)[a-zA-Z0-9._: \-\/]{1,250}|^[a-zA-Z0-9._: \-\/]{1,250}@[0-9]{0,5}`,
          username: String.raw`^[a-zA-Z0-9._@!-?]{3,30}$`,
          singleword: String.raw`^(?=[a-zA-Z0-9._:\-]{3,253}$)(?!.*[_.:\-]{2})[^_.:\-].*[^_.:\-]$`,
          multiword: String.raw`^([a-zA-Z0-9._:\-\s]{3,253})$`,
          email: String.raw`^([a-zA-Z0-9.!#$%&'*+\-\/=?^_\`\|~]+@[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*)$|^[a-zA-Z\d.!#$%&'*+\-\/=?^_\`\|~]{1,128}$`,
          emailCommaList: String.raw`^((?:[a-zA-Z0-9.!#$%&'*+\-\/=?^_\`\|~]+@[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*)|([a-zA-Z\d.!#$%&'*+\-\/=?^_\`\|~]{1,128}))(?:,((?:[a-zA-Z0-9.!#$%&'*+\-\/=?^_\`\|~]+@[a-zA-Z0-9\-]+(?:\.[a-zA-Z0-9\-]+)*)|([a-zA-Z\d.!#$%&'*+\-\/=?^_\`\|~]{1,128})))*$`,
          https: String.raw`^https?:\/\/.+$`,
          token: String.raw`^[0-9a-f]{32}`,
          score: String.raw`^[0-9]{1,5}`,
          telegram_channel: String.raw`^[0-9\-]{1,15}`,
          password: String.raw`^[\w\/$!\/()=?^*@_-]{5,31}$`,
          tls_certificate: String.raw`^[^=,]+=[^=,]+(,\s[^=,]+=[^=,]+)*$`,
          domain_name_not_strict: String.raw`^[a-zA-Z0-9\-_~]+((\.[a-zA-Z0-9\-_~]+)+)$`,
          non_quoted_text: String.raw`^[a-zA-Z0-9.-_]+$`,
  };

  class NtopUtils$1 {

    /* Show an overlay to hide loading */
    static toggleOverlays(time = 500) {
      $(`.overlay`).toggle(time);
    }
    
    static showOverlays(time = 500) {
      $(`.overlay`).fadeIn(time);
    }
    
    static hideOverlays(time = 500) {
      $(`.overlay`).fadeOut(time);
    }

          static get REGEXES() {
                  return REGEXES;
          }

          static getIPv4RegexWithCIDR() {
                  const length = REGEXES.ipv4.length;
                  return `${REGEXES.ipv4.substring(0, length - 1)}(\\/?)(\\b([0-9]|[12][0-9]|3[0-2])?\\b)$`;
          }

          static getIPv6RegexWithCIDR() {
                  const length = REGEXES.ipv6.length;
                  return `${REGEXES.ipv6.substring(0, length - 1)}(\\/?)\\b([0-9]|[1-9][0-9]|1[01][0-9]|12[0-8])?\\b$`;
          }

          /**
           * Resolve a hostname by doing a DNS Resolve.
           * @param {string} hostname The hostname to resolve
           */
          static async resolveDNS(hostname = "ntop.org") {

                  // resolve the hostname by doing a fetch request to the backend
                  try {
                          const request = await fetch(`${http_prefix}/lua/rest/v2/get/dns/resolve.lua?hostname=${hostname}`);
                          const response = await request.json();
                          return response;
                  }
                  catch (err) {
                          // prints out the error if the request fails
                          console.error(`Something went wrong when resolving hostname: ${err}`);
                  }

                  // if the request has failed return a placeholder response
                  // indicating the failure
                  return { rc: -1, rc_str: "FAILED_HTTP_REQUEST" };
          }

          /**
           * Replace the inputs which contain the [data-pattern] attribute
           * with the [pattern] attribute.
           */
          static initDataPatterns() {
                  // for each input with the data-pattern attribute
                  // substitute the data-pattern with the right regexes
                  $(`input[data-pattern]`).each(function () {

                          // if the pattern is empty then print a warn inside the console
                          const dataPattern = $(this).data('pattern');
                          if (!dataPattern) {
                                  console.warn(`An empty data-pattern on an input was found!`, this);
                                  return;
                          }

                          // build the regexp pattern for the input
                          const pattern = dataPattern.split('|').map(p => REGEXES[p].toString()).join('|');
                          // load the pattern
                          $(this).attr('pattern', pattern);
                          // remove the data-pattern from the input
                          $(this).removeAttr('data-pattern');
                  });
          }

          static is_good_ipv4(ipv4) {
                  return new RegExp(REGEXES.ipv4).test(ipv4);
          }

          static is_good_ipv6(ipv6) {
                  return new RegExp(REGEXES.ipv6).test(ipv6);
          }

          static is_mac_address(mac) {
                  return new RegExp(REGEXES.macAddress).test(mac);
          }

          static isNumeric(value) {
                  return /^\d+$/.test(value);
          }

          static is_network_mask(what, optional_mask) {
                  var elems = what.split("/");
                  var mask = null;
                  var ip_addr;

                  if (elems.length != 2) {
                          if (!optional_mask)
                                  return null;
                          else
                                  ip_addr = what;
                  } else {
                          ip_addr = elems[0];

                          if (!NtopUtils$1.isNumeric(elems[1]))
                                  return null;

                          mask = parseInt(elems[1]);

                          if (mask < 0)
                                  return null;
                  }

                  if (NtopUtils$1.is_good_ipv4(ip_addr)) {
                          if (mask === null)
                                  mask = 32;
                          else if (mask > 32)
                                  return null;

                          return {
                                  type: "ipv4",
                                  address: ip_addr,
                                  mask: mask
                          };
                  } else if (NtopUtils$1.is_good_ipv6(elems[0])) {
                          if (mask === null)
                                  mask = 128;
                          else if (mask > 128)
                                  return (false);

                          return {
                                  type: "ipv6",
                                  address: ip_addr,
                                  mask: mask
                          };
                  }

                  return null;
          }

          static fbits(bits) {
                  const sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];

                  if (typeof (bits) === "undefined")
                          return "-";

                  if (bits == 0) return '0';
                  if ((bits > 0) && (bits < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' bps');
                  var bits_log1000 = Math.log(bits) / Math.log(1000);
                  var i = parseInt(Math.floor(bits_log1000));
                  if (i < 0 || isNaN(i)) {
                          i = 0;
                  } else if (i >= sizes.length) { // prevents overflows
                          return "> " + sizes[sizes.length - 1]
                  }

                  if (i <= 1) {
                          return Math.round(bits / Math.pow(1000, i) * 100) / 100 + ' ' + sizes[i]
                  } 
                  else {
                          var ret = parseFloat(bits / Math.pow(1000, i)).toFixed(2);
                          if (ret % 1 == 0)
                                  ret = Math.round(ret);
                          return ret + ' ' + sizes[i]
                  }
          }

          static export_rate(eps) {
                  if (typeof (eps) === "undefined")
                          return "-";

                  var sizes = ['exp/s', 'Kexp/s'];
                  if (eps == 0) return '0';
                  if ((eps > 0) && (eps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' exps/s');
                  var res = NtopUtils$1.scaleValue(eps, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static exports_format(exports) {
                  if (typeof (exports) === "undefined")
                          return "-";

                  var exports_label = i18n_ext.exports.toLowerCase();

                  var sizes = [exports_label, 'K ' + exports_label];
                  if (exports == 0) return '0';
                  if ((exports > 0) && (exports < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' exps/s');
                  var res = NtopUtils$1.scaleValue(exports, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fbits_from_bytes(bytes) {
                  if (typeof (bytes) === "undefined")
                          return "-";
                  return (NtopUtils$1.fbits(bytes * 8));
          }

          static fpackets(pps) {
                  if (typeof (pps) === "undefined")
                          return "-";

                  var sizes = ['pps', 'Kpps', 'Mpps', 'Gpps', 'Tpps'];
                  if (pps == 0) return '0';
                  if ((pps > 0) && (pps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' pps');
                  var res = NtopUtils$1.scaleValue(pps, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fpoints(pps) {
                  if (typeof (pps) === "undefined")
                          return "-";

                  var sizes = ['pt/s', 'Kpt/s', 'Mpt/s', 'Gpt/s', 'Tpt/s'];
                  if (pps == 0) return '0';
                  if ((pps > 0) && (pps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' pt/s');
                  var res = NtopUtils$1.scaleValue(pps, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fflows(fps) {
                  if (typeof (fps) === "undefined")
                          return "-";

                  var sizes = ['fps', 'Kfps', 'Mfps', 'Gfps', 'Tfps'];
                  if (fps == 0) return '0';
                  if ((fps > 0) && (fps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' fps');
                  var res = NtopUtils$1.scaleValue(fps, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fmsgs(mps) {
                  if (typeof (mps) === "undefined")
                          return "-";

                  var sizes = ['msg/s', 'Kmsg/s', 'Msg/s', 'Gmsg/s', 'Tmsg/s'];
                  if (mps == 0) return '0';
                  if ((mps > 0) && (mps < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + ' mps');
                  var res = NtopUtils$1.scaleValue(mps, sizes, 1000);

                  // Round to two decimal digits
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fmillis(ms) {

                  if (ms === undefined) return '-';
                  const sizes = ['ms'];
                  const res = NtopUtils$1.scaleValue(ms, sizes, 1000);
                  return Math.round(res[0] * 100) / 100 + ' ' + res[1];
          }

          static fnone(val) {

                  if (val === undefined) return '-';
                  return Math.round(val * 100) / 100;
          }

          static falerts(aps) {
                  if (typeof (aps) === "undefined")
                          return "-";

                  // Round to two decimal digits
                  return Math.round(aps * 100) / 100 + ' alerts/s';
          }

          static fint(value) {
                  if (typeof (value) === "undefined")
                          return "-";

                  var x = Math.round(value);
                  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
          }

          static ffloat(value) {
                  if (typeof (value) === "undefined")
                          return "-";

                  var x = Math.round(value * 100) / 100.;
                  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
          }

          static fpercent(value) {
                  if (typeof (value) === "undefined")
                          return "-";

                  return Math.round(value * 100) / 100 + " %";
          }

      static percentage(value, total) {
          if(total > 0) {
              var pctg = Math.round((value * 10000) / total);
              
              if(pctg > 0) {
                  /* Two decimals */
                  return(" [ " + (pctg/100) + " % ] ")
              }
          }
          
          return("") 
      }

          static fdate(when) {
                  var epoch = when * 1000;
                  var d = new Date(epoch);

                  return (d);
          }

          static capitaliseFirstLetter(string) {
                  return string.charAt(0).toUpperCase() + string.slice(1);
          }

          static get_trend(actual, before) {
                  if ((actual === undefined) || (before === undefined) || (actual == before)) {
                          return ("<i class=\"fas fa-minus\"></i>");
                  } else if (actual > before) {
                          return ("<i class=\"fas fa-arrow-up\"></i>");
                  } else {
                          return ("<i class=\"fas fa-arrow-down\"></i>");
                  }
          }

          static abbreviateString(str, len) {
                  if (!str)
                          return "";
                  if (str.length < len)
                          return str;
                  return str.substring(0, len) + "...";
          }

          static toFixed2(num) {
                  if (!num) return "";
                  return num.toFixed(2);
          }

          // Convert bytes to human readable format
          static bytesToSize(bytes) {
                  if (typeof (bytes) === "undefined")
                          return "-";

                  var precision = 2;
                  var kilobyte = 1024;
                  var megabyte = kilobyte * 1024;
                  var gigabyte = megabyte * 1024;
                  var terabyte = gigabyte * 1024;

                  if ((bytes >= 0) && (bytes < kilobyte))
                          if(bytes != 0)        
                                  return parseFloat(bytes.toFixed(precision)) + " Bytes";
                          else
                                  return parseFloat(bytes) + " Bytes";
    
                  else if ((bytes >= kilobyte) && (bytes < megabyte))
                          return parseFloat((bytes / kilobyte).toFixed(precision)) + ' KB';
                  else if ((bytes >= megabyte) && (bytes < gigabyte))
                          return parseFloat((bytes / megabyte).toFixed(precision)) + ' MB';
                  else if ((bytes >= gigabyte) && (bytes < terabyte))
                          return parseFloat((bytes / gigabyte).toFixed(precision)) + ' GB';
                  else if (bytes >= terabyte)
                          return parseFloat((bytes / terabyte).toFixed(precision)) + ' TB';
                  else
                          return parseFloat(bytes.toFixed(precision)) + ' Bytes';
          }

          static drawTrend(current, last, withColor) {
                  if (current == last) {
                          return ("<i class=\"fas fa-minus\"></i>");
                  } else if (current > last) {
                          return ("<i class=\"fas fa-arrow-up\"" + withColor + "></i>");
                  } else {
                          return ("<i class=\"fas fa-arrow-down\"></i>");
                  }
          }

          static toggleAllTabs(enabled) {
                  if (enabled === true)
                          $("#historical-tabs-container").find("li").removeClass("disabled").find("a").attr("data-toggle", "tab");
                  else
                          $("#historical-tabs-container").find("li").addClass("disabled").find("a").removeAttr("data-toggle");
          }

          static disableAllDropdownsAndTabs() {
                  $("select").each(function () {
                          $(this).prop("disabled", true);
                  });
                  NtopUtils$1.toggleAllTabs(false);
          }

          static enableAllDropdownsAndTabs() {
                  $("select").each(function () {
                          $(this).prop("disabled", false);
                  });
                  NtopUtils$1.toggleAllTabs(true);
          }

          static capitalize(s) {
                  return s && s[0].toUpperCase() + s.slice(1);
          }

          static addCommas(nStr) {
                  nStr += '';
                  var x = nStr.split('.');
                  var x1 = x[0];
                  var x2 = x.length > 1 ? '.' + x[1] : '';
                  var rgx = /(\d+)(\d{3})/;
                  while (rgx.test(x1)) {
                          x1 = x1.replace(rgx, '$1' + ',' + '$2');
                  }
                  return x1 + x2;
          }

          static scaleValue(val, sizes, scale, decimals) {
                  if (val == 0) return [0, sizes[0]];
                  let factor = decimals ? (10 * decimals) : 10;

                  var i = parseInt(Math.floor(Math.log(val) / Math.log(scale)));
                  if (i < 0 || isNaN(i)) {
                          i = 0;
                  } else if (i >= sizes.length) {
                          i = sizes.length - 1;
                  }

                  return [Math.round((val / Math.pow(scale, i)) * factor) / factor, sizes[i]];
          }

          static formatValue(val, decimals) {
                  var sizes = ['', 'K', 'M', 'G', 'T'];
                  if (val == 0) return '0';
                  if ((val > 0) && (val < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE);
                  if (decimals == undefined) decimals = 0;
                  var res = NtopUtils$1.scaleValue(val, sizes, 1000, decimals);

                  return res[0] + res[1];
          }

          static formatPackets(n) {
                  return (NtopUtils$1.addCommas(n.toFixed(0)) + " Pkts");
          }

          static bytesToVolume(bytes) {
                  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                  if (bytes == 0) return '0 Bytes';
                  if ((bytes > 0) && (bytes < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + " Bytes");
                  var res = NtopUtils$1.scaleValue(bytes, sizes, 1024);

                  return parseFloat(res[0]) + " " + res[1];
          };

          static bytesToVolumeAndLabel(bytes) {
                  var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                  if (bytes == 0) return '0 Bytes';
                  var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
                  return [(bytes / Math.pow(1024, i)).toFixed(2), sizes[i]];
          };

          static bitsToSize(bits, factor) {
                  factor = factor || 1000;
                  var sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];
                  if (bits == 0) return '0 bps';
                  if ((bits > 0) && (bits < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + " bps");
                  var res = NtopUtils$1.scaleValue(bits, sizes, factor);

                  return res[0].toFixed(2) + " " + res[1];
          };

          static bitsToSize_no_comma(bits, factor) {
                  factor = factor || 1000;
                  var sizes = ['bps', 'Kbps', 'Mbps', 'Gbps', 'Tbps'];
                  if (bits == 0) return '0 bps';
                  if ((bits > 0) && (bits < NTOPNG_MIN_VISUAL_VALUE)) return ('< ' + NTOPNG_MIN_VISUAL_VALUE + " bps");
                  var res = NtopUtils$1.scaleValue(bits, sizes, factor);

                  return res[0]+ " " + res[1];
          };

          static secondsToTime(seconds) {

                  if (seconds < 1) {
                          return ("< 1 sec")
                  }

                  let days = Math.floor(seconds / 86400);
                  let hours = Math.floor((seconds / 3600) - (days * 24));
                  let minutes = Math.floor((seconds / 60) - (days * 1440) - (hours * 60));
                  let sec = seconds % 60;
                  let msg = "", msg_array = [];

                  if (days > 0) {
                          let years = Math.floor(days / 365);

                          if (years > 0) {
                                  days = days % 365;

                                  msg = years + " year";
                                  if (years > 1) {
                                          msg += "s";
                                  }

                                  msg_array.push(msg);
                                  msg = "";
                          }
                          msg = days + " day";
                          if (days > 1) { msg += "s"; }
                          msg_array.push(msg);
                          msg = "";
                  }

                  if (hours > 0) {
                          if (hours < 10) { msg = "0"; }
                          msg += hours + ":";
                  }

                  if (minutes < 10) { msg += "0"; }
                  msg += minutes + ":";
                  if (sec < 10) { msg += "0"; }
                  msg += sec;
                  msg_array.push(msg);

                  return msg_array.join(", ")
          }

          static msecToTime(msec) {
                  if (msec >= 1000) {
                          return NtopUtils$1.secondsToTime(msec/1000);
                  } else {
                          var x = Math.round(msec * 1000) / 1000.;
                          return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") + " ms";
                  }
          }

          static epoch2Seen(epoch) {
                  /* 08/01/13 15:12:37 [18 min, 13 sec ago] */
                  var d = new Date(epoch * 1000);
                  var tdiff = Math.floor(((new Date()).getTime() / 1000) - epoch);

                  return (d.format("dd/MM/yyyy hh:mm:ss") + " [" + NtopUtils$1.secondsToTime(tdiff) + " ago]");
          }

          /* ticks for graph x axis */
          static graphGetXAxisTicksFormat(diff_epoch) {
                  var tickFormat;

                  if (diff_epoch <= 86400) {
                          tickFormat = "%H:%M:%S";
                  } else if (diff_epoch <= 2 * 86400) {
                          tickFormat = "%b %e, %H:%M:%S";
                  } else {
                          tickFormat = "%b %e";
                  }

                  return (tickFormat);
          }

          static paramsExtend(defaults, override) {
                  return $.extend({}, defaults, override);
          }

          static paramsToForm(form, params) {
                  form = $(form);

                  for (var k in params) {
                          if (params.hasOwnProperty(k)) {
                                  var input = $('<input type="hidden" name="' + k + '" value="' + params[k] + '">');
                                  input.appendTo(form);
                          }
                  }

                  return form;
          }

          /*
           * This function creates a javascript object where each k->v pair of the input object
           * translates into two pairs in the output object: a key_[i]->k and a val_[i]->v, where
           * i is an incremental index.
           *
           * The output object can then be serialized to an URL. This conversion is required for
           * handling special characters: since ntopng strips special characters in _GET keys,
           * _GET values must be used.
           *
           * This function performs the inverse conversion of lua paramsPairsDecode.
           *
           */
          static paramsPairsEncode(params) {
                  var i = 0;
                  var res = {};

                  for (var k in params) {
                          res["key_" + i] = k;
                          res["val_" + i] = params[k];
                          i = i + 1;
                  }

                  return res;
          }

          static hostkey2hostInfo(host_key) {
                  var info;

                  host_key = host_key.replace(/____/g, ":");
                  host_key = host_key.replace(/___/g, "/");
                  host_key = host_key.replace(/__/g, ".");

                  info = host_key.split("@");
                  return (info);
          }

          static handle_tab_state(nav_object, default_tab) {
                  $('a', nav_object).click(function (e) {
                          e.preventDefault();
                  });

                  // store the currently selected tab in the hash value
                  $(" > li > a", nav_object).on("shown.bs.tab", function (e) {
                          var id = $(e.target).attr("href").substr(1);
                          if (history.replaceState) {
                                  // this will prevent the 'jump' to the hash
                                  history.replaceState(null, null, "#" + id);
                          } else {
                                  // fallback
                                  window.location.hash = id;
                          }
                  });

                  // on load of the page: switch to the currently selected tab
                  var hash = window.location.hash;
                  if (!hash) hash = "#" + default_tab;
                  $('a[href="' + hash + '"]', nav_object).tab('show');
          }

          static _add_find_host_link(form, name, data) {
                  $('<input>').attr({
                          type: 'hidden',
                          id: name,
                          name: name,
                          value: data,
                  }).appendTo(form);
          }

          /* Used while searching hosts a and macs with typeahead */
          static makeFindHostBeforeSubmitCallback(http_prefix) {
                  return function (form, data) {
                          if (data.context && data.context == "historical") {
                                  form.attr("action", http_prefix + "/lua/pro/db_search.lua");
                                  if (data.type == "ip") {
                                          NtopUtils$1._add_find_host_link(form, "ip", data.ip);
                                  } else if (data.type == "mac") {
                                          NtopUtils$1._add_find_host_link(form, "mac", data.mac);
                                  } else if (data.type == "community_id") {
                                          NtopUtils$1._add_find_host_link(form, "community_id", data.community_id);
                                  } else if (data.type == "ja3_client") {
                                          NtopUtils$1._add_find_host_link(form, "ja3_client", data.ja3_client);
                                  } else if (data.type == "ja3_server") {
                                          NtopUtils$1._add_find_host_link(form, "ja3_server", data.ja3_server);
                                  } else /* "hostname" */ {
                                          NtopUtils$1._add_find_host_link(form, "name", data.hostname ? data.hostname : data.name);
                                  }
                          } else {
                                  if (data.type == "mac") {
                                          form.attr("action", http_prefix + "/lua/mac_details.lua");
                                  } else if (data.type == "network") {
                                          form.attr("action", http_prefix + "/lua/hosts_stats.lua");
                                          NtopUtils$1._add_find_host_link(form, "network", data.network);
                                  } else if (data.type == "snmp") {
                                          form.attr("action", http_prefix + "/lua/pro/enterprise/snmp_interface_details.lua");
                                          NtopUtils$1._add_find_host_link(form, "snmp_port_idx", data.snmp_port_idx);
                                  } else if (data.type == "snmp_device") {
                                          form.attr("action", http_prefix + "/lua/pro/enterprise/snmp_device_details.lua");
                                  } else if (data.type == "asn") {
                                          form.attr("action", http_prefix + "/lua/hosts_stats.lua");
                                          NtopUtils$1._add_find_host_link(form, "asn", data.asn);
                                  } else {
                                          form.attr("action", http_prefix + "/lua/host_details.lua");
                                          NtopUtils$1._add_find_host_link(form, "mode", "restore");
                                  }
                          }

                          return true;
                  }
          }

          static tstampToDateString(html_tag, format, tdiff) {
                  tdiff = tdiff || 0;
                  var timestamp = parseInt(html_tag.html()) + tdiff;
                  var localized = d3.time.format(format)(new Date(timestamp * 1000));
                  html_tag.html(localized).removeClass("hidden");
                  return localized;
          }

          static noHtml(s) {
                  return s.replace(/<[^>]+>/g, '');
          }

          static cleanCustomHostUrl(host) {
                  /* Remove starting http(s). */
                  return host
                          .replace(/^http:\/\//gi, '')
                          .replace(/^https:\/\//gi, '')
                          /* Remove starting www. */
                          .replace(/^www\./gi, '')
                          /* Remove non-allowed characters */
                          .replace(/[^0-9a-zA-Z\.:\/_-]/gi, '');
          }

          /* https://stackoverflow.com/questions/2090551/parse-query-string-in-javascript */
          static parseQuery(queryString) {
                  var query = {};
                  var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
                  for (var i = 0; i < pairs.length; i++) {
                          var pair = pairs[i].split('=');
                          query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
                  }
                  return query;
          }

          static getHistoryParameters(params) {
                  var cur_params = NtopUtils$1.parseQuery(window.location.search);
                  var new_params = $.extend(cur_params, params);
                  var new_query = "?" + $.param(new_params, true);
                  var baseUrl = [location.protocol, '//', location.host, location.pathname].join('');

                  return baseUrl + new_query;
          }

          // return true if the status code is different from 200
          static check_status_code(status_code, status_text, $error_label) {

                  const is_different = status_code != 200;

                  if (is_different && $error_label != null) {

                          let message = i18n_ext.request_failed_message;
                          if (status_code && status_text) {
                                  message += `: ${status_code} - ${status_text}`;
                          }

                          $error_label.text(message).show();
                  }
                  else if (is_different && $error_label == null) {
                          alert(`${i18n_ext.request_failed_message}: ${status_code} - ${status_text}`);
                  }

                  return is_different;
          }

          // To be used in conjunction with httpdocs/templates/config_list_components/import_modal.html
          static importModalHelper(params) {

                  if (!params.loadConfigXHR) { throw ("importModalHelper:: Missing 'loadConfigXHR' param"); }

                  $(`input#import-input`).on('change', function () {
                          $(`#btn-confirm-import`).removeAttr("disabled");
                  });

                  $(`#import-modal`).on('hidden.bs.modal', function () {
                          $(`#import-input`).val('');
                          $("#import-error").hide().removeClass('text-warning').addClass('invalid-feedback');
                          $(`#btn-confirm-import`).attr("disabled", "disabled");
                  });

                  $("#import-modal").on("submit", "form", function (e) {

                          e.preventDefault();

                          const $button = $('#btn-confirm-import');
                          $button.attr("disabled", "");

                          // read configuration file
                          const file = $('#import-input')[0].files[0];

                          if (!file) {
                                  $("#import-error").text(`${i18n_ext.no_file}`).show();
                                  $button.removeAttr("disabled");
                                  return;
                          }

                          const reader = new FileReader();
                          reader.readAsText(file, "UTF-8");

                          reader.onload = function () {
                                  // Client-side configuration file format check
                                  let jsonConfiguration = null;
                                  try { jsonConfiguration = JSON.parse(reader.result); } catch (e) { }

                                  if (!jsonConfiguration) {
                                          $("#import-error").text(i18n_ext.rest_consts[responseJSON.rc_str] || 'Not Implemented Yet').show();
                                          $button.removeAttr("disabled");
                                          return;
                                  }

                                  // Submit configuration file
                                  params.loadConfigXHR(reader.result)
                                          .done((response, status, xhr) => {

                                                  if (response.rc < 0) {
                                                          $("#import-error").text(response.rc_str).show();
                                                          return;
                                                  }

                                                  // if the operation was successful call the successCallback
                                                  if (params.successCallback) {
                                                          params.successCallback(response);
                                                  }

                                                  const key = $(`input[name='configuration']:checked`).val();

                                                  const body = (key == 'all')
                                                          ? i18n("manage_configurations.messages.import_all_success")
                                                          : i18n("manage_configurations.messages.import_success");

                                                  // show a success alert message
                                                  ToastUtils.showToast({
                                                          id: 'import-configuration-alert',
                                                          level: 'success',
                                                          title: i18n("success"),
                                                          body: body,
                                                          delay: 2000
                                                  });

                                                  $("#import-modal").modal('hide');

                                          })
                                          .fail(({ responseJSON }) => {

                                                  const PARTIAL_IMPORT_RC = -28;

                                                  if (params.failureCallback) {
                                                          params.failureCallback(responseJSON);
                                                  }

                                                  if (responseJSON && responseJSON.rc > 0) return;
                                                  if (responseJSON.rc == PARTIAL_IMPORT_RC)
                                                          $(`#import-error`).removeClass('invalid-feedback').addClass('text-warning');

                                                  $("#import-error").text(i18n_ext.rest_consts[responseJSON.rc_str] || i18n_ext.FAILED_HTTP_REQUEST).show();

                                          })
                                          .always(() => {
                                                  $button.removeAttr("disabled");
                                          });
                          };
                  });
          }

          static serializeFormArray(serializedArray) {
                  const serialized = {};
                  serializedArray.forEach((obj) => {
                          /* if the object is an array  */
                          if (obj.name.includes('[]')) {
                                  return;
                          }
                          else {

                                  // clean the string
                                  if (typeof obj.value === "string") {
                                          obj.value = obj.value.trim();
                                  }
                                  serialized[obj.name] = obj.value;
                          }
                  });
                  return serialized;
          }

          static cleanForm(formSelector) {
                  /* remove validation fields and tracks */
                  $(formSelector).find('input,select,textarea').each(function (i, input) {
                          $(this).removeClass(`is-valid`).removeClass(`is-invalid`);
                  });
                  /* reset all the values */
                  $(formSelector)[0].reset();
          }

          /**
           * Make a fetch call with a timeout option
           */
          static fetchWithTimeout(uri, options = {}, time = 5000) {

                  const controller = new AbortController();
                  const config = { ...options, signal: controller.signal };

                  return fetch(uri, config)
                          .then((response) => {
                                  if (!response.ok) {
                                          throw new Error(`${response.status}: ${response.statusText}`)
                                  }
                                  return response
                          })
                          .catch((error) => {
                                  if (error.name === 'AbortError') {
                                          throw new Error('Response timed out')
                                  }
                          })
          }

          static setPref(action, csrf, success, failure) {

                  if (action == undefined) {
                          console.warn("An action key must be defined to set a preference!");
                          return;
                  }

                  const empty = () => { };
                  const request = $.post(`${http_prefix}/lua/update_prefs.lua`, { action: action, csrf: csrf });
                  request.done(success || empty);
                  request.fail(failure || empty);
          }

          /**
           * Glue strings contained in array separated by a comma.
           * @param {array} array The array of strings. I.e. ["Hello", "World"]
           * @param {number} limit How many words the string contains
           *
           * @return {string} A string built by array's elements. i.e: "Hello, World"
           */
          static arrayToListString(array, limit) {

                  if (array == undefined) return "";

                  if (array.length > limit) {
                          return array.slice(0, limit).join(", ") + ` ${i18n_ext.and_x_more.replace('$num', array.length - limit)}`;
                  }

                  return array.slice(0, limit).join(", ");
          }

          static buildURL(location, params = {}, hasReferer = false, refererParams = {}) {

                  const url = new URL(location, window.location);

                  for (const [name, value] of Object.entries(params)) {
                      if (value || value === 0)
                            url.searchParams.set(name, value);
                      continue;
                  }

                  if (hasReferer) {

                          const refUrl = new URL(window.location.href);
                          for (const [name, value] of Object.entries(refererParams)) {
                                  if (!value) continue;
                                  refUrl.searchParams.set(name, value);
                          }

                          url.searchParams.set('referer', refUrl.toString());
                  }

                  return url.toString();
          }

          static getEditPoolLink(href, poolId) {
                  const url = new URL(href, window.location);
                  url.searchParams.set('pool_id', poolId);
                  return url.toString();
          }

          static getPoolLink(poolType, poolId = 0) {
                  return `${http_prefix}/lua/rest/v2/get/${poolType}/pools.lua?pool=${poolId}`;
          }

          static async getPool(poolType, id = 0) {

                  if (poolType === null) throw 'A pool type must be defined!';

                  try {

                          const request = await fetch(NtopUtils$1.getPoolLink(poolType, id));
                          const pool = await request.json();

                          if (pool.rc < 0) {
                                  return [false, {}];
                          }

                          return [true, pool.rsp[0]];
                  }
                  catch (err) {
                          return [false, {}];
                  }
          }

          /**
           * Save the scale of element inside the local storage
           * @param {object} $element 
           * @param {object} scale
           */
          static saveElementScale($element, scale = {width: 0, height: 0}) {
                  
                  const key = NtopUtils$1.generateScaleElementKey($element);
                  localStorage.setItem(key, JSON.stringify(scale));
          }

          static generateScaleElementKey($element) {
                  let identificator;
                  const page = location.pathname;
                  const elementId = $element.attr('id');

                  if (elementId !== "") {
                          identificator = elementId;
                  }
                  else {
                          const className = $element.attr('class');
                          identificator = className;
                  }

                  const key = `${identificator}-${page}-scale`;
                  return key;
          }

          /**
           * Load the old scale value ofx element from the local storage
           * @param {object} $element 
           */
          static loadElementScale($element) {

                  const key = NtopUtils$1.generateScaleElementKey($element);
                  const currentValue = localStorage.getItem(key);
                  if (currentValue == null) return undefined;

                  return JSON.parse(currentValue);
          }

          static fillFieldIfValid($field, value) {

                  if (value === undefined) {
                          $field.val('');
                  }
                  else {
                          $field.val(value);
                  }

          }

          static copyToClipboard(text, item) {
      const el = document.createElement('textarea');
      el.value = text;
      el.setAttribute('readonly', '');
      el.style.position = 'absolute';
      el.style.left = '-9999px';
      document.body.appendChild(el);
      el.select();
      document.execCommand('copy');
      document.body.removeChild(el);
      $(item).attr("title", "Copied!").tooltip("dispose").tooltip().tooltip("show");
      $(item).removeAttr("data-bs-original-title");
      $(item).attr("title", text);
          }

          static stripTags(html) {
                  let t = document.createElement("div");
                  t.innerHTML = html;
                  return t.textContent || t.innerText || "";
          }

    static shortenLabel(label, len, last_char) {
      let shortened_label = label;
      if(label.length > len + 5) {
        if(last_char) {
          let last_index = label.lastIndexOf(last_char);
          const requested_label = label.slice(last_index);
          if(len > last_index) 
            len = last_index;
          shortened_label = label.slice(0, len) + "... " + requested_label;
        } else {
          shortened_label = label.slice(0, len) + "...";
        }
      }

      return shortened_label
    }
          
    static sortAlphabetically(a, b) {
      const nameA = a.label?.toUpperCase(); // ignore upper and lowercase
      const nameB = b.label?.toUpperCase(); // ignore upper and lowercase
      if (nameA < nameB) { return -1; }
      if (nameA > nameB) { return 1; }
      return 0;
    }

    /* This function, given a name and a value, return a string
     * formatted in the following way:
     * name [value]
          * If max_name_len is different from 0, then it's going to cut the name string
          * to max_name_len
     */
    static formatNameValue(name, value, max_name_len) {
                  let label = name;
                  if(name != value) {
                          if(max_name_len && typeof(max_name_len) == 'number')
                                  label = this.shortenLabel(label, max_name_len, '.');

                          label = `${label} [${value}]`; 
                  }
                  return label
    }

    /* This function, remove from a string the VLAN 0
     * name@0 -> name
     */
    static removeVlan(name) {
                  let label = name;
                  const vlan_index = label.lastIndexOf('@');
                  if(vlan_index != -1) {
                          const vlan =  label.slice(vlan_index + 1);
                          if(vlan == 0) {
                                  label = label.slice(0, vlan_index);
                          }
                  }

                  return label
    }

    /* Format an object with label and value from a column row */
    static formatGenericObj(obj, row) {
      let label = obj.label ? obj.label : obj.value;
      obj.value;
      return label;
    }

    /* Format a country from a column object */
    static formatCountry(obj, row) {
      let country_code = obj.value;
      let label = obj.label ? obj.label : obj.value;
      return `${label} <img src="/dist/images/blank.gif" class="flag flag-${country_code.toLowerCase()}">`;
    }

    /* Format an host from a column object */
    static formatHost(obj, row, is_client) {
      let label = "";

      if (!obj) {
        return label;
      }

      /* Link */
      let host_key = obj.ip;
      if (row.vlan_id && row.vlan_id.value)
        host_key = host_key + '@' + row.vlan_id.value;

      /* Label */
      label = obj.label ? obj.label : obj.value;
      if (row.vlan_id && row.vlan_id.label)
        label += `@${row.vlan_id.label}`;

      const url = NtopUtils$1.buildURL(`${http_prefix}/lua/host_details.lua`, { host: host_key});
      label = `<a href="${url}">${label}</a>`;

      /* Country */
      let country_obj = is_client ? row.cli_country : row.srv_country;
      if (!country_obj && row.country) country_obj = row.country;
      if (country_obj && country_obj.value)
        label += ` <img src="${http_prefix}/dist/images/blank.gif" class="flag flag-${country_obj.value.toLowerCase()}" title="${country_obj.title}"></a>`;

      return label;
    }

    /* Format a network from a column object */
    static formatNetwork(obj, row) {
      let label = "";

      if (!obj) {
        return label;
      }

      /* Link */
      let network_key = obj.value;

      /* Label */
      label = obj.label ? obj.label : obj.value;
      if (row.vlan_id && row.vlan_id.label)
        label += `@${row.vlan_id.label}`;

      const url = NtopUtils$1.buildURL(`${http_prefix}/lua/hosts_stats.lua`, { network: network_key});
      label = `<a href="${url}">${label}</a>`;

      return label;
    }

    /* This function converts an ip to a number equale to the ip but without . or :: in case of ipv6
     * this is needed in case of ordering
     */
    static convertIPAddress(a) {
          var i, item;
          var m, n, t;
          var x, xa;

          if (!a) {
                  return 0;
          }

          a = a.replace(/<[\s\S]*?>/g, "");
          //IPv4:Port
                  t = a.split(":");
                  if (t.length == 2){
                          m = t[0].split(".");
                  }
                  else {
                          m = a.split(".");
                  }
          n = a.split(":");
          x = "";
          xa = "";

          if (m.length == 4) {
                  // IPV4
                  for(i = 0; i < m.length; i++) {
                  item = m[i];

                  if(item.length == 1) {
                          x += "00" + item;
                  }
                  else if(item.length == 2) {
                          x += "0" + item;
                  }
                  else {
                          x += item;
                  }
                  }
          }
          else if (n.length > 0) {
                  // IPV6
                  var count = 0;
                  for(i = 0; i < n.length; i++) {
                  item = n[i];

                  if (i > 0) {
                          xa += ":";
                  }

                  if(item.length === 0) {
                          count += 0;
                  }
                  else if(item.length == 1) {
                          xa += "000" + item;
                          count += 4;
                  }
                  else if(item.length == 2) {
                          xa += "00" + item;
                          count += 4;
                  }
                  else if(item.length == 3) {
                          xa += "0" + item;
                          count += 4;
                  }
                  else {
                          xa += item;
                          count += 4;
                  }
                  }

                  // Padding the ::
                  n = xa.split(":");
                  var paddDone = 0;

                  for (i = 0; i < n.length; i++) {
                  item = n[i];

                  if (item.length === 0 && paddDone === 0) {
                          for (var padding = 0 ; padding < (32-count) ; padding++) {
                          x += "0";
                          paddDone = 1;
                          }
                  }
                  else {
                          x += item;
                  }
                  }
          }

          return x;
    }

    /* Format an AS from a column object */
    static formatASN(obj, row) {
      let label = "";

      if (!obj) {
        return label;
      }

      /* Link */
      let asn_key = obj.value;

      /* Label */
      label = obj.label ? obj.label : obj.value;

      const url = NtopUtils$1.buildURL(`${http_prefix}/lua/hosts_stats.lua`, { asn: asn_key});
      label = `<a href="${url}">${label}</a>`;

      return label;
    }

    static createProgressBar(percentage) {
      return `<div class="d-flex flex-row align-items-center">
              <div class="col-9 progress">
                <div class="progress-bar bg-warning" aria-valuenow="${percentage}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage}%;">
                </div>
              </div>
              <div class="col"> ${percentage} %</div>
            </div>`
    }

    static createBreakdown(percentage_1, percentage_2, label_1, label_2) {
      return `<div class="d-flex flex-row align-items-center">
              <div class="col-12 progress">
                <div class="progress-bar bg-warning" aria-valuenow="${percentage_1}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage_1}%;">${label_1}</div>
                <div class="progress-bar bg-success" aria-valuenow="${percentage_2}" aria-valuemin="0" aria-valuemax="100" style="width: ${percentage_2}%;">${label_2}</div>
              </div>
            </div>`
    }

    /* Return the number of rows available in a table */
    static getNumTableRows() {
      return [10, 20, 50, 100];
    }

    static formatApexChartLabelFromXandName({series, seriesIndex, dataPointIndex, w}) {
      const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
      const name = serie["name"];
      const y_value = serie["y"];
      const host_name = serie["meta"]["label"];

      const x_axis_title = w.config.xaxis.title.text;
      const y_axis_title = w.config.yaxis[0].title.text;

      return (`
    <div class='apexcharts-theme-light apexcharts-active' id='test'>
        <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
            ${host_name}
        </div>
        <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
            <div class='apexcharts-tooltip-text text-left'>
                <b>${x_axis_title}</b>: ${name}
            </div>
            <div class='apexcharts-tooltip-text text-left'>
                <b>${y_axis_title}</b>: ${y_value}
            </div>
        </div>
    </div>
    `)
    }

    static apexChartJumpToAlerts(event, chartContext, config) {
      const { seriesIndex, dataPointIndex } = config;
      const { series } = config.config;
      if (seriesIndex === -1) return;
      if (series === undefined) return;

      const serie = series[seriesIndex];
      const base_url = serie.base_url || series[0]['base_url'];
      const default_url = serie.start_url || series[0]['start_url'];
      if (base_url != null && default_url != null) {
        const search = serie.data[dataPointIndex].meta.url_query;
        location.href = `${base_url}?${default_url}${search}`;
      }
    }


    static apexChartJumpToHostDetails(event, chartContext, config) {
      const { seriesIndex, dataPointIndex } = config;
      const { series } = config.config;
      if (seriesIndex === -1) return;
      if (series === undefined) return;

      const serie = series[seriesIndex];

      const base_url = serie.base_url || series[0]['base_url'];
      
      if (base_url != null ) {
        const url = `${base_url}?${serie.data[dataPointIndex].meta.url_query}`;
        ntopng_url_manager.go_to_url(url);
      }
    }

    
    static formatApexChartLabelFromXandY({series, seriesIndex, dataPointIndex, w}) {
      const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
      
      const x_value = serie["x"];
      const y_value = serie["y"];
      const host_name = serie["meta"]["label"];

      const x_axis_title = w.config.xaxis.title.text;
      const y_axis_title = w.config.yaxis[0].title.text;

      return (`
      <div class='apexcharts-theme-light apexcharts-active' id='test'>
          <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
              ${host_name}
          </div>
          <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
              <div class='apexcharts-tooltip-text text-left'>
                  <b>${x_axis_title}</b>: ${x_value}
              </div>
              <div class='apexcharts-tooltip-text text-left'>
                  <b>${y_axis_title}</b>: ${y_value}
              </div>
          </div>
      </div>
    `)
    }
  }

  $(function () {
          // if there are inputs with 'pattern' data attribute
          // then initialize them
          NtopUtils$1.initDataPatterns();
  });

  // 2016-19 - ntop.org

  function datatableRemoveEmptyRow(table) {
    $("tbody tr.emptyRow", $(table)).remove();
  }

  function datatableAddEmptyRow(table, empty_str) {
    var columns = $("thead th", $(table)).filter(function() {
     return $(this).css('display') != 'none';
    }).length;
    $("tbody", $(table)).html('<tr class="emptyRow"><td colspan="' + columns + '"><i>' + empty_str + '</i></td></tr>');
  }

  function datatableGetNumDisplayedItems(table) {
     return $("tr:not(.emptyRow)", $(table)).length - 1;
  }

  function datatableIsEmpty(table) {
    return datatableGetNumDisplayedItems(table) == 0;
  }

  function datatableGetByForm(form) {
    return $("table", $("#dt-top-details", $(form)).parent())
  }

  function datatableUndoAddRow(new_row, empty_str, bt_to_enable, callback_str) {
    if (bt_to_enable)
       $(bt_to_enable).removeAttr("disabled").removeClass("disabled");

    var form = $(new_row).closest("form");
    $(new_row).remove();
    aysUpdateForm(form);
    var dt = datatableGetByForm(form);

    if (datatableIsEmpty(dt))
       datatableAddEmptyRow(dt, empty_str);

     if (callback_str)
        // invoke
        window[callback_str](new_row);
  }

  function datatableForEachRow(table, callbacks) {
     $("tr:not(:first)", table).each(function(row_i) {
        if(typeof callbacks === 'function') {
           callbacks.bind(this)(row_i);
        } else {
           var i;
           for (i=0; i<callbacks.length; i++)
              callbacks[i].bind(this)(row_i);
        }
     });
  }

  function datatableAddButtonCallback(td_idx, label, bs_class, callback_str, link, visible = true, title = '') {
     if ($("td:nth-child("+td_idx+")", $(this)).find('div.d-flex').length == 0) {
        $("td:nth-child("+td_idx+")", $(this)).empty();
        $("td:nth-child("+td_idx+")", $(this)).append($("<div class='d-flex justify-content-center'></div>"));
     }
     $("td:nth-child("+td_idx+")", $(this)).find('.d-flex').append('<a href="' + link + `" title='${title}' data-placement="bottom" class="btn btn-sm mx-1 ${bs_class} ${!visible ? 'disabled' : ''}" onclick="` + callback_str + '" role="button">' + label + '</a>');
  }

  function datatableAddDeleteButtonCallback(td_idx, callback_str, label) {
      datatableAddButtonCallback.bind(this)(td_idx, label, "btn-danger", callback_str, "javascript:void(0)", true, 'Delete');
  }

  function datatableAddActionButtonCallback(td_idx, callback_str, label, visible = true, title = '') {
      datatableAddButtonCallback.bind(this)(td_idx, label, "btn-info", callback_str, "javascript:void(0)", visible, title);
  }
      
  function datatableAddFilterButtonCallback(td_idx, callback_str, label, title = '', visible = true) {
      datatableAddButtonCallback.bind(this)(td_idx, label, "btn-warning", callback_str, "javascript:void(0)", visible, title);
  }

  function datatableAddLinkButtonCallback(td_idx, link, label, title = '') {
     datatableAddButtonCallback.bind(this)(td_idx, label, "btn-info", "", link, true, title);
  }

  function datatableMakeSelectUnique(tr_obj, added_rows_prefix, options) {
     options = NtopUtils.paramsExtend({
        on_change: $.noop,                     /* A callback to be called when the select input changes */
        selector_fn: function(obj) {           /* A callback which receives a tr object and returns a single select input */
           return obj.find("select").first();
        },
     }, options);

     function datatableForeachSelectOtherThan(this_select, added_rows_prefix, selector_fn, callback) {
        $("[id^=" + added_rows_prefix + "]").each(function(){
           var other = selector_fn($(this));
           if (other[0] != this_select[0])
              callback(other);
        });
     }

     function datatableOptionChangeStatus(option_obj, enable) {
        if (enable) {
           option_obj.removeAttr("disabled");
        } else {
           var select_obj = option_obj.closest("select");
           var should_reset = (select_obj.val() == option_obj.val());
           option_obj.attr("disabled", "disabled");

           if(should_reset) {
              var new_val = select_obj.find("option:not([disabled])").first().val();
              select_obj.val(new_val);
              select_obj.attr("data-old-val", new_val);
           }
        }
     }

     function datatableOnSelectEntryChange(added_rows_prefix, selector_fn, change_callback) {
        var old_value = $(this).attr("data-old-val") || "";
        var new_value = $(this).val() || "";
        var others = [];

        if (old_value == new_value)
           old_value = "";

        datatableForeachSelectOtherThan($(this), added_rows_prefix, selector_fn, function(other) {
           datatableOptionChangeStatus(other.find("option[value='" + old_value + "']"), true);
           datatableOptionChangeStatus(other.find("option[value='" + new_value + "']"), false);
           others.push(other);
        });

        change_callback($(this), old_value, new_value, others, datatableOptionChangeStatus);

        $(this).attr("data-old-val", new_value);
     }

     function datatableOnAddSelectEntry(select_obj, added_rows_prefix, selector_fn) {
        select_obj.val("");

        // Trigger an update on other inputs in order to disable entries on the select_obj
        datatableForeachSelectOtherThan(select_obj, added_rows_prefix, selector_fn, function(other) {
           //datatableOptionChangeStatus(select_obj.find("option[value='" + other.val() + "']"), false);
           other.trigger("change");
        });

        // select first available entry
        var new_sel = select_obj.find("option:not([disabled])").first();
        var new_val = new_sel.val();

        // trigger change event to update other entries
        select_obj.val(new_val);
        select_obj.trigger("change");
     }

     var select = options.selector_fn(tr_obj);
     select.on("change", function() { datatableOnSelectEntryChange.bind(this)(added_rows_prefix, options.selector_fn, options.on_change); });
     select.on("remove", function() {$(this).val("").trigger("change");});
     datatableOnAddSelectEntry(select, added_rows_prefix, options.selector_fn);
  }

  function datatableIsLastPage(table) {
     var lastpage = $("#dt-bottom-details .pagination li:nth-last-child(3)", $(table));
     return !((lastpage.length == 1) && (lastpage.hasClass("active") == false));
  }

  function datatableGetColumn(table, id_key, id_value) {
     var res = table.data("datatable").resultset.data.filter(function(item) {
        return item[id_key] === id_value;
     });

     if(res) return res[0];
  }

  function datatableGetColumnIndex(table, column_key) {
     var index = table.data("datatable").options.columns.findIndex(function(item) {
        return item.field === column_key;
     });

     return(index);
  }

  /*
   * Helper function to add refreshable datatables rows.
   *
   * table: the datatable div jquery object
   * column_id: the field key used to indentify the rows
   * refresh_interval: milliseconds refresh interval for this table
   * trend_columns: (optional) a map <field -> formatter_fn> which indicates the numeric columns
   * which should be shown with up/down arrows upon refresh.
   *
   * Returns true on success, false otherwise.
   *
   * Example usage:
   *   $("#table-redis-stats").datatable({
   *     ...
   *     tableCallback: function() {
   *       // The table rows will be identified by the "column_key",
   *       // refreshed every 5 seconds, with up/down arrows on the "column_hits"
   *       datatableInitRefreshRows($("#table-redis-stats"), "column_key", 5000, {"column_hits": addCommas});
   *     }
   *   });
   */
  function datatableInitRefreshRows(table, column_id, refresh_interval, trend_columns) {
    var $dt = table.data("datatable");
    var rows = $dt.resultset.data;
    var old_timer = table.data("dt-rr-timer");
    var old_req = table.data("dt-rr-ajax");
    trend_columns = trend_columns || {};

    if(old_timer) {
      // Remove the previously set timer to avoid double scheduling
      clearInterval(old_timer);
      table.removeData("dt-rr-timer");
    }

    if(old_req) {
      // Abort the previous request if any
      old_req.abort();
      table.removeData("dt-rr-ajax");
    }

    var ids = [];
    var id_to_row = {};

    for(var row in rows) {
      var data = rows[row];

      if(data[column_id]) {
        var data_id = data[column_id];
        id_to_row[data_id] = row;
        ids.push(data_id);
      }
    }

    // These parameters will be passed to the refresh endpoint
    // the custom_hosts parameter will be passed in the AJAX request and
    // will contain the IDs to refresh. It should be used by the receiving
    // Lua script as a filter
    var params = {
      "custom_hosts": ids.join(",")
    };
    var url = $dt.options.url;
    var first_load = true;

    var _process_result = function(result) {
      if(typeof(result) === "string")
        result = JSON.parse(result);

      if(!result) {
        console.error("Bad JSON result");
        return;
      }

      for(var row in result.data) {
         var data = result.data[row];
         var data_id = data[column_id];

         if(data_id && id_to_row[data_id]) {
            var row_idx = id_to_row[data_id];
            var row_html = $dt.rows[row_idx];
            var row_tds = $("td", row_html);

            /* Try to update all the fields for the current row (row_html) */
            for(var key in data) {
               var col_idx = datatableGetColumnIndex(table, key);
               var cell = row_tds[col_idx];
               var $cell = $(cell);

               var old_val = $cell.data("dt-rr-cur-val") || $(cell).html();
               var trend_value_formatter = trend_columns[key];
               var new_val = data[key];
               var arrows = "";

               if(trend_value_formatter) {
                if(parseFloat(new_val) != new_val)
                  console.warn("Invalid number: " + new_val);

                if(!first_load)
                  arrows = " " + NtopUtils.drawTrend(parseFloat(new_val), parseFloat(old_val));

                // This value will be neede in the next refresh
                $cell.data("dt-rr-cur-val", new_val);

                new_val = trend_value_formatter(new_val);
              }

               $(cell).html((new_val != 0) ? (new_val + arrows) : "");
            }
         }
      }

      first_load = false;
      table.removeData("dt-rr-ajax");
   };

    // Save the timer into "dt-rr-timer" to be able to stop it if
    // datatableInitRefreshRows is called again
    table.data("dt-rr-timer", setInterval(function() {
      // Double check that a request is not pending
      var old_req = table.data("dt-rr-ajax");

      if(old_req)
        return;

      // Save the ajax request to possibly abort it if
      // datatableInitRefreshRows is called again
      table.data("dt-rr-ajax", $.ajax({
         type: 'GET',
         url: url,
         data: params,
         cache: false,
         success: _process_result,
      }));
    }, refresh_interval));

    // First update
    _process_result($dt.resultset);
  }

  function draw_processes_graph(http_prefix, graph_div_id, host) {
      var links;
      var nodes = {};

      var url = http_prefix + '/lua/get_processes_graph_data.lua?host=' + host;

      d3.json(url, function(error, json) {
  	if(error)
  	    return console.warn(error);

  	links = json;
  	var _link;

  	// Compute the distinct nodes from the links.
  	links.forEach(function(link) {
  	    if(link.source_pid == -1) {
  		/* IP Address -> PID */
  		_link = http_prefix + "/lua/host_details.lua?host=" + link.source;
  	    } else {
  		/* PID -> IP Address */
  		_link = http_prefix + "/lua/process_details.lua?pid=" + link.source_pid + "&pid_name=" + link.source_name + "&host=" + host + "&page=flows";
  	    }

  	    link.source = nodes[link.source]
  		|| (nodes[link.source] = {
  		    name: link.source_name, num:link.source,
  		    link: _link, type: link.source_type, pid: link.source_pid
  		});

  	    if(link.target_pid == -1) {
  		/* IP Address -> PID */
  		_link = http_prefix + "/lua/host_details.lua?host=" + link.target;
  	    } else {
  		/* PID -> IP Address */
  		_link = http_prefix + "/lua/process_details.lua?pid=" + link.target_pid + "&pid_name=" + link.target_name + "&host=" + host + "&page=flows";
  	    }

  	    link.target = nodes[link.target]
  		|| (nodes[link.target] = {
  		    name: link.target_name, num: link.target,
  		    link: _link, type: link.target_type, pid: link.target_pid
  		});
  	});

  	var width = 960, height = 500, arrow_size = 6;
  	var color = d3.scale.category10();

  	/* Same colors as those used in the flow_details.lua page to represent hosts and processes */
  	color["proc"] = "red";
  	color["host"] = "lightsteelblue";

  	var force = d3.layout.force()
  	    .nodes(d3.values(nodes))
  	    .links(links)
  	    .size([width, height])
  	    .linkDistance(120) // Arc length
  	    .charge(-400)
  	    .on("tick", tick)
  	    .start();

  	var svg = d3.select("#" + graph_div_id).append("svg")
  	    .attr("id", "ebpf_graph")
  	    .attr("width", width)
  	    .attr("height", height);

  	// Per-type markers, as they don't inherit styles.
  	svg.append("defs").selectAll("marker")
  	    .data(["proc2proc", "proc2host", "host2proc", "host2host"])
  	    .enter().append("marker")
  	    .attr("id", function(d) { return d; })
  	    .attr("viewBox", "0 -5 20 20")
  	    .attr("refX", 15)
  	    .attr("refY", -1.5)
  	    .attr("markerWidth", arrow_size).attr("markerHeight", arrow_size)
  	    .attr("orient", "auto")
  	    .append("path")
  	    .attr("d", "M0,-5L10,0L0,5");

  	var path = svg.append("g").selectAll("path")
  	    .data(force.links())
  	    .enter().append("path")
  	    .attr("class", function(d) { return "link " + d.type; })
  	    .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });


  	var circle = svg.append("g").selectAll("circle")
  	    .data(force.nodes())
  	    .enter().append("circle")
  	    .attr("class", "ebpf_circle")
  	    .attr("r", 15) /* Radius */
  	    .style("fill", function(d) { return color[d.type]; })
  	    .call(force.drag)
  	    .on("dblclick", function(d) {
  		window.location.href = d.link;
  	    } );

  	// Circle label
  	var text = svg.append("g").selectAll("text")
  	    .data(force.nodes())
  	    .enter().append("text")
  	    .attr("class", "ebpf_text")
  	    .attr("x", 12)
  	    .attr("y", "0.5rem")
        .style("font-size", "1rem")
  	    .text(function(d) {
  		if(d.pid >= 0) // Process
  		    return(d.name + " [pid: "+d.pid+"]");
  		else { // Host
  		    return(d.name);
  		}
  	    });

  	// Use elliptical arc path segments to doubly-encode directionality.
  	function tick() {
  	    path.attr("d", linkArc);
  	    circle.attr("transform", transform);
  	    text.attr("transform", transform);
  	}

  	function linkArc(d) {
  	    var dx = d.target.x - d.source.x,
  		dy = d.target.y - d.source.y,
  		dr = Math.sqrt(dx * dx + dy * dy);
  	    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
  	}

  	function transform(d) {
  	    return "translate(" + d.x + "," + d.y + ")";
  	}
      });
  }

  var ebpfUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    draw_processes_graph: draw_processes_graph
  });

  /* Use with:
    *
    * $('#edit-recipient-modal form').modalHandler({ ... })
    */
  class ModalHandler {

      constructor(form, options) {

          if (typeof options.csrf === "undefined") {
              throw new Error("ModalHandler::Missing CSRF token!");
          }

          this.element = form;
          this.dialog = $(form).closest(".modal");

          this.options = options;
          this.csrf = options.csrf;
          this.dontDisableSubmit = options.dontDisableSubmit;

          this.observer = new MutationObserver((list) => {
              this.bindFormValidation();
              this.toggleFormSubmission();
              this.initDataPatterns();
          });

          this.observer.observe(this.element[0], {
              childList: true,
              subtree: true
          });

          this.initialState = null;
          this.currentState = null;
          this.firstCloseAttempt = false;
          this.isSubmitting = false;

          const submitButton = $(this.element).find(`[type='submit']`);
          if (submitButton.length == 0) {
              throw new Error("ModalHandler::The submit button was not found inside the form!");
          }

          this.toggleFormSubmission();

      }

      initDataPatterns() {
          NtopUtils.initDataPatterns();
      }

      /**
       * Create a form's snapshot to save a form state
       */
      createFormSnapshot() {

          const snapshot = {
              inputs: {},
              hidden: []
          };

          $(this.element).find('textarea,select,input[type!="radio"]').each(function () {

              const type = $(this).prop('nodeName').toLowerCase();
              const name = $(this).attr('name');
              snapshot.inputs[`${type}[name='${name}']`] = $(this).val();
          });

          $(this.element).find(`[style='display: none;'], span.invalid-feedback`).each(function () {
              snapshot.hidden.push($(this));
          });

          return snapshot;
      }

      compareFormSnaphsot(s1, s2) {

          if (s1 == null || s2 == null) return true;

          for (let [key, value] of Object.entries(s1.inputs)) {
              if (s2.inputs[key] != value) return false;
          }

          return true;
      }

      delegateModalClosing() {

          const self = this;

          $(this.dialog).find('button.cancel').off('click').click(function () {

              self.firstCloseAttempt = false;
              $(self.element)[0].reportValidity();
              $(self.dialog).find('.confirm-closing').fadeOut(100, function () {
                  $(self.dialog).find('button.btn-close').fadeIn(100);
              });
          });

          $(this.dialog).off('hide.bs.modal').on('hide.bs.modal', function (event) {
              
              if (self.isSubmitting) {
                  event.preventDefault();
                  return;
              }

              // if the form state hasn't changed then don't show the message
              if (self.compareFormSnaphsot(self.currentState, self.initialState)) {
                  return;
              }

              if (self.firstCloseAttempt) return;
              // abort the modal closing event
              event.preventDefault();

              // flag a close attempt has been invoked
              self.firstCloseAttempt = true;
              
              // show an alert to inform the user
              $(self.dialog).find('button.btn-close').fadeOut(100, function () {
                  $(self.dialog).find('.confirm-closing').fadeIn(100);
              });

              return;

          });

          $(this.dialog).off('hidden.bs.modal').on('hidden.bs.modal', function (event) {

              // for each input inside the form restore the initial value
              // from the snapshot taken at init
              for (const [selector, value] of Object.entries(self.initialState.inputs)) {
                  $(self.dialog).find(selector).val(value);
                  $(self.dialog).find(selector).removeClass('is-invalid');
              }

              // hide the shwon elements
              self.initialState.hidden.forEach(($hidden) => {
                  $hidden.hide();
              });

              self.element.find(`[type='submit']`).attr("disabled", "disabled");
              self.currentState = null;
              self.firstCloseAttempt = false;

              $(self.dialog).find('.confirm-closing').fadeOut(100, function () {
                  $(self.dialog).find('button.btn-close').fadeIn(100);
              });

              // clean the form when the modal is closed
              // to prevent the fields flickering
              self.cleanForm();
          });
      }

      fillFormModal() {
          return this.options.loadFormData();
      }

      invokeModalInit(data = {}) {

          const self = this;

          // reset form values when the modal closes
          this.delegateModalClosing();
          this.data = data || this.fillFormModal();
          this.options.onModalInit(this.data, this);

          $(this.element).parents('.modal').on('show.bs.modal', function () {
              self.options.onModalShow();
          });

          // create a initial form snapshot to restore elements on closing
          this.initialState = this.createFormSnapshot();
          this.currentState = null;

          this.delegateResetButton();   
      }

      delegateSubmit() {

          this.bindFormValidation();

          const self = this;

          this.submitHandler = function (e) {
              if (!self.options.isSyncRequest) {
                  e.preventDefault();
                  e.stopPropagation();
                  self.makeRequest();
              }
          };

          $(this.element).on('submit', this.submitHandler);
      }

      bindFormValidation() {

          const self = this;

          // handle input validation
          $(this.element).find(`input,select,textarea`).each(async function (i, input) {

              // jQuery object of the current input
              const $input = $(this);
              // id to handle the current timeout set to show errors
              let timeoutId = -1;

              const validHostname = async () => {

                  // show the spinner to the user and set the input to readonly
                  const $spinner = $input.parent().find('.spinner-border');
                  $input.attr("readonly", true);
                  $spinner.show();

                  const response = await NtopUtils.resolveDNS($(input).val());

                  // hide the spinner and renable write to the input
                  $input.removeAttr("readonly");
                  $spinner.hide();

                  // if the response was negative then alert the user
                  if (response.rc < 0) {
                      input.setCustomValidity(response.rc_str);
                      return [false, response.rc_str_hr];
                  }

                  // return success for valid resolved hostnmae
                  input.setCustomValidity("");

                  return [true, "Success"];
              };

              const validInput = async (validation) => {

                  // if the input require to validate host name then perform a DNS resolve
                  if (validation.data.resolveDNS && $input.val().match(NtopUtils.REGEXES.domainName)) {
                      return await validHostname();
                  }

                  if (validation.data.cannotBeEmpty && validation.isInputEmpty) {
                      // trigger input validation flag
                      input.setCustomValidity("Please fill the input.");
                      return [false, validation.data.validationEmptyMessage || i18n_ext.missing_field];
                  }

                  if (input.validity.patternMismatch) {
                      input.setCustomValidity("Pattern mismatch.");
                      return [false, validation.data.validationMessage || i18n_ext.invalid_field];
                  }

                  if (input.validity.rangeOverflow) {
                      input.setCustomValidity("Value exceed the maximum value.");
                      return [false, validation.data.rangeOverflowMessage || i18n_ext.invalid_field];
                  }

                  if (input.validity.rangeUnderflow) {
                      input.setCustomValidity("Value is under the minimum value.");
                      return [false, validation.data.rangeUnderflowMessage || i18n_ext.invalid_field];
                  }

                  // set validation to true
                  input.setCustomValidity("");
                  return [true, "Success"];
              };

              const checkValidation = async () => {

                  const validation = {
                      data: {
                          validationMessage: $input.data('validationMessage'),
                          validationEmptyMessage: $input.data('validationEmptyMessage'),
                          cannotBeEmpty: ($input.attr('required') === "required") || ($input.data("validationNotEmpty") == true),
                          resolveDNS: $input.data('validationResolvedns'),
                          rangeOverflowMessage: $input.data('validationRangeOverflowMessage'),
                          rangeUnderflowMessage: $input.data('validationUnderflowOverflowMessage'),
                      },
                      isInputEmpty: (typeof($input.val()) === "string" ? $input.val().trim() == "" : false)
                  };

                  const [isValid, messageToShow] = await validInput(validation);
                  let $error = $input.parent().find(`.invalid-feedback`);

                  // if the error element doesn't exist then create a new one
                  if ($error.length == 0) {
                      $error = $(`<span class='invalid-feedback'></span>`);
                  }

                  // display the errors and color the input box
                  if (!isValid) {
                      $input.addClass('is-invalid');
                      $input.parent().append($error);
                      $error.text(messageToShow);
                  }
                  else {
                      // clean the validation message and remove the error
                      $input.removeClass('is-invalid');
                      $error.fadeOut(500, function () { $(this).remove(); });
                  }
              };

              $(this).off('input').on('input', function (e) {

                  self.currentState = self.createFormSnapshot();

                  // if exists already a Timeout then clear it
                  if (timeoutId != -1) clearTimeout(timeoutId);

                  if (!$input.attr("formnovalidate")) {
                      // trigger input validation after 300msec
                      timeoutId = setTimeout(() => {
                          checkValidation();
                          // trigger form validation to enable the submit button
                          self.toggleFormSubmission();
                      }, 300);
                      // the user has changed the input, we can abort the first close attempt
                      self.firstCloseAttempt = false;
                  }
              });

              $(this).off('invalid').on('invalid', function (e) {
                  e.preventDefault();
                  if (!$input.attr("formnovalidate")) {
                      checkValidation();
                  }
              });
          });

      }

      getModalID() {
          return $(this.element).parents('.modal').attr('id');
      }

      toggleFormSubmission() {

          let isValid = true;

          // if each input is marked as valid then enable the form submit button
          $(this.element).find('input:not(:disabled),select:not(:disabled),textarea:not(:disabled)').each(function (idx, input) {
              // make a concatenate & between valid flags
              isValid &= input.validity.valid;
          });

          isValid
              ? $(this.element).find(`[type='submit'],[type='test']`).removeAttr("disabled")
              : $(this.element).find(`[type='submit'],[type='test']`).attr("disabled", "disabled");
      }

      cleanForm() {
          /* remove validation class from fields */
          $(this.element).find('input,textarea,select').each(function (i, input) {
              $(this).removeClass(`is-valid`).removeClass(`is-invalid`);
          });
          /* reset all the values */
          $(this.element)[0].reset();
      }

      makeRequest() {

          const $feedbackLabel = $(this.element).find(`.invalid-feedback`);
          const submitButton = $(this.element).find(`[type='submit']`);
          let dataToSend = this.options.beforeSumbit(this.data);

          dataToSend.csrf = this.csrf;
          dataToSend = $.extend(dataToSend, this.options.submitOptions);

          /* clean previous state and disable button */
          submitButton.attr("disabled", "disabled");

          const self = this;

          if (this.options.endpoint) {
              let request;

              if (self.options.method == "post") {
                  request = $.ajax({
                      url: this.options.endpoint,
                      data: JSON.stringify(dataToSend),
                      method: self.options.method,
                      dataType: "json",
                      contentType: "application/json; charset=utf-8"
                  });
              }
              else {
                  request = $.get(this.options.endpoint, dataToSend);
              }

              this.isSubmitting = true;

              request.done(function (response, textStatus) {

                  // clear submitting state
                  self.isSubmitting = false;
                  // clear the current form state
                  self.currentState = null;

                  if (self.options.resetAfterSubmit) self.cleanForm();
                  $feedbackLabel.hide();

                  const success = self.options.onSubmitSuccess(response, dataToSend, self);
                  // if the submit return a true boolean then close the modal
                  if (success) {
                    if(self.dialog.modal)
                      self.dialog.modal('hide');
                    else {
                      self.dialog[0].hidden = true;
                      $(`.modal-backdrop.fade.show`).remove();
                    }
                  }

                  /* unbind the old closure on submit event and bind a new one */
                  $(self.element).off('submit', self.submitHandler);
                  self.delegateSubmit();
              })
              .fail(function (jqxhr, textStatus, errorThrown) {

                  self.isSubmitting = false;
                  const response = jqxhr.responseJSON;
                  if (response.rc !== undefined && response.rc < 0) {
                      $feedbackLabel.html(response.rc_str_hr).show();
                  }

                  self.options.onSubmitError(response, dataToSend, textStatus, errorThrown);
              })
              .always(function (d) {
                  submitButton.removeAttr("disabled");
              });

          } else { // no endpoint

                  // clear the current form state
                  self.currentState = null;

                  //if (self.options.resetAfterSubmit) self.cleanForm();
                  $feedbackLabel.hide();

                  const success = self.options.onSubmitSuccess({}, dataToSend, self);
                  // if the submit return a true boolean then close the modal
                  if (success) {
                    if(self.dialog.modal)
                      self.dialog.modal('hide');
                    else
                      self.dialog[0].hidden = true;
                  }

                  /* unbind the old closure on submit event and bind a new one */
                  $(self.element).off('submit', self.submitHandler);
                  self.delegateSubmit();

                  submitButton.removeAttr("disabled");
          }
      }

      delegateResetButton() {

          const self = this;
          const resetButton = $(this.element).find(`[type='reset']`);
          if (resetButton.length == 0) return;

          const defaultValues = NtopUtils.serializeFormArray($(this.element).serializeArray());

          resetButton.click(function (e) {

              e.preventDefault();

              // reset the previous values
              $(self.element).find('input:visible,select').each(function (i, input) {
                  const key = $(input).attr('name');
                  $(input).val(defaultValues[key])
                      .removeClass('is-invalid').removeClass('is-valid');
              });
          });
      }
  }

  const modalHandler = function (args) {

      if (this.length != 1) throw new Error("Only a form element can by initialized!");

      const options = $.extend({
          csrf: '',
          endpoint: '',
          resetAfterSubmit: true,
          /* True to skip the are-you-sure check on the dialog */
          dontDisableSubmit: false,
          /* True if the request isn't done by AJAX request */
          isSyncRequest: false,
          method: 'get',
          /**
           * Fetch data asynchronusly from the server or
           * loads data directly from the current page.
           * The function must returns the fetched data.
           *
           * @returns Returns the fetched data.
           * @example Below there is an example showing
           * how to use the function when fetching data from the server
           * ```
           * loadFormData: async function() {
           *      const data = await fetch(`endpoint/to/data`);
           *      const user = await data.json();
           *      return user;
           * }
           * ```
           */
          loadFormData: function () { },

          /**
           * onModalInit() is invoked when the plugin has been initialized.
           * This function is used to load the fetched data from `loadFormData()`
           * inside the form modal inputs.
           *
           * @param {object} loadedData This argument contains the fetched data obtained
           * from `loadFormData()`
           * @example Below there is an example showing how to use
           * the function (we suppose that loadFormData() returns the following
           * object: `loadedUser = {firstname: 'Foo', lastname: 'Bar', id: 1428103}`)
           * ```
           * onModalInit: function(loadedUser) {
           *      $(`#userModal form input#firstname`).val(loadedUser.firstname);
           *      $(`#userModal form input#lastname`).val(loadedUser.lastname);
           *      $(`#userModal form input#id`).val(loadedUser.id);
           * }
           * ```
           */
          onModalInit: function (loadedData) { },

          onModalShow: function () { },

          /**
           * The function beforeSubmit() is invoked after the user
           * submit the form. The function must return the data to
           * send to the endpoint. If the chosen method is `post`
           * a csrf will be add to the returned object.
           *
           * @example We show below a simple example how to use the function:
           * ```
           * beforeSubmit: function() {
           *      const body = {
           *          action: 'edit',
           *          JSON: JSON.stringify(serializeArrayForm($(`form`).serializeArray()))
           *      };
           *      return body;
           * }
           * ```
           */
          beforeSumbit: function () { return {} },

          /**
           * This function is invoked when the request to the endpoint
           * terminates successfully (200). Before the call of this function
           * a new csrf retrived from the server will be set for
           * future calls.
           *
           * @param {object} response This object contains the response
           * from the server
           *
           * @example Below there is an example showing a simple user case:
           * ```
           * onSubmitSuccess: function(response) {
           *      if (response.success) {
           *          console.log(`The user info has been edit with success!`);
           *      }
           * }
           * ```
           */
          onSubmitSuccess: function (response) { },

          /**
           * This function is invoked when the request to the endpoint
           * terminates with failure (!= 200). Before the call of this function
           * a new csrf retrived from the server will be set for
           * future calls.
           *
           * @param {object} sent This object contains the sent data to the endpoint
           * @param {string} textStatus It contains the error text status obtained
           * @param {object} errorThrown This object contains info about the error
           *
           * @example Below there is an example showing a simple user case:
           * ```
           * onSubmitError: function(sent, textStatus, errorThrown) {
           *      if (errorThrown) {
           *          console.error(`Ops, something went wrong!`);
           *          console.error(errorThrown);
           *      }
           * }
           * ```
           */
          onSubmitError: function (sent, textStatus, errorThrown) { },

          /**
           * This function is invoked when the user click the reset input
           * inside the form.
           *
           * @param {object} defaultData It contains the fetched data from
           * `loadFormData()`.
           *
           * @example Below there is an example how to use the function:
           * ```
           * onModalReset: function(defaultData) {
           *      $(`input#id`).val(defaultData.id);
           *      $(`input#name`).val(defaultData.name);
           *      $(`input#address`).val(defaultData.address);
           * }
           * ```
           */
          onModalReset: function (defaultData) { },
      }, args);

      const mh = new ModalHandler(this, options);
      mh.delegateSubmit();

      return mh;
  };

  /**
      (C) 2022 - ntop.org
  */
  const types = {
      no_formatting: {
          id: "no_formatting",
          um: null,
          step: null,
          decimal: null,
          scale_values: null,
      },
      number: {
          id: "number",
          um: ["", "K", "M", "G", "T"],
          step: 1000,
          decimal: null,
          scale_values: null,
      },
      full_number: {
          id: "number",
          um: ["", "K", "M", "G", "T"],
          step: 1000,
          decimal: null,
          scale_values: null,
          thousands_sep: ",", /* Comment this to enable "um" scaled style */
      },
      bytes: {
          id: "bytes",
          um: ["B", "KB", "MB", "GB", "TB", "PB", "EB"],
          step: 1024,
          decimal: 2,
          scale_values: null,
          absolute_value: true,
      },
      bps: {
          id: "bps",
          um: ["bps", "Kbps", "Mbps", "Gbps", "Tbps", "Pbps"],
          step: 1000,
          decimal: 2,
          scale_values: 8,
          absolute_value: true,
      },
      bps_no_scale: {
          id: "bps_no_scale",
          um: ["bps", "Kbps", "Mbps", "Gbps", "Tbps", "Pbps"],
          step: 1000,
          decimal: 2,
          scale_values: null,
          absolute_value: true,
      },
      speed: {
          id: "speed",
          um: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit"],
          step: 1000,
          decimal: 0,
          scale_values: null,
          absolute_value: true,
      },
      flows: {
          id: "flows",
          um: ["flows", "Kflows", "Mflows", "Gflows"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      fps: {
          id: "fps",
          um: ["flows/s", "Kflows/s", "Mflows/s", "Gflows/s"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      alerts: {
          id: "alerts",
          um: ["alerts", "Kalerts", "Malerts", "Galerts"],
          step: 1000,
          decimal: 2,
          scale_values: null,
          absolute_value: true,
      },
      alertps: {
          id: "alertps",
          um: ["alerts/s", "Kalerts/s", "Malerts/s", "Galerts/s"],
          step: 1000,
          decimal: 2,
          scale_values: null,
          absolute_value: true,
      },
      hits: {
          id: "hits",
          um: ["hits", "Khits", "Mhits", "Ghits"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      hitss: {
          id: "hitss",
          um: ["hits/s", "Khits/s", "Mhits/s", "Ghits/s"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      packets: {
          id: "packets",
          um: ["packets", "Kpackets", "Mpackets", "Gpackets", "Tpackets"],
          step: 1000,
          decimal: 0,
          scale_values: null,        
          absolute_value: true,
      },
      pps: {
          id: "pps",
          um: ["pps", "Kpps", "Mpps", "Gpps", "Tpps"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      ms: {
          id: "ms",
          um: ["ms", "s"],
          step: 1000,
          decimal: 2,
          scale_values: null,        
          absolute_value: true,
      },
      percentage: {
          id: "percentage",
          um: ["%"],
          step: 101,
          decimal: 1,
          scale_values: null,        
          max_value: 100,
          absolute_value: true,
      },
  };

  function getUnitMeasureLen(type) {
      // 000.00
      let t = types[type];
      let spaceValue = 3;
      if (t.decimal != null && t.decimal > 0) {        
          spaceValue = 6;
      }
      let spaceUm = 0;
      if (t.um != null) {
          spaceUm = Math.max(...t.um.map((um) => um.length));
      }
      return (spaceValue + 1 + spaceUm);
  }

  function getScaleFactorIndex(type, value) {
      let typeOptions = types[type];
      if (type == types.no_formatting.id || value == null) {
          return null;
      }
      if (typeOptions.scale_values != null) {
          value *= typeOptions.scale_values;
      }
      let step = typeOptions.step;
      let negativeValue = value < 0;
      if (negativeValue) { value *= -1; }
      let i = 0;
      let measures = typeOptions.um;
      while (value >= step && i < measures.length) {
          value = value / step;
          i += 1;
      }
      return i;
  }

  function getFormatter(type, absoluteValue, scaleFactorIndex) {
      let typeOptions = types[type];
      if (typeOptions == null) { return null; }
      
      absoluteValue |= typeOptions.absolute_value; 
      let formatter = function(value) {
          if (value == null) {
              return '';
          }
          if (type == types.no_formatting.id) {
              return value;
          }
          if (typeOptions.scale_values != null) {
              value *= typeOptions.scale_values;
          }
          let negativeValue = value < 0;
          if (negativeValue) { value *= -1; }

          if (typeOptions.max_value != null && value > typeOptions.max_value) {
              value = typeOptions.max_value;
          }

          if (typeOptions.thousands_sep) {
              value = value + '';
              var x = value.split('.');
              var x1 = x[0];
              var x2 = (x.length > 1) ? ('.' + x[1]) : '';
              var rgx = /(\d+)(\d{3})/;
              while (rgx.test(x1)) {
                  x1 = x1.replace(rgx, '$1' + ',' + '$2');
              }
              return x1 + x2;
          }
          
          let step = typeOptions.step;
          let decimal = typeOptions.decimal;
          let measures = typeOptions.um;
          let i = 0;

          while ((value >= step && i < measures.length && !scaleFactorIndex) || (scaleFactorIndex != null && i < scaleFactorIndex)) {
              value = value / step;
              i += 1;
          }

          if (decimal != null && decimal > 0) {            
              value = value * Math.pow(10, decimal);
              value = Math.round(value);
              value = value / Math.pow(10, decimal);
              value = value.toFixed(decimal);
          } else {
              value = Math.round(value);
          }
          
          if (negativeValue && !absoluteValue) { value *= -1; }
          let valString = `${value}`;
          // if (valString.length < maxLenValue) {
          //     valString = valString.padEnd(maxLenValue - valString.length, " ");
          // }
          let mString = `${measures[i]}`;
          // if (mString.length < maxLenUm) {
          //     mString = mString.padStart(maxLenUm - mString.length, "_");
          // }
          let text = `${valString} ${mString}`;
          return text;
      };
      return formatter;
  }

  const formatterUtils = function() {
      return {
          types,
          getUnitMeasureLen,
          getFormatter,
          getScaleFactorIndex,
      };
  }();

  window.NtopUtils = NtopUtils$1;

  window.datatableInitRefreshRows = datatableInitRefreshRows;
  window.datatableForEachRow = datatableForEachRow;
  window.datatableIsEmpty = datatableIsEmpty;
  window.datatableRemoveEmptyRow = datatableRemoveEmptyRow;
  window.datatableAddEmptyRow = datatableAddEmptyRow;
  window.datatableGetNumDisplayedItems = datatableGetNumDisplayedItems;
  window.datatableGetByForm = datatableGetByForm;
  window.datatableUndoAddRow = datatableUndoAddRow;
  window.datatableAddButtonCallback = datatableAddButtonCallback;
  window.datatableAddDeleteButtonCallback = datatableAddDeleteButtonCallback;
  window.datatableAddActionButtonCallback = datatableAddActionButtonCallback;
  window.datatableAddFilterButtonCallback = datatableAddFilterButtonCallback;
  window.datatableAddLinkButtonCallback = datatableAddLinkButtonCallback;
  window.datatableMakeSelectUnique = datatableMakeSelectUnique;
  window.datatableIsLastPage = datatableIsLastPage;
  window.datatableGetColumn = datatableGetColumn;
  window.datatableGetColumnIndex = datatableGetColumnIndex;

  window.$.fn.modalHandler = modalHandler;

  window.ebpfUtils = ebpfUtils;
  window.ntopFormatterUtils = formatterUtils;

  function makeUniqueValidator(items_function) {
    return function(field) {
      var cmp_name = field.val();
      var count = 0;

      // this will be checked separately, with 'required' argument
      if(! cmp_name)
        return true;

      items_function(field).each(function() {
        var name = $(this).val();
        if (name == cmp_name)
          count = count + 1;
      });

      return count == 1;
    }
  }

  function memberValueValidator(input) {
    var member = input.val();
    if (member === "") return true;

    return NtopUtils.is_mac_address(member) || NtopUtils.is_network_mask(member, true);
  }

  function makePasswordPatternValidator(pattern) {
    return function passwordPatternValidator(input) {
      // required is checked separately
      if(!input.val()) return true;
      return $(input).val().match(pattern);
    }
  }

  function passwordMatchValidator(input) {
    var other_input = $(input).closest("form").find("[data-passwordmatch]").not(input);
    if(!input.val() || !other_input.val()) return true;
    return other_input.val() === input.val();
  }

  function poolnameValidator(input) {
    // required is checked separately
    if(!input.val()) return true;
    return $(input).val().match(/^[a-z0-9_]*$/);
  }

  function passwordMatchRecheck(form) {
    var items = $(form).find("[data-passwordmatch]");
    var not_empty = 0;

    items.each(function() {
      if($(this).val() != "") not_empty++;
    });

    if(not_empty == items.length) items.trigger('input');
  }

  function hostOrMacValidator(input) {
    var host = input.val();

    /* Handled separately */
    if (host === "") return true;

    return NtopUtils.is_mac_address(host) || NtopUtils.is_good_ipv4(host) || NtopUtils.is_good_ipv6(host);
  }

  function ipAddressValidator(input) {
    var host = input.val();

    /* Handled separately */
    if (host === "") return true;

    return NtopUtils.is_good_ipv4(host) || NtopUtils.is_good_ipv6(host);
  }

  var filters_to_validate = {};

  function bpfValidator(filter_field, sync = false) {
    var filter = filter_field.val();

    if (filter.trim() === "") {
      return true;
    }

    var key = filter_field.attr("name");
    var timeout = 250;

    if (!filters_to_validate[key])
       filters_to_validate[key] = {ajax_obj:null, valid:true, timer:null, submit_remind:false, last_val:null};
    var status = filters_to_validate[key];

    var sendAjax = function () {
      status.timer = null;

      var finally_check = function (valid) {
        status.ajax_obj = null;
        status.valid = valid;
        status.last_val = filter;
      };

      if (status.last_val !== filter) {
        if (status.ajax_obj)
          status.ajax_obj.abort();

        status.ajax_obj = $.ajax({
          type: "GET",
          url: `${http_prefix}/lua/pro/rest/v2/check/filter.lua`,
          async: !sync,
          data: {
            query: filter,
          }, error: function() {
            finally_check(status.valid);
          }, success: function(data) {
            var valid = data.response ? true : false;
            finally_check(valid);
          }
        });
      } else {
        // possibly process the reminder
        finally_check(status.valid);
      }
    };

    if (sync) {
      sendAjax();
    } else if (status.last_val === filter) ; else {
      if (status.timer) {
        clearTimeout(status.timer);
        status.submit_remind = false;
      }
      status.timer = setTimeout(sendAjax, timeout);
    }

    return status.valid;
  }

  window.makeUniqueValidator = makeUniqueValidator;
  window.memberValueValidator = memberValueValidator;
  window.makePasswordPatternValidator = makePasswordPatternValidator;
  window.passwordMatchValidator = passwordMatchValidator;
  window.poolnameValidator = poolnameValidator;
  window.passwordMatchRecheck = passwordMatchRecheck;
  window.hostOrMacValidator = hostOrMacValidator;
  window.ipAddressValidator = ipAddressValidator;
  window.bpfValidator = bpfValidator;

  /**
      (C) 2022 - ntop.org    
  */

  const ntopng_sync$1 = function() {
      let components_ready = {};
      let subscribers = [];        
      return {
  	ready: function(component_name) {
  	    components_ready[component_name] = true;
  	    subscribers.filter((s) => s.component_name == component_name).forEach((s) => s.resolve());
  	    subscribers = subscribers.filter((s) => s.component_name != component_name);
  	},
  	on_ready: function(component_name) {
  	    return new Promise((resolve, rejevt) => {
  		if (components_ready[component_name]) {
  		    resolve();
  		    return;
  		}
  		subscribers.push({resolve, component_name, completed: false});
  	    });
  	},
      };
  }();

  /**
  * Utility globals functions.
  */
  const ntopng_utility$1 = function() {
      let global_http_headers = {};
      return {
  	is_array: function(e) {
  	    return Array.isArray(e);
  	},
  	is_object: function(e) {
  	    return typeof e === 'object'
  		&& !this.is_array(e)
  		&& e !== null;
  	},
  	/**
  	 * Deep copy of a object.
  	 * @param {object} obj.
  	 * @returns {object}.
  	 */
  	clone: function(obj) {
              if (obj == null) { return null; }
              if (this.is_object(obj)) {
  		/* This does the deep copy using jquery for objects */
  		return $.extend(true, {}, obj);
              } else if (Array.isArray(obj)){
  		/* This does the deep copy using jquery for other types */
  		let res = [];
  		for (let i = 0; i < obj.length; i += 1) {
  		    let el = this.clone(obj[i]);
  		    res.push(el);
  		}
  		return res;
              } else {
  		// return JSON.parse(JSON.stringify(obj))
  		return obj;
  	    }
  	},      
  	object_to_array: function(obj) {
  	    if (obj == null) { return []; }
  	    let array = [];
  	    for (let key in obj) {
  		array.push(obj[key]);
  	    }
  	    return array;
  	},
  	get_utc_seconds: function(utc_ms) {
  	    if (utc_ms == null) { utc_ms = Date.now(); }
              return Number.parseInt(utc_ms / 1000);
  	},
  	get_timeframes_dict: function() {
              const min = 60;
              let t_day = new Date();
              let t_week = new Date();
              let t_month = new Date();
              let t_year = new Date();
              return {
                  "min": min,
                  "5_min": min * 5,
                  "10_min": min * 10,
                  "30_min": min * 30,
                  hour: min * 60,
                  "2_hours": 2 * min * 60,
                  "6_hours": 6 * min * 60,
                  "12_hours": 12 * min * 60,
                  day: this.get_utc_seconds(Date.now() - t_day.setDate(t_day.getDate() - 1)),
                  week: this.get_utc_seconds(Date.now() - t_week.setDate(t_week.getDate() - 7)),
                  month: this.get_utc_seconds(Date.now() - t_month.setMonth(t_month.getMonth() - 1)),
                  year: this.get_utc_seconds(Date.now() - t_year.setMonth(t_year.getMonth() - 12)),
              };
  	},
  	// given valid interval string get time in seconds
  	get_timeframe_from_timeframe_id: function (timeframe_id) {
              let timeframes_dict = this.get_timeframes_dict();            
              // timeframes_dict[interval_string] == null => key is not present
              if (timeframes_dict[timeframe_id] == null) {
  		throw `Wrong timeframe_id passed ${timeframe_id}, valid intervals are: ${Object.keys(timeframes_dict).join(", ")}`;
              }
  	    return timeframes_dict[timeframe_id];
  	},
  	round_time_by_timeframe_id: function(ts, timeframe_id) {
  	    const timeframe = this.get_timeframe_from_timeframe_id(timeframe_id);
  	    return ts - (ts % timeframe);
  	},
  	// method to set default epoch begin to 30_min ago
  	set_default_time_interval: function (time_interval_id="30_min", round_timeframe_id) {
              let epoch = {
  		epoch_begin: ntopng_url_manager$1.get_url_entry("epoch_begin"),
  		epoch_end: ntopng_url_manager$1.get_url_entry("epoch_end"),
              };
  	    const now_s = this.get_utc_seconds(Date.now());
              let seconds_in_interval = this.get_timeframe_from_timeframe_id(time_interval_id);
              epoch.epoch_begin = now_s - seconds_in_interval;
              epoch.epoch_end = now_s;
              if (round_timeframe_id != null) {
                  epoch.epoch_begin = this.round_time_by_timeframe_id(epoch.epoch_begin, round_timeframe_id);
                  epoch.epoch_end = this.round_time_by_timeframe_id(epoch.epoch_end, round_timeframe_id);
              }
              ntopng_url_manager$1.set_key_to_url("epoch_begin", epoch.epoch_begin);
              ntopng_url_manager$1.set_key_to_url("epoch_end", epoch.epoch_end);
  	    
              return epoch;
  	},
  	//should take a string as parameter that represent time: min, 5_min, 30_min, hour, 2_hours, 6_hours, 12_hours, day, week, month, year. ID time_interval_id is null, default must be 30_min
  	// return epoch_interval only if epoch url is set
  	check_and_set_default_time_interval: function (time_interval_id="30_min", f_condition, get_epoch=false, round_timeframe_id) {
              let epoch = this.get_url_epoch_interval();

              // if time_interval_id is 30 (default)
              if (epoch.epoch_begin == null || epoch.epoch_end == null || (f_condition != null && f_condition(epoch) == true))  {
  		epoch = this.set_default_time_interval(time_interval_id, round_timeframe_id);
  		return epoch;
              }
  	    if (get_epoch == true) {
  		return epoch;
  	    }
  	    return null;
  	},
  	get_url_epoch_interval: function() {
              let epoch = {
  		epoch_begin: ntopng_url_manager$1.get_url_entry("epoch_begin"),
  		epoch_end: ntopng_url_manager$1.get_url_entry("epoch_end"),
              };
  	    return epoch;
  	},
  	from_utc_s_to_server_date: function(utc_seconds) {
  	    let utc = utc_seconds * 1000;
  	    let d_local = new Date(utc);
  	    let local_offset = d_local.getTimezoneOffset();
  	    let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
  	    let offset_minutes =  server_offset + local_offset;
  	    let offset_ms = offset_minutes * 1000 * 60;
  	    var d_server = new Date(utc + offset_ms);
  	    return d_server;
  	},
      get_date_format: async function(is_range_picker, csrf, http_prefix) {
          const rest_params = {
              csrf: csrf
          };

          let date_format_url = `${http_prefix}/lua/rest/v2/get/timeseries/date_format.lua`;
          const url = NtopUtils.buildURL(date_format_url, {
              is_range_picker: is_range_picker
          });
          return await ntopng_utility$1.http_request(url, rest_params);    
      },
  	from_utc_to_server_date_format: function(utc_ms, format) {
  	    if (format == null) { format = "DD/MMM/YYYY HH:mm:ss"; }
  	    let m = moment.tz(utc_ms, ntop_zoneinfo);
  	    let tz_server = m.format(format);
  	    return tz_server;
  	},
  	copy_object_keys: function(source_obj, dest_obj, recursive_object = false) {
  	    if (source_obj == null) {
  		return;
  	    }
  	    for (let key in source_obj) {
  	    	if (source_obj[key] == null) { continue; }
  		/* Security check for Prototype pollution vulnerability */
  		if (key === "__proto__" || key === "constructor") { continue; }
  	    	if (recursive_object == true && this.is_object(source_obj[key]) && this.is_object(dest_obj[key])) {
  	    	    this.copy_object_keys(source_obj[key], dest_obj[key], recursive_object);
  	    	} else {
  	    	    dest_obj[key] = source_obj[key];
  	    	}
  	    }
  	},
      get_cve_details_url(cve_id, scan_type) {
          //  IMPORTANT: The retrieved value must match the value in 
          //  scripts/lua/modules/vulnerability_scan/cve_utils.lua for the 'cve_utils.getDocURL' function.
          if(scan_type == "cve") {
              return `https://nvd.nist.gov/vuln/detail/${cve_id}`;
          } else if(scan_type == "openvas") {
              return `https://vulners.com/openvas/OPENVAS:${cve_id}`;
          }
      },
  	set_http_globals_headers(headers) {
  	    global_http_headers = headers;
  	},
  	http_post_request: async function(url, params, throw_exception, not_unwrap) {
  	    let headers = {
  		'Content-Type': 'application/json'
  	    };
  	    if (params.csrf == null) {
  		throw `NULL csrf in ${url} POST request.`;
  	    }
  	    return this.http_request(url, { method: 'post', headers, body: JSON.stringify(params) }, throw_exception, not_unwrap);
  	},
  	http_request: async function(url, options, throw_exception, not_unwrap) {
  	    try {
  		if (options == null) {
  		    options = {};
  		}
  		if (options.headers == null) {
  		    options.headers = {};
  		}
  		if (options.headers != null && global_http_headers != null) {
  		    options.headers = {
  			...options.headers,
  			...global_http_headers,
  		    };
  		}
  		let res = await fetch(url, options);
  		if (res.ok === false) {
  		    console.error(`http_request ${url}\n ok == false`);
  		    console.error(res);
  		    return null;
  		}
  		let json_res = await res.json();
  		if (not_unwrap === true) { return json_res; }
  		return json_res.rsp;
  	    } catch (err) {
  		console.error(err);
  		console.error("URL: " + url);
  		if (throw_exception == true) { throw err; }
  		return null;
  	    }
  	},
  	download_URI: function(uri, name) {
  	    var link = document.createElement("a");
  	    link.download = name;
  	    link.href = uri;
  	    document.body.appendChild(link);
  	    link.click();
  	    document.body.removeChild(link);
  	},
  	get_random_string: function() {
  	    return Math.random().toString(16).substr(2, 8);
  	},
  	string_hash_code: function(s) {
  	    let hash = 0, i, chr;
  	    if (s.length === 0) return hash;
  	    for (i = 0; i < s.length; i++) {
  		chr   = s.charCodeAt(i);
  		hash  = ((hash << 5) - hash) + chr;
  		hash |= 0; // Convert to 32bit integer
  	    }
  	    return hash;
  	},
  	mod: function(x, y) {
  	    x = x % y;
  	    if (x < 0) { x += y; }
  	    return x;
  	}
      }
  }();

  /**
  * Allows to manage the application global status.
  * The status is incapsulated into the url.
  */
  const ntopng_status_manager$1 = function() {
      let global_status = {};
      /** @type {{ [id: string]: (status: object) => void}} */
      let subscribers = {}; // dictionary of { [id: string]: f_on_ntopng_status_change() }
      const clone = (e) => ntopng_utility$1.clone(e);

      const relplace_global_status = function(status) {
          global_status = status;
      };

      /**
       * Notifies the status to all subscribers with id different from skip_id.
       * @param {object} status object that represent the application status.
       * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
       */
      const notify_subscribers = function(status, skip_id) {
          for (let id in subscribers) {
              if (id == skip_id) { continue; }
              let f_on_change = subscribers[id];
              f_on_change(clone(status));
          }
      };

      return {
          /**
           * Gets the current global application status.
           * @returns {object}
           */
          get_status: function(not_clone) {
  	    if (not_clone == true) {
  		return global_status;
  	    }
              return clone(global_status);
          },

          update_subscribers: function() {
              const status = this.get_status();
              notify_subscribers(status);
          },

          /**
           * Allows to subscribers f_on_change callback on status change event.
           * @param {string} id an identifier of the subscribtion. 
           * @param {(status:object) => void} f_on_change callback that take object status as param.
           * @param {boolean} get_init_notify if true the callback it's immediately called with the last status available.
           */
          on_status_change: function(id, f_on_change, get_init_notify) {
              subscribers[id] = f_on_change;
              if (get_init_notify == true) {
                  let status = this.get_status();
                  f_on_change(clone(status));
              }
          },

          /**
           * Raplaces the application status and notifies the new status to all subscribers.
           * Notifies the new status to all subscribers.
           * @param {Object} status object that represent the application status.
           * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
           */
          replace_status: function(status, skip_id) {
              relplace_global_status(status);
              notify_subscribers(status, skip_id);
          },

          /**
           * Adds or replaces all obj param keys to the application status.
           * Notifies the new status to all subscribers.
           * @param {Object} obj object to add or edit to the application status. 
           * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
           */
          add_obj_to_status: function(obj, skip_id) {
              let new_status = this.get_status();
              ntopng_utility$1.copy_object_keys(obj, new_status);
              this.replace_status(new_status, skip_id);
          },

          /**
           * Adds or replaces the value key to the application status.
           * Notifies the new status to all subscribers.
           * @param {string} key key to adds or replaces.
           * @param {any} value value to adds or replaces.
           * @param {*} skip_id if != null doesn't notify the subscribers with skip_id identifier.
           */
          add_value_to_status: function(key, value, skip_id) {
              let new_status = this.get_status();
              new_status[key] = value;
              // /* This is needed to have muliple filters for the same key */
              // (new_status[key] && new_status[key].search(value) === -1) ? new_status[key] += "," + value : new_status[key] = value
            
              this.replace_status(new_status, skip_id);
          },
      }
  }();

  const ntopng_params_url_serializer = {
    // filters: function(key, filters) {
    // 	if (filters == null) { return ""; }
    // 	let filters_groups = {};
    // 	filters.forEach((f) => {
    // 	    let group = filters_groups[f.id];
    // 	    if (group == null) {
    // 		group = [];
    // 		filters_groups[f.id] = group;
    // 	    }
    // 	    group.push(f);
    // 	});
    // 	let url_params_array = [];
    // 	for (let f_id in filters_groups) {
    // 	    let group = filters_groups[f_id];
    // 	    let url_values = group.filter((f) => f.value != null && f.operator != null && f.operator != "").map((f) => `${f.value};${f.operator}`).join(",");
    // 	    let url_params = ntopng_url_manager.serialize_param(f_id, url_values);
    // 	    url_params_array.push(url_params);
    // 	}
    // 	return url_params_array.join("&");
    // },
  };

  const ntopng_url_manager$1 = function() {
      /** @type {{ [key: string]: (obj: any) => string}} */
      let custom_params_serializer = {};
      ntopng_utility$1.copy_object_keys(ntopng_params_url_serializer, custom_params_serializer);
    
      return {

          get_url_params: function() {
              return window.location.search.substring(1);
          },

          get_url_search_params: function(url) {
              if (url == null) {
                  url = this.get_url_params();
              }
              // for(const [key, value] of entries) {
              const url_params = new URLSearchParams(url);
              return url_params;
          },

          get_url_entries: function(url) {
              const url_params = this.get_url_search_params(url);
              const entries = url_params.entries();
              return entries;
          },

          get_url_entry: function(param_name, url) {
              let entries = this.get_url_entries(url);
              for(const [key, value] of entries) {
                  if (key == param_name) { return value; }
              }
              return null;
          },

          get_url_object: function(url) {
              let entries = this.get_url_entries(url);
              let obj = {};
              for (const [key, value] of entries) {
                  obj[key] = value;
              }
              return obj;
          },

          open_new_window: function(url) {
              if (url == null) {
                  url = window.location;
              }
              window.open(url);
          },

          reload_url: function() {
              window.location.reload();
          },

  	go_to_url: function(url) {
  	    window.history.pushState({}, '', window.location);
  	    window.location.replace(url);
  	},

          replace_url: function(url_params) {
              window.history.replaceState({}, null, `?${url_params}`);
          },

          replace_url_and_reload: function(url_params) {
              this.replace_url(url_params);
              this.reload_url();
          },

          serialize_param: function(key, value) {
              if (value == null) {
                  value = "";
              }
              return `${key}=${encodeURIComponent(value)}`;
          },	

          set_custom_key_serializer: function(key, f_get_url_param) {
              custom_params_serializer[key] = f_get_url_param;
          },

          /**
           * Convert js object into a string that represent url params.
           * Uses custom serializer if set.
           * @param {object} obj.
           * @returns {string}.
           */
          obj_to_url_params: function(obj) {
              let params = [];
              const default_serializer = this.serialize_param;
              for (let key in obj) {
                  let serializer = custom_params_serializer[key];
                  if (serializer == null) {
                      serializer = default_serializer;
                  }
                  let param = serializer(key, obj[key]);
                  params.push(param);
              }
              let url_params = params.join("&");
              return url_params;
          },

          delete_params: function(params_key) {
              let search_params = this.get_url_search_params();
              params_key.forEach((p) => {
                  search_params.delete(p);
              });
              this.replace_url(search_params.toString());	    
          },

          delete_key_from_url: function(key) {
              let search_params = this.get_url_search_params();
              search_params.delete(key);
              this.replace_url(search_params.toString());	    
          },

          set_key_to_url: function(key, value) {
              if (value == null) { value = ""; }	  
              let search_params = this.get_url_search_params();
              search_params.set(key, value);
              this.replace_url(search_params.toString());
          },

          add_obj_to_url: function(url_params_obj, url) {
              let new_url_params = this.obj_to_url_params(url_params_obj);
              let search_params = this.get_url_search_params(url);
              let new_entries = this.get_url_entries(new_url_params);
              for (const [key, value] of new_entries) {
          	search_params.set(key, value);
              }
              let new_url = search_params.toString();
              if (url != null) { return new_url; }
              this.replace_url(new_url);
          },
      }
  }();

  // export const ntopng_params_manager = function() {
  //     const new = function(params_in_url) {
  //     }
  //     return {
  //     }
  // }

  /**
  * Object that represents a list of prefedefined events that represent the status.
  */
  const ntopng_events$1 = {
    EPOCH_CHANGE: "epoch_change", // { epoch_begin: number, epoch_end: number }
    FILTERS_CHANGE: "filters_change", // {filters: {id: string, operator: string, value: string}[] }
  };

  const ntopng_events_compare = {
    EPOCH_CHANGE: function(new_status, old_status) {
  return new_status.epoch_begin != old_status.epoch_begin
      || new_status.epoch_end != old_status.epoch_end;
    },
    FILTERS_CHANGE: function(new_status, old_status) {	
  return (new_status.filters == null && old_status.filters != null)
      || (new_status.filters != null && old_status.filters == null)
      || (new_status.filters != null && old_status.filters != null &&
    (
        (new_status.filters.length != old_status.filters.length)
      || (new_status.filters.some((f_new) => old_status.filters.find((f_old) => f_old.id == f_new.id) == null))
    )
         );
    },
  };

  /**
  * Object that represents a list of prefedefined custom events.
  */
  const ntopng_custom_events$1 = {
    SHOW_MODAL_FILTERS: "show_modal_filters", // {id: string, operator: string, value: string}
    MODAL_FILTERS_APPLY: "modal_filters_apply", // {id: string, label: string, operator: string, value: string, value_label: string}
    SHOW_GLOBAL_ALERT_INFO: "show_global_alert_info", // html_text: string
    VIS_DATA_LOADED: "vis_data_loaded", 
    CHANGE_PAGE_TITLE: "change_page_title", 
      DATATABLE_LOADED: "datatable_loaded",
      GET_INTERFACE_FATA: "get_interface_data", // object returned by /lua/rest/v2/get/interface/data.lua
      COMPONENT_EPOCH_INTERVAL_CHANGE: "component_epoch_interval_change", // { epoch_begin: number, epoch_end: number }
  };


  /**
  * A global events service that allows to manage the application global status.
  * The status is incapsulated into the url.
  */
  const ntopng_events_manager$1 = function() {
    const events_manager_id = "events_manager";
    let status = {};

    /** @type {{ [event_name: string]: { [id: string]: (status: object) => void}}} */
    let events_subscribers = {}; // dictionary of { [event_name: string]: { [id: string]: f_on_event }

      const clone = (e) => ntopng_utility$1.clone(e);

    /**
     * Notifies the status to all subscribers with id different from skip_id.
     * @param {{ [id: string]: (status: object) => void}} subscribers dictionary of id => f_on_event().
     * @param {object} status object that represent the application status.
     * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
     */
    const notify_subscribers = function(subscribers, status, skip_id) {
        for (let id in subscribers) {
            if (id == skip_id) { continue; }
            let f_on_change = subscribers[id];
            f_on_change(clone(status));
        }
    };

    /**
     * A callback that dispatches each event to all subscribers.
     * @param {object} new_status 
     */
    const on_status_change = function(new_status) {
  for (let event_name in ntopng_events$1) {
      let f_compare = ntopng_events_compare[event_name];
      if (f_compare(new_status, status) == true) {
    let subscribers = events_subscribers[event_name];
    notify_subscribers(subscribers, new_status);
      }
  }

        status = new_status;
    };

      const get_event_for_single_dest = (event, dest_id) => {
  	return `${event}_${dest_id}`;
      };

    ntopng_status_manager$1.on_status_change(events_manager_id, on_status_change, true);

      const emit = function(event, params, skip_id, dest_id) {
  	if (dest_id != null) {
  	    event = get_event_for_single_dest(event, dest_id);
  	}
  	let subscribers = events_subscribers[event];
  	if (subscribers == null) { return; }
  	notify_subscribers(subscribers, params, skip_id);
      };

      const on_event = function(id, event, f_on_event, get_init_notify, is_single_dest_event) {
  	if (is_single_dest_event == true) {
  	    event = get_event_for_single_dest(event, id);
  	}
  	if (events_subscribers[event] == null) {
              events_subscribers[event] = {};        
  	}
  	if (get_init_notify == true) {
              let status = ntopng_status_manager$1.get_status();        
              f_on_event(clone(status));
  	}
  	events_subscribers[event][id] = f_on_event;
      };

    return {
        emit_custom_event: function(event, params, dest_id) {
  	  emit(event, params, null, dest_id);
        },
        on_custom_event: function(id, event, f_on_event, is_single_dest_event) {
  	  on_event(id, event, f_on_event, null, is_single_dest_event);
        },
        /**
         * Changes the application status and emits the new status to all subcribers registered to the event. 
         * @param {string} event event name.
         * @param {object} new_status object to add or edit to the application status.
         * @param {string} skip_id if != null doesn't notify the subscribers with skip_id identifier.
         */
        emit_event: function(event, new_status, skip_id) {
      emit(event, new_status, skip_id);
            ntopng_status_manager$1.add_obj_to_status(new_status, events_manager_id);
        },
        /**
         * Allows to subscribers f_on_event callback on status change on event event_name.
         * @param {string} id an identifier of the subscribtion. 
         * @param {string} event event name. 
         * @param {(status:object) => void} f_on_event callback that take object status as param.
         * @param {boolean} get_init_notify if true the callback it's immediately called with the last status available.
         */
        on_event_change: function(id, event, f_on_event, get_init_notify) {
      on_event(id, event, f_on_event, get_init_notify);
        },
    };
  }();

  window.ntopng_events = ntopng_events$1;
  window.ntopng_events_manager = ntopng_events_manager$1;
  window.ntopng_status_manager = ntopng_status_manager$1;
  window.ntopng_utility = ntopng_utility$1;
  window.ntopng_url_manager = ntopng_url_manager$1;
  window.ntopng_sync = ntopng_sync$1;
  window.ntopng_custom_events = ntopng_custom_events$1;

  // http://jsfiddle.net/stephenboak/hYuPb/

  // Wrapper function
  function do_pie(name, update_url, url_params, units, refresh) {
  	var pie = new PieChart(name, update_url, url_params, units, refresh);
  	if (refresh)
  		pie.setInterval(setInterval(function () { pie.update(); }, refresh));

  	// Return new class instance, with
  	return pie;
  }

  function PieChart(name, update_url, url_params, units, refresh) {

  	// Add object properties like this
  	this.name = name;
  	this.update_url = update_url;
  	this.url_params = url_params;
  	this.units = units;
  	this.refresh = refresh;

    let streakerDataAdded = [];
    let paths = "";
    let lines = [];
    let valueLabels = [];
    let nameLabels = [];

  	var pieData = [];
  	var oldPieData = [];
  	var filteredPieData = [];
  	var rsp = create_pie_chart(name, units);
  	var arc_group = rsp[0];
  	var donut = rsp[1];	
  	var totalValue = rsp[2];
  	var color = rsp[4];
  	var tweenDuration = rsp[5];
  	var arc = rsp[6];
  	var label_group = rsp[7];	
  	var r = rsp[9];
  	var textOffset = rsp[10];


  	// to run each time data is generated

  	this.update = function () {
  		// console.log(this.name);
  		// console.log(this.url_params);
  		$.ajax({
  			type: 'GET',
  			url: this.update_url,
  			data: this.url_params,
  			success: function (content) {
  				let parsed_content;

  				if (typeof (content) == "object")
  					parsed_content = content;
  				else if (typeof (content) == "string")
  					parsed_content = jQuery.parseJSON(content);

  				if (parsed_content)
  					update_pie_chart(parsed_content);
  			}
  		});
  	};

  	///////////////////////////////////////////////////////////
  	// STREAKER CONNECTION ////////////////////////////////////
  	///////////////////////////////////////////////////////////

  	// Needed to draw the pie immediately
  	this.update();
  	this.update();

  	// var updateInterval = window.setInterval(update, refresh);

  	function compare_by_label(a, b) {
  		if (a.label < b.label) {
  			return -1;
  		} else if (a.label > b.label) {
  			return 1;
  		} else {
  			return 0;
  		}
  	}

  	function update_pie_chart(data) {
  		if (data.rsp) // detect REST API v1
  			data = data.rsp;

  		data.sort(compare_by_label);
  		streakerDataAdded = data;
  		oldPieData = filteredPieData;
  		pieData = donut(streakerDataAdded);

  		var totalOctets = 0;
  		filteredPieData = pieData.filter(filterData);
  		function filterData(element, index, array) {
  			element.name = streakerDataAdded[index].label;
  			element.value = streakerDataAdded[index].value;
  			element.url = streakerDataAdded[index].url;
  			totalOctets += element.value;
  			return (element.value > 0);
  		}

  		if ((filteredPieData.length > 0) && (oldPieData.length > 0)) {
  			//REMOVE PLACEHOLDER CIRCLE
  			arc_group.selectAll("circle").remove();

  			if (totalValue) {
  				totalValue.text(function () {
  					var kb = totalOctets / 1024;
  					return kb.toFixed(1);
  					//return bchart.label.abbreviated(totalOctets*8);
  				});
  			}

  			//DRAW ARC PATHS
  			paths = arc_group.selectAll("path").data(filteredPieData);
  			paths.enter().append("svg:path")
  				.attr("stroke", "white")
  				.attr("stroke-width", 0.5)
  				.attr("fill", function (d, i) { return color(i); })
  				.transition()
  				.duration(tweenDuration)
  				.attrTween("d", pieTween);
  			paths
  				.transition()
  				.duration(tweenDuration)
  				.attrTween("d", pieTween);
  			paths.exit()
  				.transition()
  				.duration(tweenDuration)
  				.attrTween("d", removePieTween)
  				.remove();

  			//DRAW TICK MARK LINES FOR LABELS
  			lines = label_group.selectAll("line").data(filteredPieData);
  			lines.enter().append("svg:line")
  				.attr("x1", 0)
  				.attr("x2", 0)
  				.attr("y1", -r - 3)
  				.attr("y2", -r - 8)
  				.attr("stroke", "gray")
  				.attr("transform", function (d) {
  					return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
  				});
  			lines.transition()
  				.duration(tweenDuration)
  				.attr("transform", function (d) {
  					return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
  				});
  			lines.exit().remove();

  			//DRAW LABELS WITH PERCENTAGE VALUES
  			valueLabels = label_group.selectAll("text.value").data(filteredPieData)
  				.attr("dy", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
  						return 5;
  					} else {
  						return -7;
  					}
  				})
  				.attr("text-anchor", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
  						return "beginning";
  					} else {
  						return "end";
  					}
  				})
  				.text(function (d) {

  					const percentage = (d.value / totalOctets) * 100;
  					// approssimate the number to the third deciaml digit and show only the first decimal
  					let percentageLabel = percentage.toFixed(1) + "%";
  					return percentageLabel;
  				});

  			valueLabels.enter().append("svg:text")
  				.attr("class", "value")
  				.attr("transform", function (d) {
  					return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
  				})
  				.attr("dy", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
  						return 5;
  					} else {
  						return -7;
  					}
  				})
  				.attr("text-anchor", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
  						return "beginning";
  					} else {
  						return "end";
  					}
  				}).text(function (d) {
  					if (totalOctets <= 1) return "";
  					const percentage = (d.value / totalOctets) * 100;
  					let percentageLabel = percentage.toFixed(1) + "%";
  					return percentageLabel;
  				});

  			valueLabels.transition().duration(tweenDuration).attrTween("transform", textTween);
  			valueLabels.exit().remove();

  			//DRAW LABELS WITH ENTITY NAMES
  			nameLabels = label_group.selectAll("text.units").data(filteredPieData)
  				.attr("dy", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
  						return 17;
  					} else {
  						return 5;
  					}
  				})
  				.attr("text-anchor", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
  						return "beginning";
  					} else {
  						return "end";
  					}
  				}).text(function (d) {
  					return d.name;
  				})
  				.on("click", function (d) { if (d.url) window.location.href = d.url; });

  			nameLabels.enter().append("svg:text")
  				.attr("class", "units")
  				.attr("transform", function (d) {
  					return "translate(" + Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + textOffset) + "," + Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + textOffset) + ")";
  				})
  				.attr("dy", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 && (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
  						return 17;
  					} else {
  						return 5;
  					}
  				})
  				.attr("text-anchor", function (d) {
  					if ((d.startAngle + d.endAngle) / 2 < Math.PI) {
  						return "beginning";
  					} else {
  						return "end";
  					}
  				}).text(function (d) {
  					return d.name;
  				})
  				.on("click", function (d) { if (d.url) window.location.href = d.url; });

  			nameLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

  			nameLabels.exit().remove();
  		}
  	}

  	///////////////////////////////////////////////////////////
  	// FUNCTIONS //////////////////////////////////////////////
  	///////////////////////////////////////////////////////////

  	// Interpolate the arcs in data space.
  	function pieTween(d, i) {
  		var s0;
  		var e0;
  		if (oldPieData[i]) {
  			s0 = oldPieData[i].startAngle;
  			e0 = oldPieData[i].endAngle;
  		} else if (!(oldPieData[i]) && oldPieData[i - 1]) {
  			s0 = oldPieData[i - 1].endAngle;
  			e0 = oldPieData[i - 1].endAngle;
  		} else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
  			s0 = oldPieData[oldPieData.length - 1].endAngle;
  			e0 = oldPieData[oldPieData.length - 1].endAngle;
  		} else {
  			s0 = 0;
  			e0 = 0;
  		}
  		var i = d3.interpolate({ startAngle: s0, endAngle: e0 }, { startAngle: d.startAngle, endAngle: d.endAngle });
  		return function (t) {
  			var b = i(t);
  			return arc(b);
  		};
  	}

  	function removePieTween(d, i) {
  		s0 = 2 * Math.PI;
  		e0 = 2 * Math.PI;
  		var i = d3.interpolate({ startAngle: d.startAngle, endAngle: d.endAngle }, { startAngle: s0, endAngle: e0 });
  		return function (t) {
  			var b = i(t);
  			return arc(b);
  		};
  	}

  	function textTween(d, i) {
  		var a;
  		if (oldPieData[i]) {
  			a = (oldPieData[i].startAngle + oldPieData[i].endAngle - Math.PI) / 2;
  		} else if (!(oldPieData[i]) && oldPieData[i - 1]) {
  			a = (oldPieData[i - 1].startAngle + oldPieData[i - 1].endAngle - Math.PI) / 2;
  		} else if (!(oldPieData[i - 1]) && oldPieData.length > 0) {
  			a = (oldPieData[oldPieData.length - 1].startAngle + oldPieData[oldPieData.length - 1].endAngle - Math.PI) / 2;
  		} else {
  			a = 0;
  		}
  		var b = (d.startAngle + d.endAngle - Math.PI) / 2;

  		var fn = d3.interpolateNumber(a, b);
  		return function (t) {
  			var val = fn(t);
  			return "translate(" + Math.cos(val) * (r + textOffset) + "," + Math.sin(val) * (r + textOffset) + ")";
  		};
  	}

  }

  ///////////////////////////////////////////////////////////
  // PUBLIC FUNCIONTS ////////////////////////////////////
  ///////////////////////////////////////////////////////////


  PieChart.prototype.setUrlParams = function (url_params) {
  	this.url_params = url_params;
  	this.forceUpdate();
  };

  PieChart.prototype.forceUpdate = function (url_params) {
  	this.stopInterval();
  	this.update();
  	this.startInterval();
  };

  PieChart.prototype.setInterval = function (p_pieInterval) {
  	this.pieInterval = p_pieInterval;
  };

  PieChart.prototype.stopInterval = function () {
  	//disabled graph interval
  	clearInterval(this.pieInterval);
  };

  PieChart.prototype.startInterval = function () {
  	this.pieInterval = setInterval(this.update(), this.refresh);
  };
  ///////////////////////////////////////////////////////////
  // INIT FUNCIONTS ////////////////////////////////////
  ///////////////////////////////////////////////////////////

  function create_pie_chart(name, units) {
  	var w = 500; //380 - Please keep in sync with pie-chart.css
  	var h = 325; //280
  	var ir = 52; //45
  	var textOffset = 14;
  	var tweenDuration = 250;
  	var r = 116; //100;

  	if ($(name).hasClass("pie-chart-small")) {
  		w = 330;
  		h = 250;
  		r = w / 5 + 15;
  		ir = r / 2;
  	}

  	//D3 helper function to populate pie slice parameters from array data
  	var donut = d3.layout.pie().value(function (d) {
  		if (d.value == 0) { d.value = 1; } // Force to 1, in order to update the graph
  		return d.value;
  	});

  	//D3 helper function to create colors from an ordinal scale
  	var color = d3.scale.category20();

  	//D3 helper function to draw arcs, populates parameter "d" in path object
  	var arc = d3.svg.arc()
  		.startAngle(function (d) { return d.startAngle; })
  		.endAngle(function (d) { return d.endAngle; })
  		.innerRadius(ir)
  		.outerRadius(r);

  	///////////////////////////////////////////////////////////
  	// CREATE VIS & GROUPS ////////////////////////////////////
  	///////////////////////////////////////////////////////////

  	var vis = d3.select(name).append("svg:svg")
  		.attr("width", w)
  		.attr("height", h)
  		.attr("viewBox", "0 0 " + w + " " + h)
  		.attr("preserveAspectRatio", "xMidYMid");

  	//GROUP FOR ARCS/PATHS
  	var arc_group = vis.append("svg:g")
  		.attr("class", "arc")
  		.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

  	//GROUP FOR LABELS
  	var label_group = vis.append("svg:g")
  		.attr("class", "label_group")
  		.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

  	//GROUP FOR CENTER TEXT
  	var center_group = vis.append("svg:g")
  		.attr("class", "center_group")
  		.attr("transform", "translate(" + (w / 2) + "," + (h / 2) + ")");

  	//PLACEHOLDER GRAY CIRCLE
  	arc_group.append("svg:circle")
  		.attr("fill", "#EFEFEF")
  		.attr("r", r);

  	///////////////////////////////////////////////////////////
  	// CENTER TEXT ////////////////////////////////////////////
  	///////////////////////////////////////////////////////////

  	//WHITE CIRCLE BEHIND LABELS
  	center_group.append("svg:circle")
  		.attr("fill", "white")
  		.attr("r", ir);

  	var totalUnits = null;
  	var totalValue = null;
  	
  	if (units) {
  		// "TOTAL" LABEL
  		center_group.append("svg:text")
  			.attr("class", "label")
  			.attr("dy", -15)
  			.attr("text-anchor", "middle") // text-align: right
  			.text("TOTAL");

  		//TOTAL TRAFFIC VALUE
  		totalValue = center_group.append("svg:text")
  			.attr("class", "total")
  			.attr("dy", 7)
  			.attr("text-anchor", "middle") // text-align: right
  			.text("Waiting...");

  		//UNITS LABEL
  		totalUnits = center_group.append("svg:text")
  			.attr("class", "units")
  			.attr("dy", 21)
  			.attr("text-anchor", "middle") // text-align: right
  			.text(units);
  	}

  	return ([arc_group, donut, totalValue, totalUnits, color, tweenDuration, arc, label_group, center_group, r, textOffset]);
  }

  /**
   * (C) 2013-21 - ntop.org
   */

  const DEFINED_WIDGETS = {};
  /* Used to implement the on click events onto the graph */
  const DEFINED_EVENTS = {
      /* On click event used by the flow analyze section, redirect to the current url + a single filter */
      "db_analyze" : function (event, chartContext, config) {
          const { dataPointIndex } = config;
          const { filter } = config.w.config;
          let value;

          if(config.w.config.filtering_labels)
              value = config.w.config.filtering_labels[dataPointIndex];

          if(filter.length == 0 || value === undefined)
              return;

          let status = ntopng_status_manager.get_status();
          let filters = status.filters;
          filters.push({id: filter[0], operator: "eq", value: value});
          // notify that filters status is updated
          ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, {filters});
      },

      "none" : function (event, chartContext, config) {
          return;
      },
      
      /* Standard on click event, redirect to the url */
      "standard" : function (event, chartContext, config) {
          const { seriesIndex, dataPointIndex } = config;
          const { series } = config.w.config;
          if (seriesIndex === -1) return;
          if (series === undefined) return;

          const serie = series[seriesIndex];
          if (serie.base_url !== undefined) {
              const default_url = (serie.start_url || ''); 
              const search = serie.data[dataPointIndex].meta.url_query;
              location.href = `${serie.base_url}?${default_url}${search}`;
          }
      },
  };

  const DEFINED_TOOLTIP = {
      /* On click event used by the flow analyze section, redirect to the current url + a single filter */
      "format_bytes" : function(value, { config, seriesIndex, dataPointIndex }) {
          return NtopUtils.bytesToSize(value);
      },

      "format_pkts" : function(value, { config, seriesIndex, dataPointIndex }) {
          return NtopUtils.formatPackets(value);
      },

      /* On click event used by the flow analyze section, redirect to the current url + a single filter */
      "format_value" : function(value, { config, seriesIndex, dataPointIndex }) {
          return NtopUtils.formatValue(value);
      },

      "format_multiple_date" : function(value, { config, seriesIndex, dataPointIndex }) {
          return new Date(value[0]) + " - " + new Date(value[1])
      },

      /*
       *  This formatter is used by the bubble host map, from the y axis,
       *  used to show the Hosts, with their respective values 
       */
      "format_label_from_xy" : function({series, seriesIndex, dataPointIndex, w}) {
          const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
          
          const x_value = serie["x"];
          const y_value = serie["y"];
          const host_name = serie["meta"]["label"];

          const x_axis_title = w.config.xaxis.title.text;
          const y_axis_title = w.config.yaxis[0].title.text;

          return (`
            <div class='apexcharts-theme-light apexcharts-active' id='test'>
                <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
                    ${host_name}
                </div>
                <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${x_axis_title}</b>: ${x_value}
                    </div>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${y_axis_title}</b>: ${y_value}
                    </div>
                </div>
            </div>`)
      },
      "format_label_from_xname" : function({series, seriesIndex, dataPointIndex, w}) {
          const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
          const name = serie["name"];
          const y_value = serie["y"];
          const host_name = serie["meta"]["label"];

          const x_axis_title = w.config.xaxis.title.text;
          const y_axis_title = w.config.yaxis[0].title.text;

          return (`
            <div class='apexcharts-theme-light apexcharts-active' id='test'>
                <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
                    ${host_name}
                </div>
                <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${x_axis_title}</b>: ${name}
                    </div>
                    <div class='apexcharts-tooltip-text text-left'>
                        <b>${y_axis_title}</b>: ${y_value}
                    </div>
                </div>
            </div>`)
      },
  };

  /* Standard Formatter */
  const DEFAULT_FORMATTER = DEFINED_TOOLTIP["format_value"];

  class WidgetUtils {

      static registerWidget(widget) {
          if (widget === null) throw new Error(`The passed widget reference is null!`);
          if (widget.name in DEFINED_WIDGETS) throw new Error(`The widget ${widget.name} is already defined!`);
          DEFINED_WIDGETS[widget.name] = widget;
      }

      static getWidgetByName(widgetName) {
          if (widgetName in DEFINED_WIDGETS) {
              return DEFINED_WIDGETS[widgetName];
          }
          throw new Error(`Widget ${widgetName} not found!`)
      }
  }

  /**
   * Define a simple wrapper class for the widgets.
   */
  class Widget {

      constructor(name, datasource = {}, updateTime = 0, additionalParams = {}) {

          // field containing the data fetched from the datasources provided
          this._fetchedData = [];

          this.name = name;

          // if 0 then don't update the chart automatically, the time
          // is expressed in milliseconds
          this._updateTime = updateTime;

          this._datasource = datasource;
          this._additionalParams = additionalParams;
      }

      /**
       * Init the widget.
       */
      async init() {

          // register the widget to the DEFINED_WIDGETS object
          WidgetUtils.registerWidget(this);
          this._fetchedData = await this._fetchData();

          if (this._updateTime > 0) {
              setInterval(async () => { await this.update(this._datasource.params); }, this._updateTime);
          }
      }

      /**
       * Destroy the widget freeing the resources used.
       */
      async destroy() { }

      /**
       * Force the widget to reload it's data.
       */
      async destroyAndUpdate(datasourceParams = {}) {
          await this.destroy();
          await this.update(datasourceParams);
      }

      async updateByUrl(url) {
        const u = new URL(`${location.origin}${this._datasource.name}`);
        let entries = ntopng_url_manager.get_url_entries(url);
        for (const [key, value] of entries) {
            u.searchParams.set(key, value);
        }
        this._datasource.endpoint = u.pathname + u.search;
        this._fetchedData = await this._fetchData();
      }
    
      async update(datasourceParams = {}) {
  	// build the new endpoint
          const u = new URL(`${location.origin}${this._datasource.name}`);

          for (const [key, value] of Object.entries(datasourceParams)) {
              u.searchParams.set(key, value);
          }

          this._datasource.endpoint = u.pathname + u.search;
          this._fetchedData = await this._fetchData();
      }

      /**
       * For each datasources provided to the constructor,
       * do a GET request to a REST endpoint.
       */
      async _fetchData() {
          const req = await fetch(`${http_prefix}${this._datasource.endpoint}`);
          return await req.json();
      }

  }

  class ChartWidget extends Widget {

      constructor(name, type = 'line', datasource = {}, updateTime = 0, additionalParams = {}) {
          super(name, datasource, updateTime, additionalParams);

          this._chartType = type;
          this._chart = {};
          this._$htmlChart = document.querySelector(`#canvas-widget-${name}`);
      }

      static registerEventCallback(widgetName, eventName, callback) {
          setTimeout(async () => {
              try {
                  const widget = WidgetUtils.getWidgetByName(widgetName);
                  const updatedOptions = {
                      chart: {
                          events: {
                              [eventName]: callback
                          }
                      }
                  };
                  await widget._chart.updateOptions(updatedOptions);
              }
              catch (e) {

              }
          }, 1000);
      }

      _generateConfig() {
          const config = {
              series: [],
              tooltip: {
                  enabledOnSeries: [0],
                  x: {
                      show: true,
                      format: 'dd/MM/yyyy HH:mm:ss',
                  },
                  y: {
                      formatter: function(value, { series, seriesIndex, dataPointIndex, w }) {
                          return value;
                      },
                  },
                  z: {
                      show: false,
                  }
              },
              chart: {
                  type: this._chartType,
                  events: {},
                  height: '100%',
                  toolbar: {
                      show: false,
                  }
              },
              xaxis: {
                  labels: {
                      style: {
                          fontSize: '14px',
                      }
                  },
                  tooltip: {
                      enabled: true,
                      formatter: function(value) {
                          return value;
                      }
                  }
              },
              yaxis: {
                  labels: {
                      style: {
                          fontSize: '14px',
                      }
                  },
                  tooltip: {
                      enabled: true,
                      formatter: function(value) {
                          return value;
                      }
                  }
              },
              zaxis: {
                  labels: {
                      style: {
                          fontSize: '14px',
                      }
                  },
                  tooltip: {
                      enabled: true
                  }
              },
              dataLabels: {
                  enabled: true,
                  style: {
                      fontSize: '14px',
                  }
              },
  	    labels: [],
              legend: {
                  show: true,
                  fontSize: '14px',
                  position: 'bottom',
                  onItemClick: {
                      toggleDataSeries: true,
                  },
              },
              plotOptions: {
                  bar: {
                      borderRadius: 4,
                      horizontal: true,
                  }
              },
              noData: {
                  text: 'No Data',
                  align: 'center',
                  verticalAlign: 'middle',
                  style: {
                      fontSize: '24px'
                  }
              }
          };

          // check if the additionalParams field contains an apex property,
          // then merge the two configurations giving priority to the custom one
          if (this._additionalParams && this._additionalParams.apex) {
              const mergedConfig = Object.assign(config, this._additionalParams.apex);
              return mergedConfig;
          }

          return config;
      }

      _buildTooltip(config, rsp) {
          /* By default the areaChart tooltip[y] is overwritten */
          config["tooltip"]["y"] = {
              formatter: function(value, { series, seriesIndex, dataPointIndex, w }) {
                  return value;
              }
          };

          /* Changing events if given */
          if (rsp['tooltip']) {
              for (const axis in rsp['tooltip']) {
                  if (axis === "x" || axis === "y" || axis === "z") {
                      const formatter = rsp['tooltip'][axis]['formatter'];
                      if(!config['tooltip'][axis])
                          config['tooltip'][axis] = {};

                      config['tooltip'][axis]['formatter'] = DEFINED_TOOLTIP[formatter] || NtopUtils[formatter];
                  }
              }

              /* Customizable tooltip requested */
              if(rsp['tooltip']['custom'])
                  config['tooltip']['custom'] = DEFINED_TOOLTIP[rsp['tooltip']['custom']] || NtopUtils[rsp['tooltip']['custom']];
          }
      }

      _buildAxisFormatter(config, axisName) {

          const axis = config[axisName];
          
          if (axis === undefined || axis.labels === undefined) return;
          
          // enable formatters
          if (axis.labels.ntop_utils_formatter !== undefined && axis.labels.ntop_utils_formatter !== 'none') {
              
              const selectedFormatter = axis.labels.ntop_utils_formatter;

              if (NtopUtils[selectedFormatter] === undefined) {
                  console.error(`xaxis: Formatting function '${selectedFormatter}' didn't found inside NtopUtils.`);
              }
              else {
                  axis.labels.formatter = NtopUtils[selectedFormatter];
              }
          }
      }

      _buildDataLabels(config, rsp) {
          if (rsp["dataLabels"]) {
              for (const [dataLabelsOpts, data] of Object.entries(rsp["dataLabels"])) {
                  config["dataLabels"][dataLabelsOpts] = data;
              }
          }   

          let formatter = config["dataLabels"]["formatter"];
          
          if(formatter && DEFINED_TOOLTIP[formatter]) {
              config["dataLabels"]["formatter"] = DEFINED_TOOLTIP[formatter];
          }
      }

      _buildConfig() {

          const config = this._generateConfig();
          const rsp = this._fetchedData.rsp;
          
          // add additional params fetched from the datasource
          const additionals = ['series', 'xaxis', 'yaxis', 'colors', 'labels', 'fill', 'filter', 'filtering_labels'];
          
          for (const additional of additionals) {

              if (rsp[additional] === undefined) continue;

              if (config[additional] !== undefined) {
                  config[additional] = Object.assign(config[additional], rsp[additional]);
              }
              else {
                  config[additional] = rsp[additional];
              }
          }
          
          /* Changing events if given */
          if (rsp['events']) {
              /* Just pass a table of events. e.g. { events = { click = "db_analyze", updated = "standard" } }*/
              for (const event in rsp['events']) {
                  config['chart']['events'][event] = DEFINED_EVENTS[rsp['events'][event]];
              }
          }

          if (rsp['horizontal_chart'] !== undefined) {
              config['plotOptions']['bar']['horizontal'] = rsp['horizontal_chart'];
          }

          this._buildTooltip(config, rsp);
          this._buildAxisFormatter(config, 'xaxis');
          this._buildAxisFormatter(config, 'yaxis');
          this._buildDataLabels(config, rsp);

          return config;
      }

      _initializeChart() {
          const config = this._buildConfig();
          this._chartConfig = config;
          this._chart = new ApexCharts(this._$htmlChart, this._chartConfig);
          this._chart.render();
      }

      async init() {
          await super.init();
          this._initializeChart();
      }

      async destroy() {
          await super.destroy();
          this._chart.destroy();
          this._chart = null;
      }

      async update(datasourceParams = {}) {
          if(this._chartConfig !== undefined) {	    
            if (datasourceParams) {
              await super.update(datasourceParams);
            } else {
              await super.updateByUrl();
            }
            
            if (this._chart != null) {
                  // expecting that rsp contains an object called series
                  const { colors, series, dataLabels, labels, xaxis, filtering_labels } = this._fetchedData.rsp;
                  // update the colors list
                  this._chartConfig.colors = colors;
                  this._chartConfig.series = series;
                  
                  if(xaxis && xaxis.categories)
                      this._chartConfig.xaxis.categories = xaxis.categories;
                  
                  if(filtering_labels)
                      this._chartConfig.filtering_labels = filtering_labels;

                  if(dataLabels) {
                      let formatter = this._chartConfig.dataLabels.formatter;
                      if(formatter && DEFINED_TOOLTIP[formatter])
                          this._chartConfig.dataLabels.formatter = DEFINED_TOOLTIP[formatter];
                      else
                          this._chartConfig.dataLabels.formatter = DEFAULT_FORMATTER;
                  }
                      
                  if(labels) 
                      this._chartConfig.labels = labels;

                  this._chart.updateOptions(this._chartConfig, true);
              }
          }
      }

      async destroyAndUpdate(datasource = {}) {
          await super.destroyAndUpdate(datasource);
          this._initializeChart();
      }

  }

  const fixSubMenuPosition = ($submenu, $hoverButton) => {

      const MIN_SPACE = 20;
      const MIN_HEIGHT = 150;

      let distFromAbove = $hoverButton.position().top;
      const submenuHeight = $submenu.height();
      const documentHeight = $(window).height();

      // if the submenu is too high to be shown then set
      // the overflow on y axis
      if (submenuHeight + distFromAbove >= documentHeight) {

          const currentSubmenuHeight = documentHeight - distFromAbove;
          if (currentSubmenuHeight <= MIN_HEIGHT) {
              distFromAbove = distFromAbove - submenuHeight + $hoverButton.outerHeight();
          }
          else {
              $submenu.css({'max-height': currentSubmenuHeight - MIN_SPACE, 'overflow-y': 'auto'});
          }

      }

      // set the submenu height
      $submenu.css('top', `${distFromAbove}px`);

  };

  $(window).on('scroll', function(){

      const UPPER_LIMIT = 32;
      const windowScrollTop = $(this).scrollTop();

      if (windowScrollTop >= UPPER_LIMIT) {
          $(`#n-navbar`).addClass("scrolled bg-light");
      }
      else {
          $(`#n-navbar`).removeClass("scrolled bg-light");
      }

  });

  $(() => {

      const toggleSidebar = () => {
          // if the layer doesn't exists then create it
          if ($(`.sidebar-close-layer`).length == 0) {

              const $layer = $(`<div class='sidebar-close-layer' style='display:none'></div>`);
              // when the user clicks on the layer
              $layer.on('click', function(){
                  // remove active class from sidebar
                  $(`#n-sidebar`).removeClass('active');
                  // hide the layer and remove it from the DOM
                  $layer.fadeOut(function() {
                      $(this).remove();
                  });
              });

              // append the layer to the wrapper
              $(`#wrapper`).append($layer);
              // show the layer inside the page
              $layer.fadeIn();
          }
          else {
              // hide the existing layer and destroy it
              $(`.sidebar-close-layer`).fadeOut(function() {
                  $(this).remove();
              });
          }

          // show/hide the sidebar
          $(`#n-sidebar`).toggleClass('active');
      };

      $('#n-sidebar a.submenu').bind({
          mouseenter: function() {
              let submenu = $(this).parent().find(`div[id$='submenu']`);
              fixSubMenuPosition(submenu, $(this));
              submenu.show();
          },
          mouseleave: function() {
              let submenu = $(this).parent().find(`div[id$='submenu']`);
              submenu.hide();
          }
      });

      $(`div[id$='submenu']`).bind({
          mouseenter: function() {
              $(this).show();
          },
          mouseleave: function() {
              $(this).hide();
          }
      });

      /* toggle sidebar display */
      $(`button[data-bs-toggle='sidebar']`).on('click', function() {
          toggleSidebar();
      });
  });

  $(window).on('resize', function() {

      // re-calc submenu height
      const $currentSubmenu = $('#n-sidebar').find(`div.show[id$='submenu']`);

      if ($currentSubmenu.length > 0) {

          const $hoverButton = $currentSubmenu.parent().find(`a[data-bs-toggle='collapse']`);
          fixSubMenuPosition($currentSubmenu, $hoverButton);
      }

  });

  /**
      (C) 2022 - ntop.org
  */

  const ntopChartApex$1 = function () {
    // define default chartOptions for all chart type.
    const _default_BASE_ChartOptions = {
      series: [],
      chart: {
        height: "100%",
        width: "100%",
        toolbar: {
          tools: {
            zoomout: false,
            download: false,
            zoomin: false,
            zoom: " ",
            selection: false,
            pan: false,
            reset: false
          }
        },
        events: {}
      },
      xaxis: {
        tooltip: {
          enabled: false,
        },
      },
      yaxis: {
        labels: {
          show: true,
          style: {
            colors: [],
            fontSize: "11px",
            fontWeight: 400,
            cssClass: ""
          }
        },
        title: {
          rotate: -90,
          offsetY: 0,
          offsetX: 0,
          style: {
            fontSize: "11px",
            fontWeight: 900,
            cssClass: ""
          }
        },
        tooltip: {
          enabled: false,
        },
      },
      grid: {
        show: false,
      },
      legend: {
        show: true
      },
    };

    // define default xaxis formatter for chart with datetime on xaxis.
    const _setXTimeFormatter = function (chartOptions) {
      chartOptions.xaxis.labels.formatter = function (value, { series, seriesIndex, dataPointIndex, w }) {
        return ntopng_utility$1.from_utc_to_server_date_format(value);
      };
    };

    // define default chartOptions for area chart type.
    const _default_TS_COLUMN_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_COLUMN_ChartOptions = {
        chart: {
          stacked: true,
          type: "bar",
          zoom: {
            enabled: true,
            type: "x",
          },
        },
        tooltip: {
          // shared: true,
          x: {
            format: "dd MMM yyyy HH:mm:ss"
          },
          y: {}
        },
        xaxis: {
          labels: {
            show: true,
            datetimeUTC: false,
            formatter: null,
          },
          axisTicks: {
            show: false,
          },
          type: "datetime",
          axisBorder: {
            show: true,
          },
          convertedCatToNumeric: false
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
      };
      ntopng_utility$1.copy_object_keys(TS_COLUMN_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    // define default chartOptions for area chart type.
    const _default_TS_STACKED_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_STACKED_ChartOptions = {
        chart: {
          stacked: true,
          type: "area",
          zoom: {
            enabled: true,
            type: "x",
          },
        },
        tooltip: {
          // shared: true,
          x: {
            format: "dd MMM yyyy HH:mm:ss"
          },
          y: {}
        },
        xaxis: {
          labels: {
            show: true,
            datetimeUTC: false,
            formatter: null,
          },
          axisTicks: {
            show: false,
          },
          type: "datetime",
          axisBorder: {
            show: true,
          },
          convertedCatToNumeric: false
        },
        dataLabels: {
          enabled: false
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
      };
      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
      return chartOptions;
    }();


    // define default chartOptions for area chart type.
    const _default_TS_POLAR_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_STACKED_ChartOptions = {
        chart: {
          stacked: true,
          type: "polarArea",
          height: 400
        },
        yaxis: {
          show: true,
          labels: {
            formatter: NtopUtils$1.bytesToSize
          }
        },
        dataLabels: {
          enabled: true,
          formatter: function (val, opts) {
            return (val ? `${val.toFixed(1)}%` : `0%`)
          },
        },
        legend: {
          enabled: true,
          position: 'bottom',
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
        tooltip: {
          y: {
            formatter: NtopUtils$1.bytesToSize
          },
        },
      };
      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    // define default chartOptions for area chart type.
    const _default_TS_DONUT_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_STACKED_ChartOptions = {
        chart: {
          stacked: true,
          type: "donut",
          height: 300
        },
        yaxis: {
          show: true,
          labels: {
            formatter: NtopUtils$1.bytesToSize
          }
        },
        dataLabels: {
          enabled: true,
          formatter: function (val, opts) {
            return (val ? `${val.toFixed(1)}%` : `0%`)
          },
        },
        legend: {
          enabled: true,
          position: 'bottom',
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
        tooltip: {
          y: {
              formatter: formatterUtils.getFormatter("number"),
          },
        },
        noData: {
          text: 'No Data',
          style: {
            color: undefined,
            fontSize: '24px',
            fontFamily: undefined
          }
        }
      };
      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    // define default chartOptions for area chart type.
    const _default_TS_RADIALBAR_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_STACKED_ChartOptions = {
        chart: {
          stacked: true,
          type: "radialBar",
          height: 300
        },
        yaxis: {
          show: true,
        },
        dataLabels: {
          enabled: true,
          formatter: function (val, opts) {
            return val
          },
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
        tooltip: {
          y: {
            formatter: NtopUtils$1.bytesToSize
          },
        },
        noData: {
          text: 'No Data',
          style: {
            color: undefined,
            fontSize: '24px',
            fontFamily: undefined
          }
        },
        plotOptions: {
          radialBar: {
            offsetY: 0,
            startAngle: 0,
            endAngle: 270,
            hollow: {
              margin: 5,
              size: '30%',
              background: 'transparent',
              image: undefined,
            },
            dataLabels: {
              name: {
                show: false,
              },
              value: {
                show: false,
              }
            }
          }
        },
        legend: {
          show: true,
          floating: true,
          fontSize: '16px',
          position: 'left',
          offsetX: 160,
          offsetY: 15,
          labels: {
            useSeriesColors: true,
          },
          markers: {
            size: 0
          },
          formatter: function(seriesName, opts) {
            return seriesName + ":  " + opts.w.globals.series[opts.seriesIndex]
          },
          itemMargin: {
            vertical: 3
          }
        },
        responsive: [{
          breakpoint: 480,
          options: {
            legend: {
                show: false
            }
          }
        }]
      };
      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    // define default chartOptions for area chart type.
    const _default_TS_PIE_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_STACKED_ChartOptions = {
        chart: {
          stacked: true,
          type: "pie",
          height: 400
        },
        yaxis: {
          show: true,
          labels: {
            formatter: NtopUtils$1.bytesToSize
          }
        },
        dataLabels: {
          enabled: true,
          formatter: function (val, opts) {
            return (val ? `${val.toFixed(1)}%` : `0%`)
          },
        },
        legend: {
          enabled: true,
          position: 'bottom',
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
        tooltip: {
          y: {
            formatter: NtopUtils$1.bytesToSize
          },
        },
      };
      ntopng_utility$1.copy_object_keys(TS_STACKED_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    // define default chartOptions for line chart type.
    const _default_TS_LINE_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_LINE_ChartOptions = {
        chart: {
          type: "line",
          zoom: {
            enabled: true,
            type: "x",
          },
        },
        tooltip: {
          shared: true,
          x: {
            format: "dd MMM yyyy HH:mm:ss"
          },
          y: {}
        },
        xaxis: {
          labels: {
            show: false,
            datetimeUTC: false,
            formatter: null,
          },
          axisTicks: {
            show: true
          },
          type: "datetime",
          axisBorder: {
            show: true
          },
          convertedCatToNumeric: false
        },
        stroke: {
          show: true,
          width: 2,
          curve: "smooth"
        },
        grid: {
          show: true,
        },
        dataLabels: {
          enabled: false
        },
      };
      ntopng_utility$1.copy_object_keys(TS_LINE_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    const format_label_from_xname = function ({ series, seriesIndex, dataPointIndex, w }) {
      const serie = w.config.series[seriesIndex]["data"][dataPointIndex];
      const name = serie["name"];
      const y_value = serie["y"];
      const host_name = serie["meta"]["label"];

      const x_axis_title = w.config.xaxis.title.text;
      const y_axis_title = w.config.yaxis[0].title.text;

      return (`
          <div class='apexcharts-theme-light apexcharts-active' id='test'>
              <div class='apexcharts-tooltip-title' style='font-family: Helvetica, Arial, sans-serif; font-size: 12px;'>
                  ${host_name}
              </div>
              <div class='apexcharts-tooltip-series-group apexcharts-active d-block'>
                  <div class='apexcharts-tooltip-text text-left'>
                      <b>${x_axis_title}</b>: ${name}
                  </div>
                  <div class='apexcharts-tooltip-text text-left'>
                      <b>${y_axis_title}</b>: ${y_value}
                  </div>
              </div>
          </div>`)
    };

    // define default chartOptions for line chart type.
    const _default_TS_BUBBLE_ChartOptions = function () {
      let chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
      let TS_BUBBLE_ChartOptions = {
        chart: {
          width: '100%',
          height: '100%',
          stacked: true,
          type: "bubble",
          zoom: {
            autoScaleYaxis: true
          },
        },
        legend: {
          enabled: true,
          position: 'bottom',
        },
        stroke: {
          show: false,
          curve: "smooth"
        },
        fill: {
          type: "solid"
        },
        events: {
          dataPointSelection: "standard",
        },
        grid: {
          padding: {
            left: 6
          },
        },
        xaxis: {
          type: 'numeric',
          labels: {}
        },
        yaxis: {
          type: 'numeric',
          forceNiceScale: true,
          labels: {}
        },
        dataLabels: {
          enabled: false
        },
        tooltip: {
          custom: format_label_from_xname,
        }
      };
      ntopng_utility$1.copy_object_keys(TS_BUBBLE_ChartOptions, chartOptions, true);
      return chartOptions;
    }();

    return {
      typeChart: {
        TS_LINE: "TS_LINE",
        TS_STACKED: "TS_STACKED",
        TS_COLUMN: "TS_COLUMN",
        PIE: "PIE",
        DONUT: "DONUT",
        RADIALBAR: "RADIALBAR",
        RADAR: "RADAR",
        BUBBLE: "BUBBLE",
        BASE: "BASE",
      },
      newChart: function (type) {
        let _chartOptions = {};
        let _chart;

        if (type == this.typeChart.TS_STACKED) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_STACKED_ChartOptions);
          _setXTimeFormatter(_chartOptions);
        } else if (type == this.typeChart.TS_LINE) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_LINE_ChartOptions);
          _setXTimeFormatter(_chartOptions);
        } else if (type == this.typeChart.TS_COLUMN) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_COLUMN_ChartOptions);
          _setXTimeFormatter(_chartOptions);
        } else if (type == this.typeChart.PIE) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_PIE_ChartOptions);
        } else if (type == this.typeChart.DONUT) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_DONUT_ChartOptions);
        } else if (type == this.typeChart.RADIALBAR) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_RADIALBAR_ChartOptions);
        } else if (type == this.typeChart.POLAR) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_POLAR_ChartOptions);
        } else if (type == this.typeChart.BUBBLE) {
          _chartOptions = ntopng_utility$1.clone(_default_TS_BUBBLE_ChartOptions);
        } else if (type == this.typeChart.BASE) {
          _chartOptions = ntopng_utility$1.clone(_default_BASE_ChartOptions);
        } else {
          throw `ntopChartApex::newChart: chart type = ${type} unsupported`;
        }
          const setYaxisFormatter = (chartOptions) => {            
              if (typeof(chartOptions?.yaxis?.labels?.formatter) == "string") {
                const formatter = chartOptions.yaxis.labels.formatter;
                let chartFormatter = formatterUtils.getFormatter(formatter);
                if (chartFormatter != null) {
                    chartOptions.yaxis.labels.formatter = chartFormatter;
                } else {
                    if (formatter == "formatValue") {
                        chartOptions.yaxis.labels.formatter = formatterUtils.getFormatter("number");
                    }
                    else if (formatter == "bytesToSize") {
                        chartOptions.yaxis.labels.formatter = formatterUtils.getFormatter("bytes");
                    }
                }
            }          
          };
        return {
            drawChart: function (htmlElement, chartOptions) {
            // add/replace chartOptions fields in _chartOptions
                setYaxisFormatter(chartOptions);
            ntopng_utility$1.copy_object_keys(chartOptions, _chartOptions, true);
            _chart = new ApexCharts(htmlElement, _chartOptions);
            _chart.render();
          },
          to_data_uri: async function (options) {
            if (_chart == null) { return; }
            let res = await _chart.dataURI(options);
            return res.imgURI;
          },
          destroyChart: function () {
            if (_chart == null) { return; }
            _chart.destroy();
          },
          updateChart: function (chartOptions) {
            if (_chart == null) { return; }
              setYaxisFormatter(chartOptions);
            _chart.updateOptions(chartOptions, false, false, false);
          },
          updateSeries: function (series) {
            if (_chart == null) { return; }
            _chart.updateSeries(series);
          },
          registerEvent: function (eventName, callback, updateChart = false) {
            _chartOptions.chart.events[eventName] = callback;
            if (updateChart == true) {
              _chart.updateOptions(_chartOptions);
            }
          },
        };
      },
    };
  }();

  /**
   * (C) 2020-21 - ntop.org
   * This file contains utilities used by the *new* datatables.
   */


  const DataTableHandlers = function() {
      let handlersIdDict = {};
      return {
          addHandler: function(h) {
              let handlers = handlersIdDict[h.handlerId];
              if (handlers == null) {
                  handlers = [];
                  handlersIdDict[h.handlerId] = handlers;
              }
              handlers.push(() => {
                  h.onClick();
              });
              return `window['_DataTableButtonsOnClick']('${h.handlerId}', '${handlers.length - 1}')`;
          },
          getHandler: function(handlerId, rowId) {
              let handlers = handlersIdDict[handlerId];
              if (handlers == null) { return null; }
              return handlers[rowId];
          },
          deleteHandlersById: function(handlerId) {
              handlersIdDict[handlerId] = null;
          },
      }
  }();
      
  window["_DataTableButtonsOnClick"] = function(handlerId, rowId) {
      let onClick = DataTableHandlers.getHandler(handlerId, rowId);
      if (onClick != null) {
          onClick();
      }
  };

  class DataTableFiltersMenu$1 {

      /**
       *
       * @param {options}
       */
      constructor({ tableAPI, filterMenuKey, filterTitle, filters, columnIndex, icon = null, extraAttributes = "", id = null, url = null, urlParams = null, removeAllEntry = false, callbackFunction = null }) {
          this.rawFilters = filters;
          this.tableAPI = tableAPI;
          this.filterTitle = filterTitle;
          this.icon = icon;
          this.filterMenuKey = filterMenuKey;
          this.columnIndex = columnIndex;
          this.preventUpdate = false;
          this.currentFilterSelected = undefined;
          this.$datatableWrapper = $(tableAPI.context[0].nTableWrapper);
          this.extraAttributes = extraAttributes;
          this.id = id;
          this.url = url;
          this.removeAllEntry = removeAllEntry;
          this.callbackFunction = callbackFunction;
        }

      get selectedFilter() {
          return this.currentFilterSelected;
      }

      init() {

          const self = this;

          // when the datatable has been initialized render the dropdown
          this.$datatableWrapper.on('init.dt', function () {
            self._render(self.rawFilters);
          });

          // on ajax reload then update the datatable entries
          this.tableAPI.on('draw', function () {
            self._update();
          });

          return self;
      }

      _countEntries(regex, data = []) {

          if (regex === undefined) {
              console.error("DataTableFiltersMenu::_countEntries() => the passed regex is undefined!");
          }

          const reg = new RegExp(regex);
          return data.filter(cellValue => reg.test(cellValue)).length;
      }

      _createMenuEntry(filter) {

          const self = this;
          let $entry = $(`<li class='dropdown-item pointer'>${filter.label} </li>`);
          
          if(self.url) {
            $entry = $(`<li class='dropdown-item pointer'><a href=# class='p-1 standard-color'>${filter.label} </li>`);

            if(filter.currently_active == true) {
              // set active filter title and key
              if (self.$dropdown.title.parent().find(`i.fas`).length == 0) {
                self.$dropdown.title.parent().prepend(`<i class='fas fa-filter'></i>`);
              }

              const newContent = $entry.html();
              self.$dropdown.title.html(newContent);
              // remove the active class from the li elements
              self.$dropdown.container.find('li').removeClass(`active`);
              // add active class to current entry
              if(filter.key !== 'all') {
                $entry.addClass(`active`);
              }
            }
          } else if (filter.regex !== undefined && (filter.countable === undefined || filter.countable)) {
              const data = this.tableAPI.columns(this.columnIndex).data()[0];
              const count = this._countEntries(filter.regex, data);
              const $counter = $(`<span class='counter'>(${count})</span>`);

              // if the count is 0 then hide the menu entry
              if (count == 0) $entry.hide();

              //append the $counter object inside the $entry
              $entry.append($counter);
          }

          $entry.on('click', function (e) {
            // set active filter title and key
            if (self.$dropdown.title.parent().find(`i.fas`).length == 0) {
              self.$dropdown.title.parent().prepend(`<i class='fas fa-filter'></i>`);
            }

            const newContent = $entry.html();
            self.$dropdown.title.html(newContent);
            // remove the active class from the li elements
            self.$dropdown.container.find('li').removeClass(`active`);
            // add active class to current entry
            if(filter.key !== 'all') {
              $entry.addClass(`active`);
            }

            if(self.callbackFunction) {
              self.callbackFunction(self.tableAPI, filter);
              if(filter.callback) filter.callback();
              return;
            }

            if(!self.url) {
              self.preventUpdate = true;

              // if the filter have a callback then call it
              if (filter.callback) filter.callback();
              // perform the table filtering
              self.tableAPI.column(self.columnIndex).search(filter.regex, true, false).draw();
              // set current filter
              self.currentFilterSelected = filter;
            } else {
              self.urlParams = window.location.search;
              const newUrlParams = new URLSearchParams(self.urlParams);
              newUrlParams.set(self.filterMenuKey, (typeof(filter.id) != "undefined") ? filter.id : '');

              window.history.pushState('', '', window.location.pathname + '?' + newUrlParams.toString());
              location.reload();
            }
          });

          return $entry;
      }

      _createFilters(filters) {

          const filtersCreated = {};

          // for each filter defined in this.filters
          for (const filter of filters) {

              const $filter = this._createMenuEntry(filter);
              // save the filter inside the $filters object
              filtersCreated[filter.key] = { filter: filter, $node: $filter };
          }

          return filtersCreated;
      }

      _render(filters) {
        if(typeof this.columnIndex == 'undefined') {
          $(`<span id="${this.id}" ${this.extraAttributes} title="${this.filterTitle}">${this.icon || this.filterTitle}</span>`).insertBefore(this.$datatableWrapper.find('.dataTables_filter').parent());
        } else {
          const $dropdownContainer = $(`<div id='${this.filterMenuKey}_dropdown' class='dropdown d-inline'></div>`);
          const $dropdownButton = $(`<button class='btn-link btn dropdown-toggle' data-bs-toggle="dropdown" type='button'></button>`);
          const $dropdownTitle = $(`<span class='filter-title'>${this.filterTitle}</span>`);
          $dropdownButton.append($dropdownTitle);

          this.$dropdown = {
            container: $dropdownContainer,
            title: $dropdownTitle,
            button: $dropdownButton
          };

          this.filters = this._createFilters(filters);

          const $menuContainer = $(`<ul class='dropdown-menu dropdown-menu-lg-end scrollable-dropdown' id='${this.filterMenuKey}_dropdown_menu'></ul>`);
          for (const [_, filter] of Object.entries(this.filters)) {
              $menuContainer.append(filter.$node);
          }

          // the All entry is created by the object
          if(!this.removeAllEntry) {
            const allFilter = this._generateAllFilter();
            $menuContainer.prepend(this._createMenuEntry(allFilter));  
          }
          
          // append the created dropdown inside
          $dropdownContainer.append($dropdownButton);
          $dropdownContainer.append($menuContainer);
          // append the dropdown menu inside the filter wrapper
          $dropdownContainer.insertBefore(this.$datatableWrapper.find('.dataTables_filter').parent());

          this._selectFilterFromState(this.filterMenuKey);
        }
      }

      _selectFilterFromState(filterKey) {

          if (!this.tableAPI.state) return;
          if (!this.tableAPI.state.loaded()) return;
          if (!this.tableAPI.state.loaded().filters) return;

          // save the current table state
          tableAPI.state.save();
      }

      _generateAllFilter() {
          return {
              key: 'all',
              label: i18n_ext.all,
              regex: '',
              countable: false,
              callback: () => {
                  this.$dropdown.title.parent().find('i.fas.fa-filter').remove();
                  this.$dropdown.title.html(`${this.filterTitle}`);
              }
          };
      }

      _update() {

          // if the filters have not been initialized by _render then return
          if (this.filters === undefined) return;
          if (this.preventUpdate) {
              this.preventUpdate = false;
              return;
          }

          for (const [_, filter] of Object.entries(this.filters)) {
              if (filter.countable == false || filter.filter.countable == false) continue;

              const data = this.tableAPI.columns(this.columnIndex).data()[0];
              const count = this._countEntries(filter.filter.regex, data);

              // hide the filter if the count is zero
              (count == 0) ? filter.$node.hide() : filter.$node.show();
              // update the counter label
              filter.$node.find('.counter').text(`(${count})`);
              // update the selected button counter
              this.$dropdown.button.find('.counter').text(`(${count})`);
          }
      }

  }

  class DataTableUtils$1 {

      /**
       * Return a standard config for the Sprymedia (c) DataTables
       */
      static getStdDatatableConfig(dtButtons = [], dom = "<'row'<'col-sm-2 d-inline-block'l><'col-sm-10 text-end d-inline-block'<'dt-search'f>B>rtip>") {

          // hide the buttons section if there aren't buttons inside the array
          if (dtButtons.length == 0) {
              dom = "fBrtip";
          }

          return {
              dom: dom,
              pagingType: 'full_numbers',
              lengthMenu: [[10, 20, 50, 100], [10, 20, 50, 100]],
              language: {
                  search: i18n.script_search,
                  paginate: {
                      previous: '&lt;',
                      next: '&gt;',
                      first: '«',
                      last: '»'
                  }
              },
              saveState: true,
              responsive: true,
              buttons: {
                  buttons: dtButtons,
                  dom: {
                      button: {
                          className: 'btn btn-link'
                      },
                      container: {
                          className: 'd-inline-block'
                      }
                  }
              }
          }
      }

      static createLinkCallback(action) {
          let handler = "";
          let fOnClick = DataTableHandlers.addHandler(action.handler);
          handler = `onclick="${fOnClick}"`;
          return `<a href=#
                   ${handler}>
                   ${action.text || ''}
                </a>`;
      }

      /**
       * Example of action:
       * {
       *  class: string,
       *  data: object,
       *  icon: string,
       *  modal: string,
       *  href: string,
       *  hidden: bool,
       * }
       * @param {*} actions
       */
      static createActionButtons(actions = []) {

          const buttons = [];
          const dropdownButton = '<button type="button" class="btn btn-sm btn-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false"><i class="fas fa-align-justify"></i></button>';

          actions.forEach((action, i) => {
              let handler = "";
              if (action.handler) {
                  let fOnClick = DataTableHandlers.addHandler(action.handler);
                  handler = `onclick="${fOnClick}"`;
              }
              let button = (`
            <li>
                <a
                    ${(action.href || action.modal) ? `href='${action.href || action.modal}'` : ``}
                    ${handler}
                    ${(action.onclick) ? `onclick='${action.onclick}'` : ``}
                    ${action.modal ? "data-bs-toggle='modal'" : ``}
                    class='dropdown-item ${action.class ? action.class : ``}'
                    ${action.hidden ? "style='display: none'" : ``}
                    ${action.external ? "target='_about'" : ``}
                    >
                    <i class='fas ${action.icon}'></i> ${action.title || ''}
                </a>
            </li>
            `);
              buttons.push(button);
          });

          const list = `<ul class="dropdown-menu">${buttons.join('')}</ul>`;

          return (`<div class='dropdown'>${dropdownButton}${list}</div>`);
      }

      static deleteButtonHandlers(handlerId) {
          DataTableHandlers.deleteHandlersById(handlerId);
      }

      static setAjaxConfig(config, url, dataSrc = '', method = "get", params = {}) {

          config.ajax = {
              url: url,
              type: method,
              dataSrc: dataSrc,
              data: function (d) {
                  return $.extend({}, d, params);
              }
          };

          return config;
      }

      static extendConfig(config, extension) {

          // if there are custom filters then manage state in this way
          if (extension.hasFilters) {

              extension.stateSaveCallback = function (settings, data) {
                  localStorage.setItem('DataTables_' + settings.sInstance, JSON.stringify(data));
              };

              extension.stateLoadCallback = function (settings) {
                  return JSON.parse(localStorage.getItem('DataTables_' + settings.sInstance));
              };

              // on saving the table state store the selected filters
              extension.stateSaveParams = function (settings, data) {

                  // save the filters selected from the user inside the state
                  $('[data-filter]').each(function () {

                      const activeFilter = $(this).find(`li.active`).data('filter-key');
                      if (!activeFilter) return;

                      // if the filters object is not allocated then initizializes it
                      if (!data.filters) data.filters = {};
                      data.filters[$(this).data('filter')] = activeFilter;

                  });
              };
          }

          // const userInitComplete = extension.initComplete;

          // const initComplete = (settings, json) => {
          //     if (userInitComplete !== undefined) userInitComplete(settings, json);
          //     // turn on tooltips
          //     $(`.actions-group [title]`).tooltip('enable');
          // };

          // // override initComplete function
          // extension.initComplete = initComplete;

          return $.extend({}, config, extension);
      }

      /**
       * Format the passed seconds into the "HH:MM:SS" string.
       * @param {number} seconds
       */
      static secondsToHHMMSS(seconds) {

          const padZeroes = n => `${n}`.padStart(2, '0');

          const sec = seconds % 60;
          const mins = Math.floor(seconds / 60) % 60;
          const hours = Math.floor(seconds / 3600);

          return `${padZeroes(hours)}:${padZeroes(mins)}:${padZeroes(sec)}`;
      }

      /**
      * Open the pool edit modal of a chosen pool if the query params contains the pool paramater
      * @param tableAPI
      */
      static openEditModalByQuery(params) {

          const urlParams = new URLSearchParams(window.location.search);
          if (!urlParams.has(params.paramName)) return;

          const dataID = urlParams.get(params.paramName);
          const data = params.datatableInstance.data().toArray().find((data => data[params.paramName] == dataID));

          // if the cancelIf param has been passed
          // then test the cancelIf function, if the return value
          // is true then cancel the modal opening
          if (typeof (params.cancelIf) === 'function') {
              if (params.cancelIf(data)) return;
          }

          const $modal = $(`#${params.modalHandler.getModalID()}`);

          // if the pool id is valid then open the edit modal
          if (data !== undefined) {
              params.modalHandler.invokeModalInit(data);
              $modal.modal('show');
          }

          if (!urlParams.has('referer')) {
              $modal.on('hidden.bs.modal', function (e) {

                  const url = new URL(window.location.href);
                  url.searchParams.delete(params.paramName);

                  history.replaceState({}, '', url.toString());
              });
              return;
          }
          const referer = urlParams.get('referer');

          $modal.on('hidden.bs.modal', function (e) {
              window.location = referer;
          });
      }

      static addToggleColumnsDropdown(tableAPI, toggleCallback = (col, visible) => {}) {

          if (tableAPI === undefined) {
              throw 'The $table is undefined!';
          }

          const tableID = tableAPI.table().node().id;

          DataTableUtils$1._loadColumnsVisibility(tableAPI).then(function (fetchedData) {

              let savedColumns = [-1];
              if (fetchedData.success) {
                  savedColumns = fetchedData.columns.map(i => parseInt(i));
              }
              else {
                  console.warn(fetchedData.message);
              }

              const columns = [];
              const ignoredColumns = [];
              const $datatableWrapper = $(tableAPI.context[0].nTableWrapper);

              // get the table headers 
              tableAPI.columns().every(function (i) {

                  // avoid already hidden columns
                  if (!tableAPI.column(i).visible()) {
                      ignoredColumns.push(i);
                      return;
                  }

                  columns.push({ index: i, name: this.header().textContent, label: this.i18n.name /* Human-readable column name */ });
              });

              const $btnGroup = $(`
                <div class="btn-group">
                    <button type="button" class="btn btn-link dropdown-toggle" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <i class="fas fa-eye"></i>
                    </button>
                </div>
            `);

              const $dropdownMenu = $(`<div class="dropdown-menu dropdown-menu-right" style='width: max-content;'><h6 class="dropdown-header">Show Columns</h6></div>`);
              const $checkboxes = $(`<div class='px-4'></div>`);

              for (let i = 0; i < columns.length; i++) {
                  const column = columns[i];

                  // Prevents columns with no names to be selectively hidden (e.g., the entity under the all alerts page)
                  if(column.name == "")
                      continue;

                  // create a checkbox and delegate a change event
                  const id = `toggle-${column.name.split().join('_')}`; 

                  // check if the column id it's inside the savedColumns array
                  // if toggled is true then the column is not hidden
                  const toggled = savedColumns.indexOf(column.index) === -1;
                  if (!toggled) {
                      const col = tableAPI.column(column.index);
                      col.visible(false);
                  }

                  const $checkbox = $(`<input class="form-check-input" ${(toggled ? 'checked' : '')} type="checkbox" id="${id}">`);
                  const $wrapper = $(`
                    <div class="form-check form-switch">
                        <label class="form-check-label" for="${id}">
                            ${column.name}
                        </label>
                    </div>
                `);

                  $checkbox.on('change', function (e) {
                      $(`.overlay`).toggle(500);
                      
                      // Get the column API object
                      const col = tableAPI.column(column.index);
                      // Toggle the visibility
                      col.visible(!col.visible());

                      const visible = col.visible();

                      const hiddenColumns = [];
                      // insert inside the array only the hidden columns
                      tableAPI.columns().every(function(i) {
                          if (tableAPI.column(i).visible() || ignoredColumns.indexOf(i) !== -1) return;
                          hiddenColumns.push(i); 
                      });

                      // save the table view inside redis
                      $.post(`${http_prefix}/lua/datatable_columns.lua`, {
                          action: 'save', table: tableID, columns: hiddenColumns.join(','), csrf: window.__CSRF_DATATABLE__
                      }).then(function(data) {
                          if (data.success) return;
                          console.warn(data.message);
                      });

                      if (toggleCallback !== undefined) {
                          toggleCallback(col, visible);
                      }

                  });

                  $wrapper.prepend($checkbox);
                  $checkboxes.append($wrapper);
              }

              $dropdownMenu.on("click.bs.dropdown", function (e) { e.stopPropagation(); });

              // append the new node inside the datatable
              $btnGroup.append($dropdownMenu.append($checkboxes));
              $datatableWrapper.find('.dt-search').parent().append($btnGroup);
          });
      }

      static async _loadColumnsVisibility(tableAPI) {
          const tableID = tableAPI.table().node().id;
          return $.get(`${http_prefix}/lua/datatable_columns.lua?table=${tableID}&action=load`);
      }

  }

  class DataTableRenders$1 {

      static alertSeverityAndType(severity, type, alert) {
          return `${DataTableRenders$1.formatValueLabel(severity, type, alert)} ${DataTableRenders$1.formatValueLabel(alert.alert_id, type, alert)}`;
      }

      static hideIfZero(obj, type, row, zero_is_null) {
          let color = (obj.color !== undefined ? obj.color : "#aaa");
          let value = (obj.value !== undefined ? obj.value : obj);
          if (type === "display" && parseInt(value) === 0) color = "#aaa";
          let span = `<span style='color: ${color}'>${NtopUtils$1.fint(value)}</span>`;
          if (obj.url !== undefined) span = `<a href="${obj.url}">${span}</a>`;
          return span;
      }

      static secondsToTime(seconds, type, row, zero_is_null) {
          if (type === "display") return NtopUtils$1.secondsToTime(seconds);
          return seconds;
      }

      static filterize(key, value, label, tag_label, title, html, is_snmp_ip, ip) {
          let content = `<a class='tag-filter' data-tag-key='${key}' title='${title || value}' data-tag-value='${value}' data-tag-label='${tag_label || label || value}' href='javascript:void(0)'>${html || label || value}</a>`;
          if(is_snmp_ip != null) {
              if(is_snmp_ip) {
                  if (value) {
                      let url = NtopUtils$1.buildURL(`${http_prefix}/lua/pro/enterprise/snmp_device_details.lua?host=${value}`);
                      content += ` <a href='${url}'data-bs-toggle='tooltip' title=''><i class='fas fa-laptop'></i></a>`;
                  }
              } else {
                  if (ip && value) {
                      let url = NtopUtils$1.buildURL(`${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${ip}&snmp_port_idx=${value}`);
                      content += ` <a href='${url}'data-bs-toggle='tooltip' title=''><i class='fas fa-laptop'></i></a>`;
                  }
              }
          }
          return content;
      }

      static formatValueLabel(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.value;
          let cell = obj.label;
          if (zero_is_null == true && obj.value == 0) {
              cell = "";
          }
          if (obj.color) cell = `<span class='font-weight-bold' style='color: ${obj.color}'>${cell}</span>`;
          return cell;
      }

      static formatCategory(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.value;
          let cell = `<a class='tag-filter' data-tag-key='alert_category' data-tag-value='${obj.value}' data-tag-label='${obj.label}' href='javascript:void(0)'><i class="fa fas ${obj.icon}" title="${obj.label}"></i></a>`;
          if (zero_is_null == true && obj.value == 0) {
              cell = "";
          }
          return cell;
      }

      static formatScore(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.value;
          let cell = obj.label;
          if (zero_is_null == true && obj.value == 0) {
              cell = "";
          }
          if (obj.color) cell = `<span class='font-weight-bold' style='color: ${obj.color}'>${cell}</span>`;
          return `<a class='tag-filter' data-tag-key='score' title='${obj.label}' data-tag-value='${obj.value}' data-tag-label='${obj.label}' href='javascript:void(0)'>${cell}</a>`;
      }

      static formatMessage(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.value;
             
          let cell = obj.descr;
          if (obj.shorten_descr)
              cell = `<span title="${obj.descr}">${obj.shorten_descr}</span>`;

          return cell;
      }

      static formatTraffic(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.total_bytes;
          
          const traffic = `${NtopUtils$1.formatPackets(obj.total_packets)} / ${NtopUtils$1.bytesToVolume(obj.total_bytes)}`;
          return traffic;
      }

      static formatSubtype(obj, type, row, zero_is_null) {
          if (type !== "display") return obj;

          let label = DataTableRenders$1.filterize('subtype', obj, obj);

          return label; 
      }

      static filterize_2(key, value, label, tag_label, title, html) {
          if (value == null || (value == 0 && (label == null || label == ""))) { return ""; }
          return `<a class='tag-filter' data-tag-key='${key}' title='${title || value}' data-tag-value='${value}' data-tag-label='${tag_label || label || value}' href='javascript:void(0)'>${html || label || value}</a>`;
      }

      static getFormatGenericField(field, zero_is_null) {        
          return function(obj, type, row) {
              if (type !== "display") return obj.value;
              if (zero_is_null == true && obj?.value == 0) { return ""; }
                  let html_ref = '';
              if (obj.reference !== undefined)
                  html_ref = obj.reference;
              let label = DataTableRenders$1.filterize_2(field, row[field].value, row[field].label, row[field].label, row[field].label);
              return label + ' ' + html_ref;
          }
      }

      static formatSNMPInterface(obj, type, row) {
          if (type !== "display") return obj.value;
          let cell = DataTableRenders$1.filterize('snmp_interface', `${row.ip}_${obj.value}`, obj.label, obj.label, obj.label,null,false, row.ip);
          if (obj.color) cell = `<span class='font-weight-bold' style='color: ${obj.color}'>${cell}</span>`;
          return cell;
      }

      static formatSNMPIP(obj, type, row, zero_is_null) {
          if (type !== "display") return obj;
          return DataTableRenders$1.filterize('ip', obj, obj, obj, obj, null, true);
      }

      static formatNetwork(obj, type, row, zero_is_null) {
          if (type !== "display") return obj;
          return DataTableRenders$1.filterize('network_name', obj, obj, obj, obj, null, false);
      }

      static formatProbeIP(obj, type, row, zero_is_null) {
          if (type !== "display") return obj;

          let label = DataTableRenders$1.filterize('probe_ip', obj.value, obj.label, obj.label, obj.label_long);

          return label; 
      }
     
      static formatHost(obj, type, row, zero_is_null) {
          if (type !== "display") return obj;
              let html_ref = '';
          if (obj.reference !== undefined)
             html_ref = obj.reference;
          let label = "";

          let hostKey, hostValue;
          if (obj.label && obj.label != obj.value) {
              hostKey = "name";
              hostValue = obj.label_long;
              label = DataTableRenders$1.filterize('name', obj.label_long, obj.label, obj.label, obj.label_long);
          }
          else {
              hostKey = "ip";
              hostValue = obj.value;
              label = DataTableRenders$1.filterize('ip', obj.value, obj.label, obj.label, obj.label_long);
          }

          if (row.vlan_id && row.vlan_id != "" && row.vlan_id != "0") {
              label = DataTableRenders$1.filterize(hostKey, `${hostValue}@${row.vlan_id}`, `${obj.label}@${row.vlan_id}`, `${obj.label}@${row.vlan_id}`, `${obj.label_long}@${row.vlan_id}`);
          }

          if (obj.country)
              label = label + DataTableRenders$1.filterize('country', obj.country, obj.country, obj.country, obj.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + obj.country.toLowerCase() + '"></a> ');

          if (row.role && row.role.value == 'attacker')
            label = label + ' ' + DataTableRenders$1.filterize('role', row.role.value, 
              '<i class="fas fa-skull" title="'+row.role.label+'"></i>', row.role.label);
          else if (row.role && row.role.value == 'victim')
            label = label + ' ' + DataTableRenders$1.filterize('role', row.role.value,
              '<i class="fas fa-sad-tear" title="'+row.role.label+'"></i>', row.role.label);

          if (row.role_cli_srv && row.role_cli_srv.value == 'client')
            label = label + ' ' + DataTableRenders$1.filterize('role_cli_srv', row.role_cli_srv.value, 
              '<i class="fas fa-long-arrow-alt-right" title="'+row.role_cli_srv.label+'"></i>', row.role_cli_srv.label);
          else if (row.role_cli_srv && row.role_cli_srv.value == 'server')
            label = label + ' ' + DataTableRenders$1.filterize('role_cli_srv', row.role_cli_srv.value,
              '<i class="fas fa-long-arrow-alt-left" title="'+row.role_cli_srv.label+'"></i>', row.role_cli_srv.label);

          return label + ' ' + html_ref; 
      }

      static filterizeVlan(flow, row, key, value, label, title) {
          let valueVlan = value;
    let labelVlan = label;
          let titleVlan = title;
          if (flow.vlan && flow.vlan.value != 0) {
              valueVlan = `${value}@${flow.vlan.value}`;
              labelVlan = `${label}@${flow.vlan.label}`;
              titleVlan = `${title}@${flow.vlan.title}`;
          }
        labelVlan = NtopUtils$1.shortenLabel(labelVlan, 16, ".");
        return DataTableRenders$1.filterize(key, valueVlan, labelVlan, labelVlan, titleVlan); 
      }

      static formatFlowTuple(flow, type, row, zero_is_null) {
        let active_ref = (flow.active_url ? `<a href="${flow.active_url}"><i class="fas fa-stream"></i></a>` : "");
          let cliLabel = "";
          if (flow.cli_ip.name) {
            let title = "";
              if(flow.cli_ip.label_long) title = flow.cli_ip.value + " [" + flow.cli_ip.label_long + "]";
              cliLabel = DataTableRenders$1.filterizeVlan(flow, row, 'cli_name', flow.cli_ip.name, flow.cli_ip.label, title); 
          } else
              cliLabel = DataTableRenders$1.filterizeVlan(flow, row, 'cli_ip', flow.cli_ip.value, flow.cli_ip.label, flow.cli_ip.label_long); 

          let cliFlagLabel= '';

          if (flow.cli_ip.country && flow.cli_ip.country !== "nil")
              cliFlagLabel = DataTableRenders$1.filterize('cli_country', flow.cli_ip.country, flow.cli_ip.country, flow.cli_ip.country, flow.cli_ip.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + flow.cli_ip.country.toLowerCase() + '"></a> ');

          let cliPortLabel = ((flow.cli_port && flow.cli_port > 0) ? ":"+DataTableRenders$1.filterize('cli_port', flow.cli_port, flow.cli_port) : "");

          let cliBlacklisted ='';
          if(flow.cli_ip.blacklisted == true) 
            cliBlacklisted = " <i class=\'fas fa-ban fa-sm\' title=\'" + i18n("hosts_stats.blacklisted") + "\'></i>";

          let srvLabel = "";
          if (flow.srv_ip.name) {
            let title = "";
            if(flow.srv_ip.label_long) title = flow.srv_ip.value + " [" + flow.srv_ip.label_long + "]";
              srvLabel = DataTableRenders$1.filterizeVlan(flow, row, 'srv_name', flow.srv_ip.name, flow.srv_ip.label, title);
          } else
              srvLabel = DataTableRenders$1.filterizeVlan(flow, row, 'srv_ip', flow.srv_ip.value, flow.srv_ip.label, flow.srv_ip.label_long);
          let srvPortLabel = ((flow.srv_port && flow.srv_port > 0) ? ":"+DataTableRenders$1.filterize('srv_port', flow.srv_port, flow.srv_port) : "");

          let srvFlagLabel= '';

          if (flow.srv_ip.country && flow.srv_ip.country !== "nil")
              srvFlagLabel = DataTableRenders$1.filterize('srv_country', flow.srv_ip.country, flow.srv_ip.country, flow.srv_ip.country, flow.srv_ip.country, ' <img src="' + http_prefix + '/dist/images/blank.gif" class="flag flag-' + flow.srv_ip.country.toLowerCase() + '"></a> ');

          let srvBlacklisted ='';
          if(flow.srv_ip.blacklisted == true) 
            srvBlacklisted = " <i class=\'fas fa-ban fa-sm\' title=\'" + i18n("hosts_stats.blacklisted") + "\'></i>";
      
          let cliIcons = "";
          let srvIcons = "";
          if (row.cli_role) {
              if (row.cli_role.value == 'attacker')
                  cliIcons += DataTableRenders$1.filterize('role', 'attacker', '<i class="fas fa-skull" title="'+row.cli_role.label+'"></i>', row.cli_role.tag_label);
              else if (row.cli_role.value == 'victim')
                  cliIcons += DataTableRenders$1.filterize('role', 'victim',  '<i class="fas fa-sad-tear" title="'+row.cli_role.label+'"></i>', row.cli_role.tag_label);
          }

          if (row.srv_role) {
              if (row.srv_role.value == 'attacker')
                  srvIcons += DataTableRenders$1.filterize('role', 'attacker', '<i class="fas fa-skull" title="'+row.srv_role.label+'"></i>', row.srv_role.tag_label);
              else if (row.srv_role.value == 'victim')
                  srvIcons += DataTableRenders$1.filterize('role', 'victim',  '<i class="fas fa-sad-tear" title="'+row.srv_role.label+'"></i>', row.srv_role.tag_label);
          }

          return `${active_ref} ${cliLabel}${cliBlacklisted}${cliFlagLabel}${cliPortLabel} ${cliIcons} ${flow.cli_ip.reference} <i class="fas fa-exchange-alt fa-lg" aria-hidden="true"></i> ${srvLabel}${srvBlacklisted}${srvFlagLabel}${srvPortLabel} ${srvIcons} ${flow.srv_ip.reference}`;
      }

      static formatSubtypeValueLabel(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.name;
          let msg = DataTableRenders$1.filterize('subtype', obj.value, obj.name, obj.fullname, obj.fullname);

          return msg;
      }

      static formatNameDescription(obj, type, row, zero_is_null) {
          if (type !== "display") return obj.name;
          let msg = DataTableRenders$1.filterize('alert_id', obj.value, obj.name, obj.fullname, obj.fullname);

          return msg;
      }

      static applyCellStyle(cell, cellData, rowData, rowIndex, colIndex) {
        if (cellData.highlight) {
           $(cell).css("border-left", "5px solid "+cellData.highlight);
        }
     }
  }

  window.do_pie = do_pie;

  window.DataTableUtils = DataTableUtils$1;
  window.DataTableFiltersMenu = DataTableFiltersMenu$1;
  window.DataTableRenders = DataTableRenders$1;

  window.ChartWidget = ChartWidget;
  window.WidgetUtils = WidgetUtils;
  window.ntopChartApex = ntopChartApex$1;

  /* Handle Blog Notifications */
  $(function () {

    function blogNotifcationClick(e) {

      if (e.type == "mousedown" && (e.metaKey || e.ctrlKey || e.which !== 2)) return;

      const id = $(this).data('id');

      $.post(`${http_prefix}/lua/update_blog_posts.lua`, {
        blog_notification_id: id,
        csrf: window.__BLOG_NOTIFICATION_CSRF__
      },
        (data) => {

          if (data.success) {

            $(this).off('click').off('mousedown').attr('data-read', 'true').data('read', 'true').find('.badge').remove();
            
            const count = $(`.blog-notification[data-read='false']`).length;

            if (count == 0) {
              $('.notification-bell').remove();
            }
            else {
              $('.notification-bell').html(count);
            }
          }
        });
    }

    // on the notifications not yet read delegate the click event
    $(`.blog-notification[data-read='false']`).on('click', blogNotifcationClick).on('mousedown', blogNotifcationClick);
  });

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  function makeMap(str, expectsLowerCase) {
      const map = Object.create(null);
      const list = str.split(',');
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
  }

  /**
   * dev only flag -> name mapping
   */
  const PatchFlagNames = {
      [1 /* TEXT */]: `TEXT`,
      [2 /* CLASS */]: `CLASS`,
      [4 /* STYLE */]: `STYLE`,
      [8 /* PROPS */]: `PROPS`,
      [16 /* FULL_PROPS */]: `FULL_PROPS`,
      [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
      [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
      [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
      [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
      [512 /* NEED_PATCH */]: `NEED_PATCH`,
      [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
      [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
      [-1 /* HOISTED */]: `HOISTED`,
      [-2 /* BAIL */]: `BAIL`
  };

  /**
   * Dev only
   */
  const slotFlagsText = {
      [1 /* STABLE */]: 'STABLE',
      [2 /* DYNAMIC */]: 'DYNAMIC',
      [3 /* FORWARDED */]: 'FORWARDED'
  };

  const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
      'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
      'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
  const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

  const range = 2;
  function generateCodeFrame(source, start = 0, end = source.length) {
      // Split the content into individual lines but capture the newline sequence
      // that separated each line. This is important because the actual sequence is
      // needed to properly take into account the full line length for offset
      // comparison
      let lines = source.split(/(\r?\n)/);
      // Separate the lines and newline sequences into separate arrays for easier referencing
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
          count +=
              lines[i].length +
                  ((newlineSequences[i] && newlineSequences[i].length) || 0);
          if (count >= start) {
              for (let j = i - range; j <= i + range || end > count; j++) {
                  if (j < 0 || j >= lines.length)
                      continue;
                  const line = j + 1;
                  res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
                  const lineLength = lines[j].length;
                  const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;
                  if (j === i) {
                      // push underline
                      const pad = start - (count - (lineLength + newLineSeqLength));
                      const length = Math.max(1, end > count ? lineLength - pad : end - start);
                      res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                  }
                  else if (j > i) {
                      if (end > count) {
                          const length = Math.max(Math.min(end - count, lineLength), 1);
                          res.push(`   |  ` + '^'.repeat(length));
                      }
                      count += lineLength + newLineSeqLength;
                  }
              }
              break;
          }
      }
      return res.join('\n');
  }

  /**
   * On the client we only need to offer special cases for boolean attributes that
   * have different names from their corresponding dom properties:
   * - itemscope -> N/A
   * - allowfullscreen -> allowFullscreen
   * - formnovalidate -> formNoValidate
   * - ismap -> isMap
   * - nomodule -> noModule
   * - novalidate -> noValidate
   * - readonly -> readOnly
   */
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
  /**
   * Boolean attributes should be included if the value is truthy or ''.
   * e.g. `<select multiple>` compiles to `{ multiple: '' }`
   */
  function includeBooleanAttr(value) {
      return !!value || value === '';
  }

  function normalizeStyle(value) {
      if (isArray(value)) {
          const res = {};
          for (let i = 0; i < value.length; i++) {
              const item = value[i];
              const normalized = isString(item)
                  ? parseStringStyle(item)
                  : normalizeStyle(item);
              if (normalized) {
                  for (const key in normalized) {
                      res[key] = normalized[key];
                  }
              }
          }
          return res;
      }
      else if (isString(value)) {
          return value;
      }
      else if (isObject(value)) {
          return value;
      }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach(item => {
          if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
      });
      return ret;
  }
  function normalizeClass(value) {
      let res = '';
      if (isString(value)) {
          res = value;
      }
      else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
              const normalized = normalizeClass(value[i]);
              if (normalized) {
                  res += normalized + ' ';
              }
          }
      }
      else if (isObject(value)) {
          for (const name in value) {
              if (value[name]) {
                  res += name + ' ';
              }
          }
      }
      return res.trim();
  }
  function normalizeProps(props) {
      if (!props)
          return null;
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
          props.class = normalizeClass(klass);
      }
      if (style) {
          props.style = normalizeStyle(style);
      }
      return props;
  }

  // These tag configs are shared between compiler-dom and runtime-dom, so they
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
  const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
      'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
      'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
      'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
      'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
      'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
      'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
      'option,output,progress,select,textarea,details,dialog,menu,' +
      'summary,template,blockquote,iframe,tfoot';
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
      'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
      'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
      'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
      'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
      'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
      'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
      'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
      'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
      'text,textPath,title,tspan,unknown,use,view';
  const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
  /**
   * Compiler only.
   * Do NOT use in runtime code paths unless behind `true` flag.
   */
  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

  function looseCompareArrays(a, b) {
      if (a.length !== b.length)
          return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
          equal = looseEqual(a[i], b[i]);
      }
      return equal;
  }
  function looseEqual(a, b) {
      if (a === b)
          return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
          return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol(a);
      bValidType = isSymbol(b);
      if (aValidType || bValidType) {
          return a === b;
      }
      aValidType = isArray(a);
      bValidType = isArray(b);
      if (aValidType || bValidType) {
          return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject(a);
      bValidType = isObject(b);
      if (aValidType || bValidType) {
          /* istanbul ignore if: this if will probably never be called */
          if (!aValidType || !bValidType) {
              return false;
          }
          const aKeysCount = Object.keys(a).length;
          const bKeysCount = Object.keys(b).length;
          if (aKeysCount !== bKeysCount) {
              return false;
          }
          for (const key in a) {
              const aHasKey = a.hasOwnProperty(key);
              const bHasKey = b.hasOwnProperty(key);
              if ((aHasKey && !bHasKey) ||
                  (!aHasKey && bHasKey) ||
                  !looseEqual(a[key], b[key])) {
                  return false;
              }
          }
      }
      return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
      return arr.findIndex(item => looseEqual(item, val));
  }

  /**
   * For converting {{ interpolation }} values to displayed strings.
   * @private
   */
  const toDisplayString = (val) => {
      return isString(val)
          ? val
          : val == null
              ? ''
              : isArray(val) ||
                  (isObject(val) &&
                      (val.toString === objectToString || !isFunction(val.toString)))
                  ? JSON.stringify(val, replacer, 2)
                  : String(val);
  };
  const replacer = (_key, val) => {
      // can't use isRef here since @vue/shared has no deps
      if (val && val.__v_isRef) {
          return replacer(_key, val.value);
      }
      else if (isMap(val)) {
          return {
              [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                  entries[`${key} =>`] = val;
                  return entries;
              }, {})
          };
      }
      else if (isSet(val)) {
          return {
              [`Set(${val.size})`]: [...val.values()]
          };
      }
      else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
          return String(val);
      }
      return val;
  };

  const EMPTY_OBJ = Object.freeze({})
      ;
  const EMPTY_ARR = Object.freeze([]) ;
  const NOOP = () => { };
  /**
   * Always return false.
   */
  const NO = () => false;
  const onRE = /^on[^a-z]/;
  const isOn = (key) => onRE.test(key);
  const isModelListener = (key) => key.startsWith('onUpdate:');
  const extend = Object.assign;
  const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
          arr.splice(i, 1);
      }
  };
  const hasOwnProperty = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty.call(val, key);
  const isArray = Array.isArray;
  const isMap = (val) => toTypeString(val) === '[object Map]';
  const isSet = (val) => toTypeString(val) === '[object Set]';
  const isDate = (val) => toTypeString(val) === '[object Date]';
  const isFunction = (val) => typeof val === 'function';
  const isString = (val) => typeof val === 'string';
  const isSymbol = (val) => typeof val === 'symbol';
  const isObject = (val) => val !== null && typeof val === 'object';
  const isPromise = (val) => {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
      // extract "RawType" from strings like "[object RawType]"
      return toTypeString(value).slice(8, -1);
  };
  const isPlainObject = (val) => toTypeString(val) === '[object Object]';
  const isIntegerKey = (key) => isString(key) &&
      key !== 'NaN' &&
      key[0] !== '-' &&
      '' + parseInt(key, 10) === key;
  const isReservedProp = /*#__PURE__*/ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ',key,ref,ref_for,ref_key,' +
      'onVnodeBeforeMount,onVnodeMounted,' +
      'onVnodeBeforeUpdate,onVnodeUpdated,' +
      'onVnodeBeforeUnmount,onVnodeUnmounted');
  const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
  const cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return ((str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
      });
  };
  const camelizeRE = /-(\w)/g;
  /**
   * @private
   */
  const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
  });
  const hyphenateRE = /\B([A-Z])/g;
  /**
   * @private
   */
  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
  /**
   * @private
   */
  const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  /**
   * @private
   */
  const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
  // compare whether a value has changed, accounting for NaN.
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
      }
  };
  const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
          configurable: true,
          enumerable: false,
          value
      });
  };
  const toNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
      return (_globalThis ||
          (_globalThis =
              typeof globalThis !== 'undefined'
                  ? globalThis
                  : typeof self !== 'undefined'
                      ? self
                      : typeof window !== 'undefined'
                          ? window
                          : typeof global !== 'undefined'
                              ? global
                              : {}));
  };

  function warn(msg, ...args) {
      console.warn(`[Vue warn] ${msg}`, ...args);
  }

  let activeEffectScope;
  class EffectScope {
      constructor(detached = false) {
          /**
           * @internal
           */
          this.active = true;
          /**
           * @internal
           */
          this.effects = [];
          /**
           * @internal
           */
          this.cleanups = [];
          if (!detached && activeEffectScope) {
              this.parent = activeEffectScope;
              this.index =
                  (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
          }
      }
      run(fn) {
          if (this.active) {
              const currentEffectScope = activeEffectScope;
              try {
                  activeEffectScope = this;
                  return fn();
              }
              finally {
                  activeEffectScope = currentEffectScope;
              }
          }
          else {
              warn(`cannot run an inactive effect scope.`);
          }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
          activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
          activeEffectScope = this.parent;
      }
      stop(fromParent) {
          if (this.active) {
              let i, l;
              for (i = 0, l = this.effects.length; i < l; i++) {
                  this.effects[i].stop();
              }
              for (i = 0, l = this.cleanups.length; i < l; i++) {
                  this.cleanups[i]();
              }
              if (this.scopes) {
                  for (i = 0, l = this.scopes.length; i < l; i++) {
                      this.scopes[i].stop(true);
                  }
              }
              // nested scope, dereference from parent to avoid memory leaks
              if (this.parent && !fromParent) {
                  // optimized O(1) removal
                  const last = this.parent.scopes.pop();
                  if (last && last !== this) {
                      this.parent.scopes[this.index] = last;
                      last.index = this.index;
                  }
              }
              this.active = false;
          }
      }
  }
  function effectScope(detached) {
      return new EffectScope(detached);
  }
  function recordEffectScope(effect, scope = activeEffectScope) {
      if (scope && scope.active) {
          scope.effects.push(effect);
      }
  }
  function getCurrentScope() {
      return activeEffectScope;
  }
  function onScopeDispose(fn) {
      if (activeEffectScope) {
          activeEffectScope.cleanups.push(fn);
      }
      else {
          warn(`onScopeDispose() is called when there is no active effect scope` +
              ` to be associated with.`);
      }
  }

  const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
  };
  const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
  const newTracked = (dep) => (dep.n & trackOpBit) > 0;
  const initDepMarkers = ({ deps }) => {
      if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
              deps[i].w |= trackOpBit; // set was tracked
          }
      }
  };
  const finalizeDepMarkers = (effect) => {
      const { deps } = effect;
      if (deps.length) {
          let ptr = 0;
          for (let i = 0; i < deps.length; i++) {
              const dep = deps[i];
              if (wasTracked(dep) && !newTracked(dep)) {
                  dep.delete(effect);
              }
              else {
                  deps[ptr++] = dep;
              }
              // clear bits
              dep.w &= ~trackOpBit;
              dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
      }
  };

  const targetMap = new WeakMap();
  // The number of effects currently being tracked recursively.
  let effectTrackDepth = 0;
  let trackOpBit = 1;
  /**
   * The bitwise track markers support at most 30 levels of recursion.
   * This value is chosen to enable modern JS engines to use a SMI on all platforms.
   * When recursion depth is greater, fall back to using a full cleanup.
   */
  const maxMarkerBits = 30;
  let activeEffect;
  const ITERATE_KEY = Symbol('iterate' );
  const MAP_KEY_ITERATE_KEY = Symbol('Map key iterate' );
  class ReactiveEffect {
      constructor(fn, scheduler = null, scope) {
          this.fn = fn;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          this.parent = undefined;
          recordEffectScope(this, scope);
      }
      run() {
          if (!this.active) {
              return this.fn();
          }
          let parent = activeEffect;
          let lastShouldTrack = shouldTrack;
          while (parent) {
              if (parent === this) {
                  return;
              }
              parent = parent.parent;
          }
          try {
              this.parent = activeEffect;
              activeEffect = this;
              shouldTrack = true;
              trackOpBit = 1 << ++effectTrackDepth;
              if (effectTrackDepth <= maxMarkerBits) {
                  initDepMarkers(this);
              }
              else {
                  cleanupEffect(this);
              }
              return this.fn();
          }
          finally {
              if (effectTrackDepth <= maxMarkerBits) {
                  finalizeDepMarkers(this);
              }
              trackOpBit = 1 << --effectTrackDepth;
              activeEffect = this.parent;
              shouldTrack = lastShouldTrack;
              this.parent = undefined;
              if (this.deferStop) {
                  this.stop();
              }
          }
      }
      stop() {
          // stopped while running itself - defer the cleanup
          if (activeEffect === this) {
              this.deferStop = true;
          }
          else if (this.active) {
              cleanupEffect(this);
              if (this.onStop) {
                  this.onStop();
              }
              this.active = false;
          }
      }
  }
  function cleanupEffect(effect) {
      const { deps } = effect;
      if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
              deps[i].delete(effect);
          }
          deps.length = 0;
      }
  }
  function effect(fn, options) {
      if (fn.effect) {
          fn = fn.effect.fn;
      }
      const _effect = new ReactiveEffect(fn);
      if (options) {
          extend(_effect, options);
          if (options.scope)
              recordEffectScope(_effect, options.scope);
      }
      if (!options || !options.lazy) {
          _effect.run();
      }
      const runner = _effect.run.bind(_effect);
      runner.effect = _effect;
      return runner;
  }
  function stop(runner) {
      runner.effect.stop();
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
  }
  function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === undefined ? true : last;
  }
  function track(target, type, key) {
      if (shouldTrack && activeEffect) {
          let depsMap = targetMap.get(target);
          if (!depsMap) {
              targetMap.set(target, (depsMap = new Map()));
          }
          let dep = depsMap.get(key);
          if (!dep) {
              depsMap.set(key, (dep = createDep()));
          }
          const eventInfo = { effect: activeEffect, target, type, key }
              ;
          trackEffects(dep, eventInfo);
      }
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack = false;
      if (effectTrackDepth <= maxMarkerBits) {
          if (!newTracked(dep)) {
              dep.n |= trackOpBit; // set newly tracked
              shouldTrack = !wasTracked(dep);
          }
      }
      else {
          // Full cleanup mode.
          shouldTrack = !dep.has(activeEffect);
      }
      if (shouldTrack) {
          dep.add(activeEffect);
          activeEffect.deps.push(dep);
          if (activeEffect.onTrack) {
              activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
          }
      }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
          // never been tracked
          return;
      }
      let deps = [];
      if (type === "clear" /* CLEAR */) {
          // collection being cleared
          // trigger all effects for target
          deps = [...depsMap.values()];
      }
      else if (key === 'length' && isArray(target)) {
          depsMap.forEach((dep, key) => {
              if (key === 'length' || key >= newValue) {
                  deps.push(dep);
              }
          });
      }
      else {
          // schedule runs for SET | ADD | DELETE
          if (key !== void 0) {
              deps.push(depsMap.get(key));
          }
          // also run for iteration key on ADD | DELETE | Map.SET
          switch (type) {
              case "add" /* ADD */:
                  if (!isArray(target)) {
                      deps.push(depsMap.get(ITERATE_KEY));
                      if (isMap(target)) {
                          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                  }
                  else if (isIntegerKey(key)) {
                      // new index added to array -> length changes
                      deps.push(depsMap.get('length'));
                  }
                  break;
              case "delete" /* DELETE */:
                  if (!isArray(target)) {
                      deps.push(depsMap.get(ITERATE_KEY));
                      if (isMap(target)) {
                          deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                      }
                  }
                  break;
              case "set" /* SET */:
                  if (isMap(target)) {
                      deps.push(depsMap.get(ITERATE_KEY));
                  }
                  break;
          }
      }
      const eventInfo = { target, type, key, newValue, oldValue, oldTarget }
          ;
      if (deps.length === 1) {
          if (deps[0]) {
              {
                  triggerEffects(deps[0], eventInfo);
              }
          }
      }
      else {
          const effects = [];
          for (const dep of deps) {
              if (dep) {
                  effects.push(...dep);
              }
          }
          {
              triggerEffects(createDep(effects), eventInfo);
          }
      }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
      // spread into array for stabilization
      const effects = isArray(dep) ? dep : [...dep];
      for (const effect of effects) {
          if (effect.computed) {
              triggerEffect(effect, debuggerEventExtraInfo);
          }
      }
      for (const effect of effects) {
          if (!effect.computed) {
              triggerEffect(effect, debuggerEventExtraInfo);
          }
      }
  }
  function triggerEffect(effect, debuggerEventExtraInfo) {
      if (effect !== activeEffect || effect.allowRecurse) {
          if (effect.onTrigger) {
              effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
          }
          if (effect.scheduler) {
              effect.scheduler();
          }
          else {
              effect.run();
          }
      }
  }

  const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
  /*#__PURE__*/
  Object.getOwnPropertyNames(Symbol)
      // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'
      // but accessing them on Symbol leads to TypeError because Symbol is a strict mode
      // function
      .filter(key => key !== 'arguments' && key !== 'caller')
      .map(key => Symbol[key])
      .filter(isSymbol));
  const get = /*#__PURE__*/ createGetter();
  const shallowGet = /*#__PURE__*/ createGetter(false, true);
  const readonlyGet = /*#__PURE__*/ createGetter(true);
  const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
  const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
  function createArrayInstrumentations() {
      const instrumentations = {};
      ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
          instrumentations[key] = function (...args) {
              const arr = toRaw(this);
              for (let i = 0, l = this.length; i < l; i++) {
                  track(arr, "get" /* GET */, i + '');
              }
              // we run the method using the original args first (which may be reactive)
              const res = arr[key](...args);
              if (res === -1 || res === false) {
                  // if that didn't work, run it again using raw values.
                  return arr[key](...args.map(toRaw));
              }
              else {
                  return res;
              }
          };
      });
      ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
          instrumentations[key] = function (...args) {
              pauseTracking();
              const res = toRaw(this)[key].apply(this, args);
              resetTracking();
              return res;
          };
      });
      return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
      return function get(target, key, receiver) {
          if (key === "__v_isReactive" /* IS_REACTIVE */) {
              return !isReadonly;
          }
          else if (key === "__v_isReadonly" /* IS_READONLY */) {
              return isReadonly;
          }
          else if (key === "__v_isShallow" /* IS_SHALLOW */) {
              return shallow;
          }
          else if (key === "__v_raw" /* RAW */ &&
              receiver ===
                  (isReadonly
                      ? shallow
                          ? shallowReadonlyMap
                          : readonlyMap
                      : shallow
                          ? shallowReactiveMap
                          : reactiveMap).get(target)) {
              return target;
          }
          const targetIsArray = isArray(target);
          if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
              return Reflect.get(arrayInstrumentations, key, receiver);
          }
          const res = Reflect.get(target, key, receiver);
          if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
              return res;
          }
          if (!isReadonly) {
              track(target, "get" /* GET */, key);
          }
          if (shallow) {
              return res;
          }
          if (isRef(res)) {
              // ref unwrapping - skip unwrap for Array + integer key.
              return targetIsArray && isIntegerKey(key) ? res : res.value;
          }
          if (isObject(res)) {
              // Convert returned value into a proxy as well. we do the isObject check
              // here to avoid invalid value warning. Also need to lazy access readonly
              // and reactive here to avoid circular dependency.
              return isReadonly ? readonly(res) : reactive(res);
          }
          return res;
      };
  }
  const set = /*#__PURE__*/ createSetter();
  const shallowSet = /*#__PURE__*/ createSetter(true);
  function createSetter(shallow = false) {
      return function set(target, key, value, receiver) {
          let oldValue = target[key];
          if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
              return false;
          }
          if (!shallow && !isReadonly(value)) {
              if (!isShallow(value)) {
                  value = toRaw(value);
                  oldValue = toRaw(oldValue);
              }
              if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
                  oldValue.value = value;
                  return true;
              }
          }
          const hadKey = isArray(target) && isIntegerKey(key)
              ? Number(key) < target.length
              : hasOwn(target, key);
          const result = Reflect.set(target, key, value, receiver);
          // don't trigger if target is something up in the prototype chain of original
          if (target === toRaw(receiver)) {
              if (!hadKey) {
                  trigger(target, "add" /* ADD */, key, value);
              }
              else if (hasChanged(value, oldValue)) {
                  trigger(target, "set" /* SET */, key, value, oldValue);
              }
          }
          return result;
      };
  }
  function deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
      }
      return result;
  }
  function has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has" /* HAS */, key);
      }
      return result;
  }
  function ownKeys(target) {
      track(target, "iterate" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);
      return Reflect.ownKeys(target);
  }
  const mutableHandlers = {
      get,
      set,
      deleteProperty,
      has,
      ownKeys
  };
  const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
          {
              warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
      },
      deleteProperty(target, key) {
          {
              warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
          }
          return true;
      }
  };
  const shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
  });
  // Props handlers are special in the sense that it should not unwrap top-level
  // refs (in order to allow refs to be explicitly passed down), but should
  // retain the reactivity of the normal readonly object.
  const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {
      get: shallowReadonlyGet
  });

  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
      // #1772: readonly(reactive(Map)) should return readonly + reactive version
      // of the value
      target = target["__v_raw" /* RAW */];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly) {
          if (key !== rawKey) {
              track(rawTarget, "get" /* GET */, key);
          }
          track(rawTarget, "get" /* GET */, rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
          return wrap(target.get(key));
      }
      else if (has.call(rawTarget, rawKey)) {
          return wrap(target.get(rawKey));
      }
      else if (target !== rawTarget) {
          // #3602 readonly(reactive(Map))
          // ensure that the nested reactive `Map` can do tracking for itself
          target.get(key);
      }
  }
  function has$1(key, isReadonly = false) {
      const target = this["__v_raw" /* RAW */];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly) {
          if (key !== rawKey) {
              track(rawTarget, "has" /* HAS */, key);
          }
          track(rawTarget, "has" /* HAS */, rawKey);
      }
      return key === rawKey
          ? target.has(key)
          : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
      target = target["__v_raw" /* RAW */];
      !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
      return Reflect.get(target, 'size', target);
  }
  function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
          target.add(value);
          trigger(target, "add" /* ADD */, value, value);
      }
      return this;
  }
  function set$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has, get } = getProto(target);
      let hadKey = has.call(target, key);
      if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
      }
      else {
          checkIdentityKeys(target, has, key);
      }
      const oldValue = get.call(target, key);
      target.set(key, value);
      if (!hadKey) {
          trigger(target, "add" /* ADD */, key, value);
      }
      else if (hasChanged(value, oldValue)) {
          trigger(target, "set" /* SET */, key, value, oldValue);
      }
      return this;
  }
  function deleteEntry(key) {
      const target = toRaw(this);
      const { has, get } = getProto(target);
      let hadKey = has.call(target, key);
      if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
      }
      else {
          checkIdentityKeys(target, has, key);
      }
      const oldValue = get ? get.call(target, key) : undefined;
      // forward the operation before queueing reactions
      const result = target.delete(key);
      if (hadKey) {
          trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
      }
      return result;
  }
  function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const oldTarget = isMap(target)
              ? new Map(target)
              : new Set(target)
          ;
      // forward the operation before queueing reactions
      const result = target.clear();
      if (hadItems) {
          trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
      }
      return result;
  }
  function createForEach(isReadonly, isShallow) {
      return function forEach(callback, thisArg) {
          const observed = this;
          const target = observed["__v_raw" /* RAW */];
          const rawTarget = toRaw(target);
          const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
          !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
          return target.forEach((value, key) => {
              // important: make sure the callback is
              // 1. invoked with the reactive map as `this` and 3rd arg
              // 2. the value received should be a corresponding reactive/readonly.
              return callback.call(thisArg, wrap(value), wrap(key), observed);
          });
      };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
      return function (...args) {
          const target = this["__v_raw" /* RAW */];
          const rawTarget = toRaw(target);
          const targetIsMap = isMap(rawTarget);
          const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
          const isKeyOnly = method === 'keys' && targetIsMap;
          const innerIterator = target[method](...args);
          const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
          !isReadonly &&
              track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
          // return a wrapped iterator which returns observed versions of the
          // values emitted from the real iterator
          return {
              // iterator protocol
              next() {
                  const { value, done } = innerIterator.next();
                  return done
                      ? { value, done }
                      : {
                          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                          done
                      };
              },
              // iterable protocol
              [Symbol.iterator]() {
                  return this;
              }
          };
      };
  }
  function createReadonlyMethod(type) {
      return function (...args) {
          {
              const key = args[0] ? `on key "${args[0]}" ` : ``;
              console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
          }
          return type === "delete" /* DELETE */ ? false : this;
      };
  }
  function createInstrumentations() {
      const mutableInstrumentations = {
          get(key) {
              return get$1(this, key);
          },
          get size() {
              return size(this);
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, false)
      };
      const shallowInstrumentations = {
          get(key) {
              return get$1(this, key, false, true);
          },
          get size() {
              return size(this);
          },
          has: has$1,
          add,
          set: set$1,
          delete: deleteEntry,
          clear,
          forEach: createForEach(false, true)
      };
      const readonlyInstrumentations = {
          get(key) {
              return get$1(this, key, true);
          },
          get size() {
              return size(this, true);
          },
          has(key) {
              return has$1.call(this, key, true);
          },
          add: createReadonlyMethod("add" /* ADD */),
          set: createReadonlyMethod("set" /* SET */),
          delete: createReadonlyMethod("delete" /* DELETE */),
          clear: createReadonlyMethod("clear" /* CLEAR */),
          forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations = {
          get(key) {
              return get$1(this, key, true, true);
          },
          get size() {
              return size(this, true);
          },
          has(key) {
              return has$1.call(this, key, true);
          },
          add: createReadonlyMethod("add" /* ADD */),
          set: createReadonlyMethod("set" /* SET */),
          delete: createReadonlyMethod("delete" /* DELETE */),
          clear: createReadonlyMethod("clear" /* CLEAR */),
          forEach: createForEach(true, true)
      };
      const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
      iteratorMethods.forEach(method => {
          mutableInstrumentations[method] = createIterableMethod(method, false, false);
          readonlyInstrumentations[method] = createIterableMethod(method, true, false);
          shallowInstrumentations[method] = createIterableMethod(method, false, true);
          shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
      });
      return [
          mutableInstrumentations,
          readonlyInstrumentations,
          shallowInstrumentations,
          shallowReadonlyInstrumentations
      ];
  }
  const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
      const instrumentations = shallow
          ? isReadonly
              ? shallowReadonlyInstrumentations
              : shallowInstrumentations
          : isReadonly
              ? readonlyInstrumentations
              : mutableInstrumentations;
      return (target, key, receiver) => {
          if (key === "__v_isReactive" /* IS_REACTIVE */) {
              return !isReadonly;
          }
          else if (key === "__v_isReadonly" /* IS_READONLY */) {
              return isReadonly;
          }
          else if (key === "__v_raw" /* RAW */) {
              return target;
          }
          return Reflect.get(hasOwn(instrumentations, key) && key in target
              ? instrumentations
              : target, key, receiver);
      };
  }
  const mutableCollectionHandlers = {
      get: /*#__PURE__*/ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
      get: /*#__PURE__*/ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
      get: /*#__PURE__*/ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
      get: /*#__PURE__*/ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has.call(target, rawKey)) {
          const type = toRawType(target);
          console.warn(`Reactive ${type} contains both the raw and reactive ` +
              `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
              `which can lead to inconsistencies. ` +
              `Avoid differentiating between the raw and reactive versions ` +
              `of an object and only use the reactive version if possible.`);
      }
  }

  const reactiveMap = new WeakMap();
  const shallowReactiveMap = new WeakMap();
  const readonlyMap = new WeakMap();
  const shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
      switch (rawType) {
          case 'Object':
          case 'Array':
              return 1 /* COMMON */;
          case 'Map':
          case 'Set':
          case 'WeakMap':
          case 'WeakSet':
              return 2 /* COLLECTION */;
          default:
              return 0 /* INVALID */;
      }
  }
  function getTargetType(value) {
      return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
          ? 0 /* INVALID */
          : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
      // if trying to observe a readonly proxy, return the readonly version.
      if (isReadonly(target)) {
          return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  /**
   * Return a shallowly-reactive copy of the original object, where only the root
   * level properties are reactive. It also does not auto-unwrap refs (even at the
   * root level).
   */
  function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  /**
   * Creates a readonly copy of the original object. Note the returned copy is not
   * made reactive, but `readonly` can be called on an already reactive object.
   */
  function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  /**
   * Returns a reactive-copy of the original object, where only the root level
   * properties are readonly, and does NOT unwrap refs nor recursively convert
   * returned properties.
   * This is used for creating the props proxy object for stateful components.
   */
  function shallowReadonly(target) {
      return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject(target)) {
          {
              console.warn(`value cannot be made reactive: ${String(target)}`);
          }
          return target;
      }
      // target is already a Proxy, return it.
      // exception: calling readonly() on a reactive object
      if (target["__v_raw" /* RAW */] &&
          !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
          return target;
      }
      // target already has corresponding Proxy
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
          return existingProxy;
      }
      // only specific value types can be observed.
      const targetType = getTargetType(target);
      if (targetType === 0 /* INVALID */) {
          return target;
      }
      const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
  }
  function isReactive(value) {
      if (isReadonly(value)) {
          return isReactive(value["__v_raw" /* RAW */]);
      }
      return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
  }
  function isReadonly(value) {
      return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
  }
  function isShallow(value) {
      return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
  }
  function isProxy(value) {
      return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
      const raw = observed && observed["__v_raw" /* RAW */];
      return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
      def(value, "__v_skip" /* SKIP */, true);
      return value;
  }
  const toReactive = (value) => isObject(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject(value) ? readonly(value) : value;

  function trackRefValue(ref) {
      if (shouldTrack && activeEffect) {
          ref = toRaw(ref);
          {
              trackEffects(ref.dep || (ref.dep = createDep()), {
                  target: ref,
                  type: "get" /* GET */,
                  key: 'value'
              });
          }
      }
  }
  function triggerRefValue(ref, newVal) {
      ref = toRaw(ref);
      if (ref.dep) {
          {
              triggerEffects(ref.dep, {
                  target: ref,
                  type: "set" /* SET */,
                  key: 'value',
                  newValue: newVal
              });
          }
      }
  }
  function isRef(r) {
      return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
      return createRef(value, false);
  }
  function shallowRef(value) {
      return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
          return rawValue;
      }
      return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
      constructor(value, __v_isShallow) {
          this.__v_isShallow = __v_isShallow;
          this.dep = undefined;
          this.__v_isRef = true;
          this._rawValue = __v_isShallow ? value : toRaw(value);
          this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
          trackRefValue(this);
          return this._value;
      }
      set value(newVal) {
          newVal = this.__v_isShallow ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
              this._rawValue = newVal;
              this._value = this.__v_isShallow ? newVal : toReactive(newVal);
              triggerRefValue(this, newVal);
          }
      }
  }
  function triggerRef(ref) {
      triggerRefValue(ref, ref.value );
  }
  function unref(ref) {
      return isRef(ref) ? ref.value : ref;
  }
  const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
          const oldValue = target[key];
          if (isRef(oldValue) && !isRef(value)) {
              oldValue.value = value;
              return true;
          }
          else {
              return Reflect.set(target, key, value, receiver);
          }
      }
  };
  function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs)
          ? objectWithRefs
          : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class CustomRefImpl {
      constructor(factory) {
          this.dep = undefined;
          this.__v_isRef = true;
          const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
          this._get = get;
          this._set = set;
      }
      get value() {
          return this._get();
      }
      set value(newVal) {
          this._set(newVal);
      }
  }
  function customRef(factory) {
      return new CustomRefImpl(factory);
  }
  function toRefs(object) {
      if (!isProxy(object)) {
          console.warn(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = isArray(object) ? new Array(object.length) : {};
      for (const key in object) {
          ret[key] = toRef(object, key);
      }
      return ret;
  }
  class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
          this._object = _object;
          this._key = _key;
          this._defaultValue = _defaultValue;
          this.__v_isRef = true;
      }
      get value() {
          const val = this._object[this._key];
          return val === undefined ? this._defaultValue : val;
      }
      set value(newVal) {
          this._object[this._key] = newVal;
      }
  }
  function toRef(object, key, defaultValue) {
      const val = object[key];
      return isRef(val)
          ? val
          : new ObjectRefImpl(object, key, defaultValue);
  }

  class ComputedRefImpl {
      constructor(getter, _setter, isReadonly, isSSR) {
          this._setter = _setter;
          this.dep = undefined;
          this.__v_isRef = true;
          this._dirty = true;
          this.effect = new ReactiveEffect(getter, () => {
              if (!this._dirty) {
                  this._dirty = true;
                  triggerRefValue(this);
              }
          });
          this.effect.computed = this;
          this.effect.active = this._cacheable = !isSSR;
          this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
      }
      get value() {
          // the computed ref may get wrapped by other proxies e.g. readonly() #3376
          const self = toRaw(this);
          trackRefValue(self);
          if (self._dirty || !self._cacheable) {
              self._dirty = false;
              self._value = self.effect.run();
          }
          return self._value;
      }
      set value(newValue) {
          this._setter(newValue);
      }
  }
  function computed(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction(getterOrOptions);
      if (onlyGetter) {
          getter = getterOrOptions;
          setter = () => {
                  console.warn('Write operation failed: computed value is readonly');
              }
              ;
      }
      else {
          getter = getterOrOptions.get;
          setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      if (debugOptions && !isSSR) {
          cRef.effect.onTrack = debugOptions.onTrack;
          cRef.effect.onTrigger = debugOptions.onTrigger;
      }
      return cRef;
  }

  const stack = [];
  function pushWarningContext(vnode) {
      stack.push(vnode);
  }
  function popWarningContext() {
      stack.pop();
  }
  function warn$1(msg, ...args) {
      // avoid props formatting or warn handler tracking deps that might be mutated
      // during patch, leading to infinite recursion.
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
          callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
              msg + args.join(''),
              instance && instance.proxy,
              trace
                  .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                  .join('\n'),
              trace
          ]);
      }
      else {
          const warnArgs = [`[Vue warn]: ${msg}`, ...args];
          /* istanbul ignore if */
          if (trace.length &&
              // avoid spamming console during tests
              !false) {
              warnArgs.push(`\n`, ...formatTrace(trace));
          }
          console.warn(...warnArgs);
      }
      resetTracking();
  }
  function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
          return [];
      }
      // we can't just use the stack because it will be incomplete during updates
      // that did not start from the root. Re-construct the parent chain using
      // instance parent pointers.
      const normalizedStack = [];
      while (currentVNode) {
          const last = normalizedStack[0];
          if (last && last.vnode === currentVNode) {
              last.recurseCount++;
          }
          else {
              normalizedStack.push({
                  vnode: currentVNode,
                  recurseCount: 0
              });
          }
          const parentInstance = currentVNode.component && currentVNode.component.parent;
          currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
  }
  /* istanbul ignore next */
  function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
          logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
      });
      return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
      const close = `>` + postfix;
      return vnode.props
          ? [open, ...formatProps(vnode.props), close]
          : [open + close];
  }
  /* istanbul ignore next */
  function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach(key => {
          res.push(...formatProp(key, props[key]));
      });
      if (keys.length > 3) {
          res.push(` ...`);
      }
      return res;
  }
  /* istanbul ignore next */
  function formatProp(key, value, raw) {
      if (isString(value)) {
          value = JSON.stringify(value);
          return raw ? value : [`${key}=${value}`];
      }
      else if (typeof value === 'number' ||
          typeof value === 'boolean' ||
          value == null) {
          return raw ? value : [`${key}=${value}`];
      }
      else if (isRef(value)) {
          value = formatProp(key, toRaw(value.value), true);
          return raw ? value : [`${key}=Ref<`, value, `>`];
      }
      else if (isFunction(value)) {
          return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      }
      else {
          value = toRaw(value);
          return raw ? value : [`${key}=`, value];
      }
  }

  const ErrorTypeStrings = {
      ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
      ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
      ["c" /* CREATED */]: 'created hook',
      ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
      ["m" /* MOUNTED */]: 'mounted hook',
      ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
      ["u" /* UPDATED */]: 'updated',
      ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
      ["um" /* UNMOUNTED */]: 'unmounted hook',
      ["a" /* ACTIVATED */]: 'activated hook',
      ["da" /* DEACTIVATED */]: 'deactivated hook',
      ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
      ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
      ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
      [0 /* SETUP_FUNCTION */]: 'setup function',
      [1 /* RENDER_FUNCTION */]: 'render function',
      [2 /* WATCH_GETTER */]: 'watcher getter',
      [3 /* WATCH_CALLBACK */]: 'watcher callback',
      [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
      [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
      [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
      [7 /* VNODE_HOOK */]: 'vnode hook',
      [8 /* DIRECTIVE_HOOK */]: 'directive hook',
      [9 /* TRANSITION_HOOK */]: 'transition hook',
      [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
      [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
      [12 /* FUNCTION_REF */]: 'ref function',
      [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
      [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
          'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
  };
  function callWithErrorHandling(fn, instance, type, args) {
      let res;
      try {
          res = args ? fn(...args) : fn();
      }
      catch (err) {
          handleError(err, instance, type);
      }
      return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction(fn)) {
          const res = callWithErrorHandling(fn, instance, type, args);
          if (res && isPromise(res)) {
              res.catch(err => {
                  handleError(err, instance, type);
              });
          }
          return res;
      }
      const values = [];
      for (let i = 0; i < fn.length; i++) {
          values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
          let cur = instance.parent;
          // the exposed instance is the render proxy to keep it consistent with 2.x
          const exposedInstance = instance.proxy;
          // in production the hook receives only the error code
          const errorInfo = ErrorTypeStrings[type] ;
          while (cur) {
              const errorCapturedHooks = cur.ec;
              if (errorCapturedHooks) {
                  for (let i = 0; i < errorCapturedHooks.length; i++) {
                      if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                          return;
                      }
                  }
              }
              cur = cur.parent;
          }
          // app-level handling
          const appErrorHandler = instance.appContext.config.errorHandler;
          if (appErrorHandler) {
              callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
              return;
          }
      }
      logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
      {
          const info = ErrorTypeStrings[type];
          if (contextVNode) {
              pushWarningContext(contextVNode);
          }
          warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
          if (contextVNode) {
              popWarningContext();
          }
          // crash in dev by default so it's more noticeable
          if (throwInDev) {
              throw err;
          }
          else {
              console.error(err);
          }
      }
  }

  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPreFlushCbs = [];
  let activePreFlushCbs = null;
  let preFlushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /*#__PURE__*/ Promise.resolve();
  let currentFlushPromise = null;
  let currentPreFlushParentJob = null;
  const RECURSION_LIMIT = 100;
  function nextTick(fn) {
      const p = currentFlushPromise || resolvedPromise;
      return fn ? p.then(this ? fn.bind(this) : fn) : p;
  }
  // #2768
  // Use binary-search to find a suitable position in the queue,
  // so that the queue maintains the increasing order of job's id,
  // which can prevent the job from being skipped and also can avoid repeated patching.
  function findInsertionIndex(id) {
      // the start index should be `flushIndex + 1`
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
          const middle = (start + end) >>> 1;
          const middleJobId = getId(queue[middle]);
          middleJobId < id ? (start = middle + 1) : (end = middle);
      }
      return start;
  }
  function queueJob(job) {
      // the dedupe search uses the startIndex argument of Array.includes()
      // by default the search index includes the current job that is being run
      // so it cannot recursively trigger itself again.
      // if the job is a watch() callback, the search will start with a +1 index to
      // allow it recursively trigger itself - it is the user's responsibility to
      // ensure it doesn't end up in an infinite loop.
      if ((!queue.length ||
          !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
          job !== currentPreFlushParentJob) {
          if (job.id == null) {
              queue.push(job);
          }
          else {
              queue.splice(findInsertionIndex(job.id), 0, job);
          }
          queueFlush();
      }
  }
  function queueFlush() {
      if (!isFlushing && !isFlushPending) {
          isFlushPending = true;
          currentFlushPromise = resolvedPromise.then(flushJobs);
      }
  }
  function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
          queue.splice(i, 1);
      }
  }
  function queueCb(cb, activeQueue, pendingQueue, index) {
      if (!isArray(cb)) {
          if (!activeQueue ||
              !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
              pendingQueue.push(cb);
          }
      }
      else {
          // if cb is an array, it is a component lifecycle hook which can only be
          // triggered by a job, which is already deduped in the main queue, so
          // we can skip duplicate check here to improve perf
          pendingQueue.push(...cb);
      }
      queueFlush();
  }
  function queuePreFlushCb(cb) {
      queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
      queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen, parentJob = null) {
      if (pendingPreFlushCbs.length) {
          currentPreFlushParentJob = parentJob;
          activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
          pendingPreFlushCbs.length = 0;
          {
              seen = seen || new Map();
          }
          for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
              if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                  continue;
              }
              activePreFlushCbs[preFlushIndex]();
          }
          activePreFlushCbs = null;
          preFlushIndex = 0;
          currentPreFlushParentJob = null;
          // recursively flush until it drains
          flushPreFlushCbs(seen, parentJob);
      }
  }
  function flushPostFlushCbs(seen) {
      // flush any pre cbs queued during the flush (e.g. pre watchers)
      flushPreFlushCbs();
      if (pendingPostFlushCbs.length) {
          const deduped = [...new Set(pendingPostFlushCbs)];
          pendingPostFlushCbs.length = 0;
          // #1947 already has active queue, nested flushPostFlushCbs call
          if (activePostFlushCbs) {
              activePostFlushCbs.push(...deduped);
              return;
          }
          activePostFlushCbs = deduped;
          {
              seen = seen || new Map();
          }
          activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
          for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
              if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                  continue;
              }
              activePostFlushCbs[postFlushIndex]();
          }
          activePostFlushCbs = null;
          postFlushIndex = 0;
      }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      {
          seen = seen || new Map();
      }
      flushPreFlushCbs(seen);
      // Sort queue before flush.
      // This ensures that:
      // 1. Components are updated from parent to child. (because parent is always
      //    created before the child so its render effect will have smaller
      //    priority number)
      // 2. If a component is unmounted during a parent component's update,
      //    its update can be skipped.
      queue.sort((a, b) => getId(a) - getId(b));
      // conditional usage of checkRecursiveUpdate must be determined out of
      // try ... catch block since Rollup by default de-optimizes treeshaking
      // inside try-catch. This can leave all warning code unshaked. Although
      // they would get eventually shaken by a minifier like terser, some minifiers
      // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
      const check = (job) => checkRecursiveUpdates(seen, job)
          ;
      try {
          for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
              const job = queue[flushIndex];
              if (job && job.active !== false) {
                  if (true && check(job)) {
                      continue;
                  }
                  // console.log(`running:`, job.id)
                  callWithErrorHandling(job, null, 14 /* SCHEDULER */);
              }
          }
      }
      finally {
          flushIndex = 0;
          queue.length = 0;
          flushPostFlushCbs(seen);
          isFlushing = false;
          currentFlushPromise = null;
          // some postFlushCb queued jobs!
          // keep flushing until it drains.
          if (queue.length ||
              pendingPreFlushCbs.length ||
              pendingPostFlushCbs.length) {
              flushJobs(seen);
          }
      }
  }
  function checkRecursiveUpdates(seen, fn) {
      if (!seen.has(fn)) {
          seen.set(fn, 1);
      }
      else {
          const count = seen.get(fn);
          if (count > RECURSION_LIMIT) {
              const instance = fn.ownerInstance;
              const componentName = instance && getComponentName(instance.type);
              warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                  `This means you have a reactive effect that is mutating its own ` +
                  `dependencies and thus recursively triggering itself. Possible sources ` +
                  `include component template, render function, updated hook or ` +
                  `watcher source function.`);
              return true;
          }
          else {
              seen.set(fn, count + 1);
          }
      }
  }

  /* eslint-disable no-restricted-globals */
  let isHmrUpdating = false;
  const hmrDirtyComponents = new Set();
  // Expose the HMR runtime on the global object
  // This makes it entirely tree-shakable without polluting the exports and makes
  // it easier to be used in toolings like vue-loader
  // Note: for a component to be eligible for HMR it also needs the __hmrId option
  // to be set so that its instances can be registered / removed.
  {
      getGlobalThis().__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
      };
  }
  const map = new Map();
  function registerHMR(instance) {
      const id = instance.type.__hmrId;
      let record = map.get(id);
      if (!record) {
          createRecord(id, instance.type);
          record = map.get(id);
      }
      record.instances.add(instance);
  }
  function unregisterHMR(instance) {
      map.get(instance.type.__hmrId).instances.delete(instance);
  }
  function createRecord(id, initialDef) {
      if (map.has(id)) {
          return false;
      }
      map.set(id, {
          initialDef: normalizeClassComponent(initialDef),
          instances: new Set()
      });
      return true;
  }
  function normalizeClassComponent(component) {
      return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
      const record = map.get(id);
      if (!record) {
          return;
      }
      // update initial record (for not-yet-rendered component)
      record.initialDef.render = newRender;
      [...record.instances].forEach(instance => {
          if (newRender) {
              instance.render = newRender;
              normalizeClassComponent(instance.type).render = newRender;
          }
          instance.renderCache = [];
          // this flag forces child components with slot content to update
          isHmrUpdating = true;
          instance.update();
          isHmrUpdating = false;
      });
  }
  function reload(id, newComp) {
      const record = map.get(id);
      if (!record)
          return;
      newComp = normalizeClassComponent(newComp);
      // update initial def (for not-yet-rendered components)
      updateComponentDef(record.initialDef, newComp);
      // create a snapshot which avoids the set being mutated during updates
      const instances = [...record.instances];
      for (const instance of instances) {
          const oldComp = normalizeClassComponent(instance.type);
          if (!hmrDirtyComponents.has(oldComp)) {
              // 1. Update existing comp definition to match new one
              if (oldComp !== record.initialDef) {
                  updateComponentDef(oldComp, newComp);
              }
              // 2. mark definition dirty. This forces the renderer to replace the
              // component on patch.
              hmrDirtyComponents.add(oldComp);
          }
          // 3. invalidate options resolution cache
          instance.appContext.optionsCache.delete(instance.type);
          // 4. actually update
          if (instance.ceReload) {
              // custom element
              hmrDirtyComponents.add(oldComp);
              instance.ceReload(newComp.styles);
              hmrDirtyComponents.delete(oldComp);
          }
          else if (instance.parent) {
              // 4. Force the parent instance to re-render. This will cause all updated
              // components to be unmounted and re-mounted. Queue the update so that we
              // don't end up forcing the same parent to re-render multiple times.
              queueJob(instance.parent.update);
              // instance is the inner component of an async custom element
              // invoke to reset styles
              if (instance.parent.type.__asyncLoader &&
                  instance.parent.ceReload) {
                  instance.parent.ceReload(newComp.styles);
              }
          }
          else if (instance.appContext.reload) {
              // root instance mounted via createApp() has a reload method
              instance.appContext.reload();
          }
          else if (typeof window !== 'undefined') {
              // root instance inside tree created via raw render(). Force reload.
              window.location.reload();
          }
          else {
              console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
          }
      }
      // 5. make sure to cleanup dirty hmr components after update
      queuePostFlushCb(() => {
          for (const instance of instances) {
              hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
          }
      });
  }
  function updateComponentDef(oldComp, newComp) {
      extend(oldComp, newComp);
      for (const key in oldComp) {
          if (key !== '__file' && !(key in newComp)) {
              delete oldComp[key];
          }
      }
  }
  function tryWrap(fn) {
      return (id, arg) => {
          try {
              return fn(id, arg);
          }
          catch (e) {
              console.error(e);
              console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                  `Full reload required.`);
          }
      };
  }

  let devtools;
  let buffer = [];
  let devtoolsNotInstalled = false;
  function emit(event, ...args) {
      if (devtools) {
          devtools.emit(event, ...args);
      }
      else if (!devtoolsNotInstalled) {
          buffer.push({ event, args });
      }
  }
  function setDevtoolsHook(hook, target) {
      var _a, _b;
      devtools = hook;
      if (devtools) {
          devtools.enabled = true;
          buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
          buffer = [];
      }
      else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== 'undefined' &&
          // some envs mock window but not fully
          window.HTMLElement &&
          // also exclude jsdom
          !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
          const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
              target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
          replay.push((newHook) => {
              setDevtoolsHook(newHook, target);
          });
          // clear buffer after 3s - the user probably doesn't have devtools installed
          // at all, and keeping the buffer will cause memory leaks (#4738)
          setTimeout(() => {
              if (!devtools) {
                  target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                  devtoolsNotInstalled = true;
                  buffer = [];
              }
          }, 3000);
      }
      else {
          // non-browser env, assume not installed
          devtoolsNotInstalled = true;
          buffer = [];
      }
  }
  function devtoolsInitApp(app, version) {
      emit("app:init" /* APP_INIT */, app, version, {
          Fragment,
          Text,
          Comment,
          Static
      });
  }
  function devtoolsUnmountApp(app) {
      emit("app:unmount" /* APP_UNMOUNT */, app);
  }
  const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
  const devtoolsComponentUpdated = 
  /*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
  const devtoolsComponentRemoved = 
  /*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
  function createDevtoolsComponentHook(hook) {
      return (component) => {
          emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
      };
  }
  const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
  const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
  function createDevtoolsPerformanceHook(hook) {
      return (component, type, time) => {
          emit(hook, component.appContext.app, component.uid, component, type, time);
      };
  }
  function devtoolsComponentEmit(component, event, params) {
      emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
  }

  function emit$1(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
          return;
      const props = instance.vnode.props || EMPTY_OBJ;
      {
          const { emitsOptions, propsOptions: [propsOptions] } = instance;
          if (emitsOptions) {
              if (!(event in emitsOptions) &&
                  !(false )) {
                  if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
                      warn$1(`Component emitted event "${event}" but it is neither declared in ` +
                          `the emits option nor as an "${toHandlerKey(event)}" prop.`);
                  }
              }
              else {
                  const validator = emitsOptions[event];
                  if (isFunction(validator)) {
                      const isValid = validator(...rawArgs);
                      if (!isValid) {
                          warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
                      }
                  }
              }
          }
      }
      let args = rawArgs;
      const isModelListener = event.startsWith('update:');
      // for v-model update:xxx events, apply modifiers on args
      const modelArg = isModelListener && event.slice(7);
      if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
          const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
              args = rawArgs.map(a => a.trim());
          }
          if (number) {
              args = rawArgs.map(toNumber);
          }
      }
      {
          devtoolsComponentEmit(instance, event, args);
      }
      {
          const lowerCaseEvent = event.toLowerCase();
          if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
              warn$1(`Event "${lowerCaseEvent}" is emitted in component ` +
                  `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                  `Note that HTML attributes are case-insensitive and you cannot use ` +
                  `v-on to listen to camelCase events when using in-DOM templates. ` +
                  `You should probably use "${hyphenate(event)}" instead of "${event}".`);
          }
      }
      let handlerName;
      let handler = props[(handlerName = toHandlerKey(event))] ||
          // also try camelCase event handler (#2249)
          props[(handlerName = toHandlerKey(camelize(event)))];
      // for v-model update:xxx events, also trigger kebab-case equivalent
      // for props passed via kebab-case
      if (!handler && isModelListener) {
          handler = props[(handlerName = toHandlerKey(hyphenate(event)))];
      }
      if (handler) {
          callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
          if (!instance.emitted) {
              instance.emitted = {};
          }
          else if (instance.emitted[handlerName]) {
              return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
      }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== undefined) {
          return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      // apply mixin/extends props
      let hasExtends = false;
      if (!isFunction(comp)) {
          const extendEmits = (raw) => {
              const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
              if (normalizedFromExtend) {
                  hasExtends = true;
                  extend(normalized, normalizedFromExtend);
              }
          };
          if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
              extendEmits(comp.extends);
          }
          if (comp.mixins) {
              comp.mixins.forEach(extendEmits);
          }
      }
      if (!raw && !hasExtends) {
          cache.set(comp, null);
          return null;
      }
      if (isArray(raw)) {
          raw.forEach(key => (normalized[key] = null));
      }
      else {
          extend(normalized, raw);
      }
      cache.set(comp, normalized);
      return normalized;
  }
  // Check if an incoming prop key is a declared emit event listener.
  // e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
  // both considered matched listeners.
  function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
          return false;
      }
      key = key.slice(2).replace(/Once$/, '');
      return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
          hasOwn(options, hyphenate(key)) ||
          hasOwn(options, key));
  }

  /**
   * mark the current rendering instance for asset resolution (e.g.
   * resolveComponent, resolveDirective) during render
   */
  let currentRenderingInstance = null;
  let currentScopeId = null;
  /**
   * Note: rendering calls maybe nested. The function returns the parent rendering
   * instance if present, which should be restored after the render is done:
   *
   * ```js
   * const prev = setCurrentRenderingInstance(i)
   * // ...render
   * setCurrentRenderingInstance(prev)
   * ```
   */
  function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = (instance && instance.type.__scopeId) || null;
      return prev;
  }
  /**
   * Set scope id when creating hoisted vnodes.
   * @private compiler helper
   */
  function pushScopeId(id) {
      currentScopeId = id;
  }
  /**
   * Technically we no longer need this after 3.0.8 but we need to keep the same
   * API for backwards compat w/ code generated by compilers.
   * @private
   */
  function popScopeId() {
      currentScopeId = null;
  }
  /**
   * Only for backwards compat
   * @private
   */
  const withScopeId = (_id) => withCtx;
  /**
   * Wrap a slot function to memoize current rendering instance
   * @private compiler helper
   */
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
  ) {
      if (!ctx)
          return fn;
      // already normalized
      if (fn._n) {
          return fn;
      }
      const renderFnWithContext = (...args) => {
          // If a user calls a compiled slot inside a template expression (#1745), it
          // can mess up block tracking, so by default we disable block tracking and
          // force bail out when invoking a compiled slot (indicated by the ._d flag).
          // This isn't necessary if rendering a compiled `<slot>`, so we flip the
          // ._d flag off when invoking the wrapped fn inside `renderSlot`.
          if (renderFnWithContext._d) {
              setBlockTracking(-1);
          }
          const prevInstance = setCurrentRenderingInstance(ctx);
          const res = fn(...args);
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
              setBlockTracking(1);
          }
          {
              devtoolsComponentUpdated(ctx);
          }
          return res;
      };
      // mark normalized to avoid duplicated wrapping
      renderFnWithContext._n = true;
      // mark this as compiled by default
      // this is used in vnode.ts -> normalizeChildren() to set the slot
      // rendering flag.
      renderFnWithContext._c = true;
      // disable block tracking by default
      renderFnWithContext._d = true;
      return renderFnWithContext;
  }

  /**
   * dev only flag to track whether $attrs was used during render.
   * If $attrs was used during render then the warning for failed attrs
   * fallthrough can be suppressed.
   */
  let accessedAttrs = false;
  function markAttrsAccessed() {
      accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
      const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      {
          accessedAttrs = false;
      }
      try {
          if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
              // withProxy is a proxy with a different `has` trap only for
              // runtime-compiled render functions using `with` block.
              const proxyToUse = withProxy || proxy;
              result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
              fallthroughAttrs = attrs;
          }
          else {
              // functional
              const render = Component;
              // in dev, mark attrs accessed if optional props (attrs === props)
              if (true && attrs === props) {
                  markAttrsAccessed();
              }
              result = normalizeVNode(render.length > 1
                  ? render(props, true
                      ? {
                          get attrs() {
                              markAttrsAccessed();
                              return attrs;
                          },
                          slots,
                          emit
                      }
                      : { attrs, slots, emit })
                  : render(props, null /* we know it doesn't need it */));
              fallthroughAttrs = Component.props
                  ? attrs
                  : getFunctionalFallthrough(attrs);
          }
      }
      catch (err) {
          blockStack.length = 0;
          handleError(err, instance, 1 /* RENDER_FUNCTION */);
          result = createVNode(Comment);
      }
      // attr merging
      // in dev mode, comments are preserved, and it's possible for a template
      // to have comments along side the root element which makes it a fragment
      let root = result;
      let setRoot = undefined;
      if (result.patchFlag > 0 &&
          result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
          [root, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
          const keys = Object.keys(fallthroughAttrs);
          const { shapeFlag } = root;
          if (keys.length) {
              if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                  if (propsOptions && keys.some(isModelListener)) {
                      // If a v-model listener (onUpdate:xxx) has a corresponding declared
                      // prop, it indicates this component expects to handle v-model and
                      // it should not fallthrough.
                      // related: #1543, #1643, #1989
                      fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                  }
                  root = cloneVNode(root, fallthroughAttrs);
              }
              else if (!accessedAttrs && root.type !== Comment) {
                  const allAttrs = Object.keys(attrs);
                  const eventAttrs = [];
                  const extraAttrs = [];
                  for (let i = 0, l = allAttrs.length; i < l; i++) {
                      const key = allAttrs[i];
                      if (isOn(key)) {
                          // ignore v-model handlers when they fail to fallthrough
                          if (!isModelListener(key)) {
                              // remove `on`, lowercase first letter to reflect event casing
                              // accurately
                              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                          }
                      }
                      else {
                          extraAttrs.push(key);
                      }
                  }
                  if (extraAttrs.length) {
                      warn$1(`Extraneous non-props attributes (` +
                          `${extraAttrs.join(', ')}) ` +
                          `were passed to component but could not be automatically inherited ` +
                          `because component renders fragment or text root nodes.`);
                  }
                  if (eventAttrs.length) {
                      warn$1(`Extraneous non-emits event listeners (` +
                          `${eventAttrs.join(', ')}) ` +
                          `were passed to component but could not be automatically inherited ` +
                          `because component renders fragment or text root nodes. ` +
                          `If the listener is intended to be a component custom event listener only, ` +
                          `declare it using the "emits" option.`);
                  }
              }
          }
      }
      // inherit directives
      if (vnode.dirs) {
          if (!isElementRoot(root)) {
              warn$1(`Runtime directive used on component with non-element root node. ` +
                  `The directives will not function as intended.`);
          }
          // clone before mutating since the root may be a hoisted vnode
          root = cloneVNode(root);
          root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      // inherit transition data
      if (vnode.transition) {
          if (!isElementRoot(root)) {
              warn$1(`Component inside <Transition> renders non-element root node ` +
                  `that cannot be animated.`);
          }
          root.transition = vnode.transition;
      }
      if (setRoot) {
          setRoot(root);
      }
      else {
          result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
  }
  /**
   * dev only
   * In dev mode, template root level comments are rendered, which turns the
   * template into a fragment root, but we need to locate the single element
   * root for attrs and scope id processing.
   */
  const getChildRoot = (vnode) => {
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren);
      if (!childRoot) {
          return [vnode, undefined];
      }
      const index = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
          rawChildren[index] = updatedRoot;
          if (dynamicChildren) {
              if (dynamicIndex > -1) {
                  dynamicChildren[dynamicIndex] = updatedRoot;
              }
              else if (updatedRoot.patchFlag > 0) {
                  vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
              }
          }
      };
      return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (isVNode(child)) {
              // ignore user comment
              if (child.type !== Comment || child.children === 'v-if') {
                  if (singleRoot) {
                      // has more than 1 non-comment child, return now
                      return;
                  }
                  else {
                      singleRoot = child;
                  }
              }
          }
          else {
              return;
          }
      }
      return singleRoot;
  }
  const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
          if (key === 'class' || key === 'style' || isOn(key)) {
              (res || (res = {}))[key] = attrs[key];
          }
      }
      return res;
  };
  const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
          if (!isModelListener(key) || !(key.slice(9) in props)) {
              res[key] = attrs[key];
          }
      }
      return res;
  };
  const isElementRoot = (vnode) => {
      return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
          vnode.type === Comment // potential v-if branch switch
      );
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      // Parent component's render function was hot-updated. Since this may have
      // caused the child component's slots content to have changed, we need to
      // force the child to update as well.
      if ((prevChildren || nextChildren) && isHmrUpdating) {
          return true;
      }
      // force child update for runtime directive or transition on component vnode.
      if (nextVNode.dirs || nextVNode.transition) {
          return true;
      }
      if (optimized && patchFlag >= 0) {
          if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
              // slot content that references values that might have changed,
              // e.g. in a v-for
              return true;
          }
          if (patchFlag & 16 /* FULL_PROPS */) {
              if (!prevProps) {
                  return !!nextProps;
              }
              // presence of this flag indicates props are always non-null
              return hasPropsChanged(prevProps, nextProps, emits);
          }
          else if (patchFlag & 8 /* PROPS */) {
              const dynamicProps = nextVNode.dynamicProps;
              for (let i = 0; i < dynamicProps.length; i++) {
                  const key = dynamicProps[i];
                  if (nextProps[key] !== prevProps[key] &&
                      !isEmitListener(emits, key)) {
                      return true;
                  }
              }
          }
      }
      else {
          // this path is only taken by manually written render functions
          // so presence of any children leads to a forced update
          if (prevChildren || nextChildren) {
              if (!nextChildren || !nextChildren.$stable) {
                  return true;
              }
          }
          if (prevProps === nextProps) {
              return false;
          }
          if (!prevProps) {
              return !!nextProps;
          }
          if (!nextProps) {
              return true;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
          return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          if (nextProps[key] !== prevProps[key] &&
              !isEmitListener(emitsOptions, key)) {
              return true;
          }
      }
      return false;
  }
  function updateHOCHostEl({ vnode, parent }, el // HostNode
  ) {
      while (parent && parent.subTree === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
      }
  }

  const isSuspense = (type) => type.__isSuspense;
  // Suspense exposes a component-like API, and is treated like a component
  // in the compiler, but internally it's a special built-in type that hooks
  // directly into the renderer.
  const SuspenseImpl = {
      name: 'Suspense',
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
      // platform-specific impl passed from renderer
      rendererInternals) {
          if (n1 == null) {
              mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
          }
          else {
              patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
          }
      },
      hydrate: hydrateSuspense,
      create: createSuspenseBoundary,
      normalize: normalizeSuspenseChildren
  };
  // Force-casted public typing for h and TSX props inference
  const Suspense = (SuspenseImpl );
  function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction(eventListener)) {
          eventListener();
      }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
      const { p: patch, o: { createElement } } = rendererInternals;
      const hiddenContainer = createElement('div');
      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
      // start mounting the content subtree in an off-dom container
      patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
      // now check if we have encountered any async deps
      if (suspense.deps > 0) {
          // has async
          // invoke @fallback event
          triggerEvent(vnode, 'onPending');
          triggerEvent(vnode, 'onFallback');
          // mount the fallback tree
          patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds);
          setActiveBranch(suspense, vnode.ssFallback);
      }
      else {
          // Suspense has no async deps. Just resolve.
          suspense.resolve();
      }
  }
  function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = (n2.suspense = n1.suspense);
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
          suspense.pendingBranch = newBranch;
          if (isSameVNodeType(newBranch, pendingBranch)) {
              // same root type but content may have changed.
              patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                  suspense.resolve();
              }
              else if (isInFallback) {
                  patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                  isSVG, slotScopeIds, optimized);
                  setActiveBranch(suspense, newFallback);
              }
          }
          else {
              // toggled before pending tree is resolved
              suspense.pendingId++;
              if (isHydrating) {
                  // if toggled before hydration is finished, the current DOM tree is
                  // no longer valid. set it as the active branch so it will be unmounted
                  // when resolved
                  suspense.isHydrating = false;
                  suspense.activeBranch = pendingBranch;
              }
              else {
                  unmount(pendingBranch, parentComponent, suspense);
              }
              // increment pending ID. this is used to invalidate async callbacks
              // reset suspense state
              suspense.deps = 0;
              // discard effects from pending branch
              suspense.effects.length = 0;
              // discard previous container
              suspense.hiddenContainer = createElement('div');
              if (isInFallback) {
                  // already in fallback state
                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                  if (suspense.deps <= 0) {
                      suspense.resolve();
                  }
                  else {
                      patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                      isSVG, slotScopeIds, optimized);
                      setActiveBranch(suspense, newFallback);
                  }
              }
              else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                  // toggled "back" to current active branch
                  patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                  // force resolve
                  suspense.resolve(true);
              }
              else {
                  // switched to a 3rd branch
                  patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                  if (suspense.deps <= 0) {
                      suspense.resolve();
                  }
              }
          }
      }
      else {
          if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
              // root did not change, just normal patch
              patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              setActiveBranch(suspense, newBranch);
          }
          else {
              // root node toggled
              // invoke @pending event
              triggerEvent(n2, 'onPending');
              // mount pending branch in off-dom container
              suspense.pendingBranch = newBranch;
              suspense.pendingId++;
              patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
              if (suspense.deps <= 0) {
                  // incoming branch has no async deps, resolve now.
                  suspense.resolve();
              }
              else {
                  const { timeout, pendingId } = suspense;
                  if (timeout > 0) {
                      setTimeout(() => {
                          if (suspense.pendingId === pendingId) {
                              suspense.fallback(newFallback);
                          }
                      }, timeout);
                  }
                  else if (timeout === 0) {
                      suspense.fallback(newFallback);
                  }
              }
          }
      }
  }
  let hasWarned = false;
  function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      /* istanbul ignore if */
      if (!hasWarned) {
          hasWarned = true;
          // @ts-ignore `console.info` cannot be null error
          console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
      }
      const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
      const timeout = toNumber(vnode.props && vnode.props.timeout);
      const suspense = {
          vnode,
          parent,
          parentComponent,
          isSVG,
          container,
          hiddenContainer,
          anchor,
          deps: 0,
          pendingId: 0,
          timeout: typeof timeout === 'number' ? timeout : -1,
          activeBranch: null,
          pendingBranch: null,
          isInFallback: true,
          isHydrating,
          isUnmounted: false,
          effects: [],
          resolve(resume = false) {
              {
                  if (!resume && !suspense.pendingBranch) {
                      throw new Error(`suspense.resolve() is called without a pending branch.`);
                  }
                  if (suspense.isUnmounted) {
                      throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                  }
              }
              const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
              if (suspense.isHydrating) {
                  suspense.isHydrating = false;
              }
              else if (!resume) {
                  const delayEnter = activeBranch &&
                      pendingBranch.transition &&
                      pendingBranch.transition.mode === 'out-in';
                  if (delayEnter) {
                      activeBranch.transition.afterLeave = () => {
                          if (pendingId === suspense.pendingId) {
                              move(pendingBranch, container, anchor, 0 /* ENTER */);
                          }
                      };
                  }
                  // this is initial anchor on mount
                  let { anchor } = suspense;
                  // unmount current active tree
                  if (activeBranch) {
                      // if the fallback tree was mounted, it may have been moved
                      // as part of a parent suspense. get the latest anchor for insertion
                      anchor = next(activeBranch);
                      unmount(activeBranch, parentComponent, suspense, true);
                  }
                  if (!delayEnter) {
                      // move content from off-dom container to actual container
                      move(pendingBranch, container, anchor, 0 /* ENTER */);
                  }
              }
              setActiveBranch(suspense, pendingBranch);
              suspense.pendingBranch = null;
              suspense.isInFallback = false;
              // flush buffered effects
              // check if there is a pending parent suspense
              let parent = suspense.parent;
              let hasUnresolvedAncestor = false;
              while (parent) {
                  if (parent.pendingBranch) {
                      // found a pending parent suspense, merge buffered post jobs
                      // into that parent
                      parent.effects.push(...effects);
                      hasUnresolvedAncestor = true;
                      break;
                  }
                  parent = parent.parent;
              }
              // no pending parent suspense, flush all jobs
              if (!hasUnresolvedAncestor) {
                  queuePostFlushCb(effects);
              }
              suspense.effects = [];
              // invoke @resolve event
              triggerEvent(vnode, 'onResolve');
          },
          fallback(fallbackVNode) {
              if (!suspense.pendingBranch) {
                  return;
              }
              const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
              // invoke @fallback event
              triggerEvent(vnode, 'onFallback');
              const anchor = next(activeBranch);
              const mountFallback = () => {
                  if (!suspense.isInFallback) {
                      return;
                  }
                  // mount the fallback tree
                  patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                  isSVG, slotScopeIds, optimized);
                  setActiveBranch(suspense, fallbackVNode);
              };
              const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
              if (delayEnter) {
                  activeBranch.transition.afterLeave = mountFallback;
              }
              suspense.isInFallback = true;
              // unmount current active branch
              unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
              true // shouldRemove
              );
              if (!delayEnter) {
                  mountFallback();
              }
          },
          move(container, anchor, type) {
              suspense.activeBranch &&
                  move(suspense.activeBranch, container, anchor, type);
              suspense.container = container;
          },
          next() {
              return suspense.activeBranch && next(suspense.activeBranch);
          },
          registerDep(instance, setupRenderEffect) {
              const isInPendingSuspense = !!suspense.pendingBranch;
              if (isInPendingSuspense) {
                  suspense.deps++;
              }
              const hydratedEl = instance.vnode.el;
              instance
                  .asyncDep.catch(err => {
                  handleError(err, instance, 0 /* SETUP_FUNCTION */);
              })
                  .then(asyncSetupResult => {
                  // retry when the setup() promise resolves.
                  // component may have been unmounted before resolve.
                  if (instance.isUnmounted ||
                      suspense.isUnmounted ||
                      suspense.pendingId !== instance.suspenseId) {
                      return;
                  }
                  // retry from this component
                  instance.asyncResolved = true;
                  const { vnode } = instance;
                  {
                      pushWarningContext(vnode);
                  }
                  handleSetupResult(instance, asyncSetupResult, false);
                  if (hydratedEl) {
                      // vnode may have been replaced if an update happened before the
                      // async dep is resolved.
                      vnode.el = hydratedEl;
                  }
                  const placeholder = !hydratedEl && instance.subTree.el;
                  setupRenderEffect(instance, vnode, 
                  // component may have been moved before resolve.
                  // if this is not a hydration, instance.subTree will be the comment
                  // placeholder.
                  parentNode(hydratedEl || instance.subTree.el), 
                  // anchor will not be used if this is hydration, so only need to
                  // consider the comment placeholder case.
                  hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                  if (placeholder) {
                      remove(placeholder);
                  }
                  updateHOCHostEl(instance, vnode.el);
                  {
                      popWarningContext();
                  }
                  // only decrease deps count if suspense is not already resolved
                  if (isInPendingSuspense && --suspense.deps === 0) {
                      suspense.resolve();
                  }
              });
          },
          unmount(parentSuspense, doRemove) {
              suspense.isUnmounted = true;
              if (suspense.activeBranch) {
                  unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
              }
              if (suspense.pendingBranch) {
                  unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
              }
          }
      };
      return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      /* eslint-disable no-restricted-globals */
      const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
      // there are two possible scenarios for server-rendered suspense:
      // - success: ssr content should be fully resolved
      // - failure: ssr content should be the fallback branch.
      // however, on the client we don't really know if it has failed or not
      // attempt to hydrate the DOM assuming it has succeeded, but we still
      // need to construct a suspense boundary first
      const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
      if (suspense.deps === 0) {
          suspense.resolve();
      }
      return result;
      /* eslint-enable no-restricted-globals */
  }
  function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
      vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
      vnode.ssFallback = isSlotChildren
          ? normalizeSuspenseSlot(children.fallback)
          : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s) {
      let block;
      if (isFunction(s)) {
          const trackBlock = isBlockTreeEnabled && s._c;
          if (trackBlock) {
              // disableTracking: false
              // allow block tracking for compiled slots
              // (see ./componentRenderContext.ts)
              s._d = false;
              openBlock();
          }
          s = s();
          if (trackBlock) {
              s._d = true;
              block = currentBlock;
              closeBlock();
          }
      }
      if (isArray(s)) {
          const singleChild = filterSingleRoot(s);
          if (!singleChild) {
              warn$1(`<Suspense> slots expect a single root node.`);
          }
          s = singleChild;
      }
      s = normalizeVNode(s);
      if (block && !s.dynamicChildren) {
          s.dynamicChildren = block.filter(c => c !== s);
      }
      return s;
  }
  function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
          if (isArray(fn)) {
              suspense.effects.push(...fn);
          }
          else {
              suspense.effects.push(fn);
          }
      }
      else {
          queuePostFlushCb(fn);
      }
  }
  function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      const el = (vnode.el = branch.el);
      // in case suspense is the root node of a component,
      // recursively update the HOC el
      if (parentComponent && parentComponent.subTree === vnode) {
          parentComponent.vnode.el = el;
          updateHOCHostEl(parentComponent, el);
      }
  }

  function provide(key, value) {
      if (!currentInstance) {
          {
              warn$1(`provide() can only be used inside setup().`);
          }
      }
      else {
          let provides = currentInstance.provides;
          // by default an instance inherits its parent's provides object
          // but when it needs to provide values of its own, it creates its
          // own provides object using parent provides object as prototype.
          // this way in `inject` we can simply look up injections from direct
          // parent and let the prototype chain do the work.
          const parentProvides = currentInstance.parent && currentInstance.parent.provides;
          if (parentProvides === provides) {
              provides = currentInstance.provides = Object.create(parentProvides);
          }
          // TS doesn't allow symbol as index type
          provides[key] = value;
      }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
      // fallback to `currentRenderingInstance` so that this can be called in
      // a functional component
      const instance = currentInstance || currentRenderingInstance;
      if (instance) {
          // #2400
          // to support `app.use` plugins,
          // fallback to appContext's `provides` if the instance is at root
          const provides = instance.parent == null
              ? instance.vnode.appContext && instance.vnode.appContext.provides
              : instance.parent.provides;
          if (provides && key in provides) {
              // TS doesn't allow symbol as index type
              return provides[key];
          }
          else if (arguments.length > 1) {
              return treatDefaultAsFactory && isFunction(defaultValue)
                  ? defaultValue.call(instance.proxy)
                  : defaultValue;
          }
          else {
              warn$1(`injection "${String(key)}" not found.`);
          }
      }
      else {
          warn$1(`inject() can only be used inside setup() or functional components.`);
      }
  }

  // Simple effect.
  function watchEffect(effect, options) {
      return doWatch(effect, null, options);
  }
  function watchPostEffect(effect, options) {
      return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));
  }
  function watchSyncEffect(effect, options) {
      return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));
  }
  // initial value for watchers to trigger on undefined initial values
  const INITIAL_WATCHER_VALUE = {};
  // implementation
  function watch(source, cb, options) {
      if (!isFunction(cb)) {
          warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
              `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
              `supports \`watch(source, cb, options?) signature.`);
      }
      return doWatch(source, cb, options);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      if (!cb) {
          if (immediate !== undefined) {
              warn$1(`watch() "immediate" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`);
          }
          if (deep !== undefined) {
              warn$1(`watch() "deep" option is only respected when using the ` +
                  `watch(source, callback, options?) signature.`);
          }
      }
      const warnInvalidSource = (s) => {
          warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
              `a reactive object, or an array of these types.`);
      };
      const instance = currentInstance;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
          getter = () => source.value;
          forceTrigger = isShallow(source);
      }
      else if (isReactive(source)) {
          getter = () => source;
          deep = true;
      }
      else if (isArray(source)) {
          isMultiSource = true;
          forceTrigger = source.some(s => isReactive(s) || isShallow(s));
          getter = () => source.map(s => {
              if (isRef(s)) {
                  return s.value;
              }
              else if (isReactive(s)) {
                  return traverse(s);
              }
              else if (isFunction(s)) {
                  return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
              }
              else {
                  warnInvalidSource(s);
              }
          });
      }
      else if (isFunction(source)) {
          if (cb) {
              // getter with cb
              getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
          }
          else {
              // no cb -> simple effect
              getter = () => {
                  if (instance && instance.isUnmounted) {
                      return;
                  }
                  if (cleanup) {
                      cleanup();
                  }
                  return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
              };
          }
      }
      else {
          getter = NOOP;
          warnInvalidSource(source);
      }
      if (cb && deep) {
          const baseGetter = getter;
          getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
          cleanup = effect.onStop = () => {
              callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
          };
      };
      let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
      const job = () => {
          if (!effect.active) {
              return;
          }
          if (cb) {
              // watch(source, cb)
              const newValue = effect.run();
              if (deep ||
                  forceTrigger ||
                  (isMultiSource
                      ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
                      : hasChanged(newValue, oldValue)) ||
                  (false  )) {
                  // cleanup before running cb again
                  if (cleanup) {
                      cleanup();
                  }
                  callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                      newValue,
                      // pass undefined as the old value when it's changed for the first time
                      oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                      onCleanup
                  ]);
                  oldValue = newValue;
              }
          }
          else {
              // watchEffect
              effect.run();
          }
      };
      // important: mark the job as a watcher callback so that scheduler knows
      // it is allowed to self-trigger (#1727)
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === 'sync') {
          scheduler = job; // the scheduler function gets called directly
      }
      else if (flush === 'post') {
          scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      }
      else {
          // default: 'pre'
          scheduler = () => queuePreFlushCb(job);
      }
      const effect = new ReactiveEffect(getter, scheduler);
      {
          effect.onTrack = onTrack;
          effect.onTrigger = onTrigger;
      }
      // initial run
      if (cb) {
          if (immediate) {
              job();
          }
          else {
              oldValue = effect.run();
          }
      }
      else if (flush === 'post') {
          queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
      }
      else {
          effect.run();
      }
      return () => {
          effect.stop();
          if (instance && instance.scope) {
              remove(instance.scope.effects, effect);
          }
      };
  }
  // this.$watch
  function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString(source)
          ? source.includes('.')
              ? createPathGetter(publicThis, source)
              : () => publicThis[source]
          : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction(value)) {
          cb = value;
      }
      else {
          cb = value.handler;
          options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
          setCurrentInstance(cur);
      }
      else {
          unsetCurrentInstance();
      }
      return res;
  }
  function createPathGetter(ctx, path) {
      const segments = path.split('.');
      return () => {
          let cur = ctx;
          for (let i = 0; i < segments.length && cur; i++) {
              cur = cur[segments[i]];
          }
          return cur;
      };
  }
  function traverse(value, seen) {
      if (!isObject(value) || value["__v_skip" /* SKIP */]) {
          return value;
      }
      seen = seen || new Set();
      if (seen.has(value)) {
          return value;
      }
      seen.add(value);
      if (isRef(value)) {
          traverse(value.value, seen);
      }
      else if (isArray(value)) {
          for (let i = 0; i < value.length; i++) {
              traverse(value[i], seen);
          }
      }
      else if (isSet(value) || isMap(value)) {
          value.forEach((v) => {
              traverse(v, seen);
          });
      }
      else if (isPlainObject(value)) {
          for (const key in value) {
              traverse(value[key], seen);
          }
      }
      return value;
  }

  function useTransitionState() {
      const state = {
          isMounted: false,
          isLeaving: false,
          isUnmounting: false,
          leavingVNodes: new Map()
      };
      onMounted(() => {
          state.isMounted = true;
      });
      onBeforeUnmount(() => {
          state.isUnmounting = true;
      });
      return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          // enter
          onBeforeEnter: TransitionHookValidator,
          onEnter: TransitionHookValidator,
          onAfterEnter: TransitionHookValidator,
          onEnterCancelled: TransitionHookValidator,
          // leave
          onBeforeLeave: TransitionHookValidator,
          onLeave: TransitionHookValidator,
          onAfterLeave: TransitionHookValidator,
          onLeaveCancelled: TransitionHookValidator,
          // appear
          onBeforeAppear: TransitionHookValidator,
          onAppear: TransitionHookValidator,
          onAfterAppear: TransitionHookValidator,
          onAppearCancelled: TransitionHookValidator
      },
      setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
              const children = slots.default && getTransitionRawChildren(slots.default(), true);
              if (!children || !children.length) {
                  return;
              }
              let child = children[0];
              if (children.length > 1) {
                  let hasFound = false;
                  // locate first non-comment child
                  for (const c of children) {
                      if (c.type !== Comment) {
                          if (hasFound) {
                              // warn more than one non-comment child
                              warn$1('<transition> can only be used on a single element or component. ' +
                                  'Use <transition-group> for lists.');
                              break;
                          }
                          child = c;
                          hasFound = true;
                      }
                  }
              }
              // there's no need to track reactivity for these props so use the raw
              // props for a bit better perf
              const rawProps = toRaw(props);
              const { mode } = rawProps;
              // check mode
              if (mode &&
                  mode !== 'in-out' &&
                  mode !== 'out-in' &&
                  mode !== 'default') {
                  warn$1(`invalid <transition> mode: ${mode}`);
              }
              if (state.isLeaving) {
                  return emptyPlaceholder(child);
              }
              // in the case of <transition><keep-alive/></transition>, we need to
              // compare the type of the kept-alive children.
              const innerChild = getKeepAliveChild(child);
              if (!innerChild) {
                  return emptyPlaceholder(child);
              }
              const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
              setTransitionHooks(innerChild, enterHooks);
              const oldChild = instance.subTree;
              const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
              let transitionKeyChanged = false;
              const { getTransitionKey } = innerChild.type;
              if (getTransitionKey) {
                  const key = getTransitionKey();
                  if (prevTransitionKey === undefined) {
                      prevTransitionKey = key;
                  }
                  else if (key !== prevTransitionKey) {
                      prevTransitionKey = key;
                      transitionKeyChanged = true;
                  }
              }
              // handle mode
              if (oldInnerChild &&
                  oldInnerChild.type !== Comment &&
                  (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                  const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                  // update old tree's hooks in case of dynamic transition
                  setTransitionHooks(oldInnerChild, leavingHooks);
                  // switching between different views
                  if (mode === 'out-in') {
                      state.isLeaving = true;
                      // return placeholder node and queue update when leave finishes
                      leavingHooks.afterLeave = () => {
                          state.isLeaving = false;
                          instance.update();
                      };
                      return emptyPlaceholder(child);
                  }
                  else if (mode === 'in-out' && innerChild.type !== Comment) {
                      leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                          const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                          leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                          // early removal callback
                          el._leaveCb = () => {
                              earlyRemove();
                              el._leaveCb = undefined;
                              delete enterHooks.delayedLeave;
                          };
                          enterHooks.delayedLeave = delayedLeave;
                      };
                  }
              }
              return child;
          };
      }
  };
  // export the public type for h/tsx inference
  // also to avoid inline import() in generated d.ts files
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
          leavingVNodesCache = Object.create(null);
          leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
  }
  // The transition hooks are attached to the vnode as vnode.transition
  // and will be called at appropriate timing in the renderer.
  function resolveTransitionHooks(vnode, props, state, instance) {
      const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook = (hook, args) => {
          hook &&
              callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
      };
      const callAsyncHook = (hook, args) => {
          const done = args[1];
          callHook(hook, args);
          if (isArray(hook)) {
              if (hook.every(hook => hook.length <= 1))
                  done();
          }
          else if (hook.length <= 1) {
              done();
          }
      };
      const hooks = {
          mode,
          persisted,
          beforeEnter(el) {
              let hook = onBeforeEnter;
              if (!state.isMounted) {
                  if (appear) {
                      hook = onBeforeAppear || onBeforeEnter;
                  }
                  else {
                      return;
                  }
              }
              // for same element (v-show)
              if (el._leaveCb) {
                  el._leaveCb(true /* cancelled */);
              }
              // for toggled element with same key (v-if)
              const leavingVNode = leavingVNodesCache[key];
              if (leavingVNode &&
                  isSameVNodeType(vnode, leavingVNode) &&
                  leavingVNode.el._leaveCb) {
                  // force early removal (not cancelled)
                  leavingVNode.el._leaveCb();
              }
              callHook(hook, [el]);
          },
          enter(el) {
              let hook = onEnter;
              let afterHook = onAfterEnter;
              let cancelHook = onEnterCancelled;
              if (!state.isMounted) {
                  if (appear) {
                      hook = onAppear || onEnter;
                      afterHook = onAfterAppear || onAfterEnter;
                      cancelHook = onAppearCancelled || onEnterCancelled;
                  }
                  else {
                      return;
                  }
              }
              let called = false;
              const done = (el._enterCb = (cancelled) => {
                  if (called)
                      return;
                  called = true;
                  if (cancelled) {
                      callHook(cancelHook, [el]);
                  }
                  else {
                      callHook(afterHook, [el]);
                  }
                  if (hooks.delayedLeave) {
                      hooks.delayedLeave();
                  }
                  el._enterCb = undefined;
              });
              if (hook) {
                  callAsyncHook(hook, [el, done]);
              }
              else {
                  done();
              }
          },
          leave(el, remove) {
              const key = String(vnode.key);
              if (el._enterCb) {
                  el._enterCb(true /* cancelled */);
              }
              if (state.isUnmounting) {
                  return remove();
              }
              callHook(onBeforeLeave, [el]);
              let called = false;
              const done = (el._leaveCb = (cancelled) => {
                  if (called)
                      return;
                  called = true;
                  remove();
                  if (cancelled) {
                      callHook(onLeaveCancelled, [el]);
                  }
                  else {
                      callHook(onAfterLeave, [el]);
                  }
                  el._leaveCb = undefined;
                  if (leavingVNodesCache[key] === vnode) {
                      delete leavingVNodesCache[key];
                  }
              });
              leavingVNodesCache[key] = vnode;
              if (onLeave) {
                  callAsyncHook(onLeave, [el, done]);
              }
              else {
                  done();
              }
          },
          clone(vnode) {
              return resolveTransitionHooks(vnode, props, state, instance);
          }
      };
      return hooks;
  }
  // the placeholder really only handles one special case: KeepAlive
  // in the case of a KeepAlive in a leave phase we need to return a KeepAlive
  // placeholder with empty content to avoid the KeepAlive instance from being
  // unmounted.
  function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
          vnode = cloneVNode(vnode);
          vnode.children = null;
          return vnode;
      }
  }
  function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode)
          ? vnode.children
              ? vnode.children[0]
              : undefined
          : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
          setTransitionHooks(vnode.component.subTree, hooks);
      }
      else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
          vnode.ssContent.transition = hooks.clone(vnode.ssContent);
          vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      }
      else {
          vnode.transition = hooks;
      }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
          let child = children[i];
          // #5360 inherit parent key in case of <template v-for>
          const key = parentKey == null
              ? child.key
              : String(parentKey) + String(child.key != null ? child.key : i);
          // handle fragment children case, e.g. v-for
          if (child.type === Fragment) {
              if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                  keyedFragmentCount++;
              ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
          }
          // comment placeholders should be skipped, e.g. v-if
          else if (keepComment || child.type !== Comment) {
              ret.push(key != null ? cloneVNode(child, { key }) : child);
          }
      }
      // #1126 if a transition children list contains multiple sub fragments, these
      // fragments will be merged into a flat children array. Since each v-for
      // fragment may contain different static bindings inside, we need to de-op
      // these children to force full diffs to ensure correct behavior.
      if (keyedFragmentCount > 1) {
          for (let i = 0; i < ret.length; i++) {
              ret[i].patchFlag = -2 /* BAIL */;
          }
      }
      return ret;
  }

  // implementation, close to no-op
  function defineComponent(options) {
      return isFunction(options) ? { setup: options, name: options.name } : options;
  }

  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  function defineAsyncComponent(source) {
      if (isFunction(source)) {
          source = { loader: source };
      }
      const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
      suspensible = true, onError: userOnError } = source;
      let pendingRequest = null;
      let resolvedComp;
      let retries = 0;
      const retry = () => {
          retries++;
          pendingRequest = null;
          return load();
      };
      const load = () => {
          let thisRequest;
          return (pendingRequest ||
              (thisRequest = pendingRequest =
                  loader()
                      .catch(err => {
                      err = err instanceof Error ? err : new Error(String(err));
                      if (userOnError) {
                          return new Promise((resolve, reject) => {
                              const userRetry = () => resolve(retry());
                              const userFail = () => reject(err);
                              userOnError(err, userRetry, userFail, retries + 1);
                          });
                      }
                      else {
                          throw err;
                      }
                  })
                      .then((comp) => {
                      if (thisRequest !== pendingRequest && pendingRequest) {
                          return pendingRequest;
                      }
                      if (!comp) {
                          warn$1(`Async component loader resolved to undefined. ` +
                              `If you are using retry(), make sure to return its return value.`);
                      }
                      // interop module default
                      if (comp &&
                          (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                          comp = comp.default;
                      }
                      if (comp && !isObject(comp) && !isFunction(comp)) {
                          throw new Error(`Invalid async component load result: ${comp}`);
                      }
                      resolvedComp = comp;
                      return comp;
                  })));
      };
      return defineComponent({
          name: 'AsyncComponentWrapper',
          __asyncLoader: load,
          get __asyncResolved() {
              return resolvedComp;
          },
          setup() {
              const instance = currentInstance;
              // already resolved
              if (resolvedComp) {
                  return () => createInnerComp(resolvedComp, instance);
              }
              const onError = (err) => {
                  pendingRequest = null;
                  handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
              };
              // suspense-controlled or SSR.
              if ((suspensible && instance.suspense) ||
                  (false )) {
                  return load()
                      .then(comp => {
                      return () => createInnerComp(comp, instance);
                  })
                      .catch(err => {
                      onError(err);
                      return () => errorComponent
                          ? createVNode(errorComponent, {
                              error: err
                          })
                          : null;
                  });
              }
              const loaded = ref(false);
              const error = ref();
              const delayed = ref(!!delay);
              if (delay) {
                  setTimeout(() => {
                      delayed.value = false;
                  }, delay);
              }
              if (timeout != null) {
                  setTimeout(() => {
                      if (!loaded.value && !error.value) {
                          const err = new Error(`Async component timed out after ${timeout}ms.`);
                          onError(err);
                          error.value = err;
                      }
                  }, timeout);
              }
              load()
                  .then(() => {
                  loaded.value = true;
                  if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                      // parent is keep-alive, force update so the loaded component's
                      // name is taken into account
                      queueJob(instance.parent.update);
                  }
              })
                  .catch(err => {
                  onError(err);
                  error.value = err;
              });
              return () => {
                  if (loaded.value && resolvedComp) {
                      return createInnerComp(resolvedComp, instance);
                  }
                  else if (error.value && errorComponent) {
                      return createVNode(errorComponent, {
                          error: error.value
                      });
                  }
                  else if (loadingComponent && !delayed.value) {
                      return createVNode(loadingComponent);
                  }
              };
          }
      });
  }
  function createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {
      const vnode = createVNode(comp, props, children);
      // ensure inner component inherits the async wrapper's ref owner
      vnode.ref = ref;
      return vnode;
  }

  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  const KeepAliveImpl = {
      name: `KeepAlive`,
      // Marker for special handling inside the renderer. We are not using a ===
      // check directly on KeepAlive in the renderer, because importing it directly
      // would prevent it from being tree-shaken.
      __isKeepAlive: true,
      props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
      },
      setup(props, { slots }) {
          const instance = getCurrentInstance();
          // KeepAlive communicates with the instantiated renderer via the
          // ctx where the renderer passes in its internals,
          // and the KeepAlive instance exposes activate/deactivate implementations.
          // The whole point of this is to avoid importing KeepAlive directly in the
          // renderer to facilitate tree-shaking.
          const sharedContext = instance.ctx;
          const cache = new Map();
          const keys = new Set();
          let current = null;
          {
              instance.__v_cache = cache;
          }
          const parentSuspense = instance.suspense;
          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
          const storageContainer = createElement('div');
          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
              const instance = vnode.component;
              move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
              // in case props have changed
              patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
              queuePostRenderEffect(() => {
                  instance.isDeactivated = false;
                  if (instance.a) {
                      invokeArrayFns(instance.a);
                  }
                  const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                  if (vnodeHook) {
                      invokeVNodeHook(vnodeHook, instance.parent, vnode);
                  }
              }, parentSuspense);
              {
                  // Update components tree
                  devtoolsComponentAdded(instance);
              }
          };
          sharedContext.deactivate = (vnode) => {
              const instance = vnode.component;
              move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
              queuePostRenderEffect(() => {
                  if (instance.da) {
                      invokeArrayFns(instance.da);
                  }
                  const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                  if (vnodeHook) {
                      invokeVNodeHook(vnodeHook, instance.parent, vnode);
                  }
                  instance.isDeactivated = true;
              }, parentSuspense);
              {
                  // Update components tree
                  devtoolsComponentAdded(instance);
              }
          };
          function unmount(vnode) {
              // reset the shapeFlag so it can be properly unmounted
              resetShapeFlag(vnode);
              _unmount(vnode, instance, parentSuspense, true);
          }
          function pruneCache(filter) {
              cache.forEach((vnode, key) => {
                  const name = getComponentName(vnode.type);
                  if (name && (!filter || !filter(name))) {
                      pruneCacheEntry(key);
                  }
              });
          }
          function pruneCacheEntry(key) {
              const cached = cache.get(key);
              if (!current || cached.type !== current.type) {
                  unmount(cached);
              }
              else if (current) {
                  // current active instance should no longer be kept-alive.
                  // we can't unmount it now but it might be later, so reset its flag now.
                  resetShapeFlag(current);
              }
              cache.delete(key);
              keys.delete(key);
          }
          // prune cache on include/exclude prop change
          watch(() => [props.include, props.exclude], ([include, exclude]) => {
              include && pruneCache(name => matches(include, name));
              exclude && pruneCache(name => !matches(exclude, name));
          }, 
          // prune post-render after `current` has been updated
          { flush: 'post', deep: true });
          // cache sub tree after render
          let pendingCacheKey = null;
          const cacheSubtree = () => {
              // fix #1621, the pendingCacheKey could be 0
              if (pendingCacheKey != null) {
                  cache.set(pendingCacheKey, getInnerChild(instance.subTree));
              }
          };
          onMounted(cacheSubtree);
          onUpdated(cacheSubtree);
          onBeforeUnmount(() => {
              cache.forEach(cached => {
                  const { subTree, suspense } = instance;
                  const vnode = getInnerChild(subTree);
                  if (cached.type === vnode.type) {
                      // current instance will be unmounted as part of keep-alive's unmount
                      resetShapeFlag(vnode);
                      // but invoke its deactivated hook here
                      const da = vnode.component.da;
                      da && queuePostRenderEffect(da, suspense);
                      return;
                  }
                  unmount(cached);
              });
          });
          return () => {
              pendingCacheKey = null;
              if (!slots.default) {
                  return null;
              }
              const children = slots.default();
              const rawVNode = children[0];
              if (children.length > 1) {
                  {
                      warn$1(`KeepAlive should contain exactly one component child.`);
                  }
                  current = null;
                  return children;
              }
              else if (!isVNode(rawVNode) ||
                  (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                      !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                  current = null;
                  return rawVNode;
              }
              let vnode = getInnerChild(rawVNode);
              const comp = vnode.type;
              // for async components, name check should be based in its loaded
              // inner component if available
              const name = getComponentName(isAsyncWrapper(vnode)
                  ? vnode.type.__asyncResolved || {}
                  : comp);
              const { include, exclude, max } = props;
              if ((include && (!name || !matches(include, name))) ||
                  (exclude && name && matches(exclude, name))) {
                  current = vnode;
                  return rawVNode;
              }
              const key = vnode.key == null ? comp : vnode.key;
              const cachedVNode = cache.get(key);
              // clone vnode if it's reused because we are going to mutate it
              if (vnode.el) {
                  vnode = cloneVNode(vnode);
                  if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                      rawVNode.ssContent = vnode;
                  }
              }
              // #1513 it's possible for the returned vnode to be cloned due to attr
              // fallthrough or scopeId, so the vnode here may not be the final vnode
              // that is mounted. Instead of caching it directly, we store the pending
              // key and cache `instance.subTree` (the normalized vnode) in
              // beforeMount/beforeUpdate hooks.
              pendingCacheKey = key;
              if (cachedVNode) {
                  // copy over mounted state
                  vnode.el = cachedVNode.el;
                  vnode.component = cachedVNode.component;
                  if (vnode.transition) {
                      // recursively update transition hooks on subTree
                      setTransitionHooks(vnode, vnode.transition);
                  }
                  // avoid vnode being mounted as fresh
                  vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                  // make this key the freshest
                  keys.delete(key);
                  keys.add(key);
              }
              else {
                  keys.add(key);
                  // prune oldest entry
                  if (max && keys.size > parseInt(max, 10)) {
                      pruneCacheEntry(keys.values().next().value);
                  }
              }
              // avoid vnode being unmounted
              vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
              current = vnode;
              return isSuspense(rawVNode.type) ? rawVNode : vnode;
          };
      }
  };
  // export the public type for h/tsx inference
  // also to avoid inline import() in generated d.ts files
  const KeepAlive = KeepAliveImpl;
  function matches(pattern, name) {
      if (isArray(pattern)) {
          return pattern.some((p) => matches(p, name));
      }
      else if (isString(pattern)) {
          return pattern.split(',').includes(name);
      }
      else if (pattern.test) {
          return pattern.test(name);
      }
      /* istanbul ignore next */
      return false;
  }
  function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
  }
  function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
      // cache the deactivate branch check wrapper for injected hooks so the same
      // hook can be properly deduped by the scheduler. "__wdc" stands for "with
      // deactivation check".
      const wrappedHook = hook.__wdc ||
          (hook.__wdc = () => {
              // only fire the hook if the target instance is NOT in a deactivated branch.
              let current = target;
              while (current) {
                  if (current.isDeactivated) {
                      return;
                  }
                  current = current.parent;
              }
              return hook();
          });
      injectHook(type, wrappedHook, target);
      // In addition to registering it on the target instance, we walk up the parent
      // chain and register it on all ancestor instances that are keep-alive roots.
      // This avoids the need to walk the entire component tree when invoking these
      // hooks, and more importantly, avoids the need to track child components in
      // arrays.
      if (target) {
          let current = target.parent;
          while (current && current.parent) {
              if (isKeepAlive(current.parent.vnode)) {
                  injectToKeepAliveRoot(wrappedHook, type, target, current);
              }
              current = current.parent;
          }
      }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      // injectHook wraps the original for error handling, so make sure to remove
      // the wrapped version.
      const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
      onUnmounted(() => {
          remove(keepAliveRoot[type], injected);
      }, target);
  }
  function resetShapeFlag(vnode) {
      let shapeFlag = vnode.shapeFlag;
      if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
          shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
      }
      if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
          shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
      }
      vnode.shapeFlag = shapeFlag;
  }
  function getInnerChild(vnode) {
      return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
  }

  function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
          const hooks = target[type] || (target[type] = []);
          // cache the error handling wrapper for injected hooks so the same hook
          // can be properly deduped by the scheduler. "__weh" stands for "with error
          // handling".
          const wrappedHook = hook.__weh ||
              (hook.__weh = (...args) => {
                  if (target.isUnmounted) {
                      return;
                  }
                  // disable tracking inside all lifecycle hooks
                  // since they can potentially be called inside effects.
                  pauseTracking();
                  // Set currentInstance during hook invocation.
                  // This assumes the hook does not synchronously trigger other hooks, which
                  // can only be false when the user does something really funky.
                  setCurrentInstance(target);
                  const res = callWithAsyncErrorHandling(hook, target, type, args);
                  unsetCurrentInstance();
                  resetTracking();
                  return res;
              });
          if (prepend) {
              hooks.unshift(wrappedHook);
          }
          else {
              hooks.push(wrappedHook);
          }
          return wrappedHook;
      }
      else {
          const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));
          warn$1(`${apiName} is called when there is no active component instance to be ` +
              `associated with. ` +
              `Lifecycle injection APIs can only be used during execution of setup().` +
              (` If you are using async setup(), make sure to register lifecycle ` +
                      `hooks before the first await statement.`
                  ));
      }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => 
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
      injectHook(lifecycle, hook, target);
  const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
  const onMounted = createHook("m" /* MOUNTED */);
  const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
  const onUpdated = createHook("u" /* UPDATED */);
  const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
  const onUnmounted = createHook("um" /* UNMOUNTED */);
  const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
  const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
  const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
  function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec" /* ERROR_CAPTURED */, hook, target);
  }

  /**
  Runtime helper for applying directives to a vnode. Example usage:

  const comp = resolveComponent('comp')
  const foo = resolveDirective('foo')
  const bar = resolveDirective('bar')

  return withDirectives(h(comp), [
    [foo, this.x],
    [bar, this.y]
  ])
  */
  function validateDirectiveName(name) {
      if (isBuiltInDirective(name)) {
          warn$1('Do not use built-in directive ids as custom directive id: ' + name);
      }
  }
  /**
   * Adds directives to a VNode.
   */
  function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
          warn$1(`withDirectives can only be used inside render functions.`);
          return vnode;
      }
      const instance = getExposeProxy(internalInstance) ||
          internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
          let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
          if (isFunction(dir)) {
              dir = {
                  mounted: dir,
                  updated: dir
              };
          }
          if (dir.deep) {
              traverse(value);
          }
          bindings.push({
              dir,
              instance,
              value,
              oldValue: void 0,
              arg,
              modifiers
          });
      }
      return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
          const binding = bindings[i];
          if (oldBindings) {
              binding.oldValue = oldBindings[i].value;
          }
          let hook = binding.dir[name];
          if (hook) {
              // disable tracking inside all lifecycle hooks
              // since they can potentially be called inside effects.
              pauseTracking();
              callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                  vnode.el,
                  binding,
                  vnode,
                  prevVNode
              ]);
              resetTracking();
          }
      }
  }

  const COMPONENTS = 'components';
  const DIRECTIVES = 'directives';
  /**
   * @private
   */
  function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol();
  /**
   * @private
   */
  function resolveDynamicComponent(component) {
      if (isString(component)) {
          return resolveAsset(COMPONENTS, component, false) || component;
      }
      else {
          // invalid types will fallthrough to createVNode and raise warning
          return (component || NULL_DYNAMIC_COMPONENT);
      }
  }
  /**
   * @private
   */
  function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
  }
  // implementation
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
          const Component = instance.type;
          // explicit self name has highest priority
          if (type === COMPONENTS) {
              const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);
              if (selfName &&
                  (selfName === name ||
                      selfName === camelize(name) ||
                      selfName === capitalize(camelize(name)))) {
                  return Component;
              }
          }
          const res = 
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) ||
              // global registration
              resolve(instance.appContext[type], name);
          if (!res && maybeSelfReference) {
              // fallback to implicit self-reference
              return Component;
          }
          if (warnMissing && !res) {
              const extra = type === COMPONENTS
                  ? `\nIf this is a native custom element, make sure to exclude it from ` +
                      `component resolution via compilerOptions.isCustomElement.`
                  : ``;
              warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
          }
          return res;
      }
      else {
          warn$1(`resolve${capitalize(type.slice(0, -1))} ` +
              `can only be used in render() or setup().`);
      }
  }
  function resolve(registry, name) {
      return (registry &&
          (registry[name] ||
              registry[camelize(name)] ||
              registry[capitalize(camelize(name))]));
  }

  /**
   * Actual implementation
   */
  function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = (cache && cache[index]);
      if (isArray(source) || isString(source)) {
          ret = new Array(source.length);
          for (let i = 0, l = source.length; i < l; i++) {
              ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
          }
      }
      else if (typeof source === 'number') {
          if (!Number.isInteger(source)) {
              warn$1(`The v-for range expect an integer value but got ${source}.`);
          }
          ret = new Array(source);
          for (let i = 0; i < source; i++) {
              ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
          }
      }
      else if (isObject(source)) {
          if (source[Symbol.iterator]) {
              ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
          }
          else {
              const keys = Object.keys(source);
              ret = new Array(keys.length);
              for (let i = 0, l = keys.length; i < l; i++) {
                  const key = keys[i];
                  ret[i] = renderItem(source[key], key, i, cached && cached[i]);
              }
          }
      }
      else {
          ret = [];
      }
      if (cache) {
          cache[index] = ret;
      }
      return ret;
  }

  /**
   * Compiler runtime helper for creating dynamic slots object
   * @private
   */
  function createSlots(slots, dynamicSlots) {
      for (let i = 0; i < dynamicSlots.length; i++) {
          const slot = dynamicSlots[i];
          // array of dynamic slot generated by <template v-for="..." #[...]>
          if (isArray(slot)) {
              for (let j = 0; j < slot.length; j++) {
                  slots[slot[j].name] = slot[j].fn;
              }
          }
          else if (slot) {
              // conditional single slot generated by <template v-if="..." #foo>
              slots[slot.name] = slot.fn;
          }
      }
      return slots;
  }

  /**
   * Compiler runtime helper for rendering `<slot/>`
   * @private
   */
  function renderSlot(slots, name, props = {}, 
  // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback, noSlotted) {
      if (currentRenderingInstance.isCE ||
          (currentRenderingInstance.parent &&
              isAsyncWrapper(currentRenderingInstance.parent) &&
              currentRenderingInstance.parent.isCE)) {
          return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot.length > 1) {
          warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
              `function. You need to mark this component with $dynamic-slots in the ` +
              `parent template.`);
          slot = () => [];
      }
      // a compiled slot disables block tracking by default to avoid manual
      // invocation interfering with template-based block tracking, but in
      // `renderSlot` we can be sure that it's template-based so we can force
      // enable it.
      if (slot && slot._c) {
          slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
          ? 64 /* STABLE_FRAGMENT */
          : -2 /* BAIL */);
      if (!noSlotted && rendered.scopeId) {
          rendered.slotScopeIds = [rendered.scopeId + '-s'];
      }
      if (slot && slot._c) {
          slot._d = true;
      }
      return rendered;
  }
  function ensureValidVNode(vnodes) {
      return vnodes.some(child => {
          if (!isVNode(child))
              return true;
          if (child.type === Comment)
              return false;
          if (child.type === Fragment &&
              !ensureValidVNode(child.children))
              return false;
          return true;
      })
          ? vnodes
          : null;
  }

  /**
   * For prefixing keys in v-on="obj" with "on"
   * @private
   */
  function toHandlers(obj) {
      const ret = {};
      if (!isObject(obj)) {
          warn$1(`v-on with no argument expects an object value.`);
          return ret;
      }
      for (const key in obj) {
          ret[toHandlerKey(key)] = obj[key];
      }
      return ret;
  }

  /**
   * #2437 In Vue 3, functional components do not have a public instance proxy but
   * they exist in the internal parent chain. For code that relies on traversing
   * public $parent chains, skip functional ones and go to the parent instead.
   */
  const getPublicInstance = (i) => {
      if (!i)
          return null;
      if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = 
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /*#__PURE__*/ extend(Object.create(null), {
      $: i => i,
      $el: i => i.vnode.el,
      $data: i => i.data,
      $props: i => (shallowReadonly(i.props) ),
      $attrs: i => (shallowReadonly(i.attrs) ),
      $slots: i => (shallowReadonly(i.slots) ),
      $refs: i => (shallowReadonly(i.refs) ),
      $parent: i => getPublicInstance(i.parent),
      $root: i => getPublicInstance(i.root),
      $emit: i => i.emit,
      $options: i => (resolveMergedOptions(i) ),
      $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
      $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: i => (instanceWatch.bind(i) )
  });
  const isReservedPrefix = (key) => key === '_' || key === '$';
  const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
          const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
          // for internal formatters to know that this is a Vue instance
          if (key === '__isVue') {
              return true;
          }
          // prioritize <script setup> bindings during dev.
          // this allows even properties that start with _ or $ to be used - so that
          // it aligns with the production behavior where the render fn is inlined and
          // indeed has access to all declared variables.
          if (setupState !== EMPTY_OBJ &&
              setupState.__isScriptSetup &&
              hasOwn(setupState, key)) {
              return setupState[key];
          }
          // data / props / ctx
          // This getter gets called for every property access on the render context
          // during render and is a major hotspot. The most expensive part of this
          // is the multiple hasOwn() calls. It's much faster to do a simple property
          // access on a plain object, so we use an accessCache object (with null
          // prototype) to memoize what access type a key corresponds to.
          let normalizedProps;
          if (key[0] !== '$') {
              const n = accessCache[key];
              if (n !== undefined) {
                  switch (n) {
                      case 1 /* SETUP */:
                          return setupState[key];
                      case 2 /* DATA */:
                          return data[key];
                      case 4 /* CONTEXT */:
                          return ctx[key];
                      case 3 /* PROPS */:
                          return props[key];
                      // default: just fallthrough
                  }
              }
              else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
                  accessCache[key] = 1 /* SETUP */;
                  return setupState[key];
              }
              else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                  accessCache[key] = 2 /* DATA */;
                  return data[key];
              }
              else if (
              // only cache other properties when instance has declared (thus stable)
              // props
              (normalizedProps = instance.propsOptions[0]) &&
                  hasOwn(normalizedProps, key)) {
                  accessCache[key] = 3 /* PROPS */;
                  return props[key];
              }
              else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                  accessCache[key] = 4 /* CONTEXT */;
                  return ctx[key];
              }
              else if (shouldCacheAccess) {
                  accessCache[key] = 0 /* OTHER */;
              }
          }
          const publicGetter = publicPropertiesMap[key];
          let cssModule, globalProperties;
          // public $xxx properties
          if (publicGetter) {
              if (key === '$attrs') {
                  track(instance, "get" /* GET */, key);
                  markAttrsAccessed();
              }
              return publicGetter(instance);
          }
          else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) &&
              (cssModule = cssModule[key])) {
              return cssModule;
          }
          else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
              // user may set custom properties to `this` that start with `$`
              accessCache[key] = 4 /* CONTEXT */;
              return ctx[key];
          }
          else if (
          // global properties
          ((globalProperties = appContext.config.globalProperties),
              hasOwn(globalProperties, key))) {
              {
                  return globalProperties[key];
              }
          }
          else if (currentRenderingInstance &&
              (!isString(key) ||
                  // #1091 avoid internal isRef/isVNode checks on component instance leading
                  // to infinite warning loop
                  key.indexOf('__v') !== 0)) {
              if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
                  warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                      `character ("$" or "_") and is not proxied on the render context.`);
              }
              else if (instance === currentRenderingInstance) {
                  warn$1(`Property ${JSON.stringify(key)} was accessed during render ` +
                      `but is not defined on instance.`);
              }
          }
      },
      set({ _: instance }, key, value) {
          const { data, setupState, ctx } = instance;
          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
              setupState[key] = value;
              return true;
          }
          else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
              data[key] = value;
              return true;
          }
          else if (hasOwn(instance.props, key)) {
              warn$1(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
              return false;
          }
          if (key[0] === '$' && key.slice(1) in instance) {
              warn$1(`Attempting to mutate public property "${key}". ` +
                      `Properties starting with $ are reserved and readonly.`, instance);
              return false;
          }
          else {
              if (key in instance.appContext.config.globalProperties) {
                  Object.defineProperty(ctx, key, {
                      enumerable: true,
                      configurable: true,
                      value
                  });
              }
              else {
                  ctx[key] = value;
              }
          }
          return true;
      },
      has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
          let normalizedProps;
          return (!!accessCache[key] ||
              (data !== EMPTY_OBJ && hasOwn(data, key)) ||
              (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
              ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||
              hasOwn(ctx, key) ||
              hasOwn(publicPropertiesMap, key) ||
              hasOwn(appContext.config.globalProperties, key));
      },
      defineProperty(target, key, descriptor) {
          if (descriptor.get != null) {
              // invalidate key cache of a getter based property #5417
              target._.accessCache[key] = 0;
          }
          else if (hasOwn(descriptor, 'value')) {
              this.set(target, key, descriptor.value, null);
          }
          return Reflect.defineProperty(target, key, descriptor);
      }
  };
  {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
          warn$1(`Avoid app logic that relies on enumerating keys on a component instance. ` +
              `The keys will be empty in production mode to avoid performance overhead.`);
          return Reflect.ownKeys(target);
      };
  }
  const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend({}, PublicInstanceProxyHandlers, {
      get(target, key) {
          // fast path for unscopables when using `with` block
          if (key === Symbol.unscopables) {
              return;
          }
          return PublicInstanceProxyHandlers.get(target, key, target);
      },
      has(_, key) {
          const has = key[0] !== '_' && !isGloballyWhitelisted(key);
          if (!has && PublicInstanceProxyHandlers.has(_, key)) {
              warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
          }
          return has;
      }
  });
  // dev only
  // In dev mode, the proxy target exposes the same properties as seen on `this`
  // for easier console inspection. In prod mode it will be an empty object so
  // these properties definitions can be skipped.
  function createDevRenderContext(instance) {
      const target = {};
      // expose internal instance for proxy handlers
      Object.defineProperty(target, `_`, {
          configurable: true,
          enumerable: false,
          get: () => instance
      });
      // expose public properties
      Object.keys(publicPropertiesMap).forEach(key => {
          Object.defineProperty(target, key, {
              configurable: true,
              enumerable: false,
              get: () => publicPropertiesMap[key](instance),
              // intercepted by the proxy so no need for implementation,
              // but needed to prevent set errors
              set: NOOP
          });
      });
      return target;
  }
  // dev only
  function exposePropsOnRenderContext(instance) {
      const { ctx, propsOptions: [propsOptions] } = instance;
      if (propsOptions) {
          Object.keys(propsOptions).forEach(key => {
              Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => instance.props[key],
                  set: NOOP
              });
          });
      }
  }
  // dev only
  function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(toRaw(setupState)).forEach(key => {
          if (!setupState.__isScriptSetup) {
              if (isReservedPrefix(key[0])) {
                  warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                      `which are reserved prefixes for Vue internals.`);
                  return;
              }
              Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => setupState[key],
                  set: NOOP
              });
          }
      });
  }

  function createDuplicateChecker() {
      const cache = Object.create(null);
      return (type, key) => {
          if (cache[key]) {
              warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
          }
          else {
              cache[key] = type;
          }
      };
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      // do not cache property access on public proxy during state initialization
      shouldCacheAccess = false;
      // call beforeCreate first before accessing other options since
      // the hook may mutate resolved options (#2791)
      if (options.beforeCreate) {
          callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
      }
      const { 
      // state
      data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
      // lifecycle
      created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
      // public API
      expose, inheritAttrs, 
      // assets
      components, directives, filters } = options;
      const checkDuplicateProperties = createDuplicateChecker() ;
      {
          const [propsOptions] = instance.propsOptions;
          if (propsOptions) {
              for (const key in propsOptions) {
                  checkDuplicateProperties("Props" /* PROPS */, key);
              }
          }
      }
      // options initialization order (to be consistent with Vue 2):
      // - props (already done outside of this function)
      // - inject
      // - methods
      // - data (deferred since it relies on `this` access)
      // - computed
      // - watch (deferred since it relies on `this` access)
      if (injectOptions) {
          resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
      }
      if (methods) {
          for (const key in methods) {
              const methodHandler = methods[key];
              if (isFunction(methodHandler)) {
                  // In dev mode, we use the `createRenderContext` function to define
                  // methods to the proxy target, and those are read-only but
                  // reconfigurable, so it needs to be redefined here
                  {
                      Object.defineProperty(ctx, key, {
                          value: methodHandler.bind(publicThis),
                          configurable: true,
                          enumerable: true,
                          writable: true
                      });
                  }
                  {
                      checkDuplicateProperties("Methods" /* METHODS */, key);
                  }
              }
              else {
                  warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                      `Did you reference the function correctly?`);
              }
          }
      }
      if (dataOptions) {
          if (!isFunction(dataOptions)) {
              warn$1(`The data option must be a function. ` +
                  `Plain object usage is no longer supported.`);
          }
          const data = dataOptions.call(publicThis, publicThis);
          if (isPromise(data)) {
              warn$1(`data() returned a Promise - note data() cannot be async; If you ` +
                  `intend to perform data fetching before component renders, use ` +
                  `async setup() + <Suspense>.`);
          }
          if (!isObject(data)) {
              warn$1(`data() should return an object.`);
          }
          else {
              instance.data = reactive(data);
              {
                  for (const key in data) {
                      checkDuplicateProperties("Data" /* DATA */, key);
                      // expose data on ctx during dev
                      if (!isReservedPrefix(key[0])) {
                          Object.defineProperty(ctx, key, {
                              configurable: true,
                              enumerable: true,
                              get: () => data[key],
                              set: NOOP
                          });
                      }
                  }
              }
          }
      }
      // state initialization complete at this point - start caching access
      shouldCacheAccess = true;
      if (computedOptions) {
          for (const key in computedOptions) {
              const opt = computedOptions[key];
              const get = isFunction(opt)
                  ? opt.bind(publicThis, publicThis)
                  : isFunction(opt.get)
                      ? opt.get.bind(publicThis, publicThis)
                      : NOOP;
              if (get === NOOP) {
                  warn$1(`Computed property "${key}" has no getter.`);
              }
              const set = !isFunction(opt) && isFunction(opt.set)
                  ? opt.set.bind(publicThis)
                  : () => {
                          warn$1(`Write operation failed: computed property "${key}" is readonly.`);
                      }
                      ;
              const c = computed$1({
                  get,
                  set
              });
              Object.defineProperty(ctx, key, {
                  enumerable: true,
                  configurable: true,
                  get: () => c.value,
                  set: v => (c.value = v)
              });
              {
                  checkDuplicateProperties("Computed" /* COMPUTED */, key);
              }
          }
      }
      if (watchOptions) {
          for (const key in watchOptions) {
              createWatcher(watchOptions[key], ctx, publicThis, key);
          }
      }
      if (provideOptions) {
          const provides = isFunction(provideOptions)
              ? provideOptions.call(publicThis)
              : provideOptions;
          Reflect.ownKeys(provides).forEach(key => {
              provide(key, provides[key]);
          });
      }
      if (created) {
          callHook(created, instance, "c" /* CREATED */);
      }
      function registerLifecycleHook(register, hook) {
          if (isArray(hook)) {
              hook.forEach(_hook => register(_hook.bind(publicThis)));
          }
          else if (hook) {
              register(hook.bind(publicThis));
          }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray(expose)) {
          if (expose.length) {
              const exposed = instance.exposed || (instance.exposed = {});
              expose.forEach(key => {
                  Object.defineProperty(exposed, key, {
                      get: () => publicThis[key],
                      set: val => (publicThis[key] = val)
                  });
              });
          }
          else if (!instance.exposed) {
              instance.exposed = {};
          }
      }
      // options that are handled when creating the instance but also need to be
      // applied from mixins
      if (render && instance.render === NOOP) {
          instance.render = render;
      }
      if (inheritAttrs != null) {
          instance.inheritAttrs = inheritAttrs;
      }
      // asset options.
      if (components)
          instance.components = components;
      if (directives)
          instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
      if (isArray(injectOptions)) {
          injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
          const opt = injectOptions[key];
          let injected;
          if (isObject(opt)) {
              if ('default' in opt) {
                  injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
              }
              else {
                  injected = inject(opt.from || key);
              }
          }
          else {
              injected = inject(opt);
          }
          if (isRef(injected)) {
              // TODO remove the check in 3.3
              if (unwrapRef) {
                  Object.defineProperty(ctx, key, {
                      enumerable: true,
                      configurable: true,
                      get: () => injected.value,
                      set: v => (injected.value = v)
                  });
              }
              else {
                  {
                      warn$1(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                          `and no longer needs \`.value\` in the next minor release. ` +
                          `To opt-in to the new behavior now, ` +
                          `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                          `temporary and will not be needed in the future.)`);
                  }
                  ctx[key] = injected;
              }
          }
          else {
              ctx[key] = injected;
          }
          {
              checkDuplicateProperties("Inject" /* INJECT */, key);
          }
      }
  }
  function callHook(hook, instance, type) {
      callWithAsyncErrorHandling(isArray(hook)
          ? hook.map(h => h.bind(instance.proxy))
          : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes('.')
          ? createPathGetter(publicThis, key)
          : () => publicThis[key];
      if (isString(raw)) {
          const handler = ctx[raw];
          if (isFunction(handler)) {
              watch(getter, handler);
          }
          else {
              warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
          }
      }
      else if (isFunction(raw)) {
          watch(getter, raw.bind(publicThis));
      }
      else if (isObject(raw)) {
          if (isArray(raw)) {
              raw.forEach(r => createWatcher(r, ctx, publicThis, key));
          }
          else {
              const handler = isFunction(raw.handler)
                  ? raw.handler.bind(publicThis)
                  : ctx[raw.handler];
              if (isFunction(handler)) {
                  watch(getter, handler, raw);
              }
              else {
                  warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
              }
          }
      }
      else {
          warn$1(`Invalid watch option: "${key}"`, raw);
      }
  }
  /**
   * Resolve merged options and cache it on the component.
   * This is done only once per-component since the merging does not involve
   * instances.
   */
  function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
          resolved = cached;
      }
      else if (!globalMixins.length && !mixins && !extendsOptions) {
          {
              resolved = base;
          }
      }
      else {
          resolved = {};
          if (globalMixins.length) {
              globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
          }
          mergeOptions(resolved, base, optionMergeStrategies);
      }
      cache.set(base, resolved);
      return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
          mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
          mixins.forEach((m) => mergeOptions(to, m, strats, true));
      }
      for (const key in from) {
          if (asMixin && key === 'expose') {
              warn$1(`"expose" option is ignored when declared in mixins or extends. ` +
                      `It should only be declared in the base component itself.`);
          }
          else {
              const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
              to[key] = strat ? strat(to[key], from[key]) : from[key];
          }
      }
      return to;
  }
  const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeObjectOptions,
      emits: mergeObjectOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
  };
  function mergeDataFn(to, from) {
      if (!from) {
          return to;
      }
      if (!to) {
          return from;
      }
      return function mergedDataFn() {
          return (extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
      };
  }
  function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
      if (isArray(raw)) {
          const res = {};
          for (let i = 0; i < raw.length; i++) {
              res[raw[i]] = raw[i];
          }
          return res;
      }
      return raw;
  }
  function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
      return to ? extend(extend(Object.create(null), to), from) : from;
  }
  function mergeWatchOptions(to, from) {
      if (!to)
          return from;
      if (!from)
          return to;
      const merged = extend(Object.create(null), to);
      for (const key in from) {
          merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
  }

  function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
  isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      // ensure all declared prop keys are present
      for (const key in instance.propsOptions[0]) {
          if (!(key in props)) {
              props[key] = undefined;
          }
      }
      // validation
      {
          validateProps(rawProps || {}, props, instance);
      }
      if (isStateful) {
          // stateful
          instance.props = isSSR ? props : shallowReactive(props);
      }
      else {
          if (!instance.type.props) {
              // functional w/ optional props, props === attrs
              instance.props = attrs;
          }
          else {
              // functional w/ declared props
              instance.props = props;
          }
      }
      instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const { props, attrs, vnode: { patchFlag } } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !((instance.type.__hmrId ||
              (instance.parent && instance.parent.type.__hmrId))) &&
          (optimized || patchFlag > 0) &&
          !(patchFlag & 16 /* FULL_PROPS */)) {
          if (patchFlag & 8 /* PROPS */) {
              // Compiler-generated props & no keys change, just set the updated
              // the props.
              const propsToUpdate = instance.vnode.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                  let key = propsToUpdate[i];
                  // skip if the prop key is a declared emit event listener
                  if (isEmitListener(instance.emitsOptions, key)) {
                      continue;
                  }
                  // PROPS flag guarantees rawProps to be non-null
                  const value = rawProps[key];
                  if (options) {
                      // attr / props separation was done on init and will be consistent
                      // in this code path, so just check if attrs have it.
                      if (hasOwn(attrs, key)) {
                          if (value !== attrs[key]) {
                              attrs[key] = value;
                              hasAttrsChanged = true;
                          }
                      }
                      else {
                          const camelizedKey = camelize(key);
                          props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                      }
                  }
                  else {
                      if (value !== attrs[key]) {
                          attrs[key] = value;
                          hasAttrsChanged = true;
                      }
                  }
              }
          }
      }
      else {
          // full props update.
          if (setFullProps(instance, rawProps, props, attrs)) {
              hasAttrsChanged = true;
          }
          // in case of dynamic props, check if we need to delete keys from
          // the props object
          let kebabKey;
          for (const key in rawCurrentProps) {
              if (!rawProps ||
                  // for camelCase
                  (!hasOwn(rawProps, key) &&
                      // it's possible the original props was passed in as kebab-case
                      // and converted to camelCase (#955)
                      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {
                  if (options) {
                      if (rawPrevProps &&
                          // for camelCase
                          (rawPrevProps[key] !== undefined ||
                              // for kebab-case
                              rawPrevProps[kebabKey] !== undefined)) {
                          props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                      }
                  }
                  else {
                      delete props[key];
                  }
              }
          }
          // in the case of functional component w/o props declaration, props and
          // attrs point to the same object so it should already have been updated.
          if (attrs !== rawCurrentProps) {
              for (const key in attrs) {
                  if (!rawProps ||
                      (!hasOwn(rawProps, key) &&
                          (!false ))) {
                      delete attrs[key];
                      hasAttrsChanged = true;
                  }
              }
          }
      }
      // trigger updates for $attrs in case it's used in component slots
      if (hasAttrsChanged) {
          trigger(instance, "set" /* SET */, '$attrs');
      }
      {
          validateProps(rawProps || {}, props, instance);
      }
  }
  function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
          for (let key in rawProps) {
              // key, ref are reserved and never passed down
              if (isReservedProp(key)) {
                  continue;
              }
              const value = rawProps[key];
              // prop option names are camelized during normalization, so to support
              // kebab -> camel conversion here we need to camelize the key.
              let camelKey;
              if (options && hasOwn(options, (camelKey = camelize(key)))) {
                  if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                      props[camelKey] = value;
                  }
                  else {
                      (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                  }
              }
              else if (!isEmitListener(instance.emitsOptions, key)) {
                  if (!(key in attrs) || value !== attrs[key]) {
                      attrs[key] = value;
                      hasAttrsChanged = true;
                  }
              }
          }
      }
      if (needCastKeys) {
          const rawCurrentProps = toRaw(props);
          const castValues = rawCastValues || EMPTY_OBJ;
          for (let i = 0; i < needCastKeys.length; i++) {
              const key = needCastKeys[i];
              props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
          }
      }
      return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
          const hasDefault = hasOwn(opt, 'default');
          // default values
          if (hasDefault && value === undefined) {
              const defaultValue = opt.default;
              if (opt.type !== Function && isFunction(defaultValue)) {
                  const { propsDefaults } = instance;
                  if (key in propsDefaults) {
                      value = propsDefaults[key];
                  }
                  else {
                      setCurrentInstance(instance);
                      value = propsDefaults[key] = defaultValue.call(null, props);
                      unsetCurrentInstance();
                  }
              }
              else {
                  value = defaultValue;
              }
          }
          // boolean casting
          if (opt[0 /* shouldCast */]) {
              if (isAbsent && !hasDefault) {
                  value = false;
              }
              else if (opt[1 /* shouldCastTrue */] &&
                  (value === '' || value === hyphenate(key))) {
                  value = true;
              }
          }
      }
      return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
          return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      // apply mixin/extends props
      let hasExtends = false;
      if (!isFunction(comp)) {
          const extendProps = (raw) => {
              hasExtends = true;
              const [props, keys] = normalizePropsOptions(raw, appContext, true);
              extend(normalized, props);
              if (keys)
                  needCastKeys.push(...keys);
          };
          if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendProps);
          }
          if (comp.extends) {
              extendProps(comp.extends);
          }
          if (comp.mixins) {
              comp.mixins.forEach(extendProps);
          }
      }
      if (!raw && !hasExtends) {
          cache.set(comp, EMPTY_ARR);
          return EMPTY_ARR;
      }
      if (isArray(raw)) {
          for (let i = 0; i < raw.length; i++) {
              if (!isString(raw[i])) {
                  warn$1(`props must be strings when using array syntax.`, raw[i]);
              }
              const normalizedKey = camelize(raw[i]);
              if (validatePropName(normalizedKey)) {
                  normalized[normalizedKey] = EMPTY_OBJ;
              }
          }
      }
      else if (raw) {
          if (!isObject(raw)) {
              warn$1(`invalid props options`, raw);
          }
          for (const key in raw) {
              const normalizedKey = camelize(key);
              if (validatePropName(normalizedKey)) {
                  const opt = raw[key];
                  const prop = (normalized[normalizedKey] =
                      isArray(opt) || isFunction(opt) ? { type: opt } : opt);
                  if (prop) {
                      const booleanIndex = getTypeIndex(Boolean, prop.type);
                      const stringIndex = getTypeIndex(String, prop.type);
                      prop[0 /* shouldCast */] = booleanIndex > -1;
                      prop[1 /* shouldCastTrue */] =
                          stringIndex < 0 || booleanIndex < stringIndex;
                      // if the prop needs boolean casting or default value
                      if (booleanIndex > -1 || hasOwn(prop, 'default')) {
                          needCastKeys.push(normalizedKey);
                      }
                  }
              }
          }
      }
      const res = [normalized, needCastKeys];
      cache.set(comp, res);
      return res;
  }
  function validatePropName(key) {
      if (key[0] !== '$') {
          return true;
      }
      else {
          warn$1(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
  }
  // use function string name to check type constructors
  // so that it works across vms / iframes.
  function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
      return match ? match[1] : ctor === null ? 'null' : '';
  }
  function isSameType(a, b) {
      return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
      if (isArray(expectedTypes)) {
          return expectedTypes.findIndex(t => isSameType(t, type));
      }
      else if (isFunction(expectedTypes)) {
          return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
  }
  /**
   * dev only
   */
  function validateProps(rawProps, props, instance) {
      const resolvedValues = toRaw(props);
      const options = instance.propsOptions[0];
      for (const key in options) {
          let opt = options[key];
          if (opt == null)
              continue;
          validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
      }
  }
  /**
   * dev only
   */
  function validateProp(name, value, prop, isAbsent) {
      const { type, required, validator } = prop;
      // required!
      if (required && isAbsent) {
          warn$1('Missing required prop: "' + name + '"');
          return;
      }
      // missing but optional
      if (value == null && !prop.required) {
          return;
      }
      // type check
      if (type != null && type !== true) {
          let isValid = false;
          const types = isArray(type) ? type : [type];
          const expectedTypes = [];
          // value is valid as long as one of the specified types match
          for (let i = 0; i < types.length && !isValid; i++) {
              const { valid, expectedType } = assertType(value, types[i]);
              expectedTypes.push(expectedType || '');
              isValid = valid;
          }
          if (!isValid) {
              warn$1(getInvalidTypeMessage(name, value, expectedTypes));
              return;
          }
      }
      // custom validator
      if (validator && !validator(value)) {
          warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
  }
  const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');
  /**
   * dev only
   */
  function assertType(value, type) {
      let valid;
      const expectedType = getType(type);
      if (isSimpleType(expectedType)) {
          const t = typeof value;
          valid = t === expectedType.toLowerCase();
          // for primitive wrapper objects
          if (!valid && t === 'object') {
              valid = value instanceof type;
          }
      }
      else if (expectedType === 'Object') {
          valid = isObject(value);
      }
      else if (expectedType === 'Array') {
          valid = isArray(value);
      }
      else if (expectedType === 'null') {
          valid = value === null;
      }
      else {
          valid = value instanceof type;
      }
      return {
          valid,
          expectedType
      };
  }
  /**
   * dev only
   */
  function getInvalidTypeMessage(name, value, expectedTypes) {
      let message = `Invalid prop: type check failed for prop "${name}".` +
          ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      // check if we need to specify expected value
      if (expectedTypes.length === 1 &&
          isExplicable(expectedType) &&
          !isBoolean(expectedType, receivedType)) {
          message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      // check if we need to specify received value
      if (isExplicable(receivedType)) {
          message += `with value ${receivedValue}.`;
      }
      return message;
  }
  /**
   * dev only
   */
  function styleValue(value, type) {
      if (type === 'String') {
          return `"${value}"`;
      }
      else if (type === 'Number') {
          return `${Number(value)}`;
      }
      else {
          return `${value}`;
      }
  }
  /**
   * dev only
   */
  function isExplicable(type) {
      const explicitTypes = ['string', 'number', 'boolean'];
      return explicitTypes.some(elem => type.toLowerCase() === elem);
  }
  /**
   * dev only
   */
  function isBoolean(...args) {
      return args.some(elem => elem.toLowerCase() === 'boolean');
  }

  const isInternalKey = (key) => key[0] === '_' || key === '$stable';
  const normalizeSlotValue = (value) => isArray(value)
      ? value.map(normalizeVNode)
      : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
          // already normalized - #5353
          return rawSlot;
      }
      const normalized = withCtx((...args) => {
          if (currentInstance) {
              warn$1(`Slot "${key}" invoked outside of the render function: ` +
                  `this will not track dependencies used in the slot. ` +
                  `Invoke the slot function inside the render function instead.`);
          }
          return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
          if (isInternalKey(key))
              continue;
          const value = rawSlots[key];
          if (isFunction(value)) {
              slots[key] = normalizeSlot(key, value, ctx);
          }
          else if (value != null) {
              {
                  warn$1(`Non-function value encountered for slot "${key}". ` +
                      `Prefer function slots for better performance.`);
              }
              const normalized = normalizeSlotValue(value);
              slots[key] = () => normalized;
          }
      }
  };
  const normalizeVNodeSlots = (instance, children) => {
      if (!isKeepAlive(instance.vnode) &&
          !(false )) {
          warn$1(`Non-function value encountered for default slot. ` +
              `Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
          const type = children._;
          if (type) {
              // users can get the shallow readonly version of the slots object through `this.$slots`,
              // we should avoid the proxy object polluting the slots of the internal instance
              instance.slots = toRaw(children);
              // make compiler marker non-enumerable
              def(children, '_', type);
          }
          else {
              normalizeObjectSlots(children, (instance.slots = {}));
          }
      }
      else {
          instance.slots = {};
          if (children) {
              normalizeVNodeSlots(instance, children);
          }
      }
      def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
          const type = children._;
          if (type) {
              // compiled slots.
              if (isHmrUpdating) {
                  // Parent was HMR updated so slot content may have changed.
                  // force update slots and mark instance for hmr as well
                  extend(slots, children);
              }
              else if (optimized && type === 1 /* STABLE */) {
                  // compiled AND stable.
                  // no need to update, and skip stale slots removal.
                  needDeletionCheck = false;
              }
              else {
                  // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                  // normalization.
                  extend(slots, children);
                  // #2893
                  // when rendering the optimized slots by manually written render function,
                  // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                  // i.e. let the `renderSlot` create the bailed Fragment
                  if (!optimized && type === 1 /* STABLE */) {
                      delete slots._;
                  }
              }
          }
          else {
              needDeletionCheck = !children.$stable;
              normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
      }
      else if (children) {
          // non slot object children (direct value) passed to a component
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
      }
      // delete stale slots
      if (needDeletionCheck) {
          for (const key in slots) {
              if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                  delete slots[key];
              }
          }
      }
  };

  function createAppContext() {
      return {
          app: null,
          config: {
              isNativeTag: NO,
              performance: false,
              globalProperties: {},
              optionMergeStrategies: {},
              errorHandler: undefined,
              warnHandler: undefined,
              compilerOptions: {}
          },
          mixins: [],
          components: {},
          directives: {},
          provides: Object.create(null),
          optionsCache: new WeakMap(),
          propsCache: new WeakMap(),
          emitsCache: new WeakMap()
      };
  }
  let uid = 0;
  function createAppAPI(render, hydrate) {
      return function createApp(rootComponent, rootProps = null) {
          if (!isFunction(rootComponent)) {
              rootComponent = Object.assign({}, rootComponent);
          }
          if (rootProps != null && !isObject(rootProps)) {
              warn$1(`root props passed to app.mount() must be an object.`);
              rootProps = null;
          }
          const context = createAppContext();
          const installedPlugins = new Set();
          let isMounted = false;
          const app = (context.app = {
              _uid: uid++,
              _component: rootComponent,
              _props: rootProps,
              _container: null,
              _context: context,
              _instance: null,
              version,
              get config() {
                  return context.config;
              },
              set config(v) {
                  {
                      warn$1(`app.config cannot be replaced. Modify individual options instead.`);
                  }
              },
              use(plugin, ...options) {
                  if (installedPlugins.has(plugin)) {
                      warn$1(`Plugin has already been applied to target app.`);
                  }
                  else if (plugin && isFunction(plugin.install)) {
                      installedPlugins.add(plugin);
                      plugin.install(app, ...options);
                  }
                  else if (isFunction(plugin)) {
                      installedPlugins.add(plugin);
                      plugin(app, ...options);
                  }
                  else {
                      warn$1(`A plugin must either be a function or an object with an "install" ` +
                          `function.`);
                  }
                  return app;
              },
              mixin(mixin) {
                  {
                      if (!context.mixins.includes(mixin)) {
                          context.mixins.push(mixin);
                      }
                      else {
                          warn$1('Mixin has already been applied to target app' +
                              (mixin.name ? `: ${mixin.name}` : ''));
                      }
                  }
                  return app;
              },
              component(name, component) {
                  {
                      validateComponentName(name, context.config);
                  }
                  if (!component) {
                      return context.components[name];
                  }
                  if (context.components[name]) {
                      warn$1(`Component "${name}" has already been registered in target app.`);
                  }
                  context.components[name] = component;
                  return app;
              },
              directive(name, directive) {
                  {
                      validateDirectiveName(name);
                  }
                  if (!directive) {
                      return context.directives[name];
                  }
                  if (context.directives[name]) {
                      warn$1(`Directive "${name}" has already been registered in target app.`);
                  }
                  context.directives[name] = directive;
                  return app;
              },
              mount(rootContainer, isHydrate, isSVG) {
                  if (!isMounted) {
                      // #5571
                      if (rootContainer.__vue_app__) {
                          warn$1(`There is already an app instance mounted on the host container.\n` +
                              ` If you want to mount another app on the same host container,` +
                              ` you need to unmount the previous app by calling \`app.unmount()\` first.`);
                      }
                      const vnode = createVNode(rootComponent, rootProps);
                      // store app context on the root VNode.
                      // this will be set on the root instance on initial mount.
                      vnode.appContext = context;
                      // HMR root reload
                      {
                          context.reload = () => {
                              render(cloneVNode(vnode), rootContainer, isSVG);
                          };
                      }
                      if (isHydrate && hydrate) {
                          hydrate(vnode, rootContainer);
                      }
                      else {
                          render(vnode, rootContainer, isSVG);
                      }
                      isMounted = true;
                      app._container = rootContainer;
                      rootContainer.__vue_app__ = app;
                      {
                          app._instance = vnode.component;
                          devtoolsInitApp(app, version);
                      }
                      return getExposeProxy(vnode.component) || vnode.component.proxy;
                  }
                  else {
                      warn$1(`App has already been mounted.\n` +
                          `If you want to remount the same app, move your app creation logic ` +
                          `into a factory function and create fresh app instances for each ` +
                          `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                  }
              },
              unmount() {
                  if (isMounted) {
                      render(null, app._container);
                      {
                          app._instance = null;
                          devtoolsUnmountApp(app);
                      }
                      delete app._container.__vue_app__;
                  }
                  else {
                      warn$1(`Cannot unmount an app that is not mounted.`);
                  }
              },
              provide(key, value) {
                  if (key in context.provides) {
                      warn$1(`App already provides property with key "${String(key)}". ` +
                          `It will be overwritten with the new value.`);
                  }
                  context.provides[key] = value;
                  return app;
              }
          });
          return app;
      };
  }

  /**
   * Function for handling a template ref
   */
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray(rawRef)) {
          rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
          return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
          // when mounting async components, nothing needs to be done,
          // because the template ref is forwarded to inner component
          return;
      }
      const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
          ? getExposeProxy(vnode.component) || vnode.component.proxy
          : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref } = rawRef;
      if (!owner) {
          warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
              `A vnode with ref must be created inside the render function.`);
          return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
      const setupState = owner.setupState;
      // dynamic ref changed. unset old ref
      if (oldRef != null && oldRef !== ref) {
          if (isString(oldRef)) {
              refs[oldRef] = null;
              if (hasOwn(setupState, oldRef)) {
                  setupState[oldRef] = null;
              }
          }
          else if (isRef(oldRef)) {
              oldRef.value = null;
          }
      }
      if (isFunction(ref)) {
          callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
      }
      else {
          const _isString = isString(ref);
          const _isRef = isRef(ref);
          if (_isString || _isRef) {
              const doSet = () => {
                  if (rawRef.f) {
                      const existing = _isString ? refs[ref] : ref.value;
                      if (isUnmount) {
                          isArray(existing) && remove(existing, refValue);
                      }
                      else {
                          if (!isArray(existing)) {
                              if (_isString) {
                                  refs[ref] = [refValue];
                                  if (hasOwn(setupState, ref)) {
                                      setupState[ref] = refs[ref];
                                  }
                              }
                              else {
                                  ref.value = [refValue];
                                  if (rawRef.k)
                                      refs[rawRef.k] = ref.value;
                              }
                          }
                          else if (!existing.includes(refValue)) {
                              existing.push(refValue);
                          }
                      }
                  }
                  else if (_isString) {
                      refs[ref] = value;
                      if (hasOwn(setupState, ref)) {
                          setupState[ref] = value;
                      }
                  }
                  else if (_isRef) {
                      ref.value = value;
                      if (rawRef.k)
                          refs[rawRef.k] = value;
                  }
                  else {
                      warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
                  }
              };
              if (value) {
                  doSet.id = -1;
                  queuePostRenderEffect(doSet, parentSuspense);
              }
              else {
                  doSet();
              }
          }
          else {
              warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
          }
      }
  }

  let hasMismatch = false;
  const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
  const isComment = (node) => node.nodeType === 8 /* COMMENT */;
  // Note: hydration is DOM-specific
  // But we have to place it in core due to tight coupling with core - splitting
  // it out creates a ton of unnecessary complexity.
  // Hydration also depends on some renderer internal logic which needs to be
  // passed in via arguments.
  function createHydrationFunctions(rendererInternals) {
      const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
      const hydrate = (vnode, container) => {
          if (!container.hasChildNodes()) {
              warn$1(`Attempting to hydrate existing markup but container is empty. ` +
                      `Performing full mount instead.`);
              patch(null, vnode, container);
              flushPostFlushCbs();
              container._vnode = vnode;
              return;
          }
          hasMismatch = false;
          hydrateNode(container.firstChild, vnode, null, null, null);
          flushPostFlushCbs();
          container._vnode = vnode;
          if (hasMismatch && !false) {
              // this error should show up in production
              console.error(`Hydration completed but contains mismatches.`);
          }
      };
      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
          const isFragmentStart = isComment(node) && node.data === '[';
          const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
          const { type, ref, shapeFlag, patchFlag } = vnode;
          const domType = node.nodeType;
          vnode.el = node;
          if (patchFlag === -2 /* BAIL */) {
              optimized = false;
              vnode.dynamicChildren = null;
          }
          let nextNode = null;
          switch (type) {
              case Text:
                  if (domType !== 3 /* TEXT */) {
                      // #5728 empty text node inside a slot can cause hydration failure
                      // because the server rendered HTML won't contain a text node
                      if (vnode.children === '') {
                          insert((vnode.el = createText('')), parentNode(node), node);
                          nextNode = node;
                      }
                      else {
                          nextNode = onMismatch();
                      }
                  }
                  else {
                      if (node.data !== vnode.children) {
                          hasMismatch = true;
                          warn$1(`Hydration text mismatch:` +
                                  `\n- Client: ${JSON.stringify(node.data)}` +
                                  `\n- Server: ${JSON.stringify(vnode.children)}`);
                          node.data = vnode.children;
                      }
                      nextNode = nextSibling(node);
                  }
                  break;
              case Comment:
                  if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                      nextNode = onMismatch();
                  }
                  else {
                      nextNode = nextSibling(node);
                  }
                  break;
              case Static:
                  if (domType !== 1 /* ELEMENT */ && domType !== 3 /* TEXT */) {
                      nextNode = onMismatch();
                  }
                  else {
                      // determine anchor, adopt content
                      nextNode = node;
                      // if the static vnode has its content stripped during build,
                      // adopt it from the server-rendered HTML.
                      const needToAdoptContent = !vnode.children.length;
                      for (let i = 0; i < vnode.staticCount; i++) {
                          if (needToAdoptContent)
                              vnode.children +=
                                  nextNode.nodeType === 1 /* ELEMENT */
                                      ? nextNode.outerHTML
                                      : nextNode.data;
                          if (i === vnode.staticCount - 1) {
                              vnode.anchor = nextNode;
                          }
                          nextNode = nextSibling(nextNode);
                      }
                      return nextNode;
                  }
                  break;
              case Fragment:
                  if (!isFragmentStart) {
                      nextNode = onMismatch();
                  }
                  else {
                      nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                  }
                  break;
              default:
                  if (shapeFlag & 1 /* ELEMENT */) {
                      if (domType !== 1 /* ELEMENT */ ||
                          vnode.type.toLowerCase() !==
                              node.tagName.toLowerCase()) {
                          nextNode = onMismatch();
                      }
                      else {
                          nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                      }
                  }
                  else if (shapeFlag & 6 /* COMPONENT */) {
                      // when setting up the render effect, if the initial vnode already
                      // has .el set, the component will perform hydration instead of mount
                      // on its sub-tree.
                      vnode.slotScopeIds = slotScopeIds;
                      const container = parentNode(node);
                      mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                      // component may be async, so in the case of fragments we cannot rely
                      // on component's rendered output to determine the end of the fragment
                      // instead, we do a lookahead to find the end anchor node.
                      nextNode = isFragmentStart
                          ? locateClosingAsyncAnchor(node)
                          : nextSibling(node);
                      // #4293 teleport as component root
                      if (nextNode &&
                          isComment(nextNode) &&
                          nextNode.data === 'teleport end') {
                          nextNode = nextSibling(nextNode);
                      }
                      // #3787
                      // if component is async, it may get moved / unmounted before its
                      // inner component is loaded, so we need to give it a placeholder
                      // vnode that matches its adopted DOM.
                      if (isAsyncWrapper(vnode)) {
                          let subTree;
                          if (isFragmentStart) {
                              subTree = createVNode(Fragment);
                              subTree.anchor = nextNode
                                  ? nextNode.previousSibling
                                  : container.lastChild;
                          }
                          else {
                              subTree =
                                  node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                          }
                          subTree.el = node;
                          vnode.component.subTree = subTree;
                      }
                  }
                  else if (shapeFlag & 64 /* TELEPORT */) {
                      if (domType !== 8 /* COMMENT */) {
                          nextNode = onMismatch();
                      }
                      else {
                          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                      }
                  }
                  else if (shapeFlag & 128 /* SUSPENSE */) {
                      nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                  }
                  else {
                      warn$1('Invalid HostVNode type:', type, `(${typeof type})`);
                  }
          }
          if (ref != null) {
              setRef(ref, null, parentSuspense, vnode);
          }
          return nextNode;
      };
      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!vnode.dynamicChildren;
          const { type, props, patchFlag, shapeFlag, dirs } = vnode;
          // #4006 for form elements with non-string v-model value bindings
          // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
          const forcePatchValue = (type === 'input' && dirs) || type === 'option';
          // skip props & children if this is hoisted static nodes
          // #5405 in dev, always hydrate children for HMR
          {
              if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created');
              }
              // props
              if (props) {
                  if (forcePatchValue ||
                      !optimized ||
                      patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                      for (const key in props) {
                          if ((forcePatchValue && key.endsWith('value')) ||
                              (isOn(key) && !isReservedProp(key))) {
                              patchProp(el, key, null, props[key], false, undefined, parentComponent);
                          }
                      }
                  }
                  else if (props.onClick) {
                      // Fast path for click listeners (which is most often) to avoid
                      // iterating through props.
                      patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                  }
              }
              // vnode / directive hooks
              let vnodeHooks;
              if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                  invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              }
              if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
              }
              if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                  queueEffectWithSuspense(() => {
                      vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                      dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                  }, parentSuspense);
              }
              // children
              if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                  // skip if element has innerHTML / textContent
                  !(props && (props.innerHTML || props.textContent))) {
                  let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                  let hasWarned = false;
                  while (next) {
                      hasMismatch = true;
                      if (!hasWarned) {
                          warn$1(`Hydration children mismatch in <${vnode.type}>: ` +
                              `server rendered element contains more child nodes than client vdom.`);
                          hasWarned = true;
                      }
                      // The SSRed DOM contains more nodes than it should. Remove them.
                      const cur = next;
                      next = next.nextSibling;
                      remove(cur);
                  }
              }
              else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                  if (el.textContent !== vnode.children) {
                      hasMismatch = true;
                      warn$1(`Hydration text content mismatch in <${vnode.type}>:\n` +
                              `- Client: ${el.textContent}\n` +
                              `- Server: ${vnode.children}`);
                      el.textContent = vnode.children;
                  }
              }
          }
          return el.nextSibling;
      };
      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          optimized = optimized || !!parentVNode.dynamicChildren;
          const children = parentVNode.children;
          const l = children.length;
          let hasWarned = false;
          for (let i = 0; i < l; i++) {
              const vnode = optimized
                  ? children[i]
                  : (children[i] = normalizeVNode(children[i]));
              if (node) {
                  node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
              }
              else if (vnode.type === Text && !vnode.children) {
                  continue;
              }
              else {
                  hasMismatch = true;
                  if (!hasWarned) {
                      warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                          `server rendered element contains fewer child nodes than client vdom.`);
                      hasWarned = true;
                  }
                  // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                  patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
              }
          }
          return node;
      };
      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
          const { slotScopeIds: fragmentSlotScopeIds } = vnode;
          if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds
                  ? slotScopeIds.concat(fragmentSlotScopeIds)
                  : fragmentSlotScopeIds;
          }
          const container = parentNode(node);
          const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
          if (next && isComment(next) && next.data === ']') {
              return nextSibling((vnode.anchor = next));
          }
          else {
              // fragment didn't hydrate successfully, since we didn't get a end anchor
              // back. This should have led to node/children mismatch warnings.
              hasMismatch = true;
              // since the anchor is missing, we need to create one and insert it
              insert((vnode.anchor = createComment(`]`)), container, next);
              return next;
          }
      };
      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
          hasMismatch = true;
          warn$1(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                  ? `(text)`
                  : isComment(node) && node.data === '['
                      ? `(start of fragment)`
                      : ``);
          vnode.el = null;
          if (isFragment) {
              // remove excessive fragment nodes
              const end = locateClosingAsyncAnchor(node);
              while (true) {
                  const next = nextSibling(node);
                  if (next && next !== end) {
                      remove(next);
                  }
                  else {
                      break;
                  }
              }
          }
          const next = nextSibling(node);
          const container = parentNode(node);
          remove(node);
          patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
          return next;
      };
      const locateClosingAsyncAnchor = (node) => {
          let match = 0;
          while (node) {
              node = nextSibling(node);
              if (node && isComment(node)) {
                  if (node.data === '[')
                      match++;
                  if (node.data === ']') {
                      if (match === 0) {
                          return nextSibling(node);
                      }
                      else {
                          match--;
                      }
                  }
              }
          }
          return node;
      };
      return [hydrate, hydrateNode];
  }

  /* eslint-disable no-restricted-globals */
  let supported;
  let perf;
  function startMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
          perf.mark(`vue-${type}-${instance.uid}`);
      }
      {
          devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
      }
  }
  function endMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
          const startTag = `vue-${type}-${instance.uid}`;
          const endTag = startTag + `:end`;
          perf.mark(endTag);
          perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
      }
      {
          devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
      }
  }
  function isSupported() {
      if (supported !== undefined) {
          return supported;
      }
      if (typeof window !== 'undefined' && window.performance) {
          supported = true;
          perf = window.performance;
      }
      else {
          supported = false;
      }
      return supported;
  }

  const queuePostRenderEffect = queueEffectWithSuspense
      ;
  /**
   * The createRenderer function accepts two generic arguments:
   * HostNode and HostElement, corresponding to Node and Element types in the
   * host environment. For example, for runtime-dom, HostNode would be the DOM
   * `Node` interface and HostElement would be the DOM `Element` interface.
   *
   * Custom renderers can pass in the platform specific types like this:
   *
   * ``` js
   * const { render, createApp } = createRenderer<Node, Element>({
   *   patchProp,
   *   ...nodeOps
   * })
   * ```
   */
  function createRenderer(options) {
      return baseCreateRenderer(options);
  }
  // Separate API for creating hydration-enabled renderer.
  // Hydration logic is only used when calling this function, making it
  // tree-shakable.
  function createHydrationRenderer(options) {
      return baseCreateRenderer(options, createHydrationFunctions);
  }
  // implementation
  function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      {
          setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
      }
      const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
      // Note: functions inside this closure should use `const xxx = () => {}`
      // style in order to prevent being inlined by minifiers.
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
          if (n1 === n2) {
              return;
          }
          // patching & not same type, unmount old tree
          if (n1 && !isSameVNodeType(n1, n2)) {
              anchor = getNextHostNode(n1);
              unmount(n1, parentComponent, parentSuspense, true);
              n1 = null;
          }
          if (n2.patchFlag === -2 /* BAIL */) {
              optimized = false;
              n2.dynamicChildren = null;
          }
          const { type, ref, shapeFlag } = n2;
          switch (type) {
              case Text:
                  processText(n1, n2, container, anchor);
                  break;
              case Comment:
                  processCommentNode(n1, n2, container, anchor);
                  break;
              case Static:
                  if (n1 == null) {
                      mountStaticNode(n2, container, anchor, isSVG);
                  }
                  else {
                      patchStaticNode(n1, n2, container, isSVG);
                  }
                  break;
              case Fragment:
                  processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  break;
              default:
                  if (shapeFlag & 1 /* ELEMENT */) {
                      processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
                  else if (shapeFlag & 6 /* COMPONENT */) {
                      processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
                  else if (shapeFlag & 64 /* TELEPORT */) {
                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                  }
                  else if (shapeFlag & 128 /* SUSPENSE */) {
                      type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                  }
                  else {
                      warn$1('Invalid VNode type:', type, `(${typeof type})`);
                  }
          }
          // set ref
          if (ref != null && parentComponent) {
              setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
          }
      };
      const processText = (n1, n2, container, anchor) => {
          if (n1 == null) {
              hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
          }
          else {
              const el = (n2.el = n1.el);
              if (n2.children !== n1.children) {
                  hostSetText(el, n2.children);
              }
          }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
          if (n1 == null) {
              hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
          }
          else {
              // there's no support for dynamic comments
              n2.el = n1.el;
          }
      };
      const mountStaticNode = (n2, container, anchor, isSVG) => {
          [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
      };
      /**
       * Dev / HMR only
       */
      const patchStaticNode = (n1, n2, container, isSVG) => {
          // static nodes are only patched during dev for HMR
          if (n2.children !== n1.children) {
              const anchor = hostNextSibling(n1.anchor);
              // remove existing
              removeStaticNode(n1);
              [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
          }
          else {
              n2.el = n1.el;
              n2.anchor = n1.anchor;
          }
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
          let next;
          while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostInsert(el, container, nextSibling);
              el = next;
          }
          hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
          let next;
          while (el && el !== anchor) {
              next = hostNextSibling(el);
              hostRemove(el);
              el = next;
          }
          hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          isSVG = isSVG || n2.type === 'svg';
          if (n1 == null) {
              mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
          else {
              patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let el;
          let vnodeHook;
          const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
          {
              el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
              // mount children first, since some props may rely on child content
              // being already rendered, e.g. `<select value>`
              if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                  hostSetElementText(el, vnode.children);
              }
              else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
              }
              if (dirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'created');
              }
              // props
              if (props) {
                  for (const key in props) {
                      if (key !== 'value' && !isReservedProp(key)) {
                          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                      }
                  }
                  /**
                   * Special case for setting value on DOM elements:
                   * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                   * - it needs to be forced (#1471)
                   * #2353 proposes adding another renderer option to configure this, but
                   * the properties affects are so finite it is worth special casing it
                   * here to reduce the complexity. (Special casing it also should not
                   * affect non-DOM renderers)
                   */
                  if ('value' in props) {
                      hostPatchProp(el, 'value', null, props.value);
                  }
                  if ((vnodeHook = props.onVnodeBeforeMount)) {
                      invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  }
              }
              // scopeId
              setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
          }
          {
              Object.defineProperty(el, '__vnode', {
                  value: vnode,
                  enumerable: false
              });
              Object.defineProperty(el, '__vueParentComponent', {
                  value: parentComponent,
                  enumerable: false
              });
          }
          if (dirs) {
              invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
          }
          // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
          // #1689 For inside suspense + suspense resolved case, just call it
          const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
              transition &&
              !transition.persisted;
          if (needCallTransitionHooks) {
              transition.beforeEnter(el);
          }
          hostInsert(el, container, anchor);
          if ((vnodeHook = props && props.onVnodeMounted) ||
              needCallTransitionHooks ||
              dirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  needCallTransitionHooks && transition.enter(el);
                  dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
              }, parentSuspense);
          }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
          if (scopeId) {
              hostSetScopeId(el, scopeId);
          }
          if (slotScopeIds) {
              for (let i = 0; i < slotScopeIds.length; i++) {
                  hostSetScopeId(el, slotScopeIds[i]);
              }
          }
          if (parentComponent) {
              let subTree = parentComponent.subTree;
              if (subTree.patchFlag > 0 &&
                  subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                  subTree =
                      filterSingleRoot(subTree.children) || subTree;
              }
              if (vnode === subTree) {
                  const parentVNode = parentComponent.vnode;
                  setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
              }
          }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
          for (let i = start; i < children.length; i++) {
              const child = (children[i] = optimized
                  ? cloneIfMounted(children[i])
                  : normalizeVNode(children[i]));
              patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const el = (n2.el = n1.el);
          let { patchFlag, dynamicChildren, dirs } = n2;
          // #1426 take the old vnode's patch flag into account since user may clone a
          // compiler-generated vnode, which de-opts to FULL_PROPS
          patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
          const oldProps = n1.props || EMPTY_OBJ;
          const newProps = n2.props || EMPTY_OBJ;
          let vnodeHook;
          // disable recurse in beforeUpdate hooks
          parentComponent && toggleRecurse(parentComponent, false);
          if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
              invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          }
          if (dirs) {
              invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
          }
          parentComponent && toggleRecurse(parentComponent, true);
          if (isHmrUpdating) {
              // HMR updated, force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
          }
          const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
          if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
              if (parentComponent && parentComponent.type.__hmrId) {
                  traverseStaticChildren(n1, n2);
              }
          }
          else if (!optimized) {
              // full diff
              patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
          }
          if (patchFlag > 0) {
              // the presence of a patchFlag means this element's render code was
              // generated by the compiler and can take the fast path.
              // in this path old node and new node are guaranteed to have the same shape
              // (i.e. at the exact same position in the source template)
              if (patchFlag & 16 /* FULL_PROPS */) {
                  // element props contain dynamic keys, full diff needed
                  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
              }
              else {
                  // class
                  // this flag is matched when the element has dynamic class bindings.
                  if (patchFlag & 2 /* CLASS */) {
                      if (oldProps.class !== newProps.class) {
                          hostPatchProp(el, 'class', null, newProps.class, isSVG);
                      }
                  }
                  // style
                  // this flag is matched when the element has dynamic style bindings
                  if (patchFlag & 4 /* STYLE */) {
                      hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                  }
                  // props
                  // This flag is matched when the element has dynamic prop/attr bindings
                  // other than class and style. The keys of dynamic prop/attrs are saved for
                  // faster iteration.
                  // Note dynamic keys like :[foo]="bar" will cause this optimization to
                  // bail out and go through a full diff because we need to unset the old key
                  if (patchFlag & 8 /* PROPS */) {
                      // if the flag is present then dynamicProps must be non-null
                      const propsToUpdate = n2.dynamicProps;
                      for (let i = 0; i < propsToUpdate.length; i++) {
                          const key = propsToUpdate[i];
                          const prev = oldProps[key];
                          const next = newProps[key];
                          // #1471 force patch value
                          if (next !== prev || key === 'value') {
                              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                          }
                      }
                  }
              }
              // text
              // This flag is matched when the element has only dynamic text children.
              if (patchFlag & 1 /* TEXT */) {
                  if (n1.children !== n2.children) {
                      hostSetElementText(el, n2.children);
                  }
              }
          }
          else if (!optimized && dynamicChildren == null) {
              // unoptimized, full diff
              patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
          }
          if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                  dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
              }, parentSuspense);
          }
      };
      // The fast path for blocks.
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
          for (let i = 0; i < newChildren.length; i++) {
              const oldVNode = oldChildren[i];
              const newVNode = newChildren[i];
              // Determine the container (parent element) for the patch.
              const container = 
              // oldVNode may be an errored async setup() component inside Suspense
              // which will not have a mounted element
              oldVNode.el &&
                  // - In the case of a Fragment, we need to provide the actual parent
                  // of the Fragment itself so it can move its children.
                  (oldVNode.type === Fragment ||
                      // - In the case of different nodes, there is going to be a replacement
                      // which also requires the correct parent container
                      !isSameVNodeType(oldVNode, newVNode) ||
                      // - In the case of a component, it could contain anything.
                      oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                  ? hostParentNode(oldVNode.el)
                  : // In other cases, the parent container is not actually used so we
                      // just pass the block element here to avoid a DOM parentNode call.
                      fallbackContainer;
              patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
          }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
          if (oldProps !== newProps) {
              for (const key in newProps) {
                  // empty string is not valid prop
                  if (isReservedProp(key))
                      continue;
                  const next = newProps[key];
                  const prev = oldProps[key];
                  // defer patching value
                  if (next !== prev && key !== 'value') {
                      hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                  }
              }
              if (oldProps !== EMPTY_OBJ) {
                  for (const key in oldProps) {
                      if (!isReservedProp(key) && !(key in newProps)) {
                          hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                      }
                  }
              }
              if ('value' in newProps) {
                  hostPatchProp(el, 'value', oldProps.value, newProps.value);
              }
          }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
          const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
          let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
          if (// #5523 dev root fragment may inherit directives
              (isHmrUpdating || patchFlag & 2048 /* DEV_ROOT_FRAGMENT */)) {
              // HMR updated / Dev root fragment (w/ comments), force full diff
              patchFlag = 0;
              optimized = false;
              dynamicChildren = null;
          }
          // check if this is a slot fragment with :slotted scope ids
          if (fragmentSlotScopeIds) {
              slotScopeIds = slotScopeIds
                  ? slotScopeIds.concat(fragmentSlotScopeIds)
                  : fragmentSlotScopeIds;
          }
          if (n1 == null) {
              hostInsert(fragmentStartAnchor, container, anchor);
              hostInsert(fragmentEndAnchor, container, anchor);
              // a fragment can only have array children
              // since they are either generated by the compiler, or implicitly created
              // from arrays.
              mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
          else {
              if (patchFlag > 0 &&
                  patchFlag & 64 /* STABLE_FRAGMENT */ &&
                  dynamicChildren &&
                  // #2715 the previous fragment could've been a BAILed one as a result
                  // of renderSlot() with no valid children
                  n1.dynamicChildren) {
                  // a stable fragment (template root or <template v-for>) doesn't need to
                  // patch children order, but it may contain dynamicChildren.
                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                  if (parentComponent && parentComponent.type.__hmrId) {
                      traverseStaticChildren(n1, n2);
                  }
                  else if (
                  // #2080 if the stable fragment has a key, it's a <template v-for> that may
                  //  get moved around. Make sure all root level vnodes inherit el.
                  // #2134 or if it's a component root, it may also get moved around
                  // as the component is being moved.
                  n2.key != null ||
                      (parentComponent && n2 === parentComponent.subTree)) {
                      traverseStaticChildren(n1, n2, true /* shallow */);
                  }
              }
              else {
                  // keyed / unkeyed, or manual fragments.
                  // for keyed & unkeyed, since they are compiler generated from v-for,
                  // each child is guaranteed to be a block so the fragment will never
                  // have dynamicChildren.
                  patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
          }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          n2.slotScopeIds = slotScopeIds;
          if (n1 == null) {
              if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                  parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
              }
              else {
                  mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
              }
          }
          else {
              updateComponent(n1, n2, optimized);
          }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
          const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
          if (instance.type.__hmrId) {
              registerHMR(instance);
          }
          {
              pushWarningContext(initialVNode);
              startMeasure(instance, `mount`);
          }
          // inject renderer internals for keepAlive
          if (isKeepAlive(initialVNode)) {
              instance.ctx.renderer = internals;
          }
          // resolve props and slots for setup context
          {
              {
                  startMeasure(instance, `init`);
              }
              setupComponent(instance);
              {
                  endMeasure(instance, `init`);
              }
          }
          // setup() is async. This component relies on async logic to be resolved
          // before proceeding
          if (instance.asyncDep) {
              parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
              // Give it a placeholder if this is not hydration
              // TODO handle self-defined fallback
              if (!initialVNode.el) {
                  const placeholder = (instance.subTree = createVNode(Comment));
                  processCommentNode(null, placeholder, container, anchor);
              }
              return;
          }
          setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
          {
              popWarningContext();
              endMeasure(instance, `mount`);
          }
      };
      const updateComponent = (n1, n2, optimized) => {
          const instance = (n2.component = n1.component);
          if (shouldUpdateComponent(n1, n2, optimized)) {
              if (instance.asyncDep &&
                  !instance.asyncResolved) {
                  // async & still pending - just update props and slots
                  // since the component's reactive effect for render isn't set-up yet
                  {
                      pushWarningContext(n2);
                  }
                  updateComponentPreRender(instance, n2, optimized);
                  {
                      popWarningContext();
                  }
                  return;
              }
              else {
                  // normal update
                  instance.next = n2;
                  // in case the child component is also queued, remove it to avoid
                  // double updating the same child component in the same flush.
                  invalidateJob(instance.update);
                  // instance.update is the reactive effect.
                  instance.update();
              }
          }
          else {
              // no update needed. just copy over properties
              n2.el = n1.el;
              instance.vnode = n2;
          }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
          const componentUpdateFn = () => {
              if (!instance.isMounted) {
                  let vnodeHook;
                  const { el, props } = initialVNode;
                  const { bm, m, parent } = instance;
                  const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                  toggleRecurse(instance, false);
                  // beforeMount hook
                  if (bm) {
                      invokeArrayFns(bm);
                  }
                  // onVnodeBeforeMount
                  if (!isAsyncWrapperVNode &&
                      (vnodeHook = props && props.onVnodeBeforeMount)) {
                      invokeVNodeHook(vnodeHook, parent, initialVNode);
                  }
                  toggleRecurse(instance, true);
                  if (el && hydrateNode) {
                      // vnode has adopted host node - perform hydration instead of mount.
                      const hydrateSubTree = () => {
                          {
                              startMeasure(instance, `render`);
                          }
                          instance.subTree = renderComponentRoot(instance);
                          {
                              endMeasure(instance, `render`);
                          }
                          {
                              startMeasure(instance, `hydrate`);
                          }
                          hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                          {
                              endMeasure(instance, `hydrate`);
                          }
                      };
                      if (isAsyncWrapperVNode) {
                          initialVNode.type.__asyncLoader().then(
                          // note: we are moving the render call into an async callback,
                          // which means it won't track dependencies - but it's ok because
                          // a server-rendered async wrapper is already in resolved state
                          // and it will never need to change.
                          () => !instance.isUnmounted && hydrateSubTree());
                      }
                      else {
                          hydrateSubTree();
                      }
                  }
                  else {
                      {
                          startMeasure(instance, `render`);
                      }
                      const subTree = (instance.subTree = renderComponentRoot(instance));
                      {
                          endMeasure(instance, `render`);
                      }
                      {
                          startMeasure(instance, `patch`);
                      }
                      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                      {
                          endMeasure(instance, `patch`);
                      }
                      initialVNode.el = subTree.el;
                  }
                  // mounted hook
                  if (m) {
                      queuePostRenderEffect(m, parentSuspense);
                  }
                  // onVnodeMounted
                  if (!isAsyncWrapperVNode &&
                      (vnodeHook = props && props.onVnodeMounted)) {
                      const scopedInitialVNode = initialVNode;
                      queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                  }
                  // activated hook for keep-alive roots.
                  // #1742 activated hook must be accessed after first render
                  // since the hook may be injected by a child keep-alive
                  if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||
                      (parent &&
                          isAsyncWrapper(parent.vnode) &&
                          parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {
                      instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                  }
                  instance.isMounted = true;
                  {
                      devtoolsComponentAdded(instance);
                  }
                  // #2458: deference mount-only object parameters to prevent memleaks
                  initialVNode = container = anchor = null;
              }
              else {
                  // updateComponent
                  // This is triggered by mutation of component's own state (next: null)
                  // OR parent calling processComponent (next: VNode)
                  let { next, bu, u, parent, vnode } = instance;
                  let originNext = next;
                  let vnodeHook;
                  {
                      pushWarningContext(next || instance.vnode);
                  }
                  // Disallow component effect recursion during pre-lifecycle hooks.
                  toggleRecurse(instance, false);
                  if (next) {
                      next.el = vnode.el;
                      updateComponentPreRender(instance, next, optimized);
                  }
                  else {
                      next = vnode;
                  }
                  // beforeUpdate hook
                  if (bu) {
                      invokeArrayFns(bu);
                  }
                  // onVnodeBeforeUpdate
                  if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                      invokeVNodeHook(vnodeHook, parent, next, vnode);
                  }
                  toggleRecurse(instance, true);
                  // render
                  {
                      startMeasure(instance, `render`);
                  }
                  const nextTree = renderComponentRoot(instance);
                  {
                      endMeasure(instance, `render`);
                  }
                  const prevTree = instance.subTree;
                  instance.subTree = nextTree;
                  {
                      startMeasure(instance, `patch`);
                  }
                  patch(prevTree, nextTree, 
                  // parent may have changed if it's in a teleport
                  hostParentNode(prevTree.el), 
                  // anchor may have changed if it's in a fragment
                  getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                  {
                      endMeasure(instance, `patch`);
                  }
                  next.el = nextTree.el;
                  if (originNext === null) {
                      // self-triggered update. In case of HOC, update parent component
                      // vnode el. HOC is indicated by parent instance's subTree pointing
                      // to child component's vnode
                      updateHOCHostEl(instance, nextTree.el);
                  }
                  // updated hook
                  if (u) {
                      queuePostRenderEffect(u, parentSuspense);
                  }
                  // onVnodeUpdated
                  if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                      queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                  }
                  {
                      devtoolsComponentUpdated(instance);
                  }
                  {
                      popWarningContext();
                  }
              }
          };
          // create reactive effect for rendering
          const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope
          ));
          const update = (instance.update = () => effect.run());
          update.id = instance.uid;
          // allowRecurse
          // #1801, #2043 component render effects should allow recursive updates
          toggleRecurse(instance, true);
          {
              effect.onTrack = instance.rtc
                  ? e => invokeArrayFns(instance.rtc, e)
                  : void 0;
              effect.onTrigger = instance.rtg
                  ? e => invokeArrayFns(instance.rtg, e)
                  : void 0;
              update.ownerInstance = instance;
          }
          update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
          nextVNode.component = instance;
          const prevProps = instance.vnode.props;
          instance.vnode = nextVNode;
          instance.next = null;
          updateProps(instance, nextVNode.props, prevProps, optimized);
          updateSlots(instance, nextVNode.children, optimized);
          pauseTracking();
          // props update may have triggered pre-flush watchers.
          // flush them before the render update.
          flushPreFlushCbs(undefined, instance.update);
          resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
          const c1 = n1 && n1.children;
          const prevShapeFlag = n1 ? n1.shapeFlag : 0;
          const c2 = n2.children;
          const { patchFlag, shapeFlag } = n2;
          // fast path
          if (patchFlag > 0) {
              if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                  // this could be either fully-keyed or mixed (some keyed some not)
                  // presence of patchFlag means children are guaranteed to be arrays
                  patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  return;
              }
              else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                  // unkeyed
                  patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  return;
              }
          }
          // children has 3 possibilities: text, array or no children.
          if (shapeFlag & 8 /* TEXT_CHILDREN */) {
              // text children fast path
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  unmountChildren(c1, parentComponent, parentSuspense);
              }
              if (c2 !== c1) {
                  hostSetElementText(container, c2);
              }
          }
          else {
              if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                  // prev children was array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                      // two arrays, cannot assume anything, do full diff
                      patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
                  else {
                      // no new children, just unmount old
                      unmountChildren(c1, parentComponent, parentSuspense, true);
                  }
              }
              else {
                  // prev children was text OR null
                  // new children is array OR null
                  if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                      hostSetElementText(container, '');
                  }
                  // mount new if array
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
              }
          }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          c1 = c1 || EMPTY_ARR;
          c2 = c2 || EMPTY_ARR;
          const oldLength = c1.length;
          const newLength = c2.length;
          const commonLength = Math.min(oldLength, newLength);
          let i;
          for (i = 0; i < commonLength; i++) {
              const nextChild = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]));
              patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
          if (oldLength > newLength) {
              // remove old
              unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
          }
          else {
              // mount new
              mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
          }
      };
      // can be all-keyed or mixed
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
          let i = 0;
          const l2 = c2.length;
          let e1 = c1.length - 1; // prev ending index
          let e2 = l2 - 1; // next ending index
          // 1. sync from start
          // (a b) c
          // (a b) d e
          while (i <= e1 && i <= e2) {
              const n1 = c1[i];
              const n2 = (c2[i] = optimized
                  ? cloneIfMounted(c2[i])
                  : normalizeVNode(c2[i]));
              if (isSameVNodeType(n1, n2)) {
                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
              else {
                  break;
              }
              i++;
          }
          // 2. sync from end
          // a (b c)
          // d e (b c)
          while (i <= e1 && i <= e2) {
              const n1 = c1[e1];
              const n2 = (c2[e2] = optimized
                  ? cloneIfMounted(c2[e2])
                  : normalizeVNode(c2[e2]));
              if (isSameVNodeType(n1, n2)) {
                  patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
              else {
                  break;
              }
              e1--;
              e2--;
          }
          // 3. common sequence + mount
          // (a b)
          // (a b) c
          // i = 2, e1 = 1, e2 = 2
          // (a b)
          // c (a b)
          // i = 0, e1 = -1, e2 = 0
          if (i > e1) {
              if (i <= e2) {
                  const nextPos = e2 + 1;
                  const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                  while (i <= e2) {
                      patch(null, (c2[i] = optimized
                          ? cloneIfMounted(c2[i])
                          : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                      i++;
                  }
              }
          }
          // 4. common sequence + unmount
          // (a b) c
          // (a b)
          // i = 2, e1 = 2, e2 = 1
          // a (b c)
          // (b c)
          // i = 0, e1 = 0, e2 = -1
          else if (i > e2) {
              while (i <= e1) {
                  unmount(c1[i], parentComponent, parentSuspense, true);
                  i++;
              }
          }
          // 5. unknown sequence
          // [i ... e1 + 1]: a b [c d e] f g
          // [i ... e2 + 1]: a b [e d c h] f g
          // i = 2, e1 = 4, e2 = 5
          else {
              const s1 = i; // prev starting index
              const s2 = i; // next starting index
              // 5.1 build key:index map for newChildren
              const keyToNewIndexMap = new Map();
              for (i = s2; i <= e2; i++) {
                  const nextChild = (c2[i] = optimized
                      ? cloneIfMounted(c2[i])
                      : normalizeVNode(c2[i]));
                  if (nextChild.key != null) {
                      if (keyToNewIndexMap.has(nextChild.key)) {
                          warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                      }
                      keyToNewIndexMap.set(nextChild.key, i);
                  }
              }
              // 5.2 loop through old children left to be patched and try to patch
              // matching nodes & remove nodes that are no longer present
              let j;
              let patched = 0;
              const toBePatched = e2 - s2 + 1;
              let moved = false;
              // used to track whether any node has moved
              let maxNewIndexSoFar = 0;
              // works as Map<newIndex, oldIndex>
              // Note that oldIndex is offset by +1
              // and oldIndex = 0 is a special value indicating the new node has
              // no corresponding old node.
              // used for determining longest stable subsequence
              const newIndexToOldIndexMap = new Array(toBePatched);
              for (i = 0; i < toBePatched; i++)
                  newIndexToOldIndexMap[i] = 0;
              for (i = s1; i <= e1; i++) {
                  const prevChild = c1[i];
                  if (patched >= toBePatched) {
                      // all new children have been patched so this can only be a removal
                      unmount(prevChild, parentComponent, parentSuspense, true);
                      continue;
                  }
                  let newIndex;
                  if (prevChild.key != null) {
                      newIndex = keyToNewIndexMap.get(prevChild.key);
                  }
                  else {
                      // key-less node, try to locate a key-less node of the same type
                      for (j = s2; j <= e2; j++) {
                          if (newIndexToOldIndexMap[j - s2] === 0 &&
                              isSameVNodeType(prevChild, c2[j])) {
                              newIndex = j;
                              break;
                          }
                      }
                  }
                  if (newIndex === undefined) {
                      unmount(prevChild, parentComponent, parentSuspense, true);
                  }
                  else {
                      newIndexToOldIndexMap[newIndex - s2] = i + 1;
                      if (newIndex >= maxNewIndexSoFar) {
                          maxNewIndexSoFar = newIndex;
                      }
                      else {
                          moved = true;
                      }
                      patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                      patched++;
                  }
              }
              // 5.3 move and mount
              // generate longest stable subsequence only when nodes have moved
              const increasingNewIndexSequence = moved
                  ? getSequence(newIndexToOldIndexMap)
                  : EMPTY_ARR;
              j = increasingNewIndexSequence.length - 1;
              // looping backwards so that we can use last patched node as anchor
              for (i = toBePatched - 1; i >= 0; i--) {
                  const nextIndex = s2 + i;
                  const nextChild = c2[nextIndex];
                  const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                  if (newIndexToOldIndexMap[i] === 0) {
                      // mount new
                      patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
                  else if (moved) {
                      // move if:
                      // There is no stable subsequence (e.g. a reverse)
                      // OR current node is not among the stable sequence
                      if (j < 0 || i !== increasingNewIndexSequence[j]) {
                          move(nextChild, container, anchor, 2 /* REORDER */);
                      }
                      else {
                          j--;
                      }
                  }
              }
          }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
          const { el, type, transition, children, shapeFlag } = vnode;
          if (shapeFlag & 6 /* COMPONENT */) {
              move(vnode.component.subTree, container, anchor, moveType);
              return;
          }
          if (shapeFlag & 128 /* SUSPENSE */) {
              vnode.suspense.move(container, anchor, moveType);
              return;
          }
          if (shapeFlag & 64 /* TELEPORT */) {
              type.move(vnode, container, anchor, internals);
              return;
          }
          if (type === Fragment) {
              hostInsert(el, container, anchor);
              for (let i = 0; i < children.length; i++) {
                  move(children[i], container, anchor, moveType);
              }
              hostInsert(vnode.anchor, container, anchor);
              return;
          }
          if (type === Static) {
              moveStaticNode(vnode, container, anchor);
              return;
          }
          // single nodes
          const needTransition = moveType !== 2 /* REORDER */ &&
              shapeFlag & 1 /* ELEMENT */ &&
              transition;
          if (needTransition) {
              if (moveType === 0 /* ENTER */) {
                  transition.beforeEnter(el);
                  hostInsert(el, container, anchor);
                  queuePostRenderEffect(() => transition.enter(el), parentSuspense);
              }
              else {
                  const { leave, delayLeave, afterLeave } = transition;
                  const remove = () => hostInsert(el, container, anchor);
                  const performLeave = () => {
                      leave(el, () => {
                          remove();
                          afterLeave && afterLeave();
                      });
                  };
                  if (delayLeave) {
                      delayLeave(el, remove, performLeave);
                  }
                  else {
                      performLeave();
                  }
              }
          }
          else {
              hostInsert(el, container, anchor);
          }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
          const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
          // unset ref
          if (ref != null) {
              setRef(ref, null, parentSuspense, vnode, true);
          }
          if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
              parentComponent.ctx.deactivate(vnode);
              return;
          }
          const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
          const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
          let vnodeHook;
          if (shouldInvokeVnodeHook &&
              (vnodeHook = props && props.onVnodeBeforeUnmount)) {
              invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
          if (shapeFlag & 6 /* COMPONENT */) {
              unmountComponent(vnode.component, parentSuspense, doRemove);
          }
          else {
              if (shapeFlag & 128 /* SUSPENSE */) {
                  vnode.suspense.unmount(parentSuspense, doRemove);
                  return;
              }
              if (shouldInvokeDirs) {
                  invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
              }
              if (shapeFlag & 64 /* TELEPORT */) {
                  vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
              }
              else if (dynamicChildren &&
                  // #1153: fast path should not be taken for non-stable (v-for) fragments
                  (type !== Fragment ||
                      (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                  // fast path for block nodes: only need to unmount dynamic children.
                  unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
              }
              else if ((type === Fragment &&
                  patchFlag &
                      (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                  (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                  unmountChildren(children, parentComponent, parentSuspense);
              }
              if (doRemove) {
                  remove(vnode);
              }
          }
          if ((shouldInvokeVnodeHook &&
              (vnodeHook = props && props.onVnodeUnmounted)) ||
              shouldInvokeDirs) {
              queuePostRenderEffect(() => {
                  vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                  shouldInvokeDirs &&
                      invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
              }, parentSuspense);
          }
      };
      const remove = vnode => {
          const { type, el, anchor, transition } = vnode;
          if (type === Fragment) {
              if (vnode.patchFlag > 0 &&
                  vnode.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ &&
                  transition &&
                  !transition.persisted) {
                  vnode.children.forEach(child => {
                      if (child.type === Comment) {
                          hostRemove(child.el);
                      }
                      else {
                          remove(child);
                      }
                  });
              }
              else {
                  removeFragment(el, anchor);
              }
              return;
          }
          if (type === Static) {
              removeStaticNode(vnode);
              return;
          }
          const performRemove = () => {
              hostRemove(el);
              if (transition && !transition.persisted && transition.afterLeave) {
                  transition.afterLeave();
              }
          };
          if (vnode.shapeFlag & 1 /* ELEMENT */ &&
              transition &&
              !transition.persisted) {
              const { leave, delayLeave } = transition;
              const performLeave = () => leave(el, performRemove);
              if (delayLeave) {
                  delayLeave(vnode.el, performRemove, performLeave);
              }
              else {
                  performLeave();
              }
          }
          else {
              performRemove();
          }
      };
      const removeFragment = (cur, end) => {
          // For fragments, directly remove all contained DOM nodes.
          // (fragment child nodes cannot have transition)
          let next;
          while (cur !== end) {
              next = hostNextSibling(cur);
              hostRemove(cur);
              cur = next;
          }
          hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
          if (instance.type.__hmrId) {
              unregisterHMR(instance);
          }
          const { bum, scope, update, subTree, um } = instance;
          // beforeUnmount hook
          if (bum) {
              invokeArrayFns(bum);
          }
          // stop effects in component scope
          scope.stop();
          // update may be null if a component is unmounted before its async
          // setup has resolved.
          if (update) {
              // so that scheduler will no longer invoke it
              update.active = false;
              unmount(subTree, instance, parentSuspense, doRemove);
          }
          // unmounted hook
          if (um) {
              queuePostRenderEffect(um, parentSuspense);
          }
          queuePostRenderEffect(() => {
              instance.isUnmounted = true;
          }, parentSuspense);
          // A component with async dep inside a pending suspense is unmounted before
          // its async dep resolves. This should remove the dep from the suspense, and
          // cause the suspense to resolve immediately if that was the last dep.
          if (parentSuspense &&
              parentSuspense.pendingBranch &&
              !parentSuspense.isUnmounted &&
              instance.asyncDep &&
              !instance.asyncResolved &&
              instance.suspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0) {
                  parentSuspense.resolve();
              }
          }
          {
              devtoolsComponentRemoved(instance);
          }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
          for (let i = start; i < children.length; i++) {
              unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
          }
      };
      const getNextHostNode = vnode => {
          if (vnode.shapeFlag & 6 /* COMPONENT */) {
              return getNextHostNode(vnode.component.subTree);
          }
          if (vnode.shapeFlag & 128 /* SUSPENSE */) {
              return vnode.suspense.next();
          }
          return hostNextSibling((vnode.anchor || vnode.el));
      };
      const render = (vnode, container, isSVG) => {
          if (vnode == null) {
              if (container._vnode) {
                  unmount(container._vnode, null, null, true);
              }
          }
          else {
              patch(container._vnode || null, vnode, container, null, null, null, isSVG);
          }
          flushPostFlushCbs();
          container._vnode = vnode;
      };
      const internals = {
          p: patch,
          um: unmount,
          m: move,
          r: remove,
          mt: mountComponent,
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          n: getNextHostNode,
          o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
          [hydrate, hydrateNode] = createHydrationFns(internals);
      }
      return {
          render,
          hydrate,
          createApp: createAppAPI(render, hydrate)
      };
  }
  function toggleRecurse({ effect, update }, allowed) {
      effect.allowRecurse = update.allowRecurse = allowed;
  }
  /**
   * #1156
   * When a component is HMR-enabled, we need to make sure that all static nodes
   * inside a block also inherit the DOM element from the previous tree so that
   * HMR updates (which are full updates) can retrieve the element for patching.
   *
   * #2080
   * Inside keyed `template` fragment static children, if a fragment is moved,
   * the children will always be moved. Therefore, in order to ensure correct move
   * position, el should be inherited from previous nodes.
   */
  function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray(ch1) && isArray(ch2)) {
          for (let i = 0; i < ch1.length; i++) {
              // this is only called in the optimized path so array children are
              // guaranteed to be vnodes
              const c1 = ch1[i];
              let c2 = ch2[i];
              if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                  if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                      c2 = ch2[i] = cloneIfMounted(ch2[i]);
                      c2.el = c1.el;
                  }
                  if (!shallow)
                      traverseStaticChildren(c1, c2);
              }
              // also inherit for comment nodes, but not placeholders (e.g. v-if which
              // would have received .el during block patch)
              if (c2.type === Comment && !c2.el) {
                  c2.el = c1.el;
              }
          }
      }
  }
  // https://en.wikipedia.org/wiki/Longest_increasing_subsequence
  function getSequence(arr) {
      const p = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
          const arrI = arr[i];
          if (arrI !== 0) {
              j = result[result.length - 1];
              if (arr[j] < arrI) {
                  p[i] = j;
                  result.push(i);
                  continue;
              }
              u = 0;
              v = result.length - 1;
              while (u < v) {
                  c = (u + v) >> 1;
                  if (arr[result[c]] < arrI) {
                      u = c + 1;
                  }
                  else {
                      v = c;
                  }
              }
              if (arrI < arr[result[u]]) {
                  if (u > 0) {
                      p[i] = result[u - 1];
                  }
                  result[u] = i;
              }
          }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
          result[u] = v;
          v = p[v];
      }
      return result;
  }

  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
  const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
  const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString(targetSelector)) {
          if (!select) {
              warn$1(`Current renderer does not support string target for Teleports. ` +
                      `(missing querySelector renderer option)`);
              return null;
          }
          else {
              const target = select(targetSelector);
              if (!target) {
                  warn$1(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                          `Note the target element must exist before the component is mounted - ` +
                          `i.e. the target cannot be rendered by the component itself, and ` +
                          `ideally should be outside of the entire Vue component tree.`);
              }
              return target;
          }
      }
      else {
          if (!targetSelector && !isTeleportDisabled(props)) {
              warn$1(`Invalid Teleport target: ${targetSelector}`);
          }
          return targetSelector;
      }
  };
  const TeleportImpl = {
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          // #3302
          // HMR updated, force full diff
          if (isHmrUpdating) {
              optimized = false;
              dynamicChildren = null;
          }
          if (n1 == null) {
              // insert anchors in the main view
              const placeholder = (n2.el = createComment('teleport start')
                  );
              const mainAnchor = (n2.anchor = createComment('teleport end')
                  );
              insert(placeholder, container, anchor);
              insert(mainAnchor, container, anchor);
              const target = (n2.target = resolveTarget(n2.props, querySelector));
              const targetAnchor = (n2.targetAnchor = createText(''));
              if (target) {
                  insert(targetAnchor, target);
                  // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                  isSVG = isSVG || isTargetSVG(target);
              }
              else if (!disabled) {
                  warn$1('Invalid Teleport target on mount:', target, `(${typeof target})`);
              }
              const mount = (container, anchor) => {
                  // Teleport *always* has Array children. This is enforced in both the
                  // compiler and vnode children normalization.
                  if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                      mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                  }
              };
              if (disabled) {
                  mount(container, mainAnchor);
              }
              else if (target) {
                  mount(target, targetAnchor);
              }
          }
          else {
              // update content
              n2.el = n1.el;
              const mainAnchor = (n2.anchor = n1.anchor);
              const target = (n2.target = n1.target);
              const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
              const wasDisabled = isTeleportDisabled(n1.props);
              const currentContainer = wasDisabled ? container : target;
              const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
              isSVG = isSVG || isTargetSVG(target);
              if (dynamicChildren) {
                  // fast path when the teleport happens to be a block root
                  patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                  // even in block tree mode we need to make sure all root-level nodes
                  // in the teleport inherit previous DOM references so that they can
                  // be moved in future patches.
                  traverseStaticChildren(n1, n2, true);
              }
              else if (!optimized) {
                  patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
              }
              if (disabled) {
                  if (!wasDisabled) {
                      // enabled -> disabled
                      // move into main container
                      moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                  }
              }
              else {
                  // target changed
                  if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                      const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                      if (nextTarget) {
                          moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                      }
                      else {
                          warn$1('Invalid Teleport target on update:', target, `(${typeof target})`);
                      }
                  }
                  else if (wasDisabled) {
                      // disabled -> enabled
                      // move into teleport target
                      moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                  }
              }
          }
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
          if (target) {
              hostRemove(targetAnchor);
          }
          // an unmounted teleport should always remove its children if not disabled
          if (doRemove || !isTeleportDisabled(props)) {
              hostRemove(anchor);
              if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                  for (let i = 0; i < children.length; i++) {
                      const child = children[i];
                      unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                  }
              }
          }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
      // move target anchor if this is a target change.
      if (moveType === 0 /* TARGET_CHANGE */) {
          insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2 /* REORDER */;
      // move main view anchor if this is a re-order.
      if (isReorder) {
          insert(el, container, parentAnchor);
      }
      // if this is a re-order and teleport is enabled (content is in target)
      // do not move children. So the opposite is: only move children if this
      // is not a reorder, or the teleport is disabled
      if (!isReorder || isTeleportDisabled(props)) {
          // Teleport has either Array children or no children.
          if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
              for (let i = 0; i < children.length; i++) {
                  move(children[i], container, parentAnchor, 2 /* REORDER */);
              }
          }
      }
      // move main view anchor if this is a re-order.
      if (isReorder) {
          insert(anchor, container, parentAnchor);
      }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
      const target = (vnode.target = resolveTarget(vnode.props, querySelector));
      if (target) {
          // if multiple teleports rendered to the same target element, we need to
          // pick up from where the last teleport finished instead of the first node
          const targetNode = target._lpa || target.firstChild;
          if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
              if (isTeleportDisabled(vnode.props)) {
                  vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                  vnode.targetAnchor = targetNode;
              }
              else {
                  vnode.anchor = nextSibling(node);
                  // lookahead until we find the target anchor
                  // we cannot rely on return value of hydrateChildren() because there
                  // could be nested teleports
                  let targetAnchor = targetNode;
                  while (targetAnchor) {
                      targetAnchor = nextSibling(targetAnchor);
                      if (targetAnchor &&
                          targetAnchor.nodeType === 8 &&
                          targetAnchor.data === 'teleport anchor') {
                          vnode.targetAnchor = targetAnchor;
                          target._lpa =
                              vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                          break;
                      }
                  }
                  hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
              }
          }
      }
      return vnode.anchor && nextSibling(vnode.anchor);
  }
  // Force-casted public typing for h and TSX props inference
  const Teleport = TeleportImpl;

  const Fragment = Symbol('Fragment' );
  const Text = Symbol('Text' );
  const Comment = Symbol('Comment' );
  const Static = Symbol('Static' );
  // Since v-if and v-for are the two possible ways node structure can dynamically
  // change, once we consider v-if branches and each v-for fragment a block, we
  // can divide a template into nested blocks, and within each block the node
  // structure would be stable. This allows us to skip most children diffing
  // and only worry about the dynamic nodes (indicated by patch flags).
  const blockStack = [];
  let currentBlock = null;
  /**
   * Open a block.
   * This must be called before `createBlock`. It cannot be part of `createBlock`
   * because the children of the block are evaluated before `createBlock` itself
   * is called. The generated code typically looks like this:
   *
   * ```js
   * function render() {
   *   return (openBlock(),createBlock('div', null, [...]))
   * }
   * ```
   * disableTracking is true when creating a v-for fragment block, since a v-for
   * fragment always diffs its children.
   *
   * @private
   */
  function openBlock(disableTracking = false) {
      blockStack.push((currentBlock = disableTracking ? null : []));
  }
  function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
  }
  // Whether we should be tracking dynamic child nodes inside a block.
  // Only tracks when this value is > 0
  // We are not using a simple boolean because this value may need to be
  // incremented/decremented by nested usage of v-once (see below)
  let isBlockTreeEnabled = 1;
  /**
   * Block tracking sometimes needs to be disabled, for example during the
   * creation of a tree that needs to be cached by v-once. The compiler generates
   * code like this:
   *
   * ``` js
   * _cache[1] || (
   *   setBlockTracking(-1),
   *   _cache[1] = createVNode(...),
   *   setBlockTracking(1),
   *   _cache[1]
   * )
   * ```
   *
   * @private
   */
  function setBlockTracking(value) {
      isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
      // save current block children on the block vnode
      vnode.dynamicChildren =
          isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      // close block
      closeBlock();
      // a block is always going to be patched, so track it as a child of its
      // parent block
      if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(vnode);
      }
      return vnode;
  }
  /**
   * @private
   */
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
  }
  /**
   * Create a block root vnode. Takes the same exact arguments as `createVNode`.
   * A block root keeps track of dynamic nodes within the block in the
   * `dynamicChildren` array.
   *
   * @private
   */
  function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
  }
  function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
      if (n2.shapeFlag & 6 /* COMPONENT */ &&
          hmrDirtyComponents.has(n2.type)) {
          // HMR only: if the component has been hot-updated, force a reload.
          return false;
      }
      return n1.type === n2.type && n1.key === n2.key;
  }
  let vnodeArgsTransformer;
  /**
   * Internal API for registering an arguments transform for createVNode
   * used for creating stubs in the test-utils
   * It is *internal* but needs to be exposed for test-utils to pick up proper
   * typings
   */
  function transformVNodeArgs(transformer) {
      vnodeArgsTransformer = transformer;
  }
  const createVNodeWithArgsTransform = (...args) => {
      return _createVNode(...(vnodeArgsTransformer
          ? vnodeArgsTransformer(args, currentRenderingInstance)
          : args));
  };
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({ ref, ref_key, ref_for }) => {
      return (ref != null
          ? isString(ref) || isRef(ref) || isFunction(ref)
              ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
              : ref
          : null);
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
          __v_isVNode: true,
          __v_skip: true,
          type,
          props,
          key: props && normalizeKey(props),
          ref: props && normalizeRef(props),
          scopeId: currentScopeId,
          slotScopeIds: null,
          children,
          component: null,
          suspense: null,
          ssContent: null,
          ssFallback: null,
          dirs: null,
          transition: null,
          el: null,
          anchor: null,
          target: null,
          targetAnchor: null,
          staticCount: 0,
          shapeFlag,
          patchFlag,
          dynamicProps,
          dynamicChildren: null,
          appContext: null
      };
      if (needFullChildrenNormalization) {
          normalizeChildren(vnode, children);
          // normalize suspense children
          if (shapeFlag & 128 /* SUSPENSE */) {
              type.normalize(vnode);
          }
      }
      else if (children) {
          // compiled element vnode - if children is passed, only possible types are
          // string or Array.
          vnode.shapeFlag |= isString(children)
              ? 8 /* TEXT_CHILDREN */
              : 16 /* ARRAY_CHILDREN */;
      }
      // validate key
      if (vnode.key !== vnode.key) {
          warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      // track vnode for block tree
      if (isBlockTreeEnabled > 0 &&
          // avoid a block node from tracking itself
          !isBlockNode &&
          // has current parent block
          currentBlock &&
          // presence of a patch flag indicates this node needs patching on updates.
          // component nodes also should always be patched, because even if the
          // component doesn't need to update, it needs to persist the instance on to
          // the next vnode so that it can be properly unmounted later.
          (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
          // the EVENTS flag is only for hydration and if it is the only flag, the
          // vnode should not be considered dynamic due to handler caching.
          vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
          currentBlock.push(vnode);
      }
      return vnode;
  }
  const createVNode = (createVNodeWithArgsTransform );
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
          if (!type) {
              warn$1(`Invalid vnode type when creating vnode: ${type}.`);
          }
          type = Comment;
      }
      if (isVNode(type)) {
          // createVNode receiving an existing vnode. This happens in cases like
          // <component :is="vnode"/>
          // #2078 make sure to merge refs during the clone instead of overwriting it
          const cloned = cloneVNode(type, props, true /* mergeRef: true */);
          if (children) {
              normalizeChildren(cloned, children);
          }
          if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
              if (cloned.shapeFlag & 6 /* COMPONENT */) {
                  currentBlock[currentBlock.indexOf(type)] = cloned;
              }
              else {
                  currentBlock.push(cloned);
              }
          }
          cloned.patchFlag |= -2 /* BAIL */;
          return cloned;
      }
      // class component normalization.
      if (isClassComponent(type)) {
          type = type.__vccOpts;
      }
      // class & style normalization.
      if (props) {
          // for reactive or proxy objects, we need to clone it to enable mutation.
          props = guardReactiveProps(props);
          let { class: klass, style } = props;
          if (klass && !isString(klass)) {
              props.class = normalizeClass(klass);
          }
          if (isObject(style)) {
              // reactive state objects need to be cloned since they are likely to be
              // mutated
              if (isProxy(style) && !isArray(style)) {
                  style = extend({}, style);
              }
              props.style = normalizeStyle(style);
          }
      }
      // encode the vnode type information into a bitmap
      const shapeFlag = isString(type)
          ? 1 /* ELEMENT */
          : isSuspense(type)
              ? 128 /* SUSPENSE */
              : isTeleport(type)
                  ? 64 /* TELEPORT */
                  : isObject(type)
                      ? 4 /* STATEFUL_COMPONENT */
                      : isFunction(type)
                          ? 2 /* FUNCTIONAL_COMPONENT */
                          : 0;
      if (shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {
          type = toRaw(type);
          warn$1(`Vue received a Component which was made a reactive object. This can ` +
              `lead to unnecessary performance overhead, and should be avoided by ` +
              `marking the component with \`markRaw\` or using \`shallowRef\` ` +
              `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
      }
      return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
      if (!props)
          return null;
      return isProxy(props) || InternalObjectKey in props
          ? extend({}, props)
          : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
      // This is intentionally NOT using spread or extend to avoid the runtime
      // key enumeration cost.
      const { props, ref, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
          __v_isVNode: true,
          __v_skip: true,
          type: vnode.type,
          props: mergedProps,
          key: mergedProps && normalizeKey(mergedProps),
          ref: extraProps && extraProps.ref
              ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                  // if the vnode itself already has a ref, cloneVNode will need to merge
                  // the refs so the single vnode can be set on multiple refs
                  mergeRef && ref
                      ? isArray(ref)
                          ? ref.concat(normalizeRef(extraProps))
                          : [ref, normalizeRef(extraProps)]
                      : normalizeRef(extraProps)
              : ref,
          scopeId: vnode.scopeId,
          slotScopeIds: vnode.slotScopeIds,
          children: patchFlag === -1 /* HOISTED */ && isArray(children)
              ? children.map(deepCloneVNode)
              : children,
          target: vnode.target,
          targetAnchor: vnode.targetAnchor,
          staticCount: vnode.staticCount,
          shapeFlag: vnode.shapeFlag,
          // if the vnode is cloned with extra props, we can no longer assume its
          // existing patch flag to be reliable and need to add the FULL_PROPS flag.
          // note: preserve flag for fragments since they use the flag for children
          // fast paths only.
          patchFlag: extraProps && vnode.type !== Fragment
              ? patchFlag === -1 // hoisted node
                  ? 16 /* FULL_PROPS */
                  : patchFlag | 16 /* FULL_PROPS */
              : patchFlag,
          dynamicProps: vnode.dynamicProps,
          dynamicChildren: vnode.dynamicChildren,
          appContext: vnode.appContext,
          dirs: vnode.dirs,
          transition: vnode.transition,
          // These should technically only be non-null on mounted VNodes. However,
          // they *should* be copied for kept-alive vnodes. So we just always copy
          // them since them being non-null during a mount doesn't affect the logic as
          // they will simply be overwritten.
          component: vnode.component,
          suspense: vnode.suspense,
          ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
          ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
          el: vnode.el,
          anchor: vnode.anchor
      };
      return cloned;
  }
  /**
   * Dev only, for HMR of hoisted vnodes reused in v-for
   * https://github.com/vitejs/vite/issues/2022
   */
  function deepCloneVNode(vnode) {
      const cloned = cloneVNode(vnode);
      if (isArray(vnode.children)) {
          cloned.children = vnode.children.map(deepCloneVNode);
      }
      return cloned;
  }
  /**
   * @private
   */
  function createTextVNode(text = ' ', flag = 0) {
      return createVNode(Text, null, text, flag);
  }
  /**
   * @private
   */
  function createStaticVNode(content, numberOfNodes) {
      // A static vnode can contain multiple stringified elements, and the number
      // of elements is necessary for hydration.
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
  }
  /**
   * @private
   */
  function createCommentVNode(text = '', 
  // when used as the v-else branch, the comment node must be created as a
  // block to ensure correct updates.
  asBlock = false) {
      return asBlock
          ? (openBlock(), createBlock(Comment, null, text))
          : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
      if (child == null || typeof child === 'boolean') {
          // empty placeholder
          return createVNode(Comment);
      }
      else if (isArray(child)) {
          // fragment
          return createVNode(Fragment, null, 
          // #3666, avoid reference pollution when reusing vnode
          child.slice());
      }
      else if (typeof child === 'object') {
          // already vnode, this should be the most common since compiled templates
          // always produce all-vnode children arrays
          return cloneIfMounted(child);
      }
      else {
          // strings and numbers
          return createVNode(Text, null, String(child));
      }
  }
  // optimized normalization for template-compiled render fns
  function cloneIfMounted(child) {
      return child.el === null || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
          children = null;
      }
      else if (isArray(children)) {
          type = 16 /* ARRAY_CHILDREN */;
      }
      else if (typeof children === 'object') {
          if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
              // Normalize slot to plain children for plain element and Teleport
              const slot = children.default;
              if (slot) {
                  // _c marker is added by withCtx() indicating this is a compiled slot
                  slot._c && (slot._d = false);
                  normalizeChildren(vnode, slot());
                  slot._c && (slot._d = true);
              }
              return;
          }
          else {
              type = 32 /* SLOTS_CHILDREN */;
              const slotFlag = children._;
              if (!slotFlag && !(InternalObjectKey in children)) {
                  children._ctx = currentRenderingInstance;
              }
              else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                  // a child component receives forwarded slots from the parent.
                  // its slot type is determined by its parent's slot type.
                  if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                      children._ = 1 /* STABLE */;
                  }
                  else {
                      children._ = 2 /* DYNAMIC */;
                      vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  }
              }
          }
      }
      else if (isFunction(children)) {
          children = { default: children, _ctx: currentRenderingInstance };
          type = 32 /* SLOTS_CHILDREN */;
      }
      else {
          children = String(children);
          // force teleport children to array so it can be moved around
          if (shapeFlag & 64 /* TELEPORT */) {
              type = 16 /* ARRAY_CHILDREN */;
              children = [createTextVNode(children)];
          }
          else {
              type = 8 /* TEXT_CHILDREN */;
          }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
          const toMerge = args[i];
          for (const key in toMerge) {
              if (key === 'class') {
                  if (ret.class !== toMerge.class) {
                      ret.class = normalizeClass([ret.class, toMerge.class]);
                  }
              }
              else if (key === 'style') {
                  ret.style = normalizeStyle([ret.style, toMerge.style]);
              }
              else if (isOn(key)) {
                  const existing = ret[key];
                  const incoming = toMerge[key];
                  if (incoming &&
                      existing !== incoming &&
                      !(isArray(existing) && existing.includes(incoming))) {
                      ret[key] = existing
                          ? [].concat(existing, incoming)
                          : incoming;
                  }
              }
              else if (key !== '') {
                  ret[key] = toMerge[key];
              }
          }
      }
      return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
          vnode,
          prevVNode
      ]);
  }

  const emptyAppContext = createAppContext();
  let uid$1 = 0;
  function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      // inherit parent app context - or - if root, adopt from root vnode
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
          uid: uid$1++,
          vnode,
          type,
          parent,
          appContext,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          scope: new EffectScope(true /* detached */),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: parent ? parent.provides : Object.create(appContext.provides),
          accessCache: null,
          renderCache: [],
          // local resolved assets
          components: null,
          directives: null,
          // resolved props and emits options
          propsOptions: normalizePropsOptions(type, appContext),
          emitsOptions: normalizeEmitsOptions(type, appContext),
          // emit
          emit: null,
          emitted: null,
          // props default value
          propsDefaults: EMPTY_OBJ,
          // inheritAttrs
          inheritAttrs: type.inheritAttrs,
          // state
          ctx: EMPTY_OBJ,
          data: EMPTY_OBJ,
          props: EMPTY_OBJ,
          attrs: EMPTY_OBJ,
          slots: EMPTY_OBJ,
          refs: EMPTY_OBJ,
          setupState: EMPTY_OBJ,
          setupContext: null,
          // suspense related
          suspense,
          suspenseId: suspense ? suspense.pendingId : 0,
          asyncDep: null,
          asyncResolved: false,
          // lifecycle hooks
          // not using enums here because it results in computed properties
          isMounted: false,
          isUnmounted: false,
          isDeactivated: false,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
      };
      {
          instance.ctx = createDevRenderContext(instance);
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit$1.bind(null, instance);
      // apply custom element special handling
      if (vnode.ce) {
          vnode.ce(instance);
      }
      return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  const setCurrentInstance = (instance) => {
      currentInstance = instance;
      instance.scope.on();
  };
  const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      currentInstance = null;
  };
  const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');
  function validateComponentName(name, config) {
      const appIsNativeTag = config.isNativeTag || NO;
      if (isBuiltInTag(name) || appIsNativeTag(name)) {
          warn$1('Do not use built-in or reserved HTML elements as component id: ' + name);
      }
  }
  function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful
          ? setupStatefulComponent(instance, isSSR)
          : undefined;
      isInSSRComponentSetup = false;
      return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
      var _a;
      const Component = instance.type;
      {
          if (Component.name) {
              validateComponentName(Component.name, instance.appContext.config);
          }
          if (Component.components) {
              const names = Object.keys(Component.components);
              for (let i = 0; i < names.length; i++) {
                  validateComponentName(names[i], instance.appContext.config);
              }
          }
          if (Component.directives) {
              const names = Object.keys(Component.directives);
              for (let i = 0; i < names.length; i++) {
                  validateDirectiveName(names[i]);
              }
          }
          if (Component.compilerOptions && isRuntimeOnly()) {
              warn$1(`"compilerOptions" is only supported when using a build of Vue that ` +
                  `includes the runtime compiler. Since you are using a runtime-only ` +
                  `build, the options should be passed via your build tool config instead.`);
          }
      }
      // 0. create render proxy property access cache
      instance.accessCache = Object.create(null);
      // 1. create public instance / render proxy
      // also mark it raw so it's never observed
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      {
          exposePropsOnRenderContext(instance);
      }
      // 2. call setup()
      const { setup } = Component;
      if (setup) {
          const setupContext = (instance.setupContext =
              setup.length > 1 ? createSetupContext(instance) : null);
          setCurrentInstance(instance);
          pauseTracking();
          const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [shallowReadonly(instance.props) , setupContext]);
          resetTracking();
          unsetCurrentInstance();
          if (isPromise(setupResult)) {
              setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
              if (isSSR) {
                  // return the promise so server-renderer can wait on it
                  return setupResult
                      .then((resolvedResult) => {
                      handleSetupResult(instance, resolvedResult, isSSR);
                  })
                      .catch(e => {
                      handleError(e, instance, 0 /* SETUP_FUNCTION */);
                  });
              }
              else {
                  // async setup returned Promise.
                  // bail here and wait for re-entry.
                  instance.asyncDep = setupResult;
                  if (!instance.suspense) {
                      const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';
                      warn$1(`Component <${name}>: setup function returned a promise, but no ` +
                          `<Suspense> boundary was found in the parent component tree. ` +
                          `A component with async setup() must be nested in a <Suspense> ` +
                          `in order to be rendered.`);
                  }
              }
          }
          else {
              handleSetupResult(instance, setupResult, isSSR);
          }
      }
      else {
          finishComponentSetup(instance, isSSR);
      }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction(setupResult)) {
          // setup returned an inline render function
          {
              instance.render = setupResult;
          }
      }
      else if (isObject(setupResult)) {
          if (isVNode(setupResult)) {
              warn$1(`setup() should not return VNodes directly - ` +
                  `return a render function instead.`);
          }
          // setup returned bindings.
          // assuming a render function compiled from template is present.
          {
              instance.devtoolsRawSetupState = setupResult;
          }
          instance.setupState = proxyRefs(setupResult);
          {
              exposeSetupStateOnRenderContext(instance);
          }
      }
      else if (setupResult !== undefined) {
          warn$1(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
      }
      finishComponentSetup(instance, isSSR);
  }
  let compile;
  let installWithProxy;
  /**
   * For runtime-dom to register the compiler.
   * Note the exported method uses any to avoid d.ts relying on the compiler types.
   */
  function registerRuntimeCompiler(_compile) {
      compile = _compile;
      installWithProxy = i => {
          if (i.render._rc) {
              i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
          }
      };
  }
  // dev only
  const isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      // template / render function normalization
      // could be already set when returned from setup()
      if (!instance.render) {
          // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
          // is done by server-renderer
          if (!isSSR && compile && !Component.render) {
              const template = Component.template;
              if (template) {
                  {
                      startMeasure(instance, `compile`);
                  }
                  const { isCustomElement, compilerOptions } = instance.appContext.config;
                  const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                  const finalCompilerOptions = extend(extend({
                      isCustomElement,
                      delimiters
                  }, compilerOptions), componentCompilerOptions);
                  Component.render = compile(template, finalCompilerOptions);
                  {
                      endMeasure(instance, `compile`);
                  }
              }
          }
          instance.render = (Component.render || NOOP);
          // for runtime-compiled render functions using `with` blocks, the render
          // proxy used needs a different `has` handler which is more performant and
          // also only allows a whitelist of globals to fallthrough.
          if (installWithProxy) {
              installWithProxy(instance);
          }
      }
      // support for 2.x options
      {
          setCurrentInstance(instance);
          pauseTracking();
          applyOptions(instance);
          resetTracking();
          unsetCurrentInstance();
      }
      // warn missing template/render
      // the runtime compilation of template in SSR is done by server-render
      if (!Component.render && instance.render === NOOP && !isSSR) {
          /* istanbul ignore if */
          if (!compile && Component.template) {
              warn$1(`Component provided template option but ` +
                  `runtime compilation is not supported in this build of Vue.` +
                  (` Use "vue.esm-browser.js" instead.`
                          ) /* should not happen */);
          }
          else {
              warn$1(`Component is missing template or render function.`);
          }
      }
  }
  function createAttrsProxy(instance) {
      return new Proxy(instance.attrs, {
              get(target, key) {
                  markAttrsAccessed();
                  track(instance, "get" /* GET */, '$attrs');
                  return target[key];
              },
              set() {
                  warn$1(`setupContext.attrs is readonly.`);
                  return false;
              },
              deleteProperty() {
                  warn$1(`setupContext.attrs is readonly.`);
                  return false;
              }
          }
          );
  }
  function createSetupContext(instance) {
      const expose = exposed => {
          if (instance.exposed) {
              warn$1(`expose() should be called only once per setup().`);
          }
          instance.exposed = exposed || {};
      };
      let attrs;
      {
          // We use getters in dev in case libs like test-utils overwrite instance
          // properties (overwrites should not be done in prod)
          return Object.freeze({
              get attrs() {
                  return attrs || (attrs = createAttrsProxy(instance));
              },
              get slots() {
                  return shallowReadonly(instance.slots);
              },
              get emit() {
                  return (event, ...args) => instance.emit(event, ...args);
              },
              expose
          });
      }
  }
  function getExposeProxy(instance) {
      if (instance.exposed) {
          return (instance.exposeProxy ||
              (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                  get(target, key) {
                      if (key in target) {
                          return target[key];
                      }
                      else if (key in publicPropertiesMap) {
                          return publicPropertiesMap[key](instance);
                      }
                  }
              })));
      }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
  function getComponentName(Component, includeInferred = true) {
      return isFunction(Component)
          ? Component.displayName || Component.name
          : Component.name || (includeInferred && Component.__name);
  }
  /* istanbul ignore next */
  function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
          const match = Component.__file.match(/([^/\\]+)\.\w+$/);
          if (match) {
              name = match[1];
          }
      }
      if (!name && instance && instance.parent) {
          // try to infer the name based on reverse resolution
          const inferFromRegistry = (registry) => {
              for (const key in registry) {
                  if (registry[key] === Component) {
                      return key;
                  }
              }
          };
          name =
              inferFromRegistry(instance.components ||
                  instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
      return isFunction(value) && '__vccOpts' in value;
  }

  const computed$1 = ((getterOrOptions, debugOptions) => {
      // @ts-ignore
      return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
  });

  // dev only
  const warnRuntimeUsage = (method) => warn$1(`${method}() is a compiler-hint helper that is only usable inside ` +
      `<script setup> of a single file component. Its arguments should be ` +
      `compiled away and passing it at runtime has no effect.`);
  // implementation
  function defineProps() {
      {
          warnRuntimeUsage(`defineProps`);
      }
      return null;
  }
  // implementation
  function defineEmits() {
      {
          warnRuntimeUsage(`defineEmits`);
      }
      return null;
  }
  /**
   * Vue `<script setup>` compiler macro for declaring a component's exposed
   * instance properties when it is accessed by a parent component via template
   * refs.
   *
   * `<script setup>` components are closed by default - i.e. variables inside
   * the `<script setup>` scope is not exposed to parent unless explicitly exposed
   * via `defineExpose`.
   *
   * This is only usable inside `<script setup>`, is compiled away in the
   * output and should **not** be actually called at runtime.
   */
  function defineExpose(exposed) {
      {
          warnRuntimeUsage(`defineExpose`);
      }
  }
  /**
   * Vue `<script setup>` compiler macro for providing props default values when
   * using type-based `defineProps` declaration.
   *
   * Example usage:
   * ```ts
   * withDefaults(defineProps<{
   *   size?: number
   *   labels?: string[]
   * }>(), {
   *   size: 3,
   *   labels: () => ['default label']
   * })
   * ```
   *
   * This is only usable inside `<script setup>`, is compiled away in the output
   * and should **not** be actually called at runtime.
   */
  function withDefaults(props, defaults) {
      {
          warnRuntimeUsage(`withDefaults`);
      }
      return null;
  }
  function useSlots() {
      return getContext().slots;
  }
  function useAttrs() {
      return getContext().attrs;
  }
  function getContext() {
      const i = getCurrentInstance();
      if (!i) {
          warn$1(`useContext() called without active instance.`);
      }
      return i.setupContext || (i.setupContext = createSetupContext(i));
  }
  /**
   * Runtime helper for merging default declarations. Imported by compiled code
   * only.
   * @internal
   */
  function mergeDefaults(raw, defaults) {
      const props = isArray(raw)
          ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
          : raw;
      for (const key in defaults) {
          const opt = props[key];
          if (opt) {
              if (isArray(opt) || isFunction(opt)) {
                  props[key] = { type: opt, default: defaults[key] };
              }
              else {
                  opt.default = defaults[key];
              }
          }
          else if (opt === null) {
              props[key] = { default: defaults[key] };
          }
          else {
              warn$1(`props default key "${key}" has no corresponding declaration.`);
          }
      }
      return props;
  }
  /**
   * Used to create a proxy for the rest element when destructuring props with
   * defineProps().
   * @internal
   */
  function createPropsRestProxy(props, excludedKeys) {
      const ret = {};
      for (const key in props) {
          if (!excludedKeys.includes(key)) {
              Object.defineProperty(ret, key, {
                  enumerable: true,
                  get: () => props[key]
              });
          }
      }
      return ret;
  }
  /**
   * `<script setup>` helper for persisting the current instance context over
   * async/await flows.
   *
   * `@vue/compiler-sfc` converts the following:
   *
   * ```ts
   * const x = await foo()
   * ```
   *
   * into:
   *
   * ```ts
   * let __temp, __restore
   * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
   * ```
   * @internal
   */
  function withAsyncContext(getAwaitable) {
      const ctx = getCurrentInstance();
      if (!ctx) {
          warn$1(`withAsyncContext called without active current instance. ` +
              `This is likely a bug.`);
      }
      let awaitable = getAwaitable();
      unsetCurrentInstance();
      if (isPromise(awaitable)) {
          awaitable = awaitable.catch(e => {
              setCurrentInstance(ctx);
              throw e;
          });
      }
      return [awaitable, () => setCurrentInstance(ctx)];
  }

  // Actual implementation
  function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
          if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
              // single vnode without props
              if (isVNode(propsOrChildren)) {
                  return createVNode(type, null, [propsOrChildren]);
              }
              // props without children
              return createVNode(type, propsOrChildren);
          }
          else {
              // omit props
              return createVNode(type, null, propsOrChildren);
          }
      }
      else {
          if (l > 3) {
              children = Array.prototype.slice.call(arguments, 2);
          }
          else if (l === 3 && isVNode(children)) {
              children = [children];
          }
          return createVNode(type, propsOrChildren, children);
      }
  }

  const ssrContextKey = Symbol(`ssrContext` );
  const useSSRContext = () => {
      {
          const ctx = inject(ssrContextKey);
          if (!ctx) {
              warn$1(`Server rendering context not provided. Make sure to only call ` +
                  `useSSRContext() conditionally in the server build.`);
          }
          return ctx;
      }
  };

  function initCustomFormatter() {
      /* eslint-disable no-restricted-globals */
      if (typeof window === 'undefined') {
          return;
      }
      const vueStyle = { style: 'color:#3ba776' };
      const numberStyle = { style: 'color:#0b1bc9' };
      const stringStyle = { style: 'color:#b62e24' };
      const keywordStyle = { style: 'color:#9d288c' };
      // custom formatter for Chrome
      // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
      const formatter = {
          header(obj) {
              // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
              if (!isObject(obj)) {
                  return null;
              }
              if (obj.__isVue) {
                  return ['div', vueStyle, `VueInstance`];
              }
              else if (isRef(obj)) {
                  return [
                      'div',
                      {},
                      ['span', vueStyle, genRefFlag(obj)],
                      '<',
                      formatValue(obj.value),
                      `>`
                  ];
              }
              else if (isReactive(obj)) {
                  return [
                      'div',
                      {},
                      ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                      '<',
                      formatValue(obj),
                      `>${isReadonly(obj) ? ` (readonly)` : ``}`
                  ];
              }
              else if (isReadonly(obj)) {
                  return [
                      'div',
                      {},
                      ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                      '<',
                      formatValue(obj),
                      '>'
                  ];
              }
              return null;
          },
          hasBody(obj) {
              return obj && obj.__isVue;
          },
          body(obj) {
              if (obj && obj.__isVue) {
                  return [
                      'div',
                      {},
                      ...formatInstance(obj.$)
                  ];
              }
          }
      };
      function formatInstance(instance) {
          const blocks = [];
          if (instance.type.props && instance.props) {
              blocks.push(createInstanceBlock('props', toRaw(instance.props)));
          }
          if (instance.setupState !== EMPTY_OBJ) {
              blocks.push(createInstanceBlock('setup', instance.setupState));
          }
          if (instance.data !== EMPTY_OBJ) {
              blocks.push(createInstanceBlock('data', toRaw(instance.data)));
          }
          const computed = extractKeys(instance, 'computed');
          if (computed) {
              blocks.push(createInstanceBlock('computed', computed));
          }
          const injected = extractKeys(instance, 'inject');
          if (injected) {
              blocks.push(createInstanceBlock('injected', injected));
          }
          blocks.push([
              'div',
              {},
              [
                  'span',
                  {
                      style: keywordStyle.style + ';opacity:0.66'
                  },
                  '$ (internal): '
              ],
              ['object', { object: instance }]
          ]);
          return blocks;
      }
      function createInstanceBlock(type, target) {
          target = extend({}, target);
          if (!Object.keys(target).length) {
              return ['span', {}];
          }
          return [
              'div',
              { style: 'line-height:1.25em;margin-bottom:0.6em' },
              [
                  'div',
                  {
                      style: 'color:#476582'
                  },
                  type
              ],
              [
                  'div',
                  {
                      style: 'padding-left:1.25em'
                  },
                  ...Object.keys(target).map(key => {
                      return [
                          'div',
                          {},
                          ['span', keywordStyle, key + ': '],
                          formatValue(target[key], false)
                      ];
                  })
              ]
          ];
      }
      function formatValue(v, asRaw = true) {
          if (typeof v === 'number') {
              return ['span', numberStyle, v];
          }
          else if (typeof v === 'string') {
              return ['span', stringStyle, JSON.stringify(v)];
          }
          else if (typeof v === 'boolean') {
              return ['span', keywordStyle, v];
          }
          else if (isObject(v)) {
              return ['object', { object: asRaw ? toRaw(v) : v }];
          }
          else {
              return ['span', stringStyle, String(v)];
          }
      }
      function extractKeys(instance, type) {
          const Comp = instance.type;
          if (isFunction(Comp)) {
              return;
          }
          const extracted = {};
          for (const key in instance.ctx) {
              if (isKeyOfType(Comp, key, type)) {
                  extracted[key] = instance.ctx[key];
              }
          }
          return extracted;
      }
      function isKeyOfType(Comp, key, type) {
          const opts = Comp[type];
          if ((isArray(opts) && opts.includes(key)) ||
              (isObject(opts) && key in opts)) {
              return true;
          }
          if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
              return true;
          }
          if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
              return true;
          }
      }
      function genRefFlag(v) {
          if (isShallow(v)) {
              return `ShallowRef`;
          }
          if (v.effect) {
              return `ComputedRef`;
          }
          return `Ref`;
      }
      if (window.devtoolsFormatters) {
          window.devtoolsFormatters.push(formatter);
      }
      else {
          window.devtoolsFormatters = [formatter];
      }
  }

  function withMemo(memo, render, cache, index) {
      const cached = cache[index];
      if (cached && isMemoSame(cached, memo)) {
          return cached;
      }
      const ret = render();
      // shallow clone
      ret.memo = memo.slice();
      return (cache[index] = ret);
  }
  function isMemoSame(cached, memo) {
      const prev = cached.memo;
      if (prev.length != memo.length) {
          return false;
      }
      for (let i = 0; i < prev.length; i++) {
          if (hasChanged(prev[i], memo[i])) {
              return false;
          }
      }
      // make sure to let parent block track it when returning cached
      if (isBlockTreeEnabled > 0 && currentBlock) {
          currentBlock.push(cached);
      }
      return true;
  }

  // Core API ------------------------------------------------------------------
  const version = "3.2.37";
  /**
   * SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.
   * @internal
   */
  const ssrUtils = (null);
  /**
   * @internal only exposed in compat builds
   */
  const resolveFilter = null;
  /**
   * @internal only exposed in compat builds.
   */
  const compatUtils = (null);

  const svgNS = 'http://www.w3.org/2000/svg';
  const doc = (typeof document !== 'undefined' ? document : null);
  const templateContainer = doc && /*#__PURE__*/ doc.createElement('template');
  const nodeOps = {
      insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
      },
      remove: child => {
          const parent = child.parentNode;
          if (parent) {
              parent.removeChild(child);
          }
      },
      createElement: (tag, isSVG, is, props) => {
          const el = isSVG
              ? doc.createElementNS(svgNS, tag)
              : doc.createElement(tag, is ? { is } : undefined);
          if (tag === 'select' && props && props.multiple != null) {
              el.setAttribute('multiple', props.multiple);
          }
          return el;
      },
      createText: text => doc.createTextNode(text),
      createComment: text => doc.createComment(text),
      setText: (node, text) => {
          node.nodeValue = text;
      },
      setElementText: (el, text) => {
          el.textContent = text;
      },
      parentNode: node => node.parentNode,
      nextSibling: node => node.nextSibling,
      querySelector: selector => doc.querySelector(selector),
      setScopeId(el, id) {
          el.setAttribute(id, '');
      },
      cloneNode(el) {
          const cloned = el.cloneNode(true);
          // #3072
          // - in `patchDOMProp`, we store the actual value in the `el._value` property.
          // - normally, elements using `:value` bindings will not be hoisted, but if
          //   the bound value is a constant, e.g. `:value="true"` - they do get
          //   hoisted.
          // - in production, hoisted nodes are cloned when subsequent inserts, but
          //   cloneNode() does not copy the custom property we attached.
          // - This may need to account for other custom DOM properties we attach to
          //   elements in addition to `_value` in the future.
          if (`_value` in el) {
              cloned._value = el._value;
          }
          return cloned;
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG, start, end) {
          // <parent> before | first ... last | anchor </parent>
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          // #5308 can only take cached path if:
          // - has a single root node
          // - nextSibling info is still available
          if (start && (start === end || start.nextSibling)) {
              // cached
              while (true) {
                  parent.insertBefore(start.cloneNode(true), anchor);
                  if (start === end || !(start = start.nextSibling))
                      break;
              }
          }
          else {
              // fresh insert
              templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
              const template = templateContainer.content;
              if (isSVG) {
                  // remove outer svg wrapper
                  const wrapper = template.firstChild;
                  while (wrapper.firstChild) {
                      template.appendChild(wrapper.firstChild);
                  }
                  template.removeChild(wrapper);
              }
              parent.insertBefore(template, anchor);
          }
          return [
              // first
              before ? before.nextSibling : parent.firstChild,
              // last
              anchor ? anchor.previousSibling : parent.lastChild
          ];
      }
  };

  // compiler should normalize class + :class bindings on the same element
  // into a single binding ['staticClass', dynamic]
  function patchClass(el, value, isSVG) {
      // directly setting className should be faster than setAttribute in theory
      // if this is an element during a transition, take the temporary transition
      // classes into account.
      const transitionClasses = el._vtc;
      if (transitionClasses) {
          value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
      }
      if (value == null) {
          el.removeAttribute('class');
      }
      else if (isSVG) {
          el.setAttribute('class', value);
      }
      else {
          el.className = value;
      }
  }

  function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString(next);
      if (next && !isCssString) {
          for (const key in next) {
              setStyle(style, key, next[key]);
          }
          if (prev && !isString(prev)) {
              for (const key in prev) {
                  if (next[key] == null) {
                      setStyle(style, key, '');
                  }
              }
          }
      }
      else {
          const currentDisplay = style.display;
          if (isCssString) {
              if (prev !== next) {
                  style.cssText = next;
              }
          }
          else if (prev) {
              el.removeAttribute('style');
          }
          // indicates that the `display` of the element is controlled by `v-show`,
          // so we always keep the current `display` value regardless of the `style`
          // value, thus handing over control to `v-show`.
          if ('_vod' in el) {
              style.display = currentDisplay;
          }
      }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
      if (isArray(val)) {
          val.forEach(v => setStyle(style, name, v));
      }
      else {
          if (val == null)
              val = '';
          if (name.startsWith('--')) {
              // custom property definition
              style.setProperty(name, val);
          }
          else {
              const prefixed = autoPrefix(style, name);
              if (importantRE.test(val)) {
                  // !important
                  style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');
              }
              else {
                  style[prefixed] = val;
              }
          }
      }
  }
  const prefixes = ['Webkit', 'Moz', 'ms'];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
          return cached;
      }
      let name = camelize(rawName);
      if (name !== 'filter' && name in style) {
          return (prefixCache[rawName] = name);
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
          const prefixed = prefixes[i] + name;
          if (prefixed in style) {
              return (prefixCache[rawName] = prefixed);
          }
      }
      return rawName;
  }

  const xlinkNS = 'http://www.w3.org/1999/xlink';
  function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith('xlink:')) {
          if (value == null) {
              el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
          }
          else {
              el.setAttributeNS(xlinkNS, key, value);
          }
      }
      else {
          // note we are only checking boolean attributes that don't have a
          // corresponding dom prop of the same name here.
          const isBoolean = isSpecialBooleanAttr(key);
          if (value == null || (isBoolean && !includeBooleanAttr(value))) {
              el.removeAttribute(key);
          }
          else {
              el.setAttribute(key, isBoolean ? '' : value);
          }
      }
  }

  // __UNSAFE__
  // functions. The user is responsible for using them with only trusted content.
  function patchDOMProp(el, key, value, 
  // the following args are passed only due to potential innerHTML/textContent
  // overriding existing VNodes, in which case the old tree must be properly
  // unmounted.
  prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === 'innerHTML' || key === 'textContent') {
          if (prevChildren) {
              unmountChildren(prevChildren, parentComponent, parentSuspense);
          }
          el[key] = value == null ? '' : value;
          return;
      }
      if (key === 'value' &&
          el.tagName !== 'PROGRESS' &&
          // custom elements may use _value internally
          !el.tagName.includes('-')) {
          // store value as _value as well since
          // non-string values will be stringified.
          el._value = value;
          const newValue = value == null ? '' : value;
          if (el.value !== newValue ||
              // #4956: always set for OPTION elements because its value falls back to
              // textContent if no value attribute is present. And setting .value for
              // OPTION has no side effect
              el.tagName === 'OPTION') {
              el.value = newValue;
          }
          if (value == null) {
              el.removeAttribute(key);
          }
          return;
      }
      let needRemove = false;
      if (value === '' || value == null) {
          const type = typeof el[key];
          if (type === 'boolean') {
              // e.g. <select multiple> compiles to { multiple: '' }
              value = includeBooleanAttr(value);
          }
          else if (value == null && type === 'string') {
              // e.g. <div :id="null">
              value = '';
              needRemove = true;
          }
          else if (type === 'number') {
              // e.g. <img :width="null">
              // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
              value = 0;
              needRemove = true;
          }
      }
      // some properties perform value validation and throw,
      // some properties has getter, no setter, will error in 'use strict'
      // eg. <select :type="null"></select> <select :willValidate="null"></select>
      try {
          el[key] = value;
      }
      catch (e) {
          {
              warn$1(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                  `value ${value} is invalid.`, e);
          }
      }
      needRemove && el.removeAttribute(key);
  }

  // Async edge case fix requires storing an event listener's attach timestamp.
  const [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {
      let _getNow = Date.now;
      let skipTimestampCheck = false;
      if (typeof window !== 'undefined') {
          // Determine what event timestamp the browser is using. Annoyingly, the
          // timestamp can either be hi-res (relative to page load) or low-res
          // (relative to UNIX epoch), so in order to compare time we have to use the
          // same timestamp type when saving the flush timestamp.
          if (Date.now() > document.createEvent('Event').timeStamp) {
              // if the low-res timestamp which is bigger than the event timestamp
              // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
              // and we need to use the hi-res version for event listeners as well.
              _getNow = performance.now.bind(performance);
          }
          // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
          // and does not fire microtasks in between event propagation, so safe to exclude.
          const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
          skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
      }
      return [_getNow, skipTimestampCheck];
  })();
  // To avoid the overhead of repeatedly calling performance.now(), we cache
  // and use the same timestamp for all event listeners attached in the same tick.
  let cachedNow = 0;
  const p = /*#__PURE__*/ Promise.resolve();
  const reset = () => {
      cachedNow = 0;
  };
  const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
  function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      // vei = vue event invokers
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
          // patch
          existingInvoker.value = nextValue;
      }
      else {
          const [name, options] = parseName(rawName);
          if (nextValue) {
              // add
              const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
              addEventListener(el, name, invoker, options);
          }
          else if (existingInvoker) {
              // remove
              removeEventListener(el, name, existingInvoker, options);
              invokers[rawName] = undefined;
          }
      }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
          options = {};
          let m;
          while ((m = name.match(optionsModifierRE))) {
              name = name.slice(0, name.length - m[0].length);
              options[m[0].toLowerCase()] = true;
          }
      }
      return [hyphenate(name.slice(2)), options];
  }
  function createInvoker(initialValue, instance) {
      const invoker = (e) => {
          // async edge case #6566: inner click event triggers patch, event handler
          // attached to outer element during patch, and triggered again. This
          // happens because browsers fire microtask ticks between event propagation.
          // the solution is simple: we save the timestamp when a handler is attached,
          // and the handler would only fire if the event passed to it was fired
          // AFTER it was attached.
          const timeStamp = e.timeStamp || _getNow();
          if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
              callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
          }
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
      if (isArray(value)) {
          const originalStop = e.stopImmediatePropagation;
          e.stopImmediatePropagation = () => {
              originalStop.call(e);
              e._stopped = true;
          };
          return value.map(fn => (e) => !e._stopped && fn && fn(e));
      }
      else {
          return value;
      }
  }

  const nativeOnRE = /^on[a-z]/;
  const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === 'class') {
          patchClass(el, nextValue, isSVG);
      }
      else if (key === 'style') {
          patchStyle(el, prevValue, nextValue);
      }
      else if (isOn(key)) {
          // ignore v-model listeners
          if (!isModelListener(key)) {
              patchEvent(el, key, prevValue, nextValue, parentComponent);
          }
      }
      else if (key[0] === '.'
          ? ((key = key.slice(1)), true)
          : key[0] === '^'
              ? ((key = key.slice(1)), false)
              : shouldSetAsProp(el, key, nextValue, isSVG)) {
          patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      }
      else {
          // special case for <input v-model type="checkbox"> with
          // :true-value & :false-value
          // store value as dom properties since non-string values will be
          // stringified.
          if (key === 'true-value') {
              el._trueValue = nextValue;
          }
          else if (key === 'false-value') {
              el._falseValue = nextValue;
          }
          patchAttr(el, key, nextValue, isSVG);
      }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
          // most keys must be set as attribute on svg elements to work
          // ...except innerHTML & textContent
          if (key === 'innerHTML' || key === 'textContent') {
              return true;
          }
          // or native onclick with function values
          if (key in el && nativeOnRE.test(key) && isFunction(value)) {
              return true;
          }
          return false;
      }
      // these are enumerated attrs, however their corresponding DOM properties
      // are actually booleans - this leads to setting it with a string "false"
      // value leading it to be coerced to `true`, so we need to always treat
      // them as attributes.
      // Note that `contentEditable` doesn't have this problem: its DOM
      // property is also enumerated string values.
      if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {
          return false;
      }
      // #1787, #2840 form property on form elements is readonly and must be set as
      // attribute.
      if (key === 'form') {
          return false;
      }
      // #1526 <input list> must be set as attribute
      if (key === 'list' && el.tagName === 'INPUT') {
          return false;
      }
      // #2766 <textarea type> must be set as attribute
      if (key === 'type' && el.tagName === 'TEXTAREA') {
          return false;
      }
      // native onclick with string value, must be set as attribute
      if (nativeOnRE.test(key) && isString(value)) {
          return false;
      }
      return key in el;
  }

  function defineCustomElement(options, hydrate) {
      const Comp = defineComponent(options);
      class VueCustomElement extends VueElement {
          constructor(initialProps) {
              super(Comp, initialProps, hydrate);
          }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
  }
  const defineSSRCustomElement = ((options) => {
      // @ts-ignore
      return defineCustomElement(options, hydrate);
  });
  const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
  });
  class VueElement extends BaseClass {
      constructor(_def, _props = {}, hydrate) {
          super();
          this._def = _def;
          this._props = _props;
          /**
           * @internal
           */
          this._instance = null;
          this._connected = false;
          this._resolved = false;
          this._numberProps = null;
          if (this.shadowRoot && hydrate) {
              hydrate(this._createVNode(), this.shadowRoot);
          }
          else {
              if (this.shadowRoot) {
                  warn$1(`Custom element has pre-rendered declarative shadow root but is not ` +
                      `defined as hydratable. Use \`defineSSRCustomElement\`.`);
              }
              this.attachShadow({ mode: 'open' });
          }
      }
      connectedCallback() {
          this._connected = true;
          if (!this._instance) {
              this._resolveDef();
          }
      }
      disconnectedCallback() {
          this._connected = false;
          nextTick(() => {
              if (!this._connected) {
                  render$k(null, this.shadowRoot);
                  this._instance = null;
              }
          });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
          if (this._resolved) {
              return;
          }
          this._resolved = true;
          // set initial attrs
          for (let i = 0; i < this.attributes.length; i++) {
              this._setAttr(this.attributes[i].name);
          }
          // watch future attr changes
          new MutationObserver(mutations => {
              for (const m of mutations) {
                  this._setAttr(m.attributeName);
              }
          }).observe(this, { attributes: true });
          const resolve = (def) => {
              const { props, styles } = def;
              const hasOptions = !isArray(props);
              const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
              // cast Number-type props set before resolve
              let numberProps;
              if (hasOptions) {
                  for (const key in this._props) {
                      const opt = props[key];
                      if (opt === Number || (opt && opt.type === Number)) {
                          this._props[key] = toNumber(this._props[key]);
                          (numberProps || (numberProps = Object.create(null)))[key] = true;
                      }
                  }
              }
              this._numberProps = numberProps;
              // check if there are props set pre-upgrade or connect
              for (const key of Object.keys(this)) {
                  if (key[0] !== '_') {
                      this._setProp(key, this[key], true, false);
                  }
              }
              // defining getter/setters on prototype
              for (const key of rawKeys.map(camelize)) {
                  Object.defineProperty(this, key, {
                      get() {
                          return this._getProp(key);
                      },
                      set(val) {
                          this._setProp(key, val);
                      }
                  });
              }
              // apply CSS
              this._applyStyles(styles);
              // initial render
              this._update();
          };
          const asyncDef = this._def.__asyncLoader;
          if (asyncDef) {
              asyncDef().then(resolve);
          }
          else {
              resolve(this._def);
          }
      }
      _setAttr(key) {
          let value = this.getAttribute(key);
          if (this._numberProps && this._numberProps[key]) {
              value = toNumber(value);
          }
          this._setProp(camelize(key), value, false);
      }
      /**
       * @internal
       */
      _getProp(key) {
          return this._props[key];
      }
      /**
       * @internal
       */
      _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
          if (val !== this._props[key]) {
              this._props[key] = val;
              if (shouldUpdate && this._instance) {
                  this._update();
              }
              // reflect
              if (shouldReflect) {
                  if (val === true) {
                      this.setAttribute(hyphenate(key), '');
                  }
                  else if (typeof val === 'string' || typeof val === 'number') {
                      this.setAttribute(hyphenate(key), val + '');
                  }
                  else if (!val) {
                      this.removeAttribute(hyphenate(key));
                  }
              }
          }
      }
      _update() {
          render$k(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
          const vnode = createVNode(this._def, extend({}, this._props));
          if (!this._instance) {
              vnode.ce = instance => {
                  this._instance = instance;
                  instance.isCE = true;
                  // HMR
                  {
                      instance.ceReload = newStyles => {
                          // always reset styles
                          if (this._styles) {
                              this._styles.forEach(s => this.shadowRoot.removeChild(s));
                              this._styles.length = 0;
                          }
                          this._applyStyles(newStyles);
                          // if this is an async component, ceReload is called from the inner
                          // component so no need to reload the async wrapper
                          if (!this._def.__asyncLoader) {
                              // reload
                              this._instance = null;
                              this._update();
                          }
                      };
                  }
                  // intercept emit
                  instance.emit = (event, ...args) => {
                      this.dispatchEvent(new CustomEvent(event, {
                          detail: args
                      }));
                  };
                  // locate nearest Vue custom element parent for provide/inject
                  let parent = this;
                  while ((parent =
                      parent && (parent.parentNode || parent.host))) {
                      if (parent instanceof VueElement) {
                          instance.parent = parent._instance;
                          break;
                      }
                  }
              };
          }
          return vnode;
      }
      _applyStyles(styles) {
          if (styles) {
              styles.forEach(css => {
                  const s = document.createElement('style');
                  s.textContent = css;
                  this.shadowRoot.appendChild(s);
                  // record for HMR
                  {
                      (this._styles || (this._styles = [])).push(s);
                  }
              });
          }
      }
  }

  function useCssModule(name = '$style') {
      /* istanbul ignore else */
      {
          const instance = getCurrentInstance();
          if (!instance) {
              warn$1(`useCssModule must be called inside setup()`);
              return EMPTY_OBJ;
          }
          const modules = instance.type.__cssModules;
          if (!modules) {
              warn$1(`Current instance does not have CSS modules injected.`);
              return EMPTY_OBJ;
          }
          const mod = modules[name];
          if (!mod) {
              warn$1(`Current instance does not have CSS module named "${name}".`);
              return EMPTY_OBJ;
          }
          return mod;
      }
  }

  /**
   * Runtime helper for SFC's CSS variable injection feature.
   * @private
   */
  function useCssVars(getter) {
      const instance = getCurrentInstance();
      /* istanbul ignore next */
      if (!instance) {
          warn$1(`useCssVars is called without current active component instance.`);
          return;
      }
      const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
      watchPostEffect(setVars);
      onMounted(() => {
          const ob = new MutationObserver(setVars);
          ob.observe(instance.subTree.el.parentNode, { childList: true });
          onUnmounted(() => ob.disconnect());
      });
  }
  function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128 /* SUSPENSE */) {
          const suspense = vnode.suspense;
          vnode = suspense.activeBranch;
          if (suspense.pendingBranch && !suspense.isHydrating) {
              suspense.effects.push(() => {
                  setVarsOnVNode(suspense.activeBranch, vars);
              });
          }
      }
      // drill down HOCs until it's a non-component vnode
      while (vnode.component) {
          vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
          setVarsOnNode(vnode.el, vars);
      }
      else if (vnode.type === Fragment) {
          vnode.children.forEach(c => setVarsOnVNode(c, vars));
      }
      else if (vnode.type === Static) {
          let { el, anchor } = vnode;
          while (el) {
              setVarsOnNode(el, vars);
              if (el === anchor)
                  break;
              el = el.nextSibling;
          }
      }
  }
  function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
          const style = el.style;
          for (const key in vars) {
              style.setProperty(`--${key}`, vars[key]);
          }
      }
  }

  const TRANSITION = 'transition';
  const ANIMATION = 'animation';
  // DOM Transition is a higher-order-component based on the platform-agnostic
  // base Transition component, with DOM-specific logic.
  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = 'Transition';
  const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
          type: Boolean,
          default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
  };
  const TransitionPropsValidators = (Transition.props =
      /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));
  /**
   * #3227 Incoming hooks may be merged into arrays when wrapping Transition
   * with custom HOCs.
   */
  const callHook$1 = (hook, args = []) => {
      if (isArray(hook)) {
          hook.forEach(h => h(...args));
      }
      else if (hook) {
          hook(...args);
      }
  };
  /**
   * Check if a hook expects a callback (2nd arg), which means the user
   * intends to explicitly control the end of the transition.
   */
  const hasExplicitCallback = (hook) => {
      return hook
          ? isArray(hook)
              ? hook.some(h => h.length > 1)
              : hook.length > 1
          : false;
  };
  function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
          if (!(key in DOMTransitionPropsValidators)) {
              baseProps[key] = rawProps[key];
          }
      }
      if (rawProps.css === false) {
          return baseProps;
      }
      const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
      const finishEnter = (el, isAppear, done) => {
          removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
          removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
          done && done();
      };
      const finishLeave = (el, done) => {
          el._isLeaving = false;
          removeTransitionClass(el, leaveFromClass);
          removeTransitionClass(el, leaveToClass);
          removeTransitionClass(el, leaveActiveClass);
          done && done();
      };
      const makeEnterHook = (isAppear) => {
          return (el, done) => {
              const hook = isAppear ? onAppear : onEnter;
              const resolve = () => finishEnter(el, isAppear, done);
              callHook$1(hook, [el, resolve]);
              nextFrame(() => {
                  removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                  addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                  if (!hasExplicitCallback(hook)) {
                      whenTransitionEnds(el, type, enterDuration, resolve);
                  }
              });
          };
      };
      return extend(baseProps, {
          onBeforeEnter(el) {
              callHook$1(onBeforeEnter, [el]);
              addTransitionClass(el, enterFromClass);
              addTransitionClass(el, enterActiveClass);
          },
          onBeforeAppear(el) {
              callHook$1(onBeforeAppear, [el]);
              addTransitionClass(el, appearFromClass);
              addTransitionClass(el, appearActiveClass);
          },
          onEnter: makeEnterHook(false),
          onAppear: makeEnterHook(true),
          onLeave(el, done) {
              el._isLeaving = true;
              const resolve = () => finishLeave(el, done);
              addTransitionClass(el, leaveFromClass);
              // force reflow so *-leave-from classes immediately take effect (#2593)
              forceReflow();
              addTransitionClass(el, leaveActiveClass);
              nextFrame(() => {
                  if (!el._isLeaving) {
                      // cancelled
                      return;
                  }
                  removeTransitionClass(el, leaveFromClass);
                  addTransitionClass(el, leaveToClass);
                  if (!hasExplicitCallback(onLeave)) {
                      whenTransitionEnds(el, type, leaveDuration, resolve);
                  }
              });
              callHook$1(onLeave, [el, resolve]);
          },
          onEnterCancelled(el) {
              finishEnter(el, false);
              callHook$1(onEnterCancelled, [el]);
          },
          onAppearCancelled(el) {
              finishEnter(el, true);
              callHook$1(onAppearCancelled, [el]);
          },
          onLeaveCancelled(el) {
              finishLeave(el);
              callHook$1(onLeaveCancelled, [el]);
          }
      });
  }
  function normalizeDuration(duration) {
      if (duration == null) {
          return null;
      }
      else if (isObject(duration)) {
          return [NumberOf(duration.enter), NumberOf(duration.leave)];
      }
      else {
          const n = NumberOf(duration);
          return [n, n];
      }
  }
  function NumberOf(val) {
      const res = toNumber(val);
      validateDuration(res);
      return res;
  }
  function validateDuration(val) {
      if (typeof val !== 'number') {
          warn$1(`<transition> explicit duration is not a valid number - ` +
              `got ${JSON.stringify(val)}.`);
      }
      else if (isNaN(val)) {
          warn$1(`<transition> explicit duration is NaN - ` +
              'the duration expression might be incorrect.');
      }
  }
  function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach(c => c && el.classList.add(c));
      (el._vtc ||
          (el._vtc = new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
      const { _vtc } = el;
      if (_vtc) {
          _vtc.delete(cls);
          if (!_vtc.size) {
              el._vtc = undefined;
          }
      }
  }
  function nextFrame(cb) {
      requestAnimationFrame(() => {
          requestAnimationFrame(cb);
      });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
      const id = (el._endId = ++endId);
      const resolveIfNotStale = () => {
          if (id === el._endId) {
              resolve();
          }
      };
      if (explicitTimeout) {
          return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
          return resolve();
      }
      const endEvent = type + 'end';
      let ended = 0;
      const end = () => {
          el.removeEventListener(endEvent, onEnd);
          resolveIfNotStale();
      };
      const onEnd = (e) => {
          if (e.target === el && ++ended >= propCount) {
              end();
          }
      };
      setTimeout(() => {
          if (ended < propCount) {
              end();
          }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      // JSDOM may return undefined for transition properties
      const getStyleProperties = (key) => (styles[key] || '').split(', ');
      const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
      const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(ANIMATION + 'Delay');
      const animationDurations = getStyleProperties(ANIMATION + 'Duration');
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      /* istanbul ignore if */
      if (expectedType === TRANSITION) {
          if (transitionTimeout > 0) {
              type = TRANSITION;
              timeout = transitionTimeout;
              propCount = transitionDurations.length;
          }
      }
      else if (expectedType === ANIMATION) {
          if (animationTimeout > 0) {
              type = ANIMATION;
              timeout = animationTimeout;
              propCount = animationDurations.length;
          }
      }
      else {
          timeout = Math.max(transitionTimeout, animationTimeout);
          type =
              timeout > 0
                  ? transitionTimeout > animationTimeout
                      ? TRANSITION
                      : ANIMATION
                  : null;
          propCount = type
              ? type === TRANSITION
                  ? transitionDurations.length
                  : animationDurations.length
              : 0;
      }
      const hasTransform = type === TRANSITION &&
          /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
      return {
          type,
          timeout,
          propCount,
          hasTransform
      };
  }
  function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
          delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
  // numbers in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down
  // (i.e. acting as a floor function) causing unexpected behaviors
  function toMs(s) {
      return Number(s.slice(0, -1).replace(',', '.')) * 1000;
  }
  // synchronously force layout to put elements into a certain state
  function forceReflow() {
      return document.body.offsetHeight;
  }

  const positionMap = new WeakMap();
  const newPositionMap = new WeakMap();
  const TransitionGroupImpl = {
      name: 'TransitionGroup',
      props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
      }),
      setup(props, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
              // children is guaranteed to exist after initial render
              if (!prevChildren.length) {
                  return;
              }
              const moveClass = props.moveClass || `${props.name || 'v'}-move`;
              if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                  return;
              }
              // we divide the work into three loops to avoid mixing DOM reads and writes
              // in each iteration - which helps prevent layout thrashing.
              prevChildren.forEach(callPendingCbs);
              prevChildren.forEach(recordPosition);
              const movedChildren = prevChildren.filter(applyTranslation);
              // force reflow to put everything in position
              forceReflow();
              movedChildren.forEach(c => {
                  const el = c.el;
                  const style = el.style;
                  addTransitionClass(el, moveClass);
                  style.transform = style.webkitTransform = style.transitionDuration = '';
                  const cb = (el._moveCb = (e) => {
                      if (e && e.target !== el) {
                          return;
                      }
                      if (!e || /transform$/.test(e.propertyName)) {
                          el.removeEventListener('transitionend', cb);
                          el._moveCb = null;
                          removeTransitionClass(el, moveClass);
                      }
                  });
                  el.addEventListener('transitionend', cb);
              });
          });
          return () => {
              const rawProps = toRaw(props);
              const cssTransitionProps = resolveTransitionProps(rawProps);
              let tag = rawProps.tag || Fragment;
              prevChildren = children;
              children = slots.default ? getTransitionRawChildren(slots.default()) : [];
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (child.key != null) {
                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                  }
                  else {
                      warn$1(`<TransitionGroup> children must be keyed.`);
                  }
              }
              if (prevChildren) {
                  for (let i = 0; i < prevChildren.length; i++) {
                      const child = prevChildren[i];
                      setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                      positionMap.set(child, child.el.getBoundingClientRect());
                  }
              }
              return createVNode(tag, null, children);
          };
      }
  };
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
      const el = c.el;
      if (el._moveCb) {
          el._moveCb();
      }
      if (el._enterCb) {
          el._enterCb();
      }
  }
  function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
          const s = c.el.style;
          s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
          s.transitionDuration = '0s';
          return c;
      }
  }
  function hasCSSTransform(el, root, moveClass) {
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      const clone = el.cloneNode();
      if (el._vtc) {
          el._vtc.forEach(cls => {
              cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
          });
      }
      moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
      clone.style.display = 'none';
      const container = (root.nodeType === 1 ? root : root.parentNode);
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
  }

  const getModelAssigner = (vnode) => {
      const fn = vnode.props['onUpdate:modelValue'] ||
          (false );
      return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e) {
      e.target.composing = true;
  }
  function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
          target.composing = false;
          target.dispatchEvent(new Event('input'));
      }
  }
  // We are exporting the v-model runtime directly as vnode hooks so that it can
  // be tree-shaken in case v-model is never used.
  const vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number || (vnode.props && vnode.props.type === 'number');
          addEventListener(el, lazy ? 'change' : 'input', e => {
              if (e.target.composing)
                  return;
              let domValue = el.value;
              if (trim) {
                  domValue = domValue.trim();
              }
              if (castToNumber) {
                  domValue = toNumber(domValue);
              }
              el._assign(domValue);
          });
          if (trim) {
              addEventListener(el, 'change', () => {
                  el.value = el.value.trim();
              });
          }
          if (!lazy) {
              addEventListener(el, 'compositionstart', onCompositionStart);
              addEventListener(el, 'compositionend', onCompositionEnd);
              // Safari < 10.2 & UIWebView doesn't fire compositionend when
              // switching focus before confirming composition choice
              // this also fixes the issue where some browsers e.g. iOS Chrome
              // fires "change" instead of "input" on autocomplete.
              addEventListener(el, 'change', onCompositionEnd);
          }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
          el.value = value == null ? '' : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          // avoid clearing unresolved text. #2302
          if (el.composing)
              return;
          if (document.activeElement === el && el.type !== 'range') {
              if (lazy) {
                  return;
              }
              if (trim && el.value.trim() === value) {
                  return;
              }
              if ((number || el.type === 'number') && toNumber(el.value) === value) {
                  return;
              }
          }
          const newValue = value == null ? '' : value;
          if (el.value !== newValue) {
              el.value = newValue;
          }
      }
  };
  const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener(el, 'change', () => {
              const modelValue = el._modelValue;
              const elementValue = getValue(el);
              const checked = el.checked;
              const assign = el._assign;
              if (isArray(modelValue)) {
                  const index = looseIndexOf(modelValue, elementValue);
                  const found = index !== -1;
                  if (checked && !found) {
                      assign(modelValue.concat(elementValue));
                  }
                  else if (!checked && found) {
                      const filtered = [...modelValue];
                      filtered.splice(index, 1);
                      assign(filtered);
                  }
              }
              else if (isSet(modelValue)) {
                  const cloned = new Set(modelValue);
                  if (checked) {
                      cloned.add(elementValue);
                  }
                  else {
                      cloned.delete(elementValue);
                  }
                  assign(cloned);
              }
              else {
                  assign(getCheckboxValue(el, checked));
              }
          });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
      }
  };
  function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray(value)) {
          el.checked = looseIndexOf(value, vnode.props.value) > -1;
      }
      else if (isSet(value)) {
          el.checked = value.has(vnode.props.value);
      }
      else if (value !== oldValue) {
          el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
  }
  const vModelRadio = {
      created(el, { value }, vnode) {
          el.checked = looseEqual(value, vnode.props.value);
          el._assign = getModelAssigner(vnode);
          addEventListener(el, 'change', () => {
              el._assign(getValue(el));
          });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (value !== oldValue) {
              el.checked = looseEqual(value, vnode.props.value);
          }
      }
  };
  const vModelSelect = {
      // <select multiple> value need to be deep traversed
      deep: true,
      created(el, { value, modifiers: { number } }, vnode) {
          const isSetModel = isSet(value);
          addEventListener(el, 'change', () => {
              const selectedVal = Array.prototype.filter
                  .call(el.options, (o) => o.selected)
                  .map((o) => number ? toNumber(getValue(o)) : getValue(o));
              el._assign(el.multiple
                  ? isSetModel
                      ? new Set(selectedVal)
                      : selectedVal
                  : selectedVal[0]);
          });
          el._assign = getModelAssigner(vnode);
      },
      // set value in mounted & updated because <select> relies on its children
      // <option>s.
      mounted(el, { value }) {
          setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
          el._assign = getModelAssigner(vnode);
      },
      updated(el, { value }) {
          setSelected(el, value);
      }
  };
  function setSelected(el, value) {
      const isMultiple = el.multiple;
      if (isMultiple && !isArray(value) && !isSet(value)) {
          warn$1(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                  `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
          return;
      }
      for (let i = 0, l = el.options.length; i < l; i++) {
          const option = el.options[i];
          const optionValue = getValue(option);
          if (isMultiple) {
              if (isArray(value)) {
                  option.selected = looseIndexOf(value, optionValue) > -1;
              }
              else {
                  option.selected = value.has(optionValue);
              }
          }
          else {
              if (looseEqual(getValue(option), value)) {
                  if (el.selectedIndex !== i)
                      el.selectedIndex = i;
                  return;
              }
          }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
          el.selectedIndex = -1;
      }
  }
  // retrieve raw value set via :value bindings
  function getValue(el) {
      return '_value' in el ? el._value : el.value;
  }
  // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
  function getCheckboxValue(el, checked) {
      const key = checked ? '_trueValue' : '_falseValue';
      return key in el ? el[key] : checked;
  }
  const vModelDynamic = {
      created(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, 'created');
      },
      mounted(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, 'mounted');
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
      },
      updated(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, 'updated');
      }
  };
  function resolveDynamicModel(tagName, type) {
      switch (tagName) {
          case 'SELECT':
              return vModelSelect;
          case 'TEXTAREA':
              return vModelText;
          default:
              switch (type) {
                  case 'checkbox':
                      return vModelCheckbox;
                  case 'radio':
                      return vModelRadio;
                  default:
                      return vModelText;
              }
      }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
      const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
      const fn = modelToUse[hook];
      fn && fn(el, binding, vnode, prevVNode);
  }

  const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
  const modifierGuards = {
      stop: e => e.stopPropagation(),
      prevent: e => e.preventDefault(),
      self: e => e.target !== e.currentTarget,
      ctrl: e => !e.ctrlKey,
      shift: e => !e.shiftKey,
      alt: e => !e.altKey,
      meta: e => !e.metaKey,
      left: e => 'button' in e && e.button !== 0,
      middle: e => 'button' in e && e.button !== 1,
      right: e => 'button' in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
  };
  /**
   * @private
   */
  const withModifiers = (fn, modifiers) => {
      return (event, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
              const guard = modifierGuards[modifiers[i]];
              if (guard && guard(event, modifiers))
                  return;
          }
          return fn(event, ...args);
      };
  };
  // Kept for 2.x compat.
  // Note: IE11 compat for `spacebar` and `del` is removed for now.
  const keyNames = {
      esc: 'escape',
      space: ' ',
      up: 'arrow-up',
      left: 'arrow-left',
      right: 'arrow-right',
      down: 'arrow-down',
      delete: 'backspace'
  };
  /**
   * @private
   */
  const withKeys = (fn, modifiers) => {
      return (event) => {
          if (!('key' in event)) {
              return;
          }
          const eventKey = hyphenate(event.key);
          if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
              return fn(event);
          }
      };
  };

  const vShow = {
      beforeMount(el, { value }, { transition }) {
          el._vod = el.style.display === 'none' ? '' : el.style.display;
          if (transition && value) {
              transition.beforeEnter(el);
          }
          else {
              setDisplay(el, value);
          }
      },
      mounted(el, { value }, { transition }) {
          if (transition && value) {
              transition.enter(el);
          }
      },
      updated(el, { value, oldValue }, { transition }) {
          if (!value === !oldValue)
              return;
          if (transition) {
              if (value) {
                  transition.beforeEnter(el);
                  setDisplay(el, true);
                  transition.enter(el);
              }
              else {
                  transition.leave(el, () => {
                      setDisplay(el, false);
                  });
              }
          }
          else {
              setDisplay(el, value);
          }
      },
      beforeUnmount(el, { value }) {
          setDisplay(el, value);
      }
  };
  function setDisplay(el, value) {
      el.style.display = value ? el._vod : 'none';
  }

  const rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps);
  // lazy create the renderer - this makes core renderer logic tree-shakable
  // in case the user only imports reactivity utilities from Vue.
  let renderer;
  let enabledHydration = false;
  function ensureRenderer() {
      return (renderer ||
          (renderer = createRenderer(rendererOptions)));
  }
  function ensureHydrationRenderer() {
      renderer = enabledHydration
          ? renderer
          : createHydrationRenderer(rendererOptions);
      enabledHydration = true;
      return renderer;
  }
  // use explicit type casts here to avoid import() calls in rolled-up d.ts
  const render$k = ((...args) => {
      ensureRenderer().render(...args);
  });
  const hydrate = ((...args) => {
      ensureHydrationRenderer().hydrate(...args);
  });
  const createApp = ((...args) => {
      const app = ensureRenderer().createApp(...args);
      {
          injectNativeTagCheck(app);
          injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
              return;
          const component = app._component;
          if (!isFunction(component) && !component.render && !component.template) {
              // __UNSAFE__
              // Reason: potential execution of JS expressions in in-DOM template.
              // The user must make sure the in-DOM template is trusted. If it's
              // rendered by the server, the template should not contain any user data.
              component.template = container.innerHTML;
          }
          // clear content before mounting
          container.innerHTML = '';
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
              container.removeAttribute('v-cloak');
              container.setAttribute('data-v-app', '');
          }
          return proxy;
      };
      return app;
  });
  const createSSRApp = ((...args) => {
      const app = ensureHydrationRenderer().createApp(...args);
      {
          injectNativeTagCheck(app);
          injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (container) {
              return mount(container, true, container instanceof SVGElement);
          }
      };
      return app;
  });
  function injectNativeTagCheck(app) {
      // Inject `isNativeTag`
      // this is used for component name validation (dev only)
      Object.defineProperty(app.config, 'isNativeTag', {
          value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
          writable: false
      });
  }
  // dev only
  function injectCompilerOptionsCheck(app) {
      if (isRuntimeOnly()) {
          const isCustomElement = app.config.isCustomElement;
          Object.defineProperty(app.config, 'isCustomElement', {
              get() {
                  return isCustomElement;
              },
              set() {
                  warn$1(`The \`isCustomElement\` config option is deprecated. Use ` +
                      `\`compilerOptions.isCustomElement\` instead.`);
              }
          });
          const compilerOptions = app.config.compilerOptions;
          const msg = `The \`compilerOptions\` config option is only respected when using ` +
              `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
              `Since you are using the runtime-only build, \`compilerOptions\` ` +
              `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
              `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
              `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
              `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
          Object.defineProperty(app.config, 'compilerOptions', {
              get() {
                  warn$1(msg);
                  return compilerOptions;
              },
              set() {
                  warn$1(msg);
              }
          });
      }
  }
  function normalizeContainer(container) {
      if (isString(container)) {
          const res = document.querySelector(container);
          if (!res) {
              warn$1(`Failed to mount app: mount target selector "${container}" returned null.`);
          }
          return res;
      }
      if (window.ShadowRoot &&
          container instanceof window.ShadowRoot &&
          container.mode === 'closed') {
          warn$1(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
      }
      return container;
  }
  /**
   * @internal
   */
  const initDirectivesForSSR = NOOP;

  var runtimeDom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    render: render$k,
    hydrate: hydrate,
    createApp: createApp,
    createSSRApp: createSSRApp,
    initDirectivesForSSR: initDirectivesForSSR,
    defineCustomElement: defineCustomElement,
    defineSSRCustomElement: defineSSRCustomElement,
    VueElement: VueElement,
    useCssModule: useCssModule,
    useCssVars: useCssVars,
    Transition: Transition,
    TransitionGroup: TransitionGroup,
    vModelText: vModelText,
    vModelCheckbox: vModelCheckbox,
    vModelRadio: vModelRadio,
    vModelSelect: vModelSelect,
    vModelDynamic: vModelDynamic,
    withModifiers: withModifiers,
    withKeys: withKeys,
    vShow: vShow,
    reactive: reactive,
    ref: ref,
    readonly: readonly,
    unref: unref,
    proxyRefs: proxyRefs,
    isRef: isRef,
    toRef: toRef,
    toRefs: toRefs,
    isProxy: isProxy,
    isReactive: isReactive,
    isReadonly: isReadonly,
    isShallow: isShallow,
    customRef: customRef,
    triggerRef: triggerRef,
    shallowRef: shallowRef,
    shallowReactive: shallowReactive,
    shallowReadonly: shallowReadonly,
    markRaw: markRaw,
    toRaw: toRaw,
    effect: effect,
    stop: stop,
    ReactiveEffect: ReactiveEffect,
    effectScope: effectScope,
    EffectScope: EffectScope,
    getCurrentScope: getCurrentScope,
    onScopeDispose: onScopeDispose,
    computed: computed$1,
    watch: watch,
    watchEffect: watchEffect,
    watchPostEffect: watchPostEffect,
    watchSyncEffect: watchSyncEffect,
    onBeforeMount: onBeforeMount,
    onMounted: onMounted,
    onBeforeUpdate: onBeforeUpdate,
    onUpdated: onUpdated,
    onBeforeUnmount: onBeforeUnmount,
    onUnmounted: onUnmounted,
    onActivated: onActivated,
    onDeactivated: onDeactivated,
    onRenderTracked: onRenderTracked,
    onRenderTriggered: onRenderTriggered,
    onErrorCaptured: onErrorCaptured,
    onServerPrefetch: onServerPrefetch,
    provide: provide,
    inject: inject,
    nextTick: nextTick,
    defineComponent: defineComponent,
    defineAsyncComponent: defineAsyncComponent,
    useAttrs: useAttrs,
    useSlots: useSlots,
    defineProps: defineProps,
    defineEmits: defineEmits,
    defineExpose: defineExpose,
    withDefaults: withDefaults,
    mergeDefaults: mergeDefaults,
    createPropsRestProxy: createPropsRestProxy,
    withAsyncContext: withAsyncContext,
    getCurrentInstance: getCurrentInstance,
    h: h,
    createVNode: createVNode,
    cloneVNode: cloneVNode,
    mergeProps: mergeProps,
    isVNode: isVNode,
    Fragment: Fragment,
    Text: Text,
    Comment: Comment,
    Static: Static,
    Teleport: Teleport,
    Suspense: Suspense,
    KeepAlive: KeepAlive,
    BaseTransition: BaseTransition,
    withDirectives: withDirectives,
    useSSRContext: useSSRContext,
    ssrContextKey: ssrContextKey,
    createRenderer: createRenderer,
    createHydrationRenderer: createHydrationRenderer,
    queuePostFlushCb: queuePostFlushCb,
    warn: warn$1,
    handleError: handleError,
    callWithErrorHandling: callWithErrorHandling,
    callWithAsyncErrorHandling: callWithAsyncErrorHandling,
    resolveComponent: resolveComponent,
    resolveDirective: resolveDirective,
    resolveDynamicComponent: resolveDynamicComponent,
    registerRuntimeCompiler: registerRuntimeCompiler,
    isRuntimeOnly: isRuntimeOnly,
    useTransitionState: useTransitionState,
    resolveTransitionHooks: resolveTransitionHooks,
    setTransitionHooks: setTransitionHooks,
    getTransitionRawChildren: getTransitionRawChildren,
    initCustomFormatter: initCustomFormatter,
    get devtools () { return devtools; },
    setDevtoolsHook: setDevtoolsHook,
    withCtx: withCtx,
    pushScopeId: pushScopeId,
    popScopeId: popScopeId,
    withScopeId: withScopeId,
    renderList: renderList,
    toHandlers: toHandlers,
    renderSlot: renderSlot,
    createSlots: createSlots,
    withMemo: withMemo,
    isMemoSame: isMemoSame,
    openBlock: openBlock,
    createBlock: createBlock,
    setBlockTracking: setBlockTracking,
    createTextVNode: createTextVNode,
    createCommentVNode: createCommentVNode,
    createStaticVNode: createStaticVNode,
    createElementVNode: createBaseVNode,
    createElementBlock: createElementBlock,
    guardReactiveProps: guardReactiveProps,
    toDisplayString: toDisplayString,
    camelize: camelize,
    capitalize: capitalize,
    toHandlerKey: toHandlerKey,
    normalizeProps: normalizeProps,
    normalizeClass: normalizeClass,
    normalizeStyle: normalizeStyle,
    transformVNodeArgs: transformVNodeArgs,
    version: version,
    ssrUtils: ssrUtils,
    resolveFilter: resolveFilter,
    compatUtils: compatUtils
  });

  function initDev() {
      {
          {
              console.info(`You are running a development build of Vue.\n` +
                  `Make sure to use the production build (*.prod.js) when deploying for production.`);
          }
          initCustomFormatter();
      }
  }

  function defaultOnError(error) {
      throw error;
  }
  function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``)
          ;
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
  }
  const errorMessages = {
      // parse errors
      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
      [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
      [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
      [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
      [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
      [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
      [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
      [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
      [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
      [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
      [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
      [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
      [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
      [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
      [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,
      [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
      [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
      [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
      [27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
          'Note that dynamic directive argument cannot contain spaces.',
      [26 /* X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',
      // transform errors
      [28 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
      [29 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
      [30 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
      [32 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
      [33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
      [34 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
      [35 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
      [36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
      [37 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
          `When there are multiple named slots, all slots should use <template> ` +
          `syntax to avoid scope ambiguity.`,
      [38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
      [39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
          `default slot. These children will be ignored.`,
      [40 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
      [41 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
      [42 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
      [43 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
      [45 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
      // generic errors
      [46 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
      [48 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
      // just to fulfill types
      [50 /* __EXTEND_POINT__ */]: ``
  };

  const FRAGMENT = Symbol(`Fragment` );
  const TELEPORT = Symbol(`Teleport` );
  const SUSPENSE = Symbol(`Suspense` );
  const KEEP_ALIVE = Symbol(`KeepAlive` );
  const BASE_TRANSITION = Symbol(`BaseTransition` );
  const OPEN_BLOCK = Symbol(`openBlock` );
  const CREATE_BLOCK = Symbol(`createBlock` );
  const CREATE_ELEMENT_BLOCK = Symbol(`createElementBlock` );
  const CREATE_VNODE = Symbol(`createVNode` );
  const CREATE_ELEMENT_VNODE = Symbol(`createElementVNode` );
  const CREATE_COMMENT = Symbol(`createCommentVNode` );
  const CREATE_TEXT = Symbol(`createTextVNode` );
  const CREATE_STATIC = Symbol(`createStaticVNode` );
  const RESOLVE_COMPONENT = Symbol(`resolveComponent` );
  const RESOLVE_DYNAMIC_COMPONENT = Symbol(`resolveDynamicComponent` );
  const RESOLVE_DIRECTIVE = Symbol(`resolveDirective` );
  const RESOLVE_FILTER = Symbol(`resolveFilter` );
  const WITH_DIRECTIVES = Symbol(`withDirectives` );
  const RENDER_LIST = Symbol(`renderList` );
  const RENDER_SLOT = Symbol(`renderSlot` );
  const CREATE_SLOTS = Symbol(`createSlots` );
  const TO_DISPLAY_STRING = Symbol(`toDisplayString` );
  const MERGE_PROPS = Symbol(`mergeProps` );
  const NORMALIZE_CLASS = Symbol(`normalizeClass` );
  const NORMALIZE_STYLE = Symbol(`normalizeStyle` );
  const NORMALIZE_PROPS = Symbol(`normalizeProps` );
  const GUARD_REACTIVE_PROPS = Symbol(`guardReactiveProps` );
  const TO_HANDLERS = Symbol(`toHandlers` );
  const CAMELIZE = Symbol(`camelize` );
  const CAPITALIZE = Symbol(`capitalize` );
  const TO_HANDLER_KEY = Symbol(`toHandlerKey` );
  const SET_BLOCK_TRACKING = Symbol(`setBlockTracking` );
  const PUSH_SCOPE_ID = Symbol(`pushScopeId` );
  const POP_SCOPE_ID = Symbol(`popScopeId` );
  const WITH_CTX = Symbol(`withCtx` );
  const UNREF = Symbol(`unref` );
  const IS_REF = Symbol(`isRef` );
  const WITH_MEMO = Symbol(`withMemo` );
  const IS_MEMO_SAME = Symbol(`isMemoSame` );
  // Name mapping for runtime helpers that need to be imported from 'vue' in
  // generated code. Make sure these are correctly exported in the runtime!
  // Using `any` here because TS doesn't allow symbols as index type.
  const helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
  };
  function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach(s => {
          helperNameMap[s] = helpers[s];
      });
  }

  // AST Utilities ---------------------------------------------------------------
  // Some expressions, e.g. sequence and conditional expressions, are never
  // associated with template nodes, so their source locations are just a stub.
  // Container types like CompoundExpression also don't need a real location.
  const locStub = {
      source: '',
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
  };
  function createRoot(children, loc = locStub) {
      return {
          type: 0 /* ROOT */,
          children,
          helpers: [],
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: undefined,
          loc
      };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {
      if (context) {
          if (isBlock) {
              context.helper(OPEN_BLOCK);
              context.helper(getVNodeBlockHelper(context.inSSR, isComponent));
          }
          else {
              context.helper(getVNodeHelper(context.inSSR, isComponent));
          }
          if (directives) {
              context.helper(WITH_DIRECTIVES);
          }
      }
      return {
          type: 13 /* VNODE_CALL */,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          isComponent,
          loc
      };
  }
  function createArrayExpression(elements, loc = locStub) {
      return {
          type: 17 /* JS_ARRAY_EXPRESSION */,
          loc,
          elements
      };
  }
  function createObjectExpression(properties, loc = locStub) {
      return {
          type: 15 /* JS_OBJECT_EXPRESSION */,
          loc,
          properties
      };
  }
  function createObjectProperty(key, value) {
      return {
          type: 16 /* JS_PROPERTY */,
          loc: locStub,
          key: isString(key) ? createSimpleExpression(key, true) : key,
          value
      };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
      return {
          type: 4 /* SIMPLE_EXPRESSION */,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
      };
  }
  function createCompoundExpression(children, loc = locStub) {
      return {
          type: 8 /* COMPOUND_EXPRESSION */,
          loc,
          children
      };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
      return {
          type: 14 /* JS_CALL_EXPRESSION */,
          loc,
          callee,
          arguments: args
      };
  }
  function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
      return {
          type: 18 /* JS_FUNCTION_EXPRESSION */,
          params,
          returns,
          newline,
          isSlot,
          loc
      };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
          type: 19 /* JS_CONDITIONAL_EXPRESSION */,
          test,
          consequent,
          alternate,
          newline,
          loc: locStub
      };
  }
  function createCacheExpression(index, value, isVNode = false) {
      return {
          type: 20 /* JS_CACHE_EXPRESSION */,
          index,
          value,
          isVNode,
          loc: locStub
      };
  }
  function createBlockStatement(body) {
      return {
          type: 21 /* JS_BLOCK_STATEMENT */,
          body,
          loc: locStub
      };
  }

  const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
  function isCoreComponent(tag) {
      if (isBuiltInType(tag, 'Teleport')) {
          return TELEPORT;
      }
      else if (isBuiltInType(tag, 'Suspense')) {
          return SUSPENSE;
      }
      else if (isBuiltInType(tag, 'KeepAlive')) {
          return KEEP_ALIVE;
      }
      else if (isBuiltInType(tag, 'BaseTransition')) {
          return BASE_TRANSITION;
      }
  }
  const nonIdentifierRE = /^\d|[^\$\w]/;
  const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
  const validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
  const validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
  const whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
  /**
   * Simple lexer to check if an expression is a member expression. This is
   * lax and only checks validity at the root level (i.e. does not validate exps
   * inside square brackets), but it's ok since these are only used on template
   * expressions and false positives are invalid expressions in the first place.
   */
  const isMemberExpressionBrowser = (path) => {
      // remove whitespaces around . or [ first
      path = path.trim().replace(whitespaceRE, s => s.trim());
      let state = 0 /* inMemberExp */;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
          const char = path.charAt(i);
          switch (state) {
              case 0 /* inMemberExp */:
                  if (char === '[') {
                      stateStack.push(state);
                      state = 1 /* inBrackets */;
                      currentOpenBracketCount++;
                  }
                  else if (char === '(') {
                      stateStack.push(state);
                      state = 2 /* inParens */;
                      currentOpenParensCount++;
                  }
                  else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                      return false;
                  }
                  break;
              case 1 /* inBrackets */:
                  if (char === `'` || char === `"` || char === '`') {
                      stateStack.push(state);
                      state = 3 /* inString */;
                      currentStringType = char;
                  }
                  else if (char === `[`) {
                      currentOpenBracketCount++;
                  }
                  else if (char === `]`) {
                      if (!--currentOpenBracketCount) {
                          state = stateStack.pop();
                      }
                  }
                  break;
              case 2 /* inParens */:
                  if (char === `'` || char === `"` || char === '`') {
                      stateStack.push(state);
                      state = 3 /* inString */;
                      currentStringType = char;
                  }
                  else if (char === `(`) {
                      currentOpenParensCount++;
                  }
                  else if (char === `)`) {
                      // if the exp ends as a call then it should not be considered valid
                      if (i === path.length - 1) {
                          return false;
                      }
                      if (!--currentOpenParensCount) {
                          state = stateStack.pop();
                      }
                  }
                  break;
              case 3 /* inString */:
                  if (char === currentStringType) {
                      state = stateStack.pop();
                      currentStringType = null;
                  }
                  break;
          }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
  };
  const isMemberExpression = isMemberExpressionBrowser
      ;
  function getInnerRange(loc, offset, length) {
      const source = loc.source.slice(offset, offset + length);
      const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
      };
      if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
          }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column =
          lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
      return pos;
  }
  function assert(condition, msg) {
      /* istanbul ignore if */
      if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
      }
  }
  function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 /* DIRECTIVE */ &&
              (allowEmpty || p.exp) &&
              (isString(name) ? p.name === name : name.test(p.name))) {
              return p;
          }
      }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (dynamicOnly)
                  continue;
              if (p.name === name && (p.value || allowEmpty)) {
                  return p;
              }
          }
          else if (p.name === 'bind' &&
              (p.exp || allowEmpty) &&
              isStaticArgOf(p.arg, name)) {
              return p;
          }
      }
  }
  function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
      return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
          p.name === 'bind' &&
          (!p.arg || // v-bind="obj"
              p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
              !p.arg.isStatic) // v-bind:[foo]
      );
  }
  function isText(node) {
      return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
  }
  function isVSlot(p) {
      return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
  }
  function isTemplateNode(node) {
      return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
  }
  function isSlotOutlet(node) {
      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
  }
  function getVNodeHelper(ssr, isComponent) {
      return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent) {
      return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  const propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
  function getUnnormalizedProps(props, callPath = []) {
      if (props &&
          !isString(props) &&
          props.type === 14 /* JS_CALL_EXPRESSION */) {
          const callee = props.callee;
          if (!isString(callee) && propsHelperSet.has(callee)) {
              return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
          }
      }
      return [props, callPath];
  }
  function injectProp(node, prop, context) {
      let propsWithInjection;
      /**
       * 1. mergeProps(...)
       * 2. toHandlers(...)
       * 3. normalizeProps(...)
       * 4. normalizeProps(guardReactiveProps(...))
       *
       * we need to get the real props before normalization
       */
      let props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
      let callPath = [];
      let parentCall;
      if (props &&
          !isString(props) &&
          props.type === 14 /* JS_CALL_EXPRESSION */) {
          const ret = getUnnormalizedProps(props);
          props = ret[0];
          callPath = ret[1];
          parentCall = callPath[callPath.length - 1];
      }
      if (props == null || isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
      }
      else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
          // merged props... add ours
          // only inject key to object literal if it's the first argument so that
          // if doesn't override user provided keys
          const first = props.arguments[0];
          if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
              first.properties.unshift(prop);
          }
          else {
              if (props.callee === TO_HANDLERS) {
                  // #2366
                  propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
                      createObjectExpression([prop]),
                      props
                  ]);
              }
              else {
                  props.arguments.unshift(createObjectExpression([prop]));
              }
          }
          !propsWithInjection && (propsWithInjection = props);
      }
      else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
          let alreadyExists = false;
          // check existing key to avoid overriding user provided keys
          if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
              const propKeyName = prop.key.content;
              alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                  p.key.content === propKeyName);
          }
          if (!alreadyExists) {
              props.properties.unshift(prop);
          }
          propsWithInjection = props;
      }
      else {
          // single v-bind with expression, return a merged replacement
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
          ]);
          // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
          // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
          // the `guardReactiveProps` will no longer be needed
          if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
              parentCall = callPath[callPath.length - 2];
          }
      }
      if (node.type === 13 /* VNODE_CALL */) {
          if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
          }
          else {
              node.props = propsWithInjection;
          }
      }
      else {
          if (parentCall) {
              parentCall.arguments[0] = propsWithInjection;
          }
          else {
              node.arguments[2] = propsWithInjection;
          }
      }
  }
  function toValidAssetId(name, type) {
      // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();
    })}`;
  }
  function getMemoedVNodeCall(node) {
      if (node.type === 14 /* JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {
          return node.arguments[1].returns;
      }
      else {
          return node;
      }
  }
  function makeBlock(node, { helper, removeHelper, inSSR }) {
      if (!node.isBlock) {
          node.isBlock = true;
          removeHelper(getVNodeHelper(inSSR, node.isComponent));
          helper(OPEN_BLOCK);
          helper(getVNodeBlockHelper(inSSR, node.isComponent));
      }
  }

  const deprecationData = {
      ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
          message: `Platform-native elements with "is" prop will no longer be ` +
              `treated as components in Vue 3 unless the "is" value is explicitly ` +
              `prefixed with "vue:".`,
          link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
          message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
              `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
              `\`v-model:${key}\`.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
              `Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
              `object spread: it will now overwrite an existing non-mergeable attribute ` +
              `that appears before v-bind in the case of conflict. ` +
              `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
              `You can also suppress this warning if the usage is intended.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
          message: `v-if / v-for precedence when used on the same element has changed ` +
              `in Vue 3: v-if now takes higher precedence and will no longer have ` +
              `access to v-for scope variables. It is best to avoid the ambiguity ` +
              `with <template> tags or use a computed property that filters v-for ` +
              `data source.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
          message: `<template> with no special directives will render as a native template ` +
              `element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
          message: `filters have been removed in Vue 3. ` +
              `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
              `Use method calls or computed properties instead.`,
          link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
  };
  function getCompatValue(key, context) {
      const config = context.options
          ? context.options.compatConfig
          : context.compatConfig;
      const value = config && config[key];
      if (key === 'MODE') {
          return value || 3; // compiler defaults to v3 behavior
      }
      else {
          return value;
      }
  }
  function isCompatEnabled(key, context) {
      const mode = getCompatValue('MODE', context);
      const value = getCompatValue(key, context);
      // in v3 mode, only enable if explicitly set to true
      // otherwise enable for any non-false value
      return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      if (enabled) {
          warnDeprecation(key, context, loc, ...args);
      }
      return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === 'suppress-warning') {
          return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
          err.loc = loc;
      context.onWarn(err);
  }

  // The default decoder only provides escapes for characters reserved as part of
  // the template syntax, and is only used if the custom renderer did not provide
  // a platform-specific decoder.
  const decodeRE = /&(gt|lt|amp|apos|quot);/g;
  const decodeMap = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  };
  const defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0 /* HTML */,
      getTextMode: () => 0 /* DATA */,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: true
  };
  function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
      const options = extend({}, defaultParserOptions);
      let key;
      for (key in rawOptions) {
          // @ts-ignore
          options[key] =
              rawOptions[key] === undefined
                  ? defaultParserOptions[key]
                  : rawOptions[key];
      }
      return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false,
          onWarn: options.onWarn
      };
  }
  function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0 /* HTML */;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node = undefined;
          if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                  // '{{'
                  node = parseInterpolation(context, mode);
              }
              else if (mode === 0 /* DATA */ && s[0] === '<') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                  if (s.length === 1) {
                      emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                  }
                  else if (s[1] === '!') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                      if (startsWith(s, '<!--')) {
                          node = parseComment(context);
                      }
                      else if (startsWith(s, '<!DOCTYPE')) {
                          // Ignore DOCTYPE by a limitation.
                          node = parseBogusComment(context);
                      }
                      else if (startsWith(s, '<![CDATA[')) {
                          if (ns !== 0 /* HTML */) {
                              node = parseCDATA(context, ancestors);
                          }
                          else {
                              emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                              node = parseBogusComment(context);
                          }
                      }
                      else {
                          emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (s[1] === '/') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                      if (s.length === 2) {
                          emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                      }
                      else if (s[2] === '>') {
                          emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                          advanceBy(context, 3);
                          continue;
                      }
                      else if (/[a-z]/i.test(s[2])) {
                          emitError(context, 23 /* X_INVALID_END_TAG */);
                          parseTag(context, 1 /* End */, parent);
                          continue;
                      }
                      else {
                          emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (/[a-z]/i.test(s[1])) {
                      node = parseElement(context, ancestors);
                  }
                  else if (s[1] === '?') {
                      emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                      node = parseBogusComment(context);
                  }
                  else {
                      emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                  }
              }
          }
          if (!node) {
              node = parseText(context, mode);
          }
          if (isArray(node)) {
              for (let i = 0; i < node.length; i++) {
                  pushNode(nodes, node[i]);
              }
          }
          else {
              pushNode(nodes, node);
          }
      }
      // Whitespace handling strategy like v2
      let removedWhitespace = false;
      if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
          const shouldCondense = context.options.whitespace !== 'preserve';
          for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (!context.inPre && node.type === 2 /* TEXT */) {
                  if (!/[^\t\r\n\f ]/.test(node.content)) {
                      const prev = nodes[i - 1];
                      const next = nodes[i + 1];
                      // Remove if:
                      // - the whitespace is the first or last node, or:
                      // - (condense mode) the whitespace is adjacent to a comment, or:
                      // - (condense mode) the whitespace is between two elements AND contains newline
                      if (!prev ||
                          !next ||
                          (shouldCondense &&
                              (prev.type === 3 /* COMMENT */ ||
                                  next.type === 3 /* COMMENT */ ||
                                  (prev.type === 1 /* ELEMENT */ &&
                                      next.type === 1 /* ELEMENT */ &&
                                      /[\r\n]/.test(node.content))))) {
                          removedWhitespace = true;
                          nodes[i] = null;
                      }
                      else {
                          // Otherwise, the whitespace is condensed into a single space
                          node.content = ' ';
                      }
                  }
                  else if (shouldCondense) {
                      // in condense mode, consecutive whitespaces in text are condensed
                      // down to a single space.
                      node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                  }
              }
              // Remove comment nodes if desired by configuration.
              else if (node.type === 3 /* COMMENT */ && !context.options.comments) {
                  removedWhitespace = true;
                  nodes[i] = null;
              }
          }
          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
              // remove leading newline per html spec
              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
              const first = nodes[0];
              if (first && first.type === 2 /* TEXT */) {
                  first.content = first.content.replace(/^\r?\n/, '');
              }
          }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
      if (node.type === 2 /* TEXT */) {
          const prev = last(nodes);
          // Merge if both this and the previous node are text and those are
          // consecutive. This happens for cases like "a < b".
          if (prev &&
              prev.type === 2 /* TEXT */ &&
              prev.loc.end.offset === node.loc.start.offset) {
              prev.content += node.content;
              prev.loc.end = node.loc.end;
              prev.loc.source += node.loc.source;
              return;
          }
      }
      nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
      if (context.source.length === 0) {
          emitError(context, 6 /* EOF_IN_CDATA */);
      }
      else {
          advanceBy(context, 3);
      }
      return nodes;
  }
  function parseComment(context) {
      const start = getCursor(context);
      let content;
      // Regular comment.
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(context, 7 /* EOF_IN_COMMENT */);
      }
      else {
          if (match.index <= 3) {
              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
          }
          if (match[1]) {
              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
          }
          content = context.source.slice(4, match.index);
          // Advancing with reporting nested comments.
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
              advanceBy(context, nestedIndex - prevIndex + 1);
              if (nestedIndex + 4 < s.length) {
                  emitError(context, 16 /* NESTED_COMMENT */);
              }
              prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === '?' ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf('>');
      if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
      }
      else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseElement(context, ancestors) {
      // Start tag.
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0 /* Start */, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          // #4030 self-closing <pre> tag
          if (isPreBoundary) {
              context.inPre = false;
          }
          if (isVPreBoundary) {
              context.inVPre = false;
          }
          return element;
      }
      // Children.
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      element.children = children;
      // End tag.
      if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, 1 /* End */, parent);
      }
      else {
          emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
              const first = children[0];
              if (first && startsWith(first.loc.source, '<!--')) {
                  emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
              }
          }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
          context.inPre = false;
      }
      if (isVPreBoundary) {
          context.inVPre = false;
      }
      return element;
  }
  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
  function parseTag(context, type, parent) {
      // Tag open.
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      // save current state in case we need to re-parse attributes with v-pre
      const cursor = getCursor(context);
      const currentSource = context.source;
      // check <pre> tag
      if (context.options.isPreTag(tag)) {
          context.inPre = true;
      }
      // Attributes.
      let props = parseAttributes(context, type);
      // check v-pre
      if (type === 0 /* Start */ &&
          !context.inVPre &&
          props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
          context.inVPre = true;
          // reset context
          extend(context, cursor);
          context.source = currentSource;
          // re-parse attrs and filter out v-pre itself
          props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
      }
      // Tag close.
      let isSelfClosing = false;
      if (context.source.length === 0) {
          emitError(context, 9 /* EOF_IN_TAG */);
      }
      else {
          isSelfClosing = startsWith(context.source, '/>');
          if (type === 1 /* End */ && isSelfClosing) {
              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
      }
      if (type === 1 /* End */) {
          return;
      }
      let tagType = 0 /* ELEMENT */;
      if (!context.inVPre) {
          if (tag === 'slot') {
              tagType = 2 /* SLOT */;
          }
          else if (tag === 'template') {
              if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                  tagType = 3 /* TEMPLATE */;
              }
          }
          else if (isComponent(tag, props, context)) {
              tagType = 1 /* COMPONENT */;
          }
      }
      return {
          type: 1 /* ELEMENT */,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      };
  }
  function isComponent(tag, props, context) {
      const options = context.options;
      if (options.isCustomElement(tag)) {
          return false;
      }
      if (tag === 'component' ||
          /^[A-Z]/.test(tag) ||
          isCoreComponent(tag) ||
          (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
          (options.isNativeTag && !options.isNativeTag(tag))) {
          return true;
      }
      // at this point the tag should be a native tag, but check for potential "is"
      // casting
      for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (p.name === 'is' && p.value) {
                  if (p.value.content.startsWith('vue:')) {
                      return true;
                  }
              }
          }
          else {
              // directive
              // v-is (TODO Deprecate)
              if (p.name === 'is') {
                  return true;
              }
              else if (
              // :is on plain element - only treat as component in compat mode
              p.name === 'bind' &&
                  isStaticArgOf(p.arg, 'is') &&
                  false &&
                  checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                  return true;
              }
          }
      }
  }
  function parseAttributes(context, type) {
      const props = [];
      const attributeNames = new Set();
      while (context.source.length > 0 &&
          !startsWith(context.source, '>') &&
          !startsWith(context.source, '/>')) {
          if (startsWith(context.source, '/')) {
              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
              advanceBy(context, 1);
              advanceSpaces(context);
              continue;
          }
          if (type === 1 /* End */) {
              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
          }
          const attr = parseAttribute(context, attributeNames);
          // Trim whitespace between class
          // https://github.com/vuejs/core/issues/4251
          if (attr.type === 6 /* ATTRIBUTE */ &&
              attr.value &&
              attr.name === 'class') {
              attr.value.content = attr.value.content.replace(/\s+/g, ' ').trim();
          }
          if (type === 0 /* Start */) {
              props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
              emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
          }
          advanceSpaces(context);
      }
      return props;
  }
  function parseAttribute(context, nameSet) {
      // Name.
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
          emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
      }
      nameSet.add(name);
      if (name[0] === '=') {
          emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
      }
      {
          const pattern = /["'<]/g;
          let m;
          while ((m = pattern.exec(name))) {
              emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
          }
      }
      advanceBy(context, name.length);
      // Value
      let value = undefined;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
          }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
          let isPropShorthand = startsWith(name, '.');
          let dirName = match[1] ||
              (isPropShorthand || startsWith(name, ':')
                  ? 'bind'
                  : startsWith(name, '@')
                      ? 'on'
                      : 'slot');
          let arg;
          if (match[2]) {
              const isSlot = dirName === 'slot';
              const startOffset = name.lastIndexOf(match[2]);
              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
              let content = match[2];
              let isStatic = true;
              if (content.startsWith('[')) {
                  isStatic = false;
                  if (!content.endsWith(']')) {
                      emitError(context, 27 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                      content = content.slice(1);
                  }
                  else {
                      content = content.slice(1, content.length - 1);
                  }
              }
              else if (isSlot) {
                  // #1241 special case for v-slot: vuetify relies extensively on slot
                  // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                  // supports such usage so we are keeping it consistent with 2.x.
                  content += match[3] || '';
              }
              arg = {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content,
                  isStatic,
                  constType: isStatic
                      ? 3 /* CAN_STRINGIFY */
                      : 0 /* NOT_CONSTANT */,
                  loc
              };
          }
          if (value && value.isQuoted) {
              const valueLoc = value.loc;
              valueLoc.start.offset++;
              valueLoc.start.column++;
              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
              valueLoc.source = valueLoc.source.slice(1, -1);
          }
          const modifiers = match[3] ? match[3].slice(1).split('.') : [];
          if (isPropShorthand)
              modifiers.push('prop');
          return {
              type: 7 /* DIRECTIVE */,
              name: dirName,
              exp: value && {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content: value.content,
                  isStatic: false,
                  // Treat as non-constant by default. This can be potentially set to
                  // other values by `transformExpression` to make it eligible for hoisting.
                  constType: 0 /* NOT_CONSTANT */,
                  loc: value.loc
              },
              arg,
              modifiers,
              loc
          };
      }
      // missing directive name or illegal directive name
      if (!context.inVPre && startsWith(name, 'v-')) {
          emitError(context, 26 /* X_MISSING_DIRECTIVE_NAME */);
      }
      return {
          type: 6 /* ATTRIBUTE */,
          name,
          value: value && {
              type: 2 /* TEXT */,
              content: value.content,
              loc: value.loc
          },
          loc
      };
  }
  function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
          // Quoted value.
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
          }
          else {
              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
              advanceBy(context, 1);
          }
      }
      else {
          // Unquoted
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
              return undefined;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while ((m = unexpectedChars.exec(match[0]))) {
              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
          }
          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
          return undefined;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
          type: 5 /* INTERPOLATION */,
          content: {
              type: 4 /* SIMPLE_EXPRESSION */,
              isStatic: false,
              // Set `isConstant` to false by default and will decide in transformExpression
              constType: 0 /* NOT_CONSTANT */,
              content,
              loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
      };
  }
  function parseText(context, mode) {
      const endTokens = mode === 3 /* CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
              endIndex = index;
          }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
          type: 2 /* TEXT */,
          content,
          loc: getSelection(context, start)
      };
  }
  /**
   * Get text data with a given length from the current location.
   * This translates HTML entities in the text data.
   */
  function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 /* RAWTEXT */ ||
          mode === 3 /* CDATA */ ||
          !rawText.includes('&')) {
          return rawText;
      }
      else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
      }
  }
  function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
  }
  function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      };
  }
  function last(xs) {
      return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
      return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
          advanceBy(context, match[0].length);
      }
  }
  function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
          loc.offset += offset;
          loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ''
      }));
  }
  function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
          case 0 /* DATA */:
              if (startsWith(s, '</')) {
                  // TODO: probably bad performance
                  for (let i = ancestors.length - 1; i >= 0; --i) {
                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                          return true;
                      }
                  }
              }
              break;
          case 1 /* RCDATA */:
          case 2 /* RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                  return true;
              }
              break;
          }
          case 3 /* CDATA */:
              if (startsWith(s, ']]>')) {
                  return true;
              }
              break;
      }
      return !s;
  }
  function startsWithEndTagOpen(source, tag) {
      return (startsWith(source, '</') &&
          source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&
          /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
  }

  function hoistStatic(root, context) {
      walk(root, context, 
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
      const { children } = root;
      return (children.length === 1 &&
          child.type === 1 /* ELEMENT */ &&
          !isSlotOutlet(child));
  }
  function walk(node, context, doNotHoistNode = false) {
      const { children } = node;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          // only plain elements & text calls are eligible for hoisting.
          if (child.type === 1 /* ELEMENT */ &&
              child.tagType === 0 /* ELEMENT */) {
              const constantType = doNotHoistNode
                  ? 0 /* NOT_CONSTANT */
                  : getConstantType(child, context);
              if (constantType > 0 /* NOT_CONSTANT */) {
                  if (constantType >= 2 /* CAN_HOIST */) {
                      child.codegenNode.patchFlag =
                          -1 /* HOISTED */ + (` /* HOISTED */` );
                      child.codegenNode = context.hoist(child.codegenNode);
                      hoistedCount++;
                      continue;
                  }
              }
              else {
                  // node may contain dynamic children, but its props may be eligible for
                  // hoisting.
                  const codegenNode = child.codegenNode;
                  if (codegenNode.type === 13 /* VNODE_CALL */) {
                      const flag = getPatchFlag(codegenNode);
                      if ((!flag ||
                          flag === 512 /* NEED_PATCH */ ||
                          flag === 1 /* TEXT */) &&
                          getGeneratedPropsConstantType(child, context) >=
                              2 /* CAN_HOIST */) {
                          const props = getNodeProps(child);
                          if (props) {
                              codegenNode.props = context.hoist(props);
                          }
                      }
                      if (codegenNode.dynamicProps) {
                          codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
                      }
                  }
              }
          }
          else if (child.type === 12 /* TEXT_CALL */ &&
              getConstantType(child.content, context) >= 2 /* CAN_HOIST */) {
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
          }
          // walk further
          if (child.type === 1 /* ELEMENT */) {
              const isComponent = child.tagType === 1 /* COMPONENT */;
              if (isComponent) {
                  context.scopes.vSlot++;
              }
              walk(child, context);
              if (isComponent) {
                  context.scopes.vSlot--;
              }
          }
          else if (child.type === 11 /* FOR */) {
              // Do not hoist v-for single child because it has to be a block
              walk(child, context, child.children.length === 1);
          }
          else if (child.type === 9 /* IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                  // Do not hoist v-if single child because it has to be a block
                  walk(child.branches[i], context, child.branches[i].children.length === 1);
              }
          }
      }
      if (hoistedCount && context.transformHoist) {
          context.transformHoist(children, context, node);
      }
      // all children were hoisted - the entire children array is hoistable.
      if (hoistedCount &&
          hoistedCount === originalCount &&
          node.type === 1 /* ELEMENT */ &&
          node.tagType === 0 /* ELEMENT */ &&
          node.codegenNode &&
          node.codegenNode.type === 13 /* VNODE_CALL */ &&
          isArray(node.codegenNode.children)) {
          node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
      }
  }
  function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
          case 1 /* ELEMENT */:
              if (node.tagType !== 0 /* ELEMENT */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const cached = constantCache.get(node);
              if (cached !== undefined) {
                  return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* VNODE_CALL */) {
                  return 0 /* NOT_CONSTANT */;
              }
              if (codegenNode.isBlock &&
                  node.tag !== 'svg' &&
                  node.tag !== 'foreignObject') {
                  return 0 /* NOT_CONSTANT */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag) {
                  let returnType = 3 /* CAN_STRINGIFY */;
                  // Element itself has no patch flag. However we still need to check:
                  // 1. Even for a node with no patch flag, it is possible for it to contain
                  // non-hoistable expressions that refers to scope variables, e.g. compiler
                  // injected keys or cached event handlers. Therefore we need to always
                  // check the codegenNode's props to be sure.
                  const generatedPropsType = getGeneratedPropsConstantType(node, context);
                  if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                      constantCache.set(node, 0 /* NOT_CONSTANT */);
                      return 0 /* NOT_CONSTANT */;
                  }
                  if (generatedPropsType < returnType) {
                      returnType = generatedPropsType;
                  }
                  // 2. its children.
                  for (let i = 0; i < node.children.length; i++) {
                      const childType = getConstantType(node.children[i], context);
                      if (childType === 0 /* NOT_CONSTANT */) {
                          constantCache.set(node, 0 /* NOT_CONSTANT */);
                          return 0 /* NOT_CONSTANT */;
                      }
                      if (childType < returnType) {
                          returnType = childType;
                      }
                  }
                  // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                  // type, check if any of the props can cause the type to be lowered
                  // we can skip can_patch because it's guaranteed by the absence of a
                  // patchFlag.
                  if (returnType > 1 /* CAN_SKIP_PATCH */) {
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                              const expType = getConstantType(p.exp, context);
                              if (expType === 0 /* NOT_CONSTANT */) {
                                  constantCache.set(node, 0 /* NOT_CONSTANT */);
                                  return 0 /* NOT_CONSTANT */;
                              }
                              if (expType < returnType) {
                                  returnType = expType;
                              }
                          }
                      }
                  }
                  // only svg/foreignObject could be block here, however if they are
                  // static then they don't need to be blocks since there will be no
                  // nested updates.
                  if (codegenNode.isBlock) {
                      // except set custom directives.
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* DIRECTIVE */) {
                              constantCache.set(node, 0 /* NOT_CONSTANT */);
                              return 0 /* NOT_CONSTANT */;
                          }
                      }
                      context.removeHelper(OPEN_BLOCK);
                      context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
                      codegenNode.isBlock = false;
                      context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
                  }
                  constantCache.set(node, returnType);
                  return returnType;
              }
              else {
                  constantCache.set(node, 0 /* NOT_CONSTANT */);
                  return 0 /* NOT_CONSTANT */;
              }
          case 2 /* TEXT */:
          case 3 /* COMMENT */:
              return 3 /* CAN_STRINGIFY */;
          case 9 /* IF */:
          case 11 /* FOR */:
          case 10 /* IF_BRANCH */:
              return 0 /* NOT_CONSTANT */;
          case 5 /* INTERPOLATION */:
          case 12 /* TEXT_CALL */:
              return getConstantType(node.content, context);
          case 4 /* SIMPLE_EXPRESSION */:
              return node.constType;
          case 8 /* COMPOUND_EXPRESSION */:
              let returnType = 3 /* CAN_STRINGIFY */;
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  if (isString(child) || isSymbol(child)) {
                      continue;
                  }
                  const childType = getConstantType(child, context);
                  if (childType === 0 /* NOT_CONSTANT */) {
                      return 0 /* NOT_CONSTANT */;
                  }
                  else if (childType < returnType) {
                      returnType = childType;
                  }
              }
              return returnType;
          default:
              return 0 /* NOT_CONSTANT */;
      }
  }
  const allowHoistedHelperSet = new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
  ]);
  function getConstantTypeOfHelperCall(value, context) {
      if (value.type === 14 /* JS_CALL_EXPRESSION */ &&
          !isString(value.callee) &&
          allowHoistedHelperSet.has(value.callee)) {
          const arg = value.arguments[0];
          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
              return getConstantType(arg, context);
          }
          else if (arg.type === 14 /* JS_CALL_EXPRESSION */) {
              // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
              return getConstantTypeOfHelperCall(arg, context);
          }
      }
      return 0 /* NOT_CONSTANT */;
  }
  function getGeneratedPropsConstantType(node, context) {
      let returnType = 3 /* CAN_STRINGIFY */;
      const props = getNodeProps(node);
      if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
          const { properties } = props;
          for (let i = 0; i < properties.length; i++) {
              const { key, value } = properties[i];
              const keyType = getConstantType(key, context);
              if (keyType === 0 /* NOT_CONSTANT */) {
                  return keyType;
              }
              if (keyType < returnType) {
                  returnType = keyType;
              }
              let valueType;
              if (value.type === 4 /* SIMPLE_EXPRESSION */) {
                  valueType = getConstantType(value, context);
              }
              else if (value.type === 14 /* JS_CALL_EXPRESSION */) {
                  // some helper calls can be hoisted,
                  // such as the `normalizeProps` generated by the compiler for pre-normalize class,
                  // in this case we need to respect the ConstantType of the helper's arguments
                  valueType = getConstantTypeOfHelperCall(value, context);
              }
              else {
                  valueType = 0 /* NOT_CONSTANT */;
              }
              if (valueType === 0 /* NOT_CONSTANT */) {
                  return valueType;
              }
              if (valueType < returnType) {
                  returnType = valueType;
              }
          }
      }
      return returnType;
  }
  function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13 /* VNODE_CALL */) {
          return codegenNode.props;
      }
  }
  function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : undefined;
  }

  function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
      const context = {
          // options
          selfName: nameMatch && capitalize(camelize(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          inSSR,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          onWarn,
          compatConfig,
          // state
          root,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new Map(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: {
              vFor: 0,
              vSlot: 0,
              vPre: 0,
              vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          inVOnce: false,
          // methods
          helper(name) {
              const count = context.helpers.get(name) || 0;
              context.helpers.set(name, count + 1);
              return name;
          },
          removeHelper(name) {
              const count = context.helpers.get(name);
              if (count) {
                  const currentCount = count - 1;
                  if (!currentCount) {
                      context.helpers.delete(name);
                  }
                  else {
                      context.helpers.set(name, currentCount);
                  }
              }
          },
          helperString(name) {
              return `_${helperNameMap[context.helper(name)]}`;
          },
          replaceNode(node) {
              /* istanbul ignore if */
              {
                  if (!context.currentNode) {
                      throw new Error(`Node being replaced is already removed.`);
                  }
                  if (!context.parent) {
                      throw new Error(`Cannot replace root node.`);
                  }
              }
              context.parent.children[context.childIndex] = context.currentNode = node;
          },
          removeNode(node) {
              if (!context.parent) {
                  throw new Error(`Cannot remove root node.`);
              }
              const list = context.parent.children;
              const removalIndex = node
                  ? list.indexOf(node)
                  : context.currentNode
                      ? context.childIndex
                      : -1;
              /* istanbul ignore if */
              if (removalIndex < 0) {
                  throw new Error(`node being removed is not a child of current parent`);
              }
              if (!node || node === context.currentNode) {
                  // current node removed
                  context.currentNode = null;
                  context.onNodeRemoved();
              }
              else {
                  // sibling node removed
                  if (context.childIndex > removalIndex) {
                      context.childIndex--;
                      context.onNodeRemoved();
                  }
              }
              context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => { },
          addIdentifiers(exp) {
          },
          removeIdentifiers(exp) {
          },
          hoist(exp) {
              if (isString(exp))
                  exp = createSimpleExpression(exp);
              context.hoists.push(exp);
              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
              identifier.hoisted = exp;
              return identifier;
          },
          cache(exp, isVNode = false) {
              return createCacheExpression(context.cached++, exp, isVNode);
          }
      };
      return context;
  }
  function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
          hoistStatic(root, context);
      }
      if (!options.ssr) {
          createRootCodegen(root, context);
      }
      // finalize meta information
      root.helpers = [...context.helpers.keys()];
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
  }
  function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
          const child = children[0];
          // if the single child is an element, turn it into a block.
          if (isSingleElementRoot(root, child) && child.codegenNode) {
              // single element root is never hoisted so codegenNode will never be
              // SimpleExpressionNode
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13 /* VNODE_CALL */) {
                  makeBlock(codegenNode, context);
              }
              root.codegenNode = codegenNode;
          }
          else {
              // - single <slot/>, IfNode, ForNode: already blocks.
              // - single text node: always patched.
              // root codegen falls through via genNode()
              root.codegenNode = child;
          }
      }
      else if (children.length > 1) {
          // root has multiple nodes - return a fragment block.
          let patchFlag = 64 /* STABLE_FRAGMENT */;
          let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];
          // check if the fragment actually contains a single valid child with
          // the rest being comments
          if (children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
              patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
              patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;
          }
          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, undefined, false /* isComponent */);
      }
      else ;
  }
  function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
          i--;
      };
      for (; i < parent.children.length; i++) {
          const child = parent.children[i];
          if (isString(child))
              continue;
          context.parent = parent;
          context.childIndex = i;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
      }
  }
  function traverseNode(node, context) {
      context.currentNode = node;
      // apply transform plugins
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i = 0; i < nodeTransforms.length; i++) {
          const onExit = nodeTransforms[i](node, context);
          if (onExit) {
              if (isArray(onExit)) {
                  exitFns.push(...onExit);
              }
              else {
                  exitFns.push(onExit);
              }
          }
          if (!context.currentNode) {
              // node was removed
              return;
          }
          else {
              // node may have been replaced
              node = context.currentNode;
          }
      }
      switch (node.type) {
          case 3 /* COMMENT */:
              if (!context.ssr) {
                  // inject import for the Comment symbol, which is needed for creating
                  // comment nodes with `createVNode`
                  context.helper(CREATE_COMMENT);
              }
              break;
          case 5 /* INTERPOLATION */:
              // no need to traverse, but we need to inject toString helper
              if (!context.ssr) {
                  context.helper(TO_DISPLAY_STRING);
              }
              break;
          // for container types, further traverse downwards
          case 9 /* IF */:
              for (let i = 0; i < node.branches.length; i++) {
                  traverseNode(node.branches[i], context);
              }
              break;
          case 10 /* IF_BRANCH */:
          case 11 /* FOR */:
          case 1 /* ELEMENT */:
          case 0 /* ROOT */:
              traverseChildren(node, context);
              break;
      }
      // exit transforms
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
          exitFns[i]();
      }
  }
  function createStructuralDirectiveTransform(name, fn) {
      const matches = isString(name)
          ? (n) => n === name
          : (n) => name.test(n);
      return (node, context) => {
          if (node.type === 1 /* ELEMENT */) {
              const { props } = node;
              // structural directive transforms are not concerned with slots
              // as they are handled separately in vSlot.ts
              if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                  return;
              }
              const exitFns = [];
              for (let i = 0; i < props.length; i++) {
                  const prop = props[i];
                  if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                      // structural directives are removed to avoid infinite recursion
                      // also we remove them *before* applying so that it can further
                      // traverse itself in case it moves the node around
                      props.splice(i, 1);
                      i--;
                      const onExit = fn(node, prop, context);
                      if (onExit)
                          exitFns.push(onExit);
                  }
              }
              return exitFns;
          }
      };
  }

  const PURE_ANNOTATION = `/*#__PURE__*/`;
  const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
  function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {
      const context = {
          mode,
          prefixIdentifiers,
          sourceMap,
          filename,
          scopeId,
          optimizeImports,
          runtimeGlobalName,
          runtimeModuleName,
          ssrRuntimeModuleName,
          ssr,
          isTS,
          inSSR,
          source: ast.loc.source,
          code: ``,
          column: 1,
          line: 1,
          offset: 0,
          indentLevel: 0,
          pure: false,
          map: undefined,
          helper(key) {
              return `_${helperNameMap[key]}`;
          },
          push(code, node) {
              context.code += code;
          },
          indent() {
              newline(++context.indentLevel);
          },
          deindent(withoutNewLine = false) {
              if (withoutNewLine) {
                  --context.indentLevel;
              }
              else {
                  newline(--context.indentLevel);
              }
          },
          newline() {
              newline(context.indentLevel);
          }
      };
      function newline(n) {
          context.push('\n' + `  `.repeat(n));
      }
      return context;
  }
  function generate(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
          options.onContextCreated(context);
      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== 'module';
      // preambles
      // in setup() inline mode, the preamble is generated in a sub context
      // and returned separately.
      const preambleContext = context;
      {
          genFunctionPreamble(ast, preambleContext);
      }
      // enter render function
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
      const signature = args.join(', ');
      {
          push(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
          push(`with (_ctx) {`);
          indent();
          // function mode const declarations should be inside with block
          // also they should be renamed to avoid collision with user properties
          if (hasHelpers) {
              push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`);
              push(`\n`);
              newline();
          }
      }
      // generate asset resolution statements
      if (ast.components.length) {
          genAssets(ast.components, 'component', context);
          if (ast.directives.length || ast.temps > 0) {
              newline();
          }
      }
      if (ast.directives.length) {
          genAssets(ast.directives, 'directive', context);
          if (ast.temps > 0) {
              newline();
          }
      }
      if (ast.temps > 0) {
          push(`let `);
          for (let i = 0; i < ast.temps; i++) {
              push(`${i > 0 ? `, ` : ``}_temp${i}`);
          }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
          push(`\n`);
          newline();
      }
      // generate the VNode tree expression
      if (!ssr) {
          push(`return `);
      }
      if (ast.codegenNode) {
          genNode(ast.codegenNode, context);
      }
      else {
          push(`null`);
      }
      if (useWithBlock) {
          deindent();
          push(`}`);
      }
      deindent();
      push(`}`);
      return {
          ast,
          code: context.code,
          preamble: ``,
          // SourceMapGenerator does have toJSON() method but it's not in the types
          map: context.map ? context.map.toJSON() : undefined
      };
  }
  function genFunctionPreamble(ast, context) {
      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
      const VueBinding = runtimeGlobalName;
      // Generate const declaration for helpers
      // In prefix mode, we place the const declaration at top so it's done
      // only once; But if we not prefixing, we place the declaration inside the
      // with block so it doesn't incur the `in` check cost for every helper access.
      if (ast.helpers.length > 0) {
          {
              // "with" mode.
              // save Vue in a separate variable to avoid collision
              push(`const _Vue = ${VueBinding}\n`);
              // in "with" mode, helpers are declared inside the with block to avoid
              // has check cost, but hoists are lifted out of the function - we need
              // to provide the helper here.
              if (ast.hoists.length) {
                  const staticHelpers = [
                      CREATE_VNODE,
                      CREATE_ELEMENT_VNODE,
                      CREATE_COMMENT,
                      CREATE_TEXT,
                      CREATE_STATIC
                  ]
                      .filter(helper => ast.helpers.includes(helper))
                      .map(aliasHelper)
                      .join(', ');
                  push(`const { ${staticHelpers} } = _Vue\n`);
              }
          }
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
  }
  function genAssets(assets, type, { helper, push, newline, isTS }) {
      const resolver = helper(type === 'component'
              ? RESOLVE_COMPONENT
              : RESOLVE_DIRECTIVE);
      for (let i = 0; i < assets.length; i++) {
          let id = assets[i];
          // potential component implicit self-reference inferred from SFC filename
          const maybeSelfReference = id.endsWith('__self');
          if (maybeSelfReference) {
              id = id.slice(0, -6);
          }
          push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
          if (i < assets.length - 1) {
              newline();
          }
      }
  }
  function genHoists(hoists, context) {
      if (!hoists.length) {
          return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      newline();
      for (let i = 0; i < hoists.length; i++) {
          const exp = hoists[i];
          if (exp) {
              push(`const _hoisted_${i + 1} = ${``}`);
              genNode(exp, context);
              newline();
          }
      }
      context.pure = false;
  }
  function isText$1(n) {
      return (isString(n) ||
          n.type === 4 /* SIMPLE_EXPRESSION */ ||
          n.type === 2 /* TEXT */ ||
          n.type === 5 /* INTERPOLATION */ ||
          n.type === 8 /* COMPOUND_EXPRESSION */);
  }
  function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 ||
          (nodes.some(n => isArray(n) || !isText$1(n)));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (isString(node)) {
              push(node);
          }
          else if (isArray(node)) {
              genNodeListAsArray(node, context);
          }
          else {
              genNode(node, context);
          }
          if (i < nodes.length - 1) {
              if (multilines) {
                  comma && push(',');
                  newline();
              }
              else {
                  comma && push(', ');
              }
          }
      }
  }
  function genNode(node, context) {
      if (isString(node)) {
          context.push(node);
          return;
      }
      if (isSymbol(node)) {
          context.push(context.helper(node));
          return;
      }
      switch (node.type) {
          case 1 /* ELEMENT */:
          case 9 /* IF */:
          case 11 /* FOR */:
              assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +
                      `Apply appropriate transforms first.`);
              genNode(node.codegenNode, context);
              break;
          case 2 /* TEXT */:
              genText(node, context);
              break;
          case 4 /* SIMPLE_EXPRESSION */:
              genExpression(node, context);
              break;
          case 5 /* INTERPOLATION */:
              genInterpolation(node, context);
              break;
          case 12 /* TEXT_CALL */:
              genNode(node.codegenNode, context);
              break;
          case 8 /* COMPOUND_EXPRESSION */:
              genCompoundExpression(node, context);
              break;
          case 3 /* COMMENT */:
              genComment(node, context);
              break;
          case 13 /* VNODE_CALL */:
              genVNodeCall(node, context);
              break;
          case 14 /* JS_CALL_EXPRESSION */:
              genCallExpression(node, context);
              break;
          case 15 /* JS_OBJECT_EXPRESSION */:
              genObjectExpression(node, context);
              break;
          case 17 /* JS_ARRAY_EXPRESSION */:
              genArrayExpression(node, context);
              break;
          case 18 /* JS_FUNCTION_EXPRESSION */:
              genFunctionExpression(node, context);
              break;
          case 19 /* JS_CONDITIONAL_EXPRESSION */:
              genConditionalExpression(node, context);
              break;
          case 20 /* JS_CACHE_EXPRESSION */:
              genCacheExpression(node, context);
              break;
          case 21 /* JS_BLOCK_STATEMENT */:
              genNodeList(node.body, context, true, false);
              break;
          // SSR only types
          case 22 /* JS_TEMPLATE_LITERAL */:
              break;
          case 23 /* JS_IF_STATEMENT */:
              break;
          case 24 /* JS_ASSIGNMENT_EXPRESSION */:
              break;
          case 25 /* JS_SEQUENCE_EXPRESSION */:
              break;
          case 26 /* JS_RETURN_STATEMENT */:
              break;
          /* istanbul ignore next */
          case 10 /* IF_BRANCH */:
              // noop
              break;
          default:
              {
                  assert(false, `unhandled codegen node type: ${node.type}`);
                  // make sure we exhaust all possible types
                  const exhaustiveCheck = node;
                  return exhaustiveCheck;
              }
      }
  }
  function genText(node, context) {
      context.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
          push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
  }
  function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child)) {
              context.push(child);
          }
          else {
              genNode(child, context);
          }
      }
  }
  function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8 /* COMPOUND_EXPRESSION */) {
          push(`[`);
          genCompoundExpression(node, context);
          push(`]`);
      }
      else if (node.isStatic) {
          // only quote keys if necessary
          const text = isSimpleIdentifier(node.content)
              ? node.content
              : JSON.stringify(node.content);
          push(text, node);
      }
      else {
          push(`[${node.content}]`, node);
      }
  }
  function genComment(node, context) {
      const { push, helper, pure } = context;
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
  }
  function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;
      if (directives) {
          push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
          push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
          push(PURE_ANNOTATION);
      }
      const callHelper = isBlock
          ? getVNodeBlockHelper(context.inSSR, isComponent)
          : getVNodeHelper(context.inSSR, isComponent);
      push(helper(callHelper) + `(`, node);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
      push(`)`);
      if (isBlock) {
          push(`)`);
      }
      if (directives) {
          push(`, `);
          genNode(directives, context);
          push(`)`);
      }
  }
  function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
          if (args[i] != null)
              break;
      }
      return args.slice(0, i + 1).map(arg => arg || `null`);
  }
  // JavaScript
  function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
          push(PURE_ANNOTATION);
      }
      push(callee + `(`, node);
      genNodeList(node.arguments, context);
      push(`)`);
  }
  function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
          push(`{}`, node);
          return;
      }
      const multilines = properties.length > 1 ||
          (properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          // key
          genExpressionAsPropertyKey(key, context);
          push(`: `);
          // value
          genNode(value, context);
          if (i < properties.length - 1) {
              // will only reach this if it's multilines
              push(`,`);
              newline();
          }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
      const { push, indent, deindent } = context;
      const { params, returns, body, newline, isSlot } = node;
      if (isSlot) {
          // wrap slot functions with owner context
          push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, node);
      if (isArray(params)) {
          genNodeList(params, context);
      }
      else if (params) {
          genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
          push(`{`);
          indent();
      }
      if (returns) {
          if (newline) {
              push(`return `);
          }
          if (isArray(returns)) {
              genNodeListAsArray(returns, context);
          }
          else {
              genNode(returns, context);
          }
      }
      else if (body) {
          genNode(body, context);
      }
      if (newline || body) {
          deindent();
          push(`}`);
      }
      if (isSlot) {
          push(`)`);
      }
  }
  function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4 /* SIMPLE_EXPRESSION */) {
          const needsParens = !isSimpleIdentifier(test.content);
          needsParens && push(`(`);
          genExpression(test, context);
          needsParens && push(`)`);
      }
      else {
          push(`(`);
          genNode(test, context);
          push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
      if (!isNested) {
          context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
          context.indentLevel--;
      }
      needNewline && deindent(true /* without newline */);
  }
  function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
          indent();
          push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
          newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
          push(`,`);
          newline();
          push(`${helper(SET_BLOCK_TRACKING)}(1),`);
          newline();
          push(`_cache[${node.index}]`);
          deindent();
      }
      push(`)`);
  }

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  const prohibitedKeywordRE = new RegExp('\\b' +
      ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
          'super,throw,while,yield,delete,export,import,return,switch,default,' +
          'extends,finally,continue,debugger,function,arguments,typeof,void')
          .split(',')
          .join('\\b|\\b') +
      '\\b');
  // strip strings in expressions
  const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
  /**
   * Validate a non-prefixed expression.
   * This is only called when using the in-browser runtime compiler since it
   * doesn't prefix expressions.
   */
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
      const exp = node.content;
      // empty expressions are validated per-directive since some directives
      // do allow empty expressions.
      if (!exp.trim()) {
          return;
      }
      try {
          new Function(asRawStatements
              ? ` ${exp} `
              : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
      }
      catch (e) {
          let message = e.message;
          const keywordMatch = exp
              .replace(stripStringRE, '')
              .match(prohibitedKeywordRE);
          if (keywordMatch) {
              message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
          }
          context.onError(createCompilerError(44 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));
      }
  }

  const transformExpression = (node, context) => {
      if (node.type === 5 /* INTERPOLATION */) {
          node.content = processExpression(node.content, context);
      }
      else if (node.type === 1 /* ELEMENT */) {
          // handle directives on element
          for (let i = 0; i < node.props.length; i++) {
              const dir = node.props[i];
              // do not process for v-on & v-for since they are special handled
              if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                  const exp = dir.exp;
                  const arg = dir.arg;
                  // do not process exp if this is v-on:arg - we need special handling
                  // for wrapping inline statements.
                  if (exp &&
                      exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                      !(dir.name === 'on' && arg)) {
                      dir.exp = processExpression(exp, context, 
                      // slot args must be processed as function params
                      dir.name === 'slot');
                  }
                  if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                      dir.arg = processExpression(arg, context);
                  }
              }
          }
      }
  };
  // Important: since this function uses Node.js only dependencies, it should
  // always be used with a leading !true check so that it can be
  // tree-shaken from the browser build.
  function processExpression(node, context, 
  // some expressions like v-slot props & v-for aliases should be parsed as
  // function params
  asParams = false, 
  // v-on handler values may contain multiple statements
  asRawStatements = false, localVars = Object.create(context.identifiers)) {
      {
          {
              // simple in-browser validation (same logic in 2.x)
              validateBrowserExpression(node, context, asParams, asRawStatements);
          }
          return node;
      }
  }

  const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          // #1587: We need to dynamically increment the key based on the current
          // node's sibling nodes, since chained v-if/else branches are
          // rendered at the same depth
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key = 0;
          while (i-- >= 0) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 9 /* IF */) {
                  key += sibling.branches.length;
              }
          }
          // Exit callback. Complete the codegenNode when all children have been
          // transformed.
          return () => {
              if (isRoot) {
                  ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
              }
              else {
                  // attach this branch's codegen node to the v-if root.
                  const parentCondition = getParentCondition(ifNode.codegenNode);
                  parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
              }
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processIf(node, dir, context, processCodegen) {
      if (dir.name !== 'else' &&
          (!dir.exp || !dir.exp.content.trim())) {
          const loc = dir.exp ? dir.exp.loc : node.loc;
          context.onError(createCompilerError(28 /* X_V_IF_NO_EXPRESSION */, dir.loc));
          dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (dir.exp) {
          validateBrowserExpression(dir.exp, context);
      }
      if (dir.name === 'if') {
          const branch = createIfBranch(node, dir);
          const ifNode = {
              type: 9 /* IF */,
              loc: node.loc,
              branches: [branch]
          };
          context.replaceNode(ifNode);
          if (processCodegen) {
              return processCodegen(ifNode, branch, true);
          }
      }
      else {
          // locate the adjacent v-if
          const siblings = context.parent.children;
          const comments = [];
          let i = siblings.indexOf(node);
          while (i-- >= -1) {
              const sibling = siblings[i];
              if (sibling && sibling.type === 3 /* COMMENT */) {
                  context.removeNode(sibling);
                  comments.unshift(sibling);
                  continue;
              }
              if (sibling &&
                  sibling.type === 2 /* TEXT */ &&
                  !sibling.content.trim().length) {
                  context.removeNode(sibling);
                  continue;
              }
              if (sibling && sibling.type === 9 /* IF */) {
                  // Check if v-else was followed by v-else-if
                  if (dir.name === 'else-if' &&
                      sibling.branches[sibling.branches.length - 1].condition === undefined) {
                      context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
                  }
                  // move the node to the if node's branches
                  context.removeNode();
                  const branch = createIfBranch(node, dir);
                  if (comments.length &&
                      // #3619 ignore comments if the v-if is direct child of <transition>
                      !(context.parent &&
                          context.parent.type === 1 /* ELEMENT */ &&
                          isBuiltInType(context.parent.tag, 'transition'))) {
                      branch.children = [...comments, ...branch.children];
                  }
                  // check if user is forcing same key on different branches
                  {
                      const key = branch.userKey;
                      if (key) {
                          sibling.branches.forEach(({ userKey }) => {
                              if (isSameKey(userKey, key)) {
                                  context.onError(createCompilerError(29 /* X_V_IF_SAME_KEY */, branch.userKey.loc));
                              }
                          });
                      }
                  }
                  sibling.branches.push(branch);
                  const onExit = processCodegen && processCodegen(sibling, branch, false);
                  // since the branch was removed, it will not be traversed.
                  // make sure to traverse here.
                  traverseNode(branch, context);
                  // call on exit
                  if (onExit)
                      onExit();
                  // make sure to reset currentNode after traversal to indicate this
                  // node has been removed.
                  context.currentNode = null;
              }
              else {
                  context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
              }
              break;
          }
      }
  }
  function createIfBranch(node, dir) {
      const isTemplateIf = node.tagType === 3 /* TEMPLATE */;
      return {
          type: 10 /* IF_BRANCH */,
          loc: node.loc,
          condition: dir.name === 'else' ? undefined : dir.exp,
          children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],
          userKey: findProp(node, `key`),
          isTemplateIf
      };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
          return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), 
          // make sure to pass in asBlock: true so that the comment node call
          // closes the current block.
          createCallExpression(context.helper(CREATE_COMMENT), [
              '"v-if"' ,
              'true'
          ]));
      }
      else {
          return createChildrenCodegenNode(branch, keyIndex, context);
      }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
      if (needFragmentWrapper) {
          if (children.length === 1 && firstChild.type === 11 /* FOR */) {
              // optimize away nested fragments when child is a ForNode
              const vnodeCall = firstChild.codegenNode;
              injectProp(vnodeCall, keyProperty, context);
              return vnodeCall;
          }
          else {
              let patchFlag = 64 /* STABLE_FRAGMENT */;
              let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];
              // check if the fragment actually contains a single valid child with
              // the rest being comments
              if (!branch.isTemplateIf &&
                  children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
                  patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
                  patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;
              }
              return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (` /* ${patchFlagText} */` ), undefined, undefined, true, false, false /* isComponent */, branch.loc);
          }
      }
      else {
          const ret = firstChild.codegenNode;
          const vnodeCall = getMemoedVNodeCall(ret);
          // Change createVNode to createBlock.
          if (vnodeCall.type === 13 /* VNODE_CALL */) {
              makeBlock(vnodeCall, context);
          }
          // inject branch key
          injectProp(vnodeCall, keyProperty, context);
          return ret;
      }
  }
  function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
          return false;
      }
      if (a.type === 6 /* ATTRIBUTE */) {
          if (a.value.content !== b.value.content) {
              return false;
          }
      }
      else {
          // directive
          const exp = a.exp;
          const branchExp = b.exp;
          if (exp.type !== branchExp.type) {
              return false;
          }
          if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||
              exp.isStatic !== branchExp.isStatic ||
              exp.content !== branchExp.content) {
              return false;
          }
      }
      return true;
  }
  function getParentCondition(node) {
      while (true) {
          if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
              if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                  node = node.alternate;
              }
              else {
                  return node;
              }
          }
          else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {
              node = node.value;
          }
      }
  }

  const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, forNode => {
          // create the loop render function expression now, and add the
          // iterator on exit after all children have been traversed
          const renderExp = createCallExpression(helper(RENDER_LIST), [
              forNode.source
          ]);
          const isTemplate = isTemplateNode(node);
          const memo = findDir(node, 'memo');
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp &&
              (keyProp.type === 6 /* ATTRIBUTE */
                  ? createSimpleExpression(keyProp.value.content, true)
                  : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&
              forNode.source.constType > 0 /* NOT_CONSTANT */;
          const fragmentFlag = isStableFragment
              ? 64 /* STABLE_FRAGMENT */
              : keyProp
                  ? 128 /* KEYED_FRAGMENT */
                  : 256 /* UNKEYED_FRAGMENT */;
          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +
              (` /* ${PatchFlagNames[fragmentFlag]} */` ), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);
          return () => {
              // finish the codegen now that all children have been traversed
              let childBlock;
              const { children } = forNode;
              // check <template v-for> key placement
              if (isTemplate) {
                  node.children.some(c => {
                      if (c.type === 1 /* ELEMENT */) {
                          const key = findProp(c, 'key');
                          if (key) {
                              context.onError(createCompilerError(33 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));
                              return true;
                          }
                      }
                  });
              }
              const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;
              const slotOutlet = isSlotOutlet(node)
                  ? node
                  : isTemplate &&
                      node.children.length === 1 &&
                      isSlotOutlet(node.children[0])
                      ? node.children[0] // api-extractor somehow fails to infer this
                      : null;
              if (slotOutlet) {
                  // <slot v-for="..."> or <template v-for="..."><slot/></template>
                  childBlock = slotOutlet.codegenNode;
                  if (isTemplate && keyProperty) {
                      // <template v-for="..." :key="..."><slot/></template>
                      // we need to inject the key to the renderSlot() call.
                      // the props for renderSlot is passed as the 3rd argument.
                      injectProp(childBlock, keyProperty, context);
                  }
              }
              else if (needFragmentWrapper) {
                  // <template v-for="..."> with text or multi-elements
                  // should generate a fragment block for each loop
                  childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +
                      (` /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`
                          ), undefined, undefined, true, undefined, false /* isComponent */);
              }
              else {
                  // Normal element v-for. Directly use the child's codegenNode
                  // but mark it as a block.
                  childBlock = children[0]
                      .codegenNode;
                  if (isTemplate && keyProperty) {
                      injectProp(childBlock, keyProperty, context);
                  }
                  if (childBlock.isBlock !== !isStableFragment) {
                      if (childBlock.isBlock) {
                          // switch from block to vnode
                          removeHelper(OPEN_BLOCK);
                          removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                      }
                      else {
                          // switch from vnode to block
                          removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                      }
                  }
                  childBlock.isBlock = !isStableFragment;
                  if (childBlock.isBlock) {
                      helper(OPEN_BLOCK);
                      helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                  }
                  else {
                      helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                  }
              }
              if (memo) {
                  const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                      createSimpleExpression(`_cached`)
                  ]));
                  loop.body = createBlockStatement([
                      createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                      createCompoundExpression([
                          `if (_cached`,
                          ...(keyExp ? [` && _cached.key === `, keyExp] : []),
                          ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                      ]),
                      createCompoundExpression([`const _item = `, childBlock]),
                      createSimpleExpression(`_item.memo = _memo`),
                      createSimpleExpression(`return _item`)
                  ]);
                  renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
              }
              else {
                  renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
              }
          };
      });
  });
  // target-agnostic transform used for both Client and SSR
  function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
          context.onError(createCompilerError(31 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
          return;
      }
      const parseResult = parseForExpression(
      // can only be simple expression because vFor transform is applied
      // before expression transform.
      dir.exp, context);
      if (!parseResult) {
          context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
          return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
          type: 11 /* FOR */,
          loc: dir.loc,
          source,
          valueAlias: value,
          keyAlias: key,
          objectIndexAlias: index,
          parseResult,
          children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      // bookkeeping
      scopes.vFor++;
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
          scopes.vFor--;
          if (onExit)
              onExit();
      };
  }
  const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  // This regex doesn't cover the case if key or index aliases have destructuring,
  // but those do not make sense in the first place, so this works in practice.
  const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  const stripParensRE = /^\(|\)$/g;
  function parseForExpression(input, context) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
          return;
      const [, LHS, RHS] = inMatch;
      const result = {
          source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
          value: undefined,
          key: undefined,
          index: undefined
      };
      {
          validateBrowserExpression(result.source, context);
      }
      let valueContent = LHS.trim().replace(stripParensRE, '').trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
          valueContent = valueContent.replace(forIteratorRE, '').trim();
          const keyContent = iteratorMatch[1].trim();
          let keyOffset;
          if (keyContent) {
              keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
              result.key = createAliasExpression(loc, keyContent, keyOffset);
              {
                  validateBrowserExpression(result.key, context, true);
              }
          }
          if (iteratorMatch[2]) {
              const indexContent = iteratorMatch[2].trim();
              if (indexContent) {
                  result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                      ? keyOffset + keyContent.length
                      : trimmedOffset + valueContent.length));
                  {
                      validateBrowserExpression(result.index, context, true);
                  }
              }
          }
      }
      if (valueContent) {
          result.value = createAliasExpression(loc, valueContent, trimmedOffset);
          {
              validateBrowserExpression(result.value, context, true);
          }
      }
      return result;
  }
  function createAliasExpression(range, content, offset) {
      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
  }
  function createForLoopParams({ value, key, index }, memoArgs = []) {
      return createParamsList([value, key, index, ...memoArgs]);
  }
  function createParamsList(args) {
      let i = args.length;
      while (i--) {
          if (args[i])
              break;
      }
      return args
          .slice(0, i + 1)
          .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));
  }

  const defaultFallback = createSimpleExpression(`undefined`, false);
  // A NodeTransform that:
  // 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
  //    by transformExpression. This is only applied in non-browser builds with
  //    { prefixIdentifiers: true }.
  // 2. Track v-slot depths so that we know a slot is inside another slot.
  //    Note the exit callback is executed before buildSlots() on the same node,
  //    so only nested slots see positive numbers.
  const trackSlotScopes = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          (node.tagType === 1 /* COMPONENT */ ||
              node.tagType === 3 /* TEMPLATE */)) {
          // We are only checking non-empty v-slot here
          // since we only care about slots that introduce scope variables.
          const vSlot = findDir(node, 'slot');
          if (vSlot) {
              vSlot.exp;
              context.scopes.vSlot++;
              return () => {
                  context.scopes.vSlot--;
              };
          }
      }
  };
  const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
  // Instead of being a DirectiveTransform, v-slot processing is called during
  // transformElement to build the slots object for a component.
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      // If the slot is inside a v-for or another v-slot, force it to be dynamic
      // since it likely uses a scope variable.
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      // 1. Check for slot with slotProps on component itself.
      //    <Comp v-slot="{ prop }"/>
      const onComponentSlot = findDir(node, 'slot', true);
      if (onComponentSlot) {
          const { arg, exp } = onComponentSlot;
          if (arg && !isStaticExp(arg)) {
              hasDynamicSlots = true;
          }
          slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
      }
      // 2. Iterate through children and check for template slots
      //    <template v-slot:foo="{ prop }">
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = new Set();
      for (let i = 0; i < children.length; i++) {
          const slotElement = children[i];
          let slotDir;
          if (!isTemplateNode(slotElement) ||
              !(slotDir = findDir(slotElement, 'slot', true))) {
              // not a <template v-slot>, skip.
              if (slotElement.type !== 3 /* COMMENT */) {
                  implicitDefaultChildren.push(slotElement);
              }
              continue;
          }
          if (onComponentSlot) {
              // already has on-component slot - this is incorrect usage.
              context.onError(createCompilerError(37 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
              break;
          }
          hasTemplateSlots = true;
          const { children: slotChildren, loc: slotLoc } = slotElement;
          const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
          // check if name is dynamic.
          let staticSlotName;
          if (isStaticExp(slotName)) {
              staticSlotName = slotName ? slotName.content : `default`;
          }
          else {
              hasDynamicSlots = true;
          }
          const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
          // check if this slot is conditional (v-if/v-for)
          let vIf;
          let vElse;
          let vFor;
          if ((vIf = findDir(slotElement, 'if'))) {
              hasDynamicSlots = true;
              dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
          }
          else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
              // find adjacent v-if
              let j = i;
              let prev;
              while (j--) {
                  prev = children[j];
                  if (prev.type !== 3 /* COMMENT */) {
                      break;
                  }
              }
              if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                  // remove node
                  children.splice(i, 1);
                  i--;
                  // attach this slot to previous conditional
                  let conditional = dynamicSlots[dynamicSlots.length - 1];
                  while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                      conditional = conditional.alternate;
                  }
                  conditional.alternate = vElse.exp
                      ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                      : buildDynamicSlot(slotName, slotFunction);
              }
              else {
                  context.onError(createCompilerError(30 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
              }
          }
          else if ((vFor = findDir(slotElement, 'for'))) {
              hasDynamicSlots = true;
              const parseResult = vFor.parseResult ||
                  parseForExpression(vFor.exp, context);
              if (parseResult) {
                  // Render the dynamic slots as an array and add it to the createSlot()
                  // args. The runtime knows how to handle it appropriately.
                  dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                      parseResult.source,
                      createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                  ]));
              }
              else {
                  context.onError(createCompilerError(32 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
              }
          }
          else {
              // check duplicate static names
              if (staticSlotName) {
                  if (seenSlotNames.has(staticSlotName)) {
                      context.onError(createCompilerError(38 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                      continue;
                  }
                  seenSlotNames.add(staticSlotName);
                  if (staticSlotName === 'default') {
                      hasNamedDefaultSlot = true;
                  }
              }
              slotsProperties.push(createObjectProperty(slotName, slotFunction));
          }
      }
      if (!onComponentSlot) {
          const buildDefaultSlotProperty = (props, children) => {
              const fn = buildSlotFn(props, children, loc);
              return createObjectProperty(`default`, fn);
          };
          if (!hasTemplateSlots) {
              // implicit default slot (on component)
              slotsProperties.push(buildDefaultSlotProperty(undefined, children));
          }
          else if (implicitDefaultChildren.length &&
              // #3766
              // with whitespace: 'preserve', whitespaces between slots will end up in
              // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
              implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {
              // implicit default slot (mixed with named slots)
              if (hasNamedDefaultSlot) {
                  context.onError(createCompilerError(39 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
              }
              else {
                  slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
              }
          }
      }
      const slotFlag = hasDynamicSlots
          ? 2 /* DYNAMIC */
          : hasForwardedSlots(node.children)
              ? 3 /* FORWARDED */
              : 1 /* STABLE */;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, 
      // 2 = compiled but dynamic = can skip normalization, but must run diff
      // 1 = compiled and static = can skip normalization AND diff as optimized
      createSimpleExpression(slotFlag + (` /* ${slotFlagsText[slotFlag]} */` ), false))), loc);
      if (dynamicSlots.length) {
          slots = createCallExpression(context.helper(CREATE_SLOTS), [
              slots,
              createArrayExpression(dynamicSlots)
          ]);
      }
      return {
          slots,
          hasDynamicSlots
      };
  }
  function buildDynamicSlot(name, fn) {
      return createObjectExpression([
          createObjectProperty(`name`, name),
          createObjectProperty(`fn`, fn)
      ]);
  }
  function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          switch (child.type) {
              case 1 /* ELEMENT */:
                  if (child.tagType === 2 /* SLOT */ ||
                      hasForwardedSlots(child.children)) {
                      return true;
                  }
                  break;
              case 9 /* IF */:
                  if (hasForwardedSlots(child.branches))
                      return true;
                  break;
              case 10 /* IF_BRANCH */:
              case 11 /* FOR */:
                  if (hasForwardedSlots(child.children))
                      return true;
                  break;
          }
      }
      return false;
  }
  function isNonWhitespaceContent(node) {
      if (node.type !== 2 /* TEXT */ && node.type !== 12 /* TEXT_CALL */)
          return true;
      return node.type === 2 /* TEXT */
          ? !!node.content.trim()
          : isNonWhitespaceContent(node.content);
  }

  // some directive transforms (e.g. v-model) may return a symbol for runtime
  // import, which should be used instead of a resolveDirective call.
  const directiveImportMap = new WeakMap();
  // generate a JavaScript AST for this element's codegen
  const transformElement = (node, context) => {
      // perform the work on exit, after all child expressions have been
      // processed and merged.
      return function postTransformElement() {
          node = context.currentNode;
          if (!(node.type === 1 /* ELEMENT */ &&
              (node.tagType === 0 /* ELEMENT */ ||
                  node.tagType === 1 /* COMPONENT */))) {
              return;
          }
          const { tag, props } = node;
          const isComponent = node.tagType === 1 /* COMPONENT */;
          // The goal of the transform is to create a codegenNode implementing the
          // VNodeCall interface.
          let vnodeTag = isComponent
              ? resolveComponentType(node, context)
              : `"${tag}"`;
          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = 
          // dynamic component may resolve to plain elements
          isDynamicComponent ||
              vnodeTag === TELEPORT ||
              vnodeTag === SUSPENSE ||
              (!isComponent &&
                  // <svg> and <foreignObject> must be forced into blocks so that block
                  // updates inside get proper isSVG flag at runtime. (#639, #643)
                  // This is technically web-specific, but splitting the logic out of core
                  // leads to too much unnecessary complexity.
                  (tag === 'svg' || tag === 'foreignObject'));
          // props
          if (props.length > 0) {
              const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);
              vnodeProps = propsBuildResult.props;
              patchFlag = propsBuildResult.patchFlag;
              dynamicPropNames = propsBuildResult.dynamicPropNames;
              const directives = propsBuildResult.directives;
              vnodeDirectives =
                  directives && directives.length
                      ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                      : undefined;
              if (propsBuildResult.shouldUseBlock) {
                  shouldUseBlock = true;
              }
          }
          // children
          if (node.children.length > 0) {
              if (vnodeTag === KEEP_ALIVE) {
                  // Although a built-in component, we compile KeepAlive with raw children
                  // instead of slot functions so that it can be used inside Transition
                  // or other Transition-wrapping HOCs.
                  // To ensure correct updates with block optimizations, we need to:
                  // 1. Force keep-alive into a block. This avoids its children being
                  //    collected by a parent block.
                  shouldUseBlock = true;
                  // 2. Force keep-alive to always be updated, since it uses raw children.
                  patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  if (node.children.length > 1) {
                      context.onError(createCompilerError(45 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              }
              const shouldBuildAsSlots = isComponent &&
                  // Teleport is not a real component and has dedicated runtime handling
                  vnodeTag !== TELEPORT &&
                  // explained above.
                  vnodeTag !== KEEP_ALIVE;
              if (shouldBuildAsSlots) {
                  const { slots, hasDynamicSlots } = buildSlots(node, context);
                  vnodeChildren = slots;
                  if (hasDynamicSlots) {
                      patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                  }
              }
              else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                  const child = node.children[0];
                  const type = child.type;
                  // check for dynamic text children
                  const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                      type === 8 /* COMPOUND_EXPRESSION */;
                  if (hasDynamicTextChild &&
                      getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                      patchFlag |= 1 /* TEXT */;
                  }
                  // pass directly if the only child is a text node
                  // (plain / interpolation / expression)
                  if (hasDynamicTextChild || type === 2 /* TEXT */) {
                      vnodeChildren = child;
                  }
                  else {
                      vnodeChildren = node.children;
                  }
              }
              else {
                  vnodeChildren = node.children;
              }
          }
          // patchFlag & dynamicPropNames
          if (patchFlag !== 0) {
              {
                  if (patchFlag < 0) {
                      // special flags (negative and mutually exclusive)
                      vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
                  }
                  else {
                      // bitwise flags
                      const flagNames = Object.keys(PatchFlagNames)
                          .map(Number)
                          .filter(n => n > 0 && patchFlag & n)
                          .map(n => PatchFlagNames[n])
                          .join(`, `);
                      vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
                  }
              }
              if (dynamicPropNames && dynamicPropNames.length) {
                  vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
              }
          }
          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);
      };
  };
  function resolveComponentType(node, context, ssr = false) {
      let { tag } = node;
      // 1. dynamic component
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node, 'is');
      if (isProp) {
          if (isExplicitDynamic ||
              (false )) {
              const exp = isProp.type === 6 /* ATTRIBUTE */
                  ? isProp.value && createSimpleExpression(isProp.value.content, true)
                  : isProp.exp;
              if (exp) {
                  return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                      exp
                  ]);
              }
          }
          else if (isProp.type === 6 /* ATTRIBUTE */ &&
              isProp.value.content.startsWith('vue:')) {
              // <button is="vue:xxx">
              // if not <component>, only is value that starts with "vue:" will be
              // treated as component by the parse phase and reach here, unless it's
              // compat mode where all is values are considered components
              tag = isProp.value.content.slice(4);
          }
      }
      // 1.5 v-is (TODO: Deprecate)
      const isDir = !isExplicitDynamic && findDir(node, 'is');
      if (isDir && isDir.exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              isDir.exp
          ]);
      }
      // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
          // built-ins are simply fallthroughs / have special handling during ssr
          // so we don't need to import their runtime equivalents
          if (!ssr)
              context.helper(builtIn);
          return builtIn;
      }
      // 5. user component (resolve)
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {
      const { tag, loc: elementLoc, children } = node;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      // patchFlag analysis
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key, value }) => {
          if (isStaticExp(key)) {
              const name = key.content;
              const isEventHandler = isOn(name);
              if (isEventHandler &&
                  (!isComponent || isDynamicComponent) &&
                  // omit the flag for click handlers because hydration gives click
                  // dedicated fast path.
                  name.toLowerCase() !== 'onclick' &&
                  // omit v-model handlers
                  name !== 'onUpdate:modelValue' &&
                  // omit onVnodeXXX hooks
                  !isReservedProp(name)) {
                  hasHydrationEventBinding = true;
              }
              if (isEventHandler && isReservedProp(name)) {
                  hasVnodeHook = true;
              }
              if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                  ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                      value.type === 8 /* COMPOUND_EXPRESSION */) &&
                      getConstantType(value, context) > 0)) {
                  // skip if the prop is a cached handler or has constant value
                  return;
              }
              if (name === 'ref') {
                  hasRef = true;
              }
              else if (name === 'class') {
                  hasClassBinding = true;
              }
              else if (name === 'style') {
                  hasStyleBinding = true;
              }
              else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                  dynamicPropNames.push(name);
              }
              // treat the dynamic class and style binding of the component as dynamic props
              if (isComponent &&
                  (name === 'class' || name === 'style') &&
                  !dynamicPropNames.includes(name)) {
                  dynamicPropNames.push(name);
              }
          }
          else {
              hasDynamicKeys = true;
          }
      };
      for (let i = 0; i < props.length; i++) {
          // static attribute
          const prop = props[i];
          if (prop.type === 6 /* ATTRIBUTE */) {
              const { loc, name, value } = prop;
              let isStatic = true;
              if (name === 'ref') {
                  hasRef = true;
                  if (context.scopes.vFor > 0) {
                      properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
                  }
              }
              // skip is on <component>, or is="vue:xxx"
              if (name === 'is' &&
                  (isComponentTag(tag) ||
                      (value && value.content.startsWith('vue:')) ||
                      (false ))) {
                  continue;
              }
              properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
          }
          else {
              // directives
              const { name, arg, exp, loc } = prop;
              const isVBind = name === 'bind';
              const isVOn = name === 'on';
              // skip v-slot - it is handled by its dedicated transform.
              if (name === 'slot') {
                  if (!isComponent) {
                      context.onError(createCompilerError(40 /* X_V_SLOT_MISPLACED */, loc));
                  }
                  continue;
              }
              // skip v-once/v-memo - they are handled by dedicated transforms.
              if (name === 'once' || name === 'memo') {
                  continue;
              }
              // skip v-is and :is on <component>
              if (name === 'is' ||
                  (isVBind &&
                      isStaticArgOf(arg, 'is') &&
                      (isComponentTag(tag) ||
                          (false )))) {
                  continue;
              }
              // skip v-on in SSR compilation
              if (isVOn && ssr) {
                  continue;
              }
              if (
              // #938: elements with dynamic keys should be forced into blocks
              (isVBind && isStaticArgOf(arg, 'key')) ||
                  // inline before-update hooks need to force block so that it is invoked
                  // before children
                  (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {
                  shouldUseBlock = true;
              }
              if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {
                  properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));
              }
              // special case for v-bind and v-on with no argument
              if (!arg && (isVBind || isVOn)) {
                  hasDynamicKeys = true;
                  if (exp) {
                      if (properties.length) {
                          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                          properties = [];
                      }
                      if (isVBind) {
                          mergeArgs.push(exp);
                      }
                      else {
                          // v-on="obj" -> toHandlers(obj)
                          mergeArgs.push({
                              type: 14 /* JS_CALL_EXPRESSION */,
                              loc,
                              callee: context.helper(TO_HANDLERS),
                              arguments: [exp]
                          });
                      }
                  }
                  else {
                      context.onError(createCompilerError(isVBind
                          ? 34 /* X_V_BIND_NO_EXPRESSION */
                          : 35 /* X_V_ON_NO_EXPRESSION */, loc));
                  }
                  continue;
              }
              const directiveTransform = context.directiveTransforms[name];
              if (directiveTransform) {
                  // has built-in directive transform.
                  const { props, needRuntime } = directiveTransform(prop, node, context);
                  !ssr && props.forEach(analyzePatchFlag);
                  properties.push(...props);
                  if (needRuntime) {
                      runtimeDirectives.push(prop);
                      if (isSymbol(needRuntime)) {
                          directiveImportMap.set(prop, needRuntime);
                      }
                  }
              }
              else if (!isBuiltInDirective(name)) {
                  // no built-in transform, this is a user custom directive.
                  runtimeDirectives.push(prop);
                  // custom dirs may use beforeUpdate so they need to force blocks
                  // to ensure before-update gets called before children update
                  if (hasChildren) {
                      shouldUseBlock = true;
                  }
              }
          }
      }
      let propsExpression = undefined;
      // has v-bind="object" or v-on="object", wrap with mergeProps
      if (mergeArgs.length) {
          if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
          }
          if (mergeArgs.length > 1) {
              propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
          }
          else {
              // single v-bind with nothing else - no need for a mergeProps call
              propsExpression = mergeArgs[0];
          }
      }
      else if (properties.length) {
          propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      // patchFlag analysis
      if (hasDynamicKeys) {
          patchFlag |= 16 /* FULL_PROPS */;
      }
      else {
          if (hasClassBinding && !isComponent) {
              patchFlag |= 2 /* CLASS */;
          }
          if (hasStyleBinding && !isComponent) {
              patchFlag |= 4 /* STYLE */;
          }
          if (dynamicPropNames.length) {
              patchFlag |= 8 /* PROPS */;
          }
          if (hasHydrationEventBinding) {
              patchFlag |= 32 /* HYDRATE_EVENTS */;
          }
      }
      if (!shouldUseBlock &&
          (patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
          (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
          patchFlag |= 512 /* NEED_PATCH */;
      }
      // pre-normalize props, SSR is skipped for now
      if (!context.inSSR && propsExpression) {
          switch (propsExpression.type) {
              case 15 /* JS_OBJECT_EXPRESSION */:
                  // means that there is no v-bind,
                  // but still need to deal with dynamic key binding
                  let classKeyIndex = -1;
                  let styleKeyIndex = -1;
                  let hasDynamicKey = false;
                  for (let i = 0; i < propsExpression.properties.length; i++) {
                      const key = propsExpression.properties[i].key;
                      if (isStaticExp(key)) {
                          if (key.content === 'class') {
                              classKeyIndex = i;
                          }
                          else if (key.content === 'style') {
                              styleKeyIndex = i;
                          }
                      }
                      else if (!key.isHandlerKey) {
                          hasDynamicKey = true;
                      }
                  }
                  const classProp = propsExpression.properties[classKeyIndex];
                  const styleProp = propsExpression.properties[styleKeyIndex];
                  // no dynamic key
                  if (!hasDynamicKey) {
                      if (classProp && !isStaticExp(classProp.value)) {
                          classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
                      }
                      if (styleProp &&
                          // the static style is compiled into an object,
                          // so use `hasStyleBinding` to ensure that it is a dynamic style binding
                          (hasStyleBinding ||
                              (styleProp.value.type === 4 /* SIMPLE_EXPRESSION */ &&
                                  styleProp.value.content.trim()[0] === `[`) ||
                              // v-bind:style and style both exist,
                              // v-bind:style with static literal object
                              styleProp.value.type === 17 /* JS_ARRAY_EXPRESSION */)) {
                          styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
                      }
                  }
                  else {
                      // dynamic key binding, wrap with `normalizeProps`
                      propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
                  }
                  break;
              case 14 /* JS_CALL_EXPRESSION */:
                  // mergeProps call, do nothing
                  break;
              default:
                  // single v-bind
                  propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
                      createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                          propsExpression
                      ])
                  ]);
                  break;
          }
      }
      return {
          props: propsExpression,
          directives: runtimeDirectives,
          patchFlag,
          dynamicPropNames,
          shouldUseBlock
      };
  }
  // Dedupe props in an object literal.
  // Literal duplicated attributes would have been warned during the parse phase,
  // however, it's possible to encounter duplicated `onXXX` handlers with different
  // modifiers. We also need to merge static and dynamic class / style attributes.
  // - onXXX handlers / style: merge into array
  // - class: merge into single expression with concatenation
  function dedupeProperties(properties) {
      const knownProps = new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
          const prop = properties[i];
          // dynamic keys are always allowed
          if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
              deduped.push(prop);
              continue;
          }
          const name = prop.key.content;
          const existing = knownProps.get(name);
          if (existing) {
              if (name === 'style' || name === 'class' || isOn(name)) {
                  mergeAsArray$1(existing, prop);
              }
              // unexpected duplicate, should have emitted error during parse
          }
          else {
              knownProps.set(name, prop);
              deduped.push(prop);
          }
      }
      return deduped;
  }
  function mergeAsArray$1(existing, incoming) {
      if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
          existing.value.elements.push(incoming.value);
      }
      else {
          existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
  }
  function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
          // built-in directive with runtime
          dirArgs.push(context.helperString(runtime));
      }
      else {
          {
              // inject statement for resolving directive
              context.helper(RESOLVE_DIRECTIVE);
              context.directives.add(dir.name);
              dirArgs.push(toValidAssetId(dir.name, `directive`));
          }
      }
      const { loc } = dir;
      if (dir.exp)
          dirArgs.push(dir.exp);
      if (dir.arg) {
          if (!dir.exp) {
              dirArgs.push(`void 0`);
          }
          dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
          if (!dir.arg) {
              if (!dir.exp) {
                  dirArgs.push(`void 0`);
              }
              dirArgs.push(`void 0`);
          }
          const trueExpression = createSimpleExpression(`true`, false, loc);
          dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
          propsNamesString += JSON.stringify(props[i]);
          if (i < l - 1)
              propsNamesString += ', ';
      }
      return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
      return tag === 'component' || tag === 'Component';
  }

  const transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context);
          const slotArgs = [
              context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
              slotName,
              '{}',
              'undefined',
              'true'
          ];
          let expectedLen = 2;
          if (slotProps) {
              slotArgs[2] = slotProps;
              expectedLen = 3;
          }
          if (children.length) {
              slotArgs[3] = createFunctionExpression([], children, false, false, loc);
              expectedLen = 4;
          }
          if (context.scopeId && !context.slotted) {
              expectedLen = 5;
          }
          slotArgs.splice(expectedLen); // remove unused arguments
          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
  };
  function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = undefined;
      const nonNameProps = [];
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (p.value) {
                  if (p.name === 'name') {
                      slotName = JSON.stringify(p.value.content);
                  }
                  else {
                      p.name = camelize(p.name);
                      nonNameProps.push(p);
                  }
              }
          }
          else {
              if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {
                  if (p.exp)
                      slotName = p.exp;
              }
              else {
                  if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
                      p.arg.content = camelize(p.arg.content);
                  }
                  nonNameProps.push(p);
              }
          }
      }
      if (nonNameProps.length > 0) {
          const { props, directives } = buildProps(node, context, nonNameProps, false, false);
          slotProps = props;
          if (directives.length) {
              context.onError(createCompilerError(36 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
          }
      }
      return {
          slotName,
          slotProps
      };
  }

  const fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
  const transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(35 /* X_V_ON_NO_EXPRESSION */, loc));
      }
      let eventName;
      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
          if (arg.isStatic) {
              let rawName = arg.content;
              // TODO deprecate @vnodeXXX usage
              if (rawName.startsWith('vue:')) {
                  rawName = `vnode-${rawName.slice(4)}`;
              }
              // for all event listeners, auto convert it to camelCase. See issue #2249
              eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
          }
          else {
              // #2388
              eventName = createCompoundExpression([
                  `${context.helperString(TO_HANDLER_KEY)}(`,
                  arg,
                  `)`
              ]);
          }
      }
      else {
          // already a compound expression.
          eventName = arg;
          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
      }
      // handler processing
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
          exp = undefined;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
          const isMemberExp = isMemberExpression(exp.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          {
              validateBrowserExpression(exp, context, false, hasMultipleStatements);
          }
          if (isInlineStatement || (shouldCache && isMemberExp)) {
              // wrap inline statement in a function expression
              exp = createCompoundExpression([
                  `${isInlineStatement
                    ? `$event`
                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
                  exp,
                  hasMultipleStatements ? `}` : `)`
              ]);
          }
      }
      let ret = {
          props: [
              createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
      };
      // apply extended compiler augmentor
      if (augmentor) {
          ret = augmentor(ret);
      }
      if (shouldCache) {
          // cache handlers so that it's always the same handler being passed down.
          // this avoids unnecessary re-renders when users use inline handlers on
          // components.
          ret.props[0].value = context.cache(ret.props[0].value);
      }
      // mark the key as handler for props normalization check
      ret.props.forEach(p => (p.key.isHandlerKey = true));
      return ret;
  };

  // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
  // codegen for the entire props object. This transform here is only for v-bind
  // *with* args.
  const transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
      }
      else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
      }
      // .sync is replaced by v-model:arg
      if (modifiers.includes('camel')) {
          if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
              if (arg.isStatic) {
                  arg.content = camelize(arg.content);
              }
              else {
                  arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
              }
          }
          else {
              arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
              arg.children.push(`)`);
          }
      }
      if (!context.inSSR) {
          if (modifiers.includes('prop')) {
              injectPrefix(arg, '.');
          }
          if (modifiers.includes('attr')) {
              injectPrefix(arg, '^');
          }
      }
      if (!exp ||
          (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {
          context.onError(createCompilerError(34 /* X_V_BIND_NO_EXPRESSION */, loc));
          return {
              props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
          };
      }
      return {
          props: [createObjectProperty(arg, exp)]
      };
  };
  const injectPrefix = (arg, prefix) => {
      if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
          if (arg.isStatic) {
              arg.content = prefix + arg.content;
          }
          else {
              arg.content = `\`${prefix}\${${arg.content}}\``;
          }
      }
      else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
      }
  };

  // Merge adjacent text nodes and expressions into a single expression
  // e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
  const transformText = (node, context) => {
      if (node.type === 0 /* ROOT */ ||
          node.type === 1 /* ELEMENT */ ||
          node.type === 11 /* FOR */ ||
          node.type === 10 /* IF_BRANCH */) {
          // perform the transform on node exit so that all expressions have already
          // been processed.
          return () => {
              const children = node.children;
              let currentContainer = undefined;
              let hasText = false;
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText(child)) {
                      hasText = true;
                      for (let j = i + 1; j < children.length; j++) {
                          const next = children[j];
                          if (isText(next)) {
                              if (!currentContainer) {
                                  currentContainer = children[i] = createCompoundExpression([child], child.loc);
                              }
                              // merge adjacent text node into current
                              currentContainer.children.push(` + `, next);
                              children.splice(j, 1);
                              j--;
                          }
                          else {
                              currentContainer = undefined;
                              break;
                          }
                      }
                  }
              }
              if (!hasText ||
                  // if this is a plain element with a single text child, leave it
                  // as-is since the runtime has dedicated fast path for this by directly
                  // setting textContent of the element.
                  // for component root it's always normalized anyway.
                  (children.length === 1 &&
                      (node.type === 0 /* ROOT */ ||
                          (node.type === 1 /* ELEMENT */ &&
                              node.tagType === 0 /* ELEMENT */ &&
                              // #3756
                              // custom directives can potentially add DOM elements arbitrarily,
                              // we need to avoid setting textContent of the element at runtime
                              // to avoid accidentally overwriting the DOM elements added
                              // by the user through custom directives.
                              !node.props.find(p => p.type === 7 /* DIRECTIVE */ &&
                                  !context.directiveTransforms[p.name]) &&
                              // in compat mode, <template> tags with no special directives
                              // will be rendered as a fragment so its children must be
                              // converted into vnodes.
                              !(false ))))) {
                  return;
              }
              // pre-convert text nodes into createTextVNode(text) calls to avoid
              // runtime normalization.
              for (let i = 0; i < children.length; i++) {
                  const child = children[i];
                  if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                      const callArgs = [];
                      // createTextVNode defaults to single whitespace, so if it is a
                      // single space the code could be an empty call to save bytes.
                      if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                          callArgs.push(child);
                      }
                      // mark dynamic text with flag so it gets patched inside a block
                      if (!context.ssr &&
                          getConstantType(child, context) === 0 /* NOT_CONSTANT */) {
                          callArgs.push(1 /* TEXT */ +
                              (` /* ${PatchFlagNames[1 /* TEXT */]} */` ));
                      }
                      children[i] = {
                          type: 12 /* TEXT_CALL */,
                          content: child,
                          loc: child.loc,
                          codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                      };
                  }
              }
          };
      }
  };

  const seen = new WeakSet();
  const transformOnce = (node, context) => {
      if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
          if (seen.has(node) || context.inVOnce) {
              return;
          }
          seen.add(node);
          context.inVOnce = true;
          context.helper(SET_BLOCK_TRACKING);
          return () => {
              context.inVOnce = false;
              const cur = context.currentNode;
              if (cur.codegenNode) {
                  cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);
              }
          };
      }
  };

  const transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
          context.onError(createCompilerError(41 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
          return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;
      // im SFC <script setup> inline mode, the exp may have been transformed into
      // _unref(exp)
      context.bindingMetadata[rawExp];
      const maybeRef = !true    /* SETUP_CONST */;
      if (!expString.trim() ||
          (!isMemberExpression(expString) && !maybeRef)) {
          context.onError(createCompilerError(42 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
          return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression('modelValue', true);
      const eventName = arg
          ? isStaticExp(arg)
              ? `onUpdate:${arg.content}`
              : createCompoundExpression(['"onUpdate:" + ', arg])
          : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      {
          assignmentExp = createCompoundExpression([
              `${eventArg} => ((`,
              exp,
              `) = $event)`
          ]);
      }
      const props = [
          // modelValue: foo
          createObjectProperty(propName, dir.exp),
          // "onUpdate:modelValue": $event => (foo = $event)
          createObjectProperty(eventName, assignmentExp)
      ];
      // modelModifiers: { foo: true, "bar-baz": true }
      if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
          const modifiers = dir.modifiers
              .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
              .join(`, `);
          const modifiersKey = arg
              ? isStaticExp(arg)
                  ? `${arg.content}Modifiers`
                  : createCompoundExpression([arg, ' + "Modifiers"'])
              : `modelModifiers`;
          props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));
      }
      return createTransformProps(props);
  };
  function createTransformProps(props = []) {
      return { props };
  }

  const seen$1 = new WeakSet();
  const transformMemo = (node, context) => {
      if (node.type === 1 /* ELEMENT */) {
          const dir = findDir(node, 'memo');
          if (!dir || seen$1.has(node)) {
              return;
          }
          seen$1.add(node);
          return () => {
              const codegenNode = node.codegenNode ||
                  context.currentNode.codegenNode;
              if (codegenNode && codegenNode.type === 13 /* VNODE_CALL */) {
                  // non-component sub tree should be turned into a block
                  if (node.tagType !== 1 /* COMPONENT */) {
                      makeBlock(codegenNode, context);
                  }
                  node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                      dir.exp,
                      createFunctionExpression(undefined, codegenNode),
                      `_cache`,
                      String(context.cached++)
                  ]);
              }
          };
      }
  };

  function getBaseTransformPreset(prefixIdentifiers) {
      return [
          [
              transformOnce,
              transformIf,
              transformMemo,
              transformFor,
              ...([]),
              ...([transformExpression]
                      ),
              transformSlotOutlet,
              transformElement,
              trackSlotScopes,
              transformText
          ],
          {
              on: transformOn,
              bind: transformBind,
              model: transformModel
          }
      ];
  }
  // we name it `baseCompile` so that higher order compilers like
  // @vue/compiler-dom can export `compile` while re-exporting everything else.
  function baseCompile(template, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === 'module';
      /* istanbul ignore if */
      {
          if (options.prefixIdentifiers === true) {
              onError(createCompilerError(46 /* X_PREFIX_ID_NOT_SUPPORTED */));
          }
          else if (isModuleMode) {
              onError(createCompilerError(47 /* X_MODULE_MODE_NOT_SUPPORTED */));
          }
      }
      const prefixIdentifiers = !true ;
      if (options.cacheHandlers) {
          onError(createCompilerError(48 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
      }
      if (options.scopeId && !isModuleMode) {
          onError(createCompilerError(49 /* X_SCOPE_ID_NOT_SUPPORTED */));
      }
      const ast = isString(template) ? baseParse(template, options) : template;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
      transform(ast, extend({}, options, {
          prefixIdentifiers,
          nodeTransforms: [
              ...nodeTransforms,
              ...(options.nodeTransforms || []) // user transforms
          ],
          directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms
          )
      }));
      return generate(ast, extend({}, options, {
          prefixIdentifiers
      }));
  }

  const noopDirectiveTransform = () => ({ props: [] });

  const V_MODEL_RADIO = Symbol(`vModelRadio` );
  const V_MODEL_CHECKBOX = Symbol(`vModelCheckbox` );
  const V_MODEL_TEXT = Symbol(`vModelText` );
  const V_MODEL_SELECT = Symbol(`vModelSelect` );
  const V_MODEL_DYNAMIC = Symbol(`vModelDynamic` );
  const V_ON_WITH_MODIFIERS = Symbol(`vOnModifiersGuard` );
  const V_ON_WITH_KEYS = Symbol(`vOnKeysGuard` );
  const V_SHOW = Symbol(`vShow` );
  const TRANSITION$1 = Symbol(`Transition` );
  const TRANSITION_GROUP = Symbol(`TransitionGroup` );
  registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION$1]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
  });

  /* eslint-disable no-restricted-globals */
  let decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
      if (!decoder) {
          decoder = document.createElement('div');
      }
      if (asAttr) {
          decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
          return decoder.children[0].getAttribute('foo');
      }
      else {
          decoder.innerHTML = raw;
          return decoder.textContent;
      }
  }

  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
  const parserOptions = {
      isVoidTag,
      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: tag => tag === 'pre',
      decodeEntities: decodeHtmlBrowser ,
      isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
              return TRANSITION$1;
          }
          else if (isBuiltInType(tag, `TransitionGroup`)) {
              return TRANSITION_GROUP;
          }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0 /* HTML */;
          if (parent && ns === 2 /* MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                  if (tag === 'svg') {
                      return 1 /* SVG */;
                  }
                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                          a.value.content === 'application/xhtml+xml'))) {
                      ns = 0 /* HTML */;
                  }
              }
              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                  tag !== 'mglyph' &&
                  tag !== 'malignmark') {
                  ns = 0 /* HTML */;
              }
          }
          else if (parent && ns === 1 /* SVG */) {
              if (parent.tag === 'foreignObject' ||
                  parent.tag === 'desc' ||
                  parent.tag === 'title') {
                  ns = 0 /* HTML */;
              }
          }
          if (ns === 0 /* HTML */) {
              if (tag === 'svg') {
                  return 1 /* SVG */;
              }
              if (tag === 'math') {
                  return 2 /* MATH_ML */;
              }
          }
          return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
          if (ns === 0 /* HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                  return 1 /* RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                  return 2 /* RAWTEXT */;
              }
          }
          return 0 /* DATA */;
      }
  };

  // Parse inline CSS strings for static style attributes into an object.
  // This is a NodeTransform since it works on the static `style` attribute and
  // converts it into a dynamic equivalent:
  // style="color: red" -> :style='{ "color": "red" }'
  // It is then processed by `transformElement` and included in the generated
  // props.
  const transformStyle = node => {
      if (node.type === 1 /* ELEMENT */) {
          node.props.forEach((p, i) => {
              if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                  // replace p with an expression node
                  node.props[i] = {
                      type: 7 /* DIRECTIVE */,
                      name: `bind`,
                      arg: createSimpleExpression(`style`, true, p.loc),
                      exp: parseInlineCSS(p.value.content, p.loc),
                      modifiers: [],
                      loc: p.loc
                  };
              }
          });
      }
  };
  const parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
  };

  function createDOMCompilerError(code, loc) {
      return createCompilerError(code, loc, DOMErrorMessages );
  }
  const DOMErrorMessages = {
      [50 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
      [51 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
      [52 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
      [53 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
      [54 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [55 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
      [56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [57 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [58 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
      [59 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
      [60 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(50 /* X_V_HTML_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(51 /* X_V_HTML_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
          ]
      };
  };

  const transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(52 /* X_V_TEXT_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(53 /* X_V_TEXT_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`textContent`, true), exp
                  ? getConstantType(exp, context) > 0
                      ? exp
                      : createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
                  : createSimpleExpression('', true))
          ]
      };
  };

  const transformModel$1 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      // base transform has errors OR component v-model (only need props)
      if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
          return baseResult;
      }
      if (dir.arg) {
          context.onError(createDOMCompilerError(55 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
      }
      function checkDuplicatedValue() {
          const value = findProp(node, 'value');
          if (value) {
              context.onError(createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
          }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === 'input' ||
          tag === 'textarea' ||
          tag === 'select' ||
          isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === 'input' || isCustomElement) {
              const type = findProp(node, `type`);
              if (type) {
                  if (type.type === 7 /* DIRECTIVE */) {
                      // :type="foo"
                      directiveToUse = V_MODEL_DYNAMIC;
                  }
                  else if (type.value) {
                      switch (type.value.content) {
                          case 'radio':
                              directiveToUse = V_MODEL_RADIO;
                              break;
                          case 'checkbox':
                              directiveToUse = V_MODEL_CHECKBOX;
                              break;
                          case 'file':
                              isInvalidType = true;
                              context.onError(createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                              break;
                          default:
                              // text type
                              checkDuplicatedValue();
                              break;
                      }
                  }
              }
              else if (hasDynamicKeyVBind(node)) {
                  // element has bindings with dynamic keys, which can possibly contain
                  // "type".
                  directiveToUse = V_MODEL_DYNAMIC;
              }
              else {
                  // text type
                  checkDuplicatedValue();
              }
          }
          else if (tag === 'select') {
              directiveToUse = V_MODEL_SELECT;
          }
          else {
              // textarea
              checkDuplicatedValue();
          }
          // inject runtime directive
          // by returning the helper symbol via needRuntime
          // the import will replaced a resolveDirective call.
          if (!isInvalidType) {
              baseResult.needRuntime = context.helper(directiveToUse);
          }
      }
      else {
          context.onError(createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
      }
      // native vmodel doesn't need the `modelValue` props since they are also
      // passed to the runtime as `binding.value`. removing it reduces code size.
      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
          p.key.content === 'modelValue'));
      return baseResult;
  };

  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /*#__PURE__*/ makeMap(
  // event propagation management
`stop,prevent,self,`   +
      // system modifiers + exact
      `ctrl,shift,alt,meta,exact,` +
      // mouse
      `middle`);
  // left & right could be mouse or key modifiers based on event type
  const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
  const resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (isEventOptionModifier(modifier)) {
              // eventOptionModifiers: modifiers for addEventListener() options,
              // e.g. .passive & .capture
              eventOptionModifiers.push(modifier);
          }
          else {
              // runtimeModifiers: modifiers that needs runtime guards
              if (maybeKeyModifier(modifier)) {
                  if (isStaticExp(key)) {
                      if (isKeyboardEvent(key.content)) {
                          keyModifiers.push(modifier);
                      }
                      else {
                          nonKeyModifiers.push(modifier);
                      }
                  }
                  else {
                      keyModifiers.push(modifier);
                      nonKeyModifiers.push(modifier);
                  }
              }
              else {
                  if (isNonKeyModifier(modifier)) {
                      nonKeyModifiers.push(modifier);
                  }
                  else {
                      keyModifiers.push(modifier);
                  }
              }
          }
      }
      return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
      };
  };
  const transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
      return isStaticClick
          ? createSimpleExpression(event, true)
          : key.type !== 4 /* SIMPLE_EXPRESSION */
              ? createCompoundExpression([
                  `(`,
                  key,
                  `) === "onClick" ? "${event}" : (`,
                  key,
                  `)`
              ])
              : key;
  };
  const transformOn$1 = (dir, node, context) => {
      return transformOn(dir, node, context, baseResult => {
          const { modifiers } = dir;
          if (!modifiers.length)
              return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
          // normalize click.right and click.middle since they don't actually fire
          if (nonKeyModifiers.includes('right')) {
              key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes('middle')) {
              key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                  handlerExp,
                  JSON.stringify(nonKeyModifiers)
              ]);
          }
          if (keyModifiers.length &&
              // if event name is dynamic, always wrap with keys guard
              (!isStaticExp(key) || isKeyboardEvent(key.content))) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                  handlerExp,
                  JSON.stringify(keyModifiers)
              ]);
          }
          if (eventOptionModifiers.length) {
              const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
              key = isStaticExp(key)
                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                  : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
              props: [createObjectProperty(key, handlerExp)]
          };
      });
  };

  const transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */, loc));
      }
      return {
          props: [],
          needRuntime: context.helper(V_SHOW)
      };
  };

  const transformTransition = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 1 /* COMPONENT */) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION$1) {
              return () => {
                  if (!node.children.length) {
                      return;
                  }
                  // warn multiple transition children
                  if (hasMultipleChildren(node)) {
                      context.onError(createDOMCompilerError(59 /* X_TRANSITION_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
                  // check if it's s single child w/ v-show
                  // if yes, inject "persisted: true" to the transition props
                  const child = node.children[0];
                  if (child.type === 1 /* ELEMENT */) {
                      for (const p of child.props) {
                          if (p.type === 7 /* DIRECTIVE */ && p.name === 'show') {
                              node.props.push({
                                  type: 6 /* ATTRIBUTE */,
                                  name: 'persisted',
                                  value: undefined,
                                  loc: node.loc
                              });
                          }
                      }
                  }
              };
          }
      }
  };
  function hasMultipleChildren(node) {
      // #1352 filter out potential comment nodes.
      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */ &&
          !(c.type === 2 /* TEXT */ && !c.content.trim())));
      const child = children[0];
      return (children.length !== 1 ||
          child.type === 11 /* FOR */ ||
          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
  }

  const ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 0 /* ELEMENT */ &&
          (node.tag === 'script' || node.tag === 'style')) {
          context.onError(createDOMCompilerError(60 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
          context.removeNode();
      }
  };

  const DOMNodeTransforms = [
      transformStyle,
      ...([transformTransition] )
  ];
  const DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel$1,
      on: transformOn$1,
      show: transformShow
  };
  function compile$1(template, options = {}) {
      return baseCompile(template, extend({}, parserOptions, options, {
          nodeTransforms: [
              // ignore <script> and <tag>
              // this is not put inside DOMNodeTransforms because that list is used
              // by compiler-ssr to generate vnode fallback branches
              ignoreSideEffectTags,
              ...DOMNodeTransforms,
              ...(options.nodeTransforms || [])
          ],
          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
          transformHoist: null 
      }));
  }

  // This entry is the "full-build" that includes both the runtime
  {
      initDev();
  }
  const compileCache = Object.create(null);
  function compileToFunction(template, options) {
      if (!isString(template)) {
          if (template.nodeType) {
              template = template.innerHTML;
          }
          else {
              warn$1(`invalid template option: `, template);
              return NOOP;
          }
      }
      const key = template;
      const cached = compileCache[key];
      if (cached) {
          return cached;
      }
      if (template[0] === '#') {
          const el = document.querySelector(template);
          if (!el) {
              warn$1(`Template element not found or is empty: ${template}`);
          }
          // __UNSAFE__
          // Reason: potential execution of JS expressions in in-DOM template.
          // The user must make sure the in-DOM template is trusted. If it's rendered
          // by the server, the template should not contain any user data.
          template = el ? el.innerHTML : ``;
      }
      const { code } = compile$1(template, extend({
          hoistStatic: true,
          onError: onError ,
          onWarn: e => onError(e, true) 
      }, options));
      function onError(err, asWarning = false) {
          const message = asWarning
              ? err.message
              : `Template compilation error: ${err.message}`;
          const codeFrame = err.loc &&
              generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
          warn$1(codeFrame ? `${message}\n${codeFrame}` : message);
      }
      // The wildcard import results in a huge object with every export
      // with keys that cannot be mangled, and can be quite heavy size-wise.
      // In the global build we know `Vue` is available globally so we can avoid
      // the wildcard object.
      const render = (new Function('Vue', code)(runtimeDom));
      render._rc = true;
      return (compileCache[key] = render);
  }
  registerRuntimeCompiler(compileToFunction);

  var Vue = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaseTransition: BaseTransition,
    Comment: Comment,
    EffectScope: EffectScope,
    Fragment: Fragment,
    KeepAlive: KeepAlive,
    ReactiveEffect: ReactiveEffect,
    Static: Static,
    Suspense: Suspense,
    Teleport: Teleport,
    Text: Text,
    Transition: Transition,
    TransitionGroup: TransitionGroup,
    VueElement: VueElement,
    callWithAsyncErrorHandling: callWithAsyncErrorHandling,
    callWithErrorHandling: callWithErrorHandling,
    camelize: camelize,
    capitalize: capitalize,
    cloneVNode: cloneVNode,
    compatUtils: compatUtils,
    compile: compileToFunction,
    computed: computed$1,
    createApp: createApp,
    createBlock: createBlock,
    createCommentVNode: createCommentVNode,
    createElementBlock: createElementBlock,
    createElementVNode: createBaseVNode,
    createHydrationRenderer: createHydrationRenderer,
    createPropsRestProxy: createPropsRestProxy,
    createRenderer: createRenderer,
    createSSRApp: createSSRApp,
    createSlots: createSlots,
    createStaticVNode: createStaticVNode,
    createTextVNode: createTextVNode,
    createVNode: createVNode,
    customRef: customRef,
    defineAsyncComponent: defineAsyncComponent,
    defineComponent: defineComponent,
    defineCustomElement: defineCustomElement,
    defineEmits: defineEmits,
    defineExpose: defineExpose,
    defineProps: defineProps,
    defineSSRCustomElement: defineSSRCustomElement,
    get devtools () { return devtools; },
    effect: effect,
    effectScope: effectScope,
    getCurrentInstance: getCurrentInstance,
    getCurrentScope: getCurrentScope,
    getTransitionRawChildren: getTransitionRawChildren,
    guardReactiveProps: guardReactiveProps,
    h: h,
    handleError: handleError,
    hydrate: hydrate,
    initCustomFormatter: initCustomFormatter,
    initDirectivesForSSR: initDirectivesForSSR,
    inject: inject,
    isMemoSame: isMemoSame,
    isProxy: isProxy,
    isReactive: isReactive,
    isReadonly: isReadonly,
    isRef: isRef,
    isRuntimeOnly: isRuntimeOnly,
    isShallow: isShallow,
    isVNode: isVNode,
    markRaw: markRaw,
    mergeDefaults: mergeDefaults,
    mergeProps: mergeProps,
    nextTick: nextTick,
    normalizeClass: normalizeClass,
    normalizeProps: normalizeProps,
    normalizeStyle: normalizeStyle,
    onActivated: onActivated,
    onBeforeMount: onBeforeMount,
    onBeforeUnmount: onBeforeUnmount,
    onBeforeUpdate: onBeforeUpdate,
    onDeactivated: onDeactivated,
    onErrorCaptured: onErrorCaptured,
    onMounted: onMounted,
    onRenderTracked: onRenderTracked,
    onRenderTriggered: onRenderTriggered,
    onScopeDispose: onScopeDispose,
    onServerPrefetch: onServerPrefetch,
    onUnmounted: onUnmounted,
    onUpdated: onUpdated,
    openBlock: openBlock,
    popScopeId: popScopeId,
    provide: provide,
    proxyRefs: proxyRefs,
    pushScopeId: pushScopeId,
    queuePostFlushCb: queuePostFlushCb,
    reactive: reactive,
    readonly: readonly,
    ref: ref,
    registerRuntimeCompiler: registerRuntimeCompiler,
    render: render$k,
    renderList: renderList,
    renderSlot: renderSlot,
    resolveComponent: resolveComponent,
    resolveDirective: resolveDirective,
    resolveDynamicComponent: resolveDynamicComponent,
    resolveFilter: resolveFilter,
    resolveTransitionHooks: resolveTransitionHooks,
    setBlockTracking: setBlockTracking,
    setDevtoolsHook: setDevtoolsHook,
    setTransitionHooks: setTransitionHooks,
    shallowReactive: shallowReactive,
    shallowReadonly: shallowReadonly,
    shallowRef: shallowRef,
    ssrContextKey: ssrContextKey,
    ssrUtils: ssrUtils,
    stop: stop,
    toDisplayString: toDisplayString,
    toHandlerKey: toHandlerKey,
    toHandlers: toHandlers,
    toRaw: toRaw,
    toRef: toRef,
    toRefs: toRefs,
    transformVNodeArgs: transformVNodeArgs,
    triggerRef: triggerRef,
    unref: unref,
    useAttrs: useAttrs,
    useCssModule: useCssModule,
    useCssVars: useCssVars,
    useSSRContext: useSSRContext,
    useSlots: useSlots,
    useTransitionState: useTransitionState,
    vModelCheckbox: vModelCheckbox,
    vModelDynamic: vModelDynamic,
    vModelRadio: vModelRadio,
    vModelSelect: vModelSelect,
    vModelText: vModelText,
    vShow: vShow,
    version: version,
    warn: warn$1,
    watch: watch,
    watchEffect: watchEffect,
    watchPostEffect: watchPostEffect,
    watchSyncEffect: watchSyncEffect,
    withAsyncContext: withAsyncContext,
    withCtx: withCtx,
    withDefaults: withDefaults,
    withDirectives: withDirectives,
    withKeys: withKeys,
    withMemo: withMemo,
    withModifiers: withModifiers,
    withScopeId: withScopeId
  });

  const render_component = function(component, { props, children, element, app } = {}) {
      let el = element;
      let vNode = createVNode(component, props, children);
      if (app && app._context) vNode.appContext = app._context;
      if (el) render$k(vNode, el);
      else if (typeof document !== 'undefined' ) render$k(vNode, el = document.createElement('div'));
      
      const destroy = () => {
  	if (el) render$k(null, el);
  	el = null;
  	vNode = null;
      };
      
      return { vNode, destroy, el }
  };

  var script$1K = {
      props: ['content'],
      watch: {
  	"content": function(val, oldVal) {
  	    // this.$forceUpdate();
  	}
      },
      render() {
  	return h(this.$props.content);
      }
  };

  script$1K.__file = "http_src/vue/vue_node.vue";

  const _hoisted_1$1w = ["id"];
  const _hoisted_2$1n = ["aria-labelledby"];
  const _hoisted_3$1k = { class: "dropdown-item" };


  var script$1J = {
    __name: 'dropdown',
    props: {
      id: String,
      auto_load: Boolean,
      button_class: String,
      button_style: String,
      f_on_open: Function,
      f_on_close: Function,
  },
    emits: [],
    setup(__props, { expose, emit }) {

  const props = __props;
  const slots = useSlots();

  const options = ref([]);
  ref([]);
  const menu_options = ref([]);
  const dropdown = ref(null);
  const dropdown_button = ref(null);





  let default_overflow = null;
  onMounted(() => {
      default_overflow = 	$(dropdown.value).parent().closest('div').css('overflow');
      if (props.auto_load == true) {
  	load_menu();
      }
      let el = { dropdown: dropdown.value, dropdown_button: dropdown_button.value };
      $(dropdown.value).on('show.bs.dropdown', function () {
  	$(dropdown.value).parent().closest('div').css('overflow', "visible");
  	if (props.f_on_open != null) {
  	    props.f_on_open(el);
  	}
      });
      $(dropdown.value).on('hide.bs.dropdown', function () {
  	$(dropdown.value).parent().closest('div').css('overflow', default_overflow);
  	if (props.f_on_close != null) {
  	    props.f_on_close(el);
  	}
      });
  });

  const button_class_2 = computed$1(() => {
      if (props.button_class != null) { return props.button_class; }
      return "btn-link";
  });

  async function load_menu() {
      options.value = [];
      if (slots == null || slots.menu == null) { return; }
      let m_options = slots.menu();
      if (m_options == null || m_options.length == 0) { return; }
      if (typeof m_options[0].type === 'symbol') {
  	m_options = m_options[0].children;
      }
      menu_options.value = [];
      m_options.forEach((opt_slot) => {
  	let node = opt_slot;
  	menu_options.value.push(node);
  	// let element = $("<div></div>")[0];
  	// const { vNode, el } = render_component(node, { app:  instance?.appContext?.app, element });
  	// options.value.push(el);
      });
      await nextTick();
      // nextTick(() => {
      // 	options.value.forEach((opt, i) => {
      // 	    let html_element = menu.value[i];
      // 	    $(html_element).append(opt);
      // 	});
      // });
  }

  expose({ load_menu });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", {
      class: "dropdown",
      ref_key: "dropdown",
      ref: dropdown,
      style: {"display":"inline-block"}
    }, [
      createBaseVNode("button", {
        class: normalizeClass(["btn dropdown-toggle", unref(button_class_2)]),
        style: normalizeStyle(__props.button_style),
        type: "button",
        id: __props.id,
        ref_key: "dropdown_button",
        ref: dropdown_button,
        "aria-expanded": "false",
        "data-bs-toggle": "dropdown"
      }, [
        renderSlot(_ctx.$slots, "title")
      ], 14 /* CLASS, STYLE, PROPS */, _hoisted_1$1w),
      createBaseVNode("ul", {
        class: "dropdown-menu",
        "aria-labelledby": __props.id,
        style: {"max-height":"25rem","overflow":"auto"}
      }, [
        createCommentVNode(" <slot name=\"menu\"></slot> "),
        createCommentVNode(" <li class=\"dropdown-item\" v-for=\"(opt, i) in options\" :ref=\"el => { menu[i] = el }\"> "),
        createCommentVNode("   asd "),
        createCommentVNode("   </li> "),
        (openBlock(true), createElementBlock(Fragment, null, renderList(menu_options.value, (opt, i) => {
          return (openBlock(), createElementBlock("li", _hoisted_3$1k, [
            createVNode(script$1K, { content: opt }, null, 8 /* PROPS */, ["content"])
          ]))
        }), 256 /* UNKEYED_FRAGMENT */))
      ], 8 /* PROPS */, _hoisted_2$1n)
    ], 512 /* NEED_PATCH */))
  }
  }

  };

  script$1J.__file = "http_src/vue/dropdown.vue";

  /**
      (C) 2022 - ntop.org
  */

  const _i18n = (t) => i18n(t);

  async function build_table(http_prefix, table_id, f_map_columns, f_get_extra_params_obj, f_on_get_rows) {
      let epoch_end = Number.parseInt(Date.now() / 1000);
      let table_def_url = `${http_prefix}/tables_config/${table_id}.json?epoch_end=${epoch_end}`;
      let table_def = await ntopng_utility$1.http_request(table_def_url, null, null, true);
      if (table_def == null) {
  	return {
  	    id: table_id,
  	    columns: [],	    
  	}
      }
      if (f_map_columns != null) {
  	table_def.columns = await f_map_columns(table_def.columns);
      }
      const table_config = {
  	id: table_id,
  	columns: table_def.columns,
  	get_rows: get_rows_func(table_def, f_get_extra_params_obj, f_on_get_rows),
  	get_column_id: get_column_id_func(table_def),
  	print_column_name: get_f_print_column_name(),
  	print_html_row: get_f_print_html_row(),
  	print_vue_node_row: get_f_print_vue_node_row(),
  	f_is_column_sortable: get_f_is_column_sortable(),
  	f_get_column_classes: get_f_get_column_classes(),
  	f_get_column_style: get_f_get_column_style(),
  	display_empty_rows: table_def.display_empty_rows,
  	enable_search: table_def.enable_search,	
  	default_sort: table_def.default_sort,
  	show_autorefresh: table_def.show_autorefresh,
  	paging: table_def.paging,
      };
      return table_config;
  }

  function get_f_is_column_sortable(table_def) {
      return (col) => {
  	return col.sortable;
      };
  }

  function get_f_get_column_classes(table_def) {
      return (col) => {
  	let classes = col?.class;
  	if (classes != null) { return classes; }
  	return [];
      };
  }

  function get_f_get_column_style(table_def) {
      return (col) => {
  	let style = col?.style;
  	if (style != null) { return style; }
  	return "";
      };
  }

  function get_f_print_vue_node_row(table_def) {
      const available_types = {
  	"button_list": get_f_print_v_node_buttons(true),
  	"button_array": get_f_print_v_node_buttons(false),
      };
      return (col, row, vue_obj, return_true_if_def) => {
  	if (col.render_v_node_type == null && col.render_v_func == null) { return null; }
  	if (return_true_if_def == true) { return true; }
  	if (col.render_v_func != null) {
  	    return col.render_v_func(col, row, vue_obj, return_true_if_def);
  	}
  	let print_v_node_buttons = available_types[col.render_v_node_type];
  	return print_v_node_buttons(col, row, vue_obj);
      };
  }

  function get_f_print_html_row(table_def) {
      return (col, row, return_true_if_def) => {
  	if (col.render_v_func != null) { return null; }
  	if (return_true_if_def == true) { return true; }

  	let data;
  	if (col.data_field != null) {
  	    data = row[col.data_field];
  	}
  	if (col.zero_is_null != null && data != null && data == 0) {
  	    data = "";
  	}
  	if (col.render_generic != null) {
  	    let render = DataTableRenders$1.getFormatGenericField(col.render_generic, col.zero_is_null);
  	    return render(data, 'display', row);
  	}
  	if (col.render_func != null) {
  	    return col.render_func(data, row);
  	}
  	if (col.render_type != null) {
  	    if (formatterUtils.types[col.render_type] != null) {
  		col.render_func = formatterUtils.getFormatter(col.render_type);
  		return col.render_func(data);
  	    } else if (DataTableRenders$1[col.render_type] != null) {
  		return DataTableRenders$1[col.render_type](data, 'display', row, col.zero_is_null);
  	    } else {
  		throw `In column ${col.data_field} render_type: ${col.render_type} not found`;
  	    }
  	}
  	return data;
      };
  }

  /* This function apparently create the action buttons */
  function get_f_print_v_node_buttons(list_or_array) {
      return (col, row, vue_obj) => {
  	const on_click = (id) => {
  	    return (e) => {
  		e.stopPropagation();
  		let event = {event_id: id, row, col};
  		vue_obj.emit('custom_event', event);
  	    }
  	};
  	let v_nodes = col.button_def_array.map((b_def) => {
  	    let attributes = {};
  	    if (b_def.attributes != null) {
  		attributes = b_def.attributes;
  	    }
  	    let class_array = ntopng_utility$1.clone(b_def.class);
  	    if (b_def.f_map_class != null) {
  		class_array = b_def.f_map_class(class_array, row);
  	    }
  	    let _class = "";
  	    if (class_array != null && class_array.length > 0) {
  		_class = class_array.join(" ");
  	    }
  		 if (list_or_array == false) {
  		return vue_obj.h("button", { class: `btn btn-sm btn-secondary ${_class}`, style: "margin-right:0.2rem;", onClick: on_click(b_def.event_id), ...attributes }, [ vue_obj.h("span", { class: b_def.icon, style: "", title: _i18n(b_def.title_i18n)}), ]);
  	    }
  	    return vue_obj.h("a", { class: `${_class} btn-sm`, onClick: on_click(b_def.event_id), style: "display:block;", ...attributes }, [ vue_obj.h("span", { class: b_def.icon, style: "margin-right:0.2rem;cursor:pointer;" }), _i18n(b_def.title_i18n)]);
  	});
  	if (list_or_array == true) {
  	    let v_title = vue_obj.h("span", { class: "fas fa-sm fa-align-justify" });
  	    let dropdown =  vue_obj.h(script$1J, { auto_load: true, button_style: "", button_class: "btn-secondary btn-sm" }, {
  		title: () => v_title,
  		menu: () => v_nodes,
  	    });
  	    return dropdown;
  	}
  	return vue_obj.h("div", {class:"button-group"}, v_nodes);
      };
  }

  function get_rows_func(table_def, f_get_extra_params_obj, f_on_get_rows) {
      let f_get_column_id = get_column_id_func(table_def);
      return async (active_page, per_page, columns_wrap, map_search, first_get_rows) => {
  	let sort_column = columns_wrap.find((c) => c.sort != 0);
  	let visible_columns = columns_wrap.filter((c) => c.visible == true)
  	    .map((c) => f_get_column_id(c)).join(",");
  	let params = {
              start: (active_page * per_page),
              length: per_page,
  	    map_search,
  	    visible_columns,
  	};
  	if (sort_column != null) {
  	    params.sort = f_get_column_id(sort_column.data);
  	    params.order = sort_column.sort == 1 ? "asc" : "desc";
  	}
  	if (f_get_extra_params_obj != null) {
  	    let extra_params = f_get_extra_params_obj();
  	    params = { ...params, ...extra_params, };
  	}
  	const url_params = ntopng_url_manager$1.obj_to_url_params(params);
  	const url = `${http_prefix}/${table_def.data_url}?${url_params}`;
  	let res = await ntopng_utility$1.http_request(url, null, null, true);
  	if (f_on_get_rows != null) {
  	    f_on_get_rows(params);
  	}
  	let rows = res.rsp;
  	if (table_def.rsp_records_field != null) {
  	    rows = res.rsp[table_def.rsp_records_field];
  	}
  	let query_info = res.query_info;
  	if (table_def.rsp_query_info_field != null) {
  	    query_info = res.rsp[table_def.rsp_query_info_field];
  	}
  	// fix server rest bug
  	if (res.recordsFiltered > res.recordsTotal) {
  	    res.recordsTotal = res.recordsFiltered;
  	}
  	return { total_rows: res.recordsTotal, rows, query_info };
  	// return { total_rows: 1, rows: [rows[0]], query_info };
      }
  }

  function get_f_print_column_name(table_def) {
      return (col) => {
  	if (col.title_i18n != null) {
              return _i18n(col.title_i18n);
  	}
  	if (col.title != null) {
  	    return col.title;
  	}
  	return "";
      };
  }

  function get_column_id_func(table_def) {
      return (col) => {
  	if (col.id != null) { return col.id; }
  	if (col.data_field != null) { return col.data_field; }
  	return table_def.columns.findIndex((c) => c == col);
      };
  }

  /**
     Get columns in new table format from old datatable format.
  */
  function get_columns_from_datatable_columns(datatable_columns_title, datatable_columns_js) {
      let table_columns_config = datatable_columns_js.map((c, index) => {
  	({
  	    data_field: c.data,
  	    title: datatable_columns_title[index],
  	    sortable: c.orderable == null || c.orderable == true,
  	});
  	if (c.className != null) {
  	    c.className.split(" ");
  	}
  	if (c.render != null) {
  	    c.render_func = (data, row) => c.render(data, 'display', row);
  	}
      });
      return table_columns_config;

  }

  const table_utils = {
      get_columns_from_datatable_columns,
      build_table,
  };

  let filters_const_dict = {};

  async function get_filter_const$1(url_request) {
      if (filters_const_dict[url_request] == null) {
  	filters_const_dict[url_request] = ntopng_utility.http_request(url_request);
      }
      let filter_consts = await filters_const_dict[url_request];
      return filter_consts;
  }

  const tag_operator_label_dict = {
      "eq": "=",
      "neq": "!=",
      "lt": "<",
      "gt": ">",
      "gte": ">=",
      "lte": "<=",
      "in": "contains",
      "nin": "does not contain"
  };

  const load_filters_data$1 = async function (filters_const) {
      filters_const.filter((x) => x.label == null).forEach((x) => { console.error(`label not defined for filter ${JSON.stringify(x)}`); x.label = ""; });
      filters_const.sort((a, b) => a.label.localeCompare(b.label));
      i18n_ext.tags = {};
      TAG_OPERATORS = {};
      DEFINED_TAGS = {};
      filters_const.forEach((f_def) => {
          i18n_ext.tags[f_def.id] = f_def.label;
          f_def.operators.forEach((op) => TAG_OPERATORS[op.id] = op.label);
          DEFINED_TAGS[f_def.id] = f_def.operators.map((op) => op.id);
      });
      let entries = ntopng_url_manager.get_url_entries();
      let filters = [];
      for (const [key, value] of entries) {
          let filter_def = FILTERS_CONST.find((fc) => fc.id == key);
          if (filter_def != null) {
              let options_string = value.split(",");
              options_string.forEach((opt_stirng) => {
                  let [value, operator] = opt_stirng.split(";");
                  if (
                      operator == null || value == null || operator == ""
                      || (filter_def.options != null && filter_def.options.find((opt) => opt.value == value) == null)
                  ) {
                      return;
                  }
  		let value_label = value;
  		if (filter_def.value_type == "array") {
  		    value_label = filter_def?.options?.find((opt) => opt.value == value)?.label;
  		}
                  filters.push({ id: filter_def.id, operator: operator, value: value, label: filter_def.label, value_label });
              });
          }
      }
      return filters;
      // "l7proto=XXX;eq"
  };


  function get_filters_object(filters) {
      let filters_groups = {};
      filters.forEach((f) => {
          let group = filters_groups[f.id];
          if (group == null) {
              group = [];
              filters_groups[f.id] = group;
          }
          group.push(f);
      });
      let filters_object = {};
      for (let f_id in filters_groups) {
          let group = filters_groups[f_id];
          let filter_values = group.filter((f) => f.value != null && f.operator != null && f.operator != "").map((f) => `${f.value};${f.operator}`).join(",");
          filters_object[f_id] = filter_values;
      }
      return filters_object;
  }

  const filtersManager = function () {
      return {
  	get_filter_const: get_filter_const$1,
  	get_filters_object,
  	load_filters_data: load_filters_data$1,
  	tag_operator_label_dict,
      };
  }();

  const _hoisted_1$1v = ["multiple", "disabled"];
  const _hoisted_2$1m = ["selected", "value", "disabled"];
  const _hoisted_3$1j = ["label"];
  const _hoisted_4$1e = ["selected", "value", "disabled"];


  var script$1I = {
    __name: 'select-search',
    props: {
      id: String,
      options: Array,
      selected_option: Object,
      selected_options: Array,
      multiple: Boolean,
      add_tag: Boolean,
      disable_change: Boolean,
      theme: String,
      dropdown_size: String,
      disabled: Boolean
  },
    emits: ['update:selected_option', 'update:selected_options', 'select_option', 'unselect_option', 'change_selected_options'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const select2 = ref(null);

  // const selected2_option = ref({});



  const options_2 = ref([]);
  const groups_options_2 = ref([]);
  const selected_option_2 = ref({});
  const selected_values = ref([]); // used only if multiple == true
  const refresh_options = ref(0);



  let first_time_render = true;

  onMounted(() => {
      if (!props.options) { return; }
      if (!props.disable_change || !first_time_render) {
      	set_input();
      }
  });

  watch(() => props.selected_option, (cur_value, old_value) => {
      set_selected_option(cur_value);
      change_select_2_selected_value();
  }, { flush: 'pre'});

  watch(() => props.selected_options, (cur_value, old_value) => {
      set_selected_values();
      change_select_2_selected_value();
  }, { flush: 'pre'});


  watch([refresh_options], (cur_value, old_value) => {
      render();
  }, { flush: 'post'});


  watch(() => props.options, (current_value, old_value) => {
      if (props.disable_change == true || current_value == null) { return; }
      set_input();
  }, { flush: 'pre'});


  function set_input() {
      set_options();
      set_selected_option();
      set_selected_values();
  }

  function set_options() {
      options_2.value = [];
      groups_options_2.value = [];
      
      if (props.options == null) { return; }
      let groups_dict = {};
      props.options.forEach((option) => {
  	let opt_2 = { ...option };
  	if (opt_2.value == null) {
  	    opt_2.value = opt_2.label;
  	}
  	if (option.group == null) {
  	    options_2.value.push(opt_2);
  	} else {
  	    if (groups_dict[option.group] == null) {
  		groups_dict[option.group] = { group: opt_2.group, options: [] };
  	    }
  	    groups_dict[option.group].options.push(opt_2);
  	}
      });
      groups_options_2.value = ntopng_utility.object_to_array(groups_dict);
      refresh_options.value += 1;
  }


  const render = () => {
      let select2Div = select2.value;
      if (first_time_render == false) {
  	destroy();
      }
      if (!$(select2Div).hasClass("select2-hidden-accessible")) {
  	$(select2Div).select2({
  	    width: '100%',
  	    theme: props.theme ? props.theme : 'bootstrap-5',
  	    dropdownParent: $(select2Div).parent(),
  	    dropdownAutoWidth : true,
          tags: props.add_tag && !props.multiple,
          selectionCssClass: props.dropdown_size == "small" ? 'select2--small' : '',
          dropdownCssClass: props.dropdown_size == "small" ? 'select2--small' : ''
  	});
  	$(select2Div).on('select2:select', function (e) {
          let data = e.params.data;
              if (data.element === null) {
                  //TODO: implement for multiselect
                  let option = { label: data.text, value: data.id };
  		emit('update:selected_option', option);
  		emit('select_option', option);
                  return;
              } 
  	    let value = data.element._value;
  	    let option = find_option_from_value_or_label(value);
  	    if (value !== props.selected_option) {
  		emit('update:selected_option', option);
  		emit('select_option', option);
              }
  	    if (!props.multiple) {
  		return;
  	    }
  	    selected_values.value = selected_values.value.filter((v) => v != value);
  	    selected_values.value.push(value);
  	    let options = find_options_from_values(selected_values.value);
  	    emit('update:selected_options', options);
  	    emit('change_selected_options', options);		 
  	});
  	$(select2Div).on('select2:unselect', function (e) {
  	    let data = e.params.data;
  	    let value = data.element._value;
  	    if (!props.multiple) {
  		return;
  	    }
  	    selected_values.value = selected_values.value.filter((v) => v != value);
  	    let option = find_option_from_value_or_label(value);
  	    let options = find_options_from_values(selected_values.value);
  	    emit('unselect_option', option);
  	    emit('update:selected_options', options);
  	    emit('change_selected_options', options);		 
  	});
      }
      first_time_render = false;
      // this.$forceUpdate();
      change_select_2_selected_value();
  };

  function change_select_2_selected_value() {
      let select2Div = select2.value;
      if (!props.multiple) {
  	let value = get_value_from_selected_option(props.selected_option);
  	$(select2Div).val(value);
  	$(select2Div).trigger("change");
      } else {
  	$(select2Div).val(selected_values.value);
  	$(select2Div).trigger("change");
      }
  }

  function is_selected(item) {
      if (!props.multiple) {
  	const is_zero_value = selected_option_2.value.value == 0 ||selected_option_2.value.value == "0";
  	return item.value == selected_option_2.value.value || (is_zero_value && item.label == selected_option_2.value.label);
  }
     return selected_values.value.find((v) => v == item.value) != null || item.selected; 
  }

  function set_selected_values() {
      if (props.selected_options == null || !props.multiple) {
          return;
      }
      selected_values.value = [];
      props.selected_options.forEach((opt) => {
          let value = opt.value || opt.label;
          selected_values.value.push(value);
      });
  }

  function set_selected_option(selected_option) {
      if (selected_option == null && !props.multiple) {
  	selected_option = get_props_selected_option();
      }
      selected_option_2.value = selected_option;
  }

  function get_props_selected_option() {
      if (props.selected_option == null) {
  	return props.options[0];
      }
      return props.selected_option;
  }

  function get_value_from_selected_option(selected_option) {
      if (selected_option == null) {
  	selected_option = get_props_selected_option();
      }
      let value;
      if (selected_option.value != null) {
  	value = selected_option.value;
      } else {
  	value = selected_option.label;
      }
      return value;
  }

  function find_options_from_values(values) {
      let options = values.map((v) => find_option_from_value_or_label(v));
      return options;
  }

  function find_option_from_value_or_label(value) {
      let option_2 = find_option_2_from_value(value);
      let option = props.options.find((o) => (o.value === option_2.value) || (o.label == option_2.label));
      return option;
  }

  function find_option_2_from_value(value) {
      if (value == null) {
  	value = get_value_from_selected_option();
      }
      // let option = options_2.value.find((o) => o.value == value);
      let option = options_2.value.find((o) => o.value === value);
      if (option != null) { return option; }
      for (let i = 0; i < groups_options_2.value.length; i += 1) {
  	let g = groups_options_2.value[i];
  	option = g.options.find((o) => o.value === value);
  	if (option != null) {
  	    return option;
  	}
      }
      return null;
  }
      
  expose({ render });

  function destroy() {
      try {
  	$(select2.value).select2('destroy');
  	$(select2.value).off('select2:select');    
      } catch(err) {
  	console.error("Destroy select-search catch error:");
  	console.error(err);
      }
  }

  onBeforeUnmount(() => {
      destroy();
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("select", {
      class: "select2 form-select",
      ref_key: "select2",
      ref: select2,
      required: "",
      name: "filter_type",
      multiple: __props.multiple,
      disabled: __props.disabled
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(options_2.value, (item, i) => {
        return (openBlock(), createElementBlock("option", {
          class: "no-wrap p-0",
          selected: is_selected(item),
          value: item.value,
          disabled: item.disabled
        }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_2$1m))
      }), 256 /* UNKEYED_FRAGMENT */)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(groups_options_2.value, (item, i) => {
        return (openBlock(), createElementBlock("optgroup", {
          label: item.group
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(item.options, (opt, j) => {
            return (openBlock(), createElementBlock("option", {
              selected: is_selected(opt),
              value: opt.value,
              disabled: opt.disabled
            }, toDisplayString(opt.label), 9 /* TEXT, PROPS */, _hoisted_4$1e))
          }), 256 /* UNKEYED_FRAGMENT */))
        ], 8 /* PROPS */, _hoisted_3$1j))
      }), 256 /* UNKEYED_FRAGMENT */))
    ], 8 /* PROPS */, _hoisted_1$1v))
  }
  }

  };

  script$1I.__file = "http_src/vue/select-search.vue";

  var script$1H = defineComponent({
      components: {
      },
      props: {
  	id: String,
  	main_title: Object,
    secondary_title_list: Array,
  	help_link: String,
  	items_table: Array,
      },
      emits: ["click_item"],
      /** This method is the first method of the component called, it's called before html template creation. */
      created() {
        },
      data() {
  	return {
  	    //i18n: (t) => i18n(t),
  	};
      },
      /** This method is the first method called after html template creation. */
      mounted() {
  	ntopng_sync.ready(this.$props["id"]);
      },
      methods: {
      },
  });

  const _hoisted_1$1u = { class: "navbar navbar-shadow navbar-expand-lg navbar-light bg-light px-2 mb-2" };
  const _hoisted_2$1l = {
    class: "me-1 text-nowrap",
    style: {"font-size":"1.1rem"}
  };
  const _hoisted_3$1i = ["href", "title"];
  const _hoisted_4$1d = ["title"];
  const _hoisted_5$15 = ["href", "title"];
  const _hoisted_6$W = ["title"];
  const _hoisted_7$T = /*#__PURE__*/createBaseVNode("span", { class: "text-muted ms-1 d-none d-lg-inline d-md-none" }, "|", -1 /* HOISTED */);
  const _hoisted_8$S = /*#__PURE__*/createBaseVNode("button", {
    class: "navbar-toggler",
    type: "button"
  }, [
    /*#__PURE__*/createBaseVNode("span", { class: "navbar-toggler-icon" })
  ], -1 /* HOISTED */);
  const _hoisted_9$K = {
    class: "collapse navbar-collapse scroll-x",
    id: "navbarNav"
  };
  const _hoisted_10$G = { class: "navbar-nav" };
  const _hoisted_11$B = ["onClick"];
  const _hoisted_12$A = {
    key: 0,
    class: "badge rounded-pill bg-dark",
    style: {"float":"right","margin-bottom":"-10px"}
  };
  const _hoisted_13$u = ["onClick"];
  const _hoisted_14$r = {
    key: 0,
    class: "badge rounded-pill bg-dark",
    style: {"float":"right","margin-bottom":"-10px"}
  };
  const _hoisted_15$p = ["onClick"];
  const _hoisted_16$o = {
    key: 0,
    class: "badge rounded-pill bg-dark",
    style: {"float":"right","margin-bottom":"-10px"}
  };
  const _hoisted_17$l = { class: "navbar-nav ms-auto" };
  const _hoisted_18$l = /*#__PURE__*/createBaseVNode("a", {
    href: "javascript:history.back()",
    class: "nav-item nav-link text-muted"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-arrow-left" })
  ], -1 /* HOISTED */);
  const _hoisted_19$l = ["href"];
  const _hoisted_20$j = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-question-circle" }, null, -1 /* HOISTED */);
  const _hoisted_21$f = [
    _hoisted_20$j
  ];

  function render$j(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("nav", _hoisted_1$1u, [
      createBaseVNode("span", _hoisted_2$1l, [
        createBaseVNode("i", {
          class: normalizeClass(_ctx.main_title.icon)
        }, null, 2 /* CLASS */),
        (_ctx.main_title.href)
          ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: _ctx.main_title.href,
              title: _ctx.main_title.title
            }, toDisplayString(_ctx.main_title.label), 9 /* TEXT, PROPS */, _hoisted_3$1i))
          : (openBlock(), createElementBlock("span", {
              key: 1,
              title: _ctx.main_title.title
            }, toDisplayString(_ctx.main_title.label), 9 /* TEXT, PROPS */, _hoisted_4$1d)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.secondary_title_list, (item) => {
          return (openBlock(), createElementBlock(Fragment, null, [
            createTextVNode(" / "),
            (item.href)
              ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  class: normalizeClass(item.class),
                  href: item.href,
                  title: item.title
                }, [
                  createTextVNode(toDisplayString(item.label) + " ", 1 /* TEXT */),
                  (item.icon)
                    ? (openBlock(), createElementBlock("i", {
                        key: 0,
                        class: normalizeClass(item.icon)
                      }, null, 2 /* CLASS */))
                    : createCommentVNode("v-if", true)
                ], 10 /* CLASS, PROPS */, _hoisted_5$15))
              : (openBlock(), createElementBlock("span", {
                  key: 1,
                  title: item.title
                }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_6$W))
          ], 64 /* STABLE_FRAGMENT */))
        }), 256 /* UNKEYED_FRAGMENT */))
      ]),
      _hoisted_7$T,
      _hoisted_8$S,
      createBaseVNode("div", _hoisted_9$K, [
        createBaseVNode("ul", _hoisted_10$G, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items_table, (item) => {
            return (openBlock(), createElementBlock(Fragment, null, [
              (item.active)
                ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    (item.active)
                      ? (openBlock(), createElementBlock("li", {
                          key: 0,
                          onClick: $event => (this.$emit('click_item', item)),
                          class: normalizeClass(["nav-item nav-link active", item.class])
                        }, [
                          (item.badge_num > 0)
                            ? (openBlock(), createElementBlock("span", _hoisted_12$A, toDisplayString(item.badge_num), 1 /* TEXT */))
                            : createCommentVNode("v-if", true),
                          createBaseVNode("b", null, [
                            createBaseVNode("i", {
                              class: normalizeClass(item.icon)
                            }, null, 2 /* CLASS */),
                            createTextVNode(" " + toDisplayString(item.label), 1 /* TEXT */)
                          ])
                        ], 10 /* CLASS, PROPS */, _hoisted_11$B))
                      : (openBlock(), createElementBlock("li", {
                          key: 1,
                          onClick: $event => (this.$emit('click_item', item)),
                          class: normalizeClass(["nav-item nav-link", item.class])
                        }, [
                          (item.badge_num > 0)
                            ? (openBlock(), createElementBlock("span", _hoisted_14$r, toDisplayString(item.badge_num), 1 /* TEXT */))
                            : createCommentVNode("v-if", true),
                          createBaseVNode("b", null, [
                            createBaseVNode("i", {
                              class: normalizeClass(item.icon)
                            }, null, 2 /* CLASS */),
                            createTextVNode(" " + toDisplayString(item.label), 1 /* TEXT */)
                          ])
                        ], 10 /* CLASS, PROPS */, _hoisted_13$u))
                  ], 64 /* STABLE_FRAGMENT */))
                : (openBlock(), createElementBlock("a", {
                    key: 1,
                    onClick: $event => (this.$emit('click_item', item)),
                    href: "#",
                    class: normalizeClass(["nav-item nav-link", item.class])
                  }, [
                    (item.badge_num > 0)
                      ? (openBlock(), createElementBlock("span", _hoisted_16$o, toDisplayString(item.badge_num), 1 /* TEXT */))
                      : createCommentVNode("v-if", true),
                    createBaseVNode("i", {
                      class: normalizeClass(item.icon)
                    }, null, 2 /* CLASS */),
                    createTextVNode(" " + toDisplayString(item.label), 1 /* TEXT */)
                  ], 10 /* CLASS, PROPS */, _hoisted_15$p))
            ], 64 /* STABLE_FRAGMENT */))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]),
        createBaseVNode("ul", _hoisted_17$l, [
          _hoisted_18$l,
          createBaseVNode("a", {
            target: "_newtab",
            href: _ctx.help_link,
            class: "nav-item nav-link text-muted"
          }, _hoisted_21$f, 8 /* PROPS */, _hoisted_19$l)
        ])
      ])
    ]))
  }

  script$1H.render = render$j;
  script$1H.__file = "http_src/vue/page-navbar.vue";

  var script$1G = defineComponent({
      components: {
      },
      props: {
  	id: String,
  	global: Boolean,
  	no_close_button: Boolean,
      },
      emits: [],
      /** This method is the first method of the component called, it's called before html template creation. */
      created() {
      },
      data() {
  	return {
  	    show_alert: false,
  	    i18n: (t) => i18n(t),
  	    body: "",
  	    alert_type: "alert-success",
  	};
      },
      /** This method is the first method called after html template creation. */
      mounted() {
  	if (this.global == true) {
  	    ntopng_events_manager.on_custom_event(this.$props["id"], ntopng_custom_events.SHOW_GLOBAL_ALERT_INFO, (info) => {
  		if (info.type != null) {
  		    this.alert_type = info.type;
  		}
  		if (info.timeout != null) {
  		    setTimeout(() => { this.close(); }, 1000 * info.timeout);
  		}
  		this.show(info.text_html);
  	    });	
  	}
      },
      methods: {
  	close: function() {
  	    this.show_alert = false;
  	},
  	show: function(body, alert_type) {
  	    this.show_alert = true;
  	    this.body = body;
  	    if (alert_type != null) {
  		this.alert_type = alert_type;
  	    }
  	},
      },
  });

  const _hoisted_1$1t = ["innerHTML"];

  function render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return (_ctx.show_alert == true)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: {"width":"100%"},
          class: normalizeClass(["alert alert-dismissable", _ctx.alert_type])
        }, [
          createBaseVNode("span", { innerHTML: _ctx.body }, null, 8 /* PROPS */, _hoisted_1$1t),
          (!_ctx.no_close_button)
            ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.close && _ctx.close(...args))),
                class: "btn-close",
                "aria-label": "Close"
              }))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  }

  script$1G.render = render$i;
  script$1G.__file = "http_src/vue/alert-info.vue";

  var script$1F = {
      components: {
      },
      props: {
  	id: String,
  	chart_type: String,
  	register_on_status_change: Boolean,
  	not_emit_global_status_update: Boolean,
  	base_url_request: String,
  	get_params_url_request: Function,
  	get_custom_chart_options: Function,
          map_chart_options: Function,
          min_time_interval_id: String,	
  	round_time: Boolean, //if min_time_interval_id != null round time by min_time_interval_id	
      },
      emits: ["apply", "hidden", "showed", "chart_reloaded", "zoom"],
      /** This method is the first method of the component called, it's called before html template creation. */
      created() {
      },
      beforeUnmount() {
  	this.chart.destroyChart();
      },
      data() {
  	return {
  	    chart: null,
  	    chart_options: null,
  	    from_zoom: false,
  	    //i18n: (t) => i18n(t),
  	};
      },
      /** This method is the first method called after html template creation. */
      async mounted() {
  	await this.init();
  	ntopng_sync.ready(this.$props["id"]);
      },
      methods: {
  	init: async function() {
  	    let status = ntopng_status_manager.get_status();
  	    let url_request = this.get_url_request(status);
  	    if (this.register_on_status_change) {
  		this.register_status(status);
  	    }
  	    await this.draw_chart(url_request);
  	},
  	get_data_uri: async function(options) {
  	    if (this.chart == null) { return null; }
  	    let data_uri = await this.chart.to_data_uri();
  	    return data_uri;
  	},
  	download_chart_png: async function(file_name, options) {
  	    if (this.chart == null) { return; }
  	    let data_uri = await this.chart.to_data_uri();
  	    downloadURI(data_uri, file_name);
  	},
  	register_status: function(status) {
  	    let url_request = this.get_url_request(status);
  	    ntopng_status_manager.on_status_change(this.id, (new_status) => {
  		if (this.from_zoom == true) {
  		    this.from_zoom = false;
  		    //return;
  		}
  		let new_url_request = this.get_url_request(new_status);
  		if (new_url_request == url_request) {
  		    url_request = new_url_request;
  		    return;
  		}
  		url_request = new_url_request;
  		this.update_chart(new_url_request);
  	    }, false);
  	},
  	get_url_request: function(status) {
  	    let url_params;
  	    if (this.get_params_url_request != null) {
  		if (status == null) {
  		    status = ntopng_status_manager.get_status();
  		}
  		url_params = this.get_params_url_request(status);
  	    } else {
  		url_params = ntopng_url_manager$1.get_url_params();
  	    }
  	    
  	    return `${this.base_url_request}?${url_params}`;
  	},
  	draw_chart: async function(url_request) {
  	    let chartApex = ntopChartApex;
  	    let chart_type = this.chart_type;
  	    if (chart_type == null) {
  		chart_type = chartApex.typeChart.TS_STACKED;
  	    }
  	    this.chart = chartApex.newChart(chart_type);
  	    let me = this;
  	    this.chart.registerEvent("beforeZoom", function(chart_context, axis) {
  		me.on_before_zoom(chart_context, axis);
  	    });
  	    this.chart.registerEvent("zoomed", function(chart_context, axis) {
  		me.on_zoomed(chart_context, axis);
  	    });
  	    let chart_options = await this.get_chart_options(url_request);
  	    this.chart.drawChart(this.$refs["chart"], chart_options);
  	},
  	update_chart: async function(url_request) {
  	    if (url_request == null) {
  		url_request = this.get_url_request();
  	    }
  	    let chart_options = await this.get_chart_options(url_request);
  	    this.chart.updateChart(chart_options);
  	},
  	update_chart_options: function(chart_options) {
  	    this.chart.updateChart(chart_options);
  	},
  	update_chart_series: function(series) {
  	    if (series == null) { return; }
  	    this.chart.updateSeries(series);
  	},
  	get_chart_options: async function(url_request) {
  	    let chart_options;
  	    if (this.get_custom_chart_options == null) {		
  		chart_options = await ntopng_utility$1.http_request(url_request);
  	    } else {
  		chart_options = await this.get_custom_chart_options(url_request);
  	    }
              if (this.map_chart_options != null) {
                  chart_options = this.map_chart_options(chart_options);
              }
  	    this.$emit('chart_reloaded', chart_options);
  	    return chart_options;
  	},
  	on_before_zoom: function(chart_context, { xaxis, yaxis }) {
  	    let new_epoch_status = this.get_epoch_from_xaxis_event(xaxis);
  	    if (this.min_time_interval_id != null) {
  		const min_time_interval = ntopng_utility$1.get_timeframe_from_timeframe_id(this.min_time_interval_id);
  		if (new_epoch_status.epoch_end - new_epoch_status.epoch_begin < min_time_interval) {
  		    
  		    new_epoch_status.epoch_end = new_epoch_status.epoch_end + min_time_interval;
  		    new_epoch_status.epoch_end = new_epoch_status.epoch_end - (new_epoch_status.epoch_end % min_time_interval);
  		    new_epoch_status.epoch_begin = new_epoch_status.epoch_end - min_time_interval;
  		}
  		if (this.round_time == true) {
  		    new_epoch_status.epoch_begin = ntopng_utility$1.round_time_by_timeframe_id(new_epoch_status.epoch_begin, this.min_time_interval_id);
  		    new_epoch_status.epoch_end = ntopng_utility$1.round_time_by_timeframe_id(new_epoch_status.epoch_end, this.min_time_interval_id);
  		}
  		
  		xaxis.min = new_epoch_status.epoch_begin * 1000;
  		xaxis.max = new_epoch_status.epoch_end * 1000;
  	    }
  	    return xaxis;
  	},
  	on_zoomed: function(chart_context, { xaxis, yaxis }) {
  	    this.from_zoom = true;
  	    const new_epoch_status = this.get_epoch_from_xaxis_event(xaxis);
              // the timestamps are in milliseconds, convert them into seconds
  	    if (!this.not_emit_global_status_update) {
  		ntopng_events_manager$1.emit_event(ntopng_events.EPOCH_CHANGE, new_epoch_status, this.id);
  	    }
  	    this.$emit('zoom', new_epoch_status);
  	},
  	get_epoch_from_xaxis_event: function(xaxis) {
  	    const begin = moment(xaxis.min);
              const end = moment(xaxis.max);
  	    let new_epoch_status = { epoch_begin: Number.parseInt(begin.unix()), epoch_end: Number.parseInt(end.unix()) };
  	    return new_epoch_status;
  	}
      },
  };

  const _hoisted_1$1s = {
    style: {"width":"100%"},
    ref: "chart"
  };

  function render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("div", _hoisted_1$1s, null, 512 /* NEED_PATCH */))
  }

  script$1F.render = render$h;
  script$1F.__file = "http_src/vue/chart.vue";

  var script$1E = {
      components: {
          'select-search': script$1I,
      },
      props: {
          id: String,
          enable_refresh: Boolean,
          disabled_date_picker: Boolean,
          min_time_interval_id: String,
  	    round_time: Boolean, //if min_time_interval_id != null round time by min_time_interval_id
          custom_time_interval_list: Array,
      },
      computed: {
          // a computed getter
          invalid_date_message: function () {
              if (this.wrong_date) {
                  return this.i18n('wrong_date_range');
              }
              else if (this.wrong_min_interval) {
                  let msg = this.i18n('wrong_min_interval');
                  msg.replace('%time_interval', this.i18n(`show_alerts.presets.${this.min_time_interval_id}`));

                  return msg
              }
          }
      },
      watch: {
          "enable_refresh": function (val, oldVal) {
              if (val == true) {
                  this.start_refresh();
              } else if (this.refresh_interval != null) {
                  clearInterval(this.refresh_interval);
                  this.refresh_interval = null;
              }
          },
          "min_time_interval_id": function () {
            // todo
          },
          "round_time": function () {
            // todo
          },
      },
      emits: ["epoch_change"],
      /** This method is the first method of the component called, it's called before html template creation. */
      created() {
      },
      beforeMount() {
          if (this.$props.custom_time_interval_list != null) {
              this.time_preset_list = this.$props.custom_time_interval_list;
          }
          // filter interval
          if (this.min_time_interval_id == null) {
              this.time_preset_list_filtered = this.time_preset_list;
              return;
          }
  	const timeframes_dict = this.get_timeframes_available();
  	const min_time_interval = timeframes_dict[this.min_time_interval_id];
          this.time_preset_list_filtered = this.time_preset_list.filter((elem) => {
              if (elem.value == "custom") {
                  return true;
              }
              return min_time_interval == null || timeframes_dict[elem.value] >= min_time_interval;
          });
      },
      /** This method is the first method called after html template creation. */
      mounted() {
          let epoch_begin = ntopng_url_manager$1.get_url_entry("epoch_begin");
          let epoch_end = ntopng_url_manager$1.get_url_entry("epoch_end");
          if (epoch_begin != null && epoch_end != null) {
              // update the status

              this.emit_epoch_change({ epoch_begin: Number.parseInt(epoch_begin), epoch_end: Number.parseInt(epoch_end) }, this.$props.id, true);
          }
          let me = this;
          let f_set_picker = (picker, var_name) => {
              return flatpickr($(this.$refs[picker]), {
                  enableTime: true,
                  dateFormat: "d/m/Y H:i",
                  //altInput: true,
                  //dateFormat: "YYYY-MM-DD HH:mm",
                  //altFormat: "d-m-Y H:i",
                  //locale: "it",
                  time_24hr: true,
                  clickOpens: true,
                  //mode: "range",
                  //static: true,
                  onChange: function (selectedDates, dateStr, instance) {
                      me.enable_apply = true;
                      me.wrong_date = me.flat_begin_date.selectedDates[0].getTime() > me.flat_end_date.selectedDates[0].getTime();
                      me.wrong_min_interval = me.min_time_interval_id && me.get_utc_seconds((me.flat_end_date.selectedDates[0].getTime() - me.flat_begin_date.selectedDates[0].getTime()) < ntopng_utility$1.get_timeframe_from_timeframe_id(me.min_time_interval_id));
                      //me.a[data] = d;
                  },
              });
          };
          this.flat_begin_date = f_set_picker("begin-date");
          this.flat_end_date = f_set_picker("end-date");
          ntopng_events_manager$1.on_event_change(this.$props.id, ntopng_events.EPOCH_CHANGE, (new_status) => this.on_status_updated(new_status), true);

          // notifies that component is ready
          //console.log(this.$props["id"]);
          ntopng_sync.ready(this.$props["id"]);
          if (this.enable_refresh) {
              this.start_refresh();
          }
      },

      /** Methods of the component. */
      methods: {
          start_refresh: function () {
              this.refresh_interval = setInterval(() => {
                  let value = this.selected_time_option?.value;
                  if (this.enable_refresh && value != null && value != "custom") {
                      this.update_from_interval = true;
                      this.change_select_time(true);
                  }
              }, this.refresh_interval_seconds * 1000);
              // }, 10* 1000);
          },
          utc_s_to_server_date: function (utc_seconds) {
              let utc = utc_seconds * 1000;
              let d_local = new Date(utc);
              let local_offset = d_local.getTimezoneOffset();
              let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
              let offset_minutes = server_offset + local_offset;
              let offset_ms = offset_minutes * 1000 * 60;
              var d_server = new Date(utc + offset_ms);
              return d_server;
          },
          server_date_to_date: function (date, format) {
              let utc = date.getTime();
              let local_offset = date.getTimezoneOffset();
              let server_offset = moment.tz(utc, ntop_zoneinfo)._offset;
              let offset_minutes = server_offset + local_offset;
              let offset_ms = offset_minutes * 1000 * 60;
              var d_local = new Date(utc - offset_ms);
              return d_local;
          },
          on_status_updated: function (status) {
              let end_date_time_utc = Date.now();
              // default begin date time now - 30 minutes
              let begin_date_time_utc = end_date_time_utc - 30 * 60 * 1000;
              if (status.epoch_end != null && status.epoch_begin != null
                  && Number.parseInt(status.epoch_end) > Number.parseInt(status.epoch_begin)) {
                  status.epoch_begin = Number.parseInt(status.epoch_begin);
                  status.epoch_end = Number.parseInt(status.epoch_end);
                  end_date_time_utc = status.epoch_end * 1000;
                  begin_date_time_utc = status.epoch_begin * 1000;
              } else {
                  status.epoch_end = this.get_utc_seconds(end_date_time_utc);
                  status.epoch_begin = this.get_utc_seconds(begin_date_time_utc);
                  ntopng_url_manager$1.add_obj_to_url(status);
                  this.emit_epoch_change(status, this.$props.id);
              }
              // this.flat_begin_date.setDate(new Date(status.epoch_begin * 1000));
              // this.flat_end_date.setDate(new Date(status.epoch_end * 1000));
              this.flat_begin_date.setDate(this.utc_s_to_server_date(status.epoch_begin));
              this.flat_end_date.setDate(this.utc_s_to_server_date(status.epoch_end));
              // this.set_date_time("begin-date", begin_date_time_utc, false);
              // this.set_date_time("begin-time", begin_date_time_utc, true);
              // this.set_date_time("end-date", end_date_time_utc, false);
              // this.set_date_time("end-time", end_date_time_utc, true);
              this.set_select_time_value(begin_date_time_utc, end_date_time_utc);
              this.epoch_status = { epoch_begin: status.epoch_begin, epoch_end: status.epoch_end };
              if (this.update_from_interval == false) {
                  this.add_status_in_history(this.epoch_status);
              }
              this.enable_apply = false;
              this.update_from_interval = false;
              ntopng_url_manager$1.add_obj_to_url(this.epoch_status);
          },
          set_select_time_value: function (begin_utc, end_utc) {
              const timeframes_dict = this.get_timeframes_available();
              const tolerance = 60;
              let now = this.get_utc_seconds(Date.now());
  	    if (this.round_time == true && this.min_time_interval_id != null) {
  		now = this.round_time_by_min_interval(now);
  	    }
              const end_utc_s = this.get_utc_seconds(end_utc);
              const begin_utc_s = this.get_utc_seconds(begin_utc);
  	    
              if (this.is_between(end_utc_s, now, tolerance)) {
  		this.select_time_value = null;
  		for (let time_id in timeframes_dict) {
  		    if (this.is_between(begin_utc_s, now - timeframes_dict[time_id], tolerance)) {
  			this.select_time_value = time_id;
  		    }
  		}
                  if (this.select_time_value == null) {
                      this.select_time_value = "custom";
                  }
              } else {
                  this.select_time_value = "custom";
              }

              this.time_preset_list_filtered.forEach(element => {
                  element.currently_active = false;
                  if (element.value == this.select_time_value) {
                      this.selected_time_option = element;
                      element.currently_active = true;
                  }
              });
          },
          apply: function () {
              // let date_begin = this.$refs["begin-date"].valueAsDate;
              // let d_time_begin = this.$refs["begin-time"].valueAsDate;
              // date_begin.setHours(d_time_begin.getHours());
              // date_begin.setMinutes(d_time_begin.getMinutes() + d_time_begin.getTimezoneOffset());
              // date_begin.setSeconds(d_time_begin.getSeconds());

              // let date_end = this.$refs["end-date"].valueAsDate;
              // let d_time_end = this.$refs["end-time"].valueAsDate;
              // date_end.setHours(d_time_end.getHours());
              // date_end.setMinutes(d_time_end.getMinutes() + d_time_end.getTimezoneOffset());
              // date_end.setSeconds(d_time_end.getSeconds());
              // let epoch_begin = this.get_utc_seconds(date_begin.valueOf());
              // let epoch_end = this.get_utc_seconds(date_end.valueOf());
              let now_s = this.get_utc_seconds(Date.now());
              let begin_date = this.server_date_to_date(this.flat_begin_date.selectedDates[0]);
              let epoch_begin = this.get_utc_seconds(begin_date.getTime());
              let end_date = this.server_date_to_date(this.flat_end_date.selectedDates[0]);
              let epoch_end = this.get_utc_seconds(end_date.getTime());
              if (epoch_end > now_s) {
                  epoch_end = now_s;
              }
              let status = { epoch_begin, epoch_end };
              this.emit_epoch_change(status);
          },
          // set_date_time: function(ref_name, utc_ts, is_time) {
          //     utc_ts = this.get_utc_seconds(utc_ts) * 1000;        
          //     let date_time = new Date(utc_ts);
          //     date_time.setMinutes(date_time.getMinutes() - date_time.getTimezoneOffset());
          //     if (is_time) {
          // 	this.$refs[ref_name].value = date_time.toISOString().substring(11,16);
          //     } else {
          // 	this.$refs[ref_name].value = date_time.toISOString().substring(0,10);
          //     }
          // },
          change_select_time: function (refresh_data) {
              let s_values = this.get_timeframes_available();
              let interval_s = s_values[this.selected_time_option.value];
              let epoch_end = this.get_utc_seconds(Date.now());
              let epoch_begin = epoch_end - interval_s;
              let status = { epoch_begin: epoch_begin, epoch_end: epoch_end, refresh_data };
              this.emit_epoch_change(status);
          },
          get_timeframes_available: function () {
  	    const timeframes_dict = ntopng_utility$1.get_timeframes_dict();
              const timeframes_ids = this.time_preset_list.map((ts) => ts.value);
  	    let timeframes_available = {};
  	    timeframes_ids.forEach((tf_id) => {
  		timeframes_available[tf_id] = timeframes_dict[tf_id];
  	    });
  	    return timeframes_available;
          },
          get_utc_seconds: function (utc_ms) {
  	    return ntopng_utility$1.get_utc_seconds(utc_ms);
          },
          is_between: function (x, y, tolerance) {
              return x >= y - tolerance && x <= y;
          },
          zoom: function (scale) {
              if (this.epoch_status == null) { return; }
              let interval = (this.epoch_status.epoch_end - this.epoch_status.epoch_begin) / scale;
              let center = (this.epoch_status.epoch_end / 2 + this.epoch_status.epoch_begin / 2);
              this.epoch_status.epoch_begin = center - interval / 2;
              this.epoch_status.epoch_end = center + interval / 2;
              let now = this.get_utc_seconds(Date.now());
              if (this.epoch_status.epoch_end > now) {
                  this.epoch_status.epoch_end = now;
              }
              this.epoch_status.epoch_end = Number.parseInt(this.epoch_status.epoch_end);
              this.epoch_status.epoch_begin = Number.parseInt(this.epoch_status.epoch_begin);
              if (this.epoch_status.epoch_begin == this.epoch_status.epoch_end) {
                  this.epoch_status.epoch_begin -= 2;
              }
              this.emit_epoch_change(this.epoch_status);
          },
          jump_time_back: function () {
              if (this.epoch_status == null) { return; }
              const min = 60;
              this.epoch_status.epoch_begin -= (30 * min);
              this.epoch_status.epoch_end -= (30 * min);
              this.emit_epoch_change(this.epoch_status);
          },
          jump_time_ahead: function () {
              if (this.epoch_status == null) { return; }
              const min = 60;
              let previous_end = this.epoch_status.epoch_end;
              let now = this.get_utc_seconds(Date.now());

              this.epoch_status.epoch_end += (30 * min);
              if (this.epoch_status.epoch_end > now) {
                  this.epoch_status.epoch_end = now;
              }
              this.epoch_status.epoch_begin += (this.epoch_status.epoch_end - previous_end);
              this.emit_epoch_change(this.epoch_status);
          },
          emit_epoch_change: function (epoch_status, id, emit_only_global_event) {
              if (epoch_status.epoch_end == null || epoch_status.epoch_begin == null) { return; }            this.wrong_date = false;
              if (epoch_status.epoch_begin > epoch_status.epoch_end) {
                  this.wrong_date = true;
                  return;
              }
  	    if (this.min_time_interval_id && this.round_time == true) {
  		epoch_status.epoch_begin = this.round_time_by_min_interval(epoch_status.epoch_begin);
  		epoch_status.epoch_end = this.round_time_by_min_interval(epoch_status.epoch_end);
  	    }

              if (id != this.id) {
                  this.on_status_updated(epoch_status);
              }
              ntopng_events_manager$1.emit_event(ntopng_events.EPOCH_CHANGE, epoch_status, this.id);
  	    if (emit_only_global_event) {
  		return;
  	    }
              this.$emit("epoch_change", epoch_status);
          },
  	round_time_by_min_interval: function(ts) {
  	    return ntopng_utility$1.round_time_by_timeframe_id(ts, this.min_time_interval_id);
  	},
          add_status_in_history: function (epoch_status) {
              this.history_last_status = this.history[this.history.length - 1];
              if (this.history.length > 5) {
                  this.history.shift();
              }
              this.history.push(epoch_status);
          },

          apply_status_by_history: function () {
              if (this.history_last_status == null) { return; }
              this.history.pop();
              this.history.pop();
              this.emit_epoch_change(this.history_last_status);
          },
      },
      /**
         Private date of vue component.
      */
      data() {
          return {
              i18n: (t) => i18n(t),
              //status_id: "date-time-range-picker" + this.$props.id,
              epoch_status: null,
              refresh_interval: null,
              refresh_interval_seconds: 60,
              update_from_interval: false,
              history: [],
              history_last_status: null,
              enable_apply: false,
              select_time_value: "5_min",
              selected_time_option: { value: "5_min", label: i18n('show_alerts.presets.5_min'), currently_active: false },
              wrong_date: false,
              wrong_min_interval: false,
              flat_begin_date: null,
              flat_end_date: null,
              time_preset_list: [
                  { value: "5_min", label: i18n('show_alerts.presets.5_min'), currently_active: false },
                  { value: "10_min", label: i18n('show_alerts.presets.10_min'), currently_active: false },
                  { value: "30_min", label: i18n('show_alerts.presets.30_min'), currently_active: true },
                  { value: "hour", label: i18n('show_alerts.presets.hour'), currently_active: false },
                  { value: "2_hours", label: i18n('show_alerts.presets.2_hours'), currently_active: false },
                  { value: "6_hours", label: i18n('show_alerts.presets.6_hours'), currently_active: false },
                  { value: "12_hours", label: i18n('show_alerts.presets.12_hours'), currently_active: false },
                  { value: "day", label: i18n('show_alerts.presets.day'), currently_active: false },
                  { value: "week", label: i18n('show_alerts.presets.week'), currently_active: false },
                  { value: "month", label: i18n('show_alerts.presets.month'), currently_active: false },
                  { value: "year", label: i18n('show_alerts.presets.year'), currently_active: false },
                  { value: "custom", label: i18n('show_alerts.presets.custom'), currently_active: false, disabled: true, },
              ],
              time_preset_list_filtered: [],
          };
      },
  };

  const _withScopeId$c = n => (pushScopeId("data-v-6ae24a28"),n=n(),popScopeId(),n);
  const _hoisted_1$1r = { class: "input-group" };
  const _hoisted_2$1k = { class: "form-group" };
  const _hoisted_3$1h = { class: "controls" };
  const _hoisted_4$1c = { class: "btn-group me-auto btn-group-sm flex-wrap d-flex" };
  const _hoisted_5$14 = { class: "btn-group ms-2" };
  const _hoisted_6$V = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-text" }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-calendar-alt" })
  ], -1 /* HOISTED */));
  const _hoisted_7$S = ["disabled"];
  const _hoisted_8$R = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-text" }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-right" })
  ], -1 /* HOISTED */));
  const _hoisted_9$J = ["disabled"];
  const _hoisted_10$F = ["title"];
  const _hoisted_11$A = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-exclamation-circle" }, null, -1 /* HOISTED */));
  const _hoisted_12$z = [
    _hoisted_11$A
  ];
  const _hoisted_13$t = { class: "d-flex align-items-center ms-2" };
  const _hoisted_14$q = ["disabled"];
  const _hoisted_15$o = { class: "btn-group" };
  const _hoisted_16$n = ["disabled", "title"];
  const _hoisted_17$k = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-left" }, null, -1 /* HOISTED */));
  const _hoisted_18$k = [
    _hoisted_17$k
  ];
  const _hoisted_19$k = ["disabled", "title"];
  const _hoisted_20$i = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-long-arrow-alt-right" }, null, -1 /* HOISTED */));
  const _hoisted_21$e = [
    _hoisted_20$i
  ];
  const _hoisted_22$e = ["disabled", "title"];
  const _hoisted_23$d = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-search-plus" }, null, -1 /* HOISTED */));
  const _hoisted_24$d = [
    _hoisted_23$d
  ];
  const _hoisted_25$b = ["disabled", "title"];
  const _hoisted_26$b = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-search-minus" }, null, -1 /* HOISTED */));
  const _hoisted_27$b = [
    _hoisted_26$b
  ];
  const _hoisted_28$9 = ["disabled", "title"];
  const _hoisted_29$9 = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-undo" }, null, -1 /* HOISTED */));
  const _hoisted_30$8 = [
    _hoisted_29$9
  ];
  const _hoisted_31$8 = ["disabled", "title"];
  const _hoisted_32$7 = /*#__PURE__*/ _withScopeId$c(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" }, null, -1 /* HOISTED */));
  const _hoisted_33$7 = [
    _hoisted_32$7
  ];

  function render$g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_search = resolveComponent("select-search");

    return (openBlock(), createElementBlock("div", _hoisted_1$1r, [
      createBaseVNode("div", _hoisted_2$1k, [
        createBaseVNode("div", _hoisted_3$1h, [
          createBaseVNode("div", _hoisted_4$1c, [
            renderSlot(_ctx.$slots, "begin"),
            createBaseVNode("div", null, [
              createVNode(_component_select_search, {
                disabled: $props.disabled_date_picker,
                selected_option: $data.selected_time_option,
                "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (($data.selected_time_option) = $event)),
                id: 'time_preset_range_picker',
                options: $data.time_preset_list_filtered,
                onSelect_option: _cache[1] || (_cache[1] = $event => ($options.change_select_time(null)))
              }, null, 8 /* PROPS */, ["disabled", "selected_option", "options"])
            ]),
            createBaseVNode("div", _hoisted_5$14, [
              _hoisted_6$V,
              createBaseVNode("input", {
                disabled: $props.disabled_date_picker,
                class: "flatpickr flatpickr-input form-control",
                type: "text",
                placeholder: "Choose a date..",
                "data-id": "datetime",
                ref: "begin-date",
                style: {"width":"10rem"}
              }, null, 8 /* PROPS */, _hoisted_7$S),
              createCommentVNode(" <input ref=\"begin-date\" @change=\"enable_apply=true\" @change=\"change_begin_date\" type=\"date\" class=\"date_time_input begin-timepicker form-control border-right-0 fix-safari-input\"> "),
              createCommentVNode(" <input ref=\"begin-time\" @change=\"enable_apply=true\" type=\"time\" class=\"date_time_input begin-timepicker form-control border-right-0 fix-safari-input\"> "),
              _hoisted_8$R,
              createBaseVNode("input", {
                disabled: $props.disabled_date_picker,
                class: "flatpickr flatpickr-input form-control",
                type: "text",
                placeholder: "Choose a date..",
                "data-id": "datetime",
                ref: "end-date",
                style: {"width":"10rem"}
              }, null, 8 /* PROPS */, _hoisted_9$J),
              createCommentVNode(" <input ref=\"end-date\" @change=\"enable_apply=true\" type=\"date\" class=\"date_time_input end-timepicker form-control border-left-0 fix-safari-input\" style=\"width: 2.5rem;\"> "),
              createCommentVNode(" <input ref=\"end-time\" @change=\"enable_apply=true\" type=\"time\" class=\"date_time_input end-timepicker form-control border-left-0 fix-safari-input\"> "),
              withDirectives(createBaseVNode("span", {
                title: $options.invalid_date_message,
                style: {"margin-left":"0.2rem","color":"red"}
              }, _hoisted_12$z, 8 /* PROPS */, _hoisted_10$F), [
                [vShow, $data.wrong_date || $data.wrong_min_interval]
              ])
            ]),
            createBaseVNode("div", _hoisted_13$t, [
              createBaseVNode("button", {
                disabled: !$data.enable_apply || $data.wrong_date || $data.wrong_min_interval,
                onClick: _cache[2] || (_cache[2] = (...args) => ($options.apply && $options.apply(...args))),
                type: "button",
                class: "btn btn-sm btn-primary"
              }, toDisplayString($data.i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_14$q),
              createBaseVNode("div", _hoisted_15$o, [
                createBaseVNode("button", {
                  disabled: $props.disabled_date_picker,
                  onClick: _cache[3] || (_cache[3] = $event => ($options.jump_time_back())),
                  type: "button",
                  class: "btn btn-sm btn-link",
                  ref: "btn-jump-time-back",
                  title: $data.i18n('date_time_range_picker.btn_move_left')
                }, _hoisted_18$k, 8 /* PROPS */, _hoisted_16$n),
                createBaseVNode("button", {
                  disabled: $props.disabled_date_picker,
                  onClick: _cache[4] || (_cache[4] = $event => ($options.jump_time_ahead())),
                  type: "button",
                  class: "btn btn-sm btn-link me-2",
                  ref: "btn-jump-time-ahead",
                  title: $data.i18n('date_time_range_picker.btn_move_right')
                }, _hoisted_21$e, 8 /* PROPS */, _hoisted_19$k),
                createBaseVNode("button", {
                  disabled: $props.disabled_date_picker,
                  onClick: _cache[5] || (_cache[5] = $event => ($options.zoom(2))),
                  type: "button",
                  class: "btn btn-sm btn-link",
                  ref: "btn-zoom-in",
                  title: $data.i18n('date_time_range_picker.btn_zoom_in')
                }, _hoisted_24$d, 8 /* PROPS */, _hoisted_22$e),
                createBaseVNode("button", {
                  disabled: $props.disabled_date_picker,
                  onClick: _cache[6] || (_cache[6] = $event => ($options.zoom(0.5))),
                  type: "button",
                  class: "btn btn-sm btn-link",
                  ref: "btn-zoom-out",
                  title: $data.i18n('date_time_range_picker.btn_zoom_out')
                }, _hoisted_27$b, 8 /* PROPS */, _hoisted_25$b),
                createBaseVNode("button", {
                  disabled: $data.history_last_status == null || $props.disabled_date_picker,
                  type: "button",
                  onClick: _cache[7] || (_cache[7] = $event => ($options.apply_status_by_history())),
                  class: "btn btn-sm btn-link",
                  title: $data.i18n('date_time_range_picker.btn_undo')
                }, _hoisted_30$8, 8 /* PROPS */, _hoisted_28$9),
                createBaseVNode("button", {
                  disabled: $data.select_time_value == 'custom' || $props.disabled_date_picker,
                  onClick: _cache[8] || (_cache[8] = $event => ($options.change_select_time())),
                  type: "button",
                  class: "btn btn-sm btn-link",
                  title: $data.i18n('date_time_range_picker.btn_refresh')
                }, _hoisted_33$7, 8 /* PROPS */, _hoisted_31$8),
                renderSlot(_ctx.$slots, "extra_buttons")
              ])
            ])
          ])
        ])
      ])
    ]))
  }

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$o = "\n.date_time_input[data-v-6ae24a28] {\n    width: 10.5rem;\n    max-width: 10.5rem;\n    min-width: 10.5rem;\n}\n";
  styleInject(css_248z$o);

  script$1E.render = render$g;
  script$1E.__scopeId = "data-v-6ae24a28";
  script$1E.__file = "http_src/vue/date-time-range-picker.vue";

  var script$1D = defineComponent({
      components: {
      },
      props: {
  	id: String,
      },
      emits: ["hidden", "showed", "closeModal", "openModal"],
      /** This method is the first method of the component called, it's called before html template creation. */
      created() {
      },
      data() {
  	return {
  	    //i18n: (t) => i18n(t),
  	};
      },
      /** This method is the first method called after html template creation. */
      mounted() {
  	let me = this;
  	$(this.$refs["modal_id"]).on('shown.bs.modal', function (e) {
  	    me.$emit("showed");
  	});
  	$(this.$refs["modal_id"]).on('hidden.bs.modal', function (e) {
  	    me.$emit("hidden");
  	});
  	// notifies that component is ready
  	ntopng_sync.ready(this.$props["id"]);
      },
      methods: {
  	show: function() {
  	    $(this.$refs["modal_id"]).modal("show");
        // emit openmodal to disable the autorefresh on vs page.
        this.$emit("openModal");
  	},
  	preventEnter: function() {},
  	close: function() {
  	    $(this.$refs["modal_id"]).modal("hide");
        // emit closemodal to enable (eventually if autorefresh variable is true)
        // the autorefresh on vs page.
        this.$emit("closeModal");
  	},
      },
  });

  const _hoisted_1$1q = {
    class: "modal-dialog modal-dialog-centered modal-lg",
    role: "document"
  };
  const _hoisted_2$1j = { class: "modal-content" };
  const _hoisted_3$1g = { class: "modal-header" };
  const _hoisted_4$1b = { class: "modal-title" };
  const _hoisted_5$13 = /*#__PURE__*/createBaseVNode("div", { class: "modal-close" }, [
    /*#__PURE__*/createBaseVNode("button", {
      type: "button",
      class: "btn-close",
      "data-bs-dismiss": "modal",
      "aria-label": "Close"
    })
  ], -1 /* HOISTED */);
  const _hoisted_6$U = { class: "modal-body" };
  const _hoisted_7$R = { class: "modal-footer" };
  const _hoisted_8$Q = /*#__PURE__*/createBaseVNode("div", { class: "mr-auto" }, null, -1 /* HOISTED */);
  const _hoisted_9$I = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-info test-feedback w-100",
    style: {"display":"none"}
  }, null, -1 /* HOISTED */);

  function render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("div", {
      onSubmit: _cache[0] || (_cache[0] = withModifiers((...args) => (_ctx.preventEnter && _ctx.preventEnter(...args)), ["prevent"])),
      class: "modal fade",
      ref: "modal_id",
      tabindex: "-1",
      role: "dialog",
      "aria-labelledby": "dt-add-filter-modal-title",
      "aria-hidden": "true"
    }, [
      createBaseVNode("div", _hoisted_1$1q, [
        createBaseVNode("div", _hoisted_2$1j, [
          createBaseVNode("div", _hoisted_3$1g, [
            createBaseVNode("h5", _hoisted_4$1b, [
              renderSlot(_ctx.$slots, "title")
            ]),
            _hoisted_5$13
          ]),
          createBaseVNode("div", _hoisted_6$U, [
            renderSlot(_ctx.$slots, "body")
          ]),
          createBaseVNode("div", _hoisted_7$R, [
            _hoisted_8$Q,
            renderSlot(_ctx.$slots, "footer"),
            _hoisted_9$I
          ])
        ])
      ])
    ], 544 /* HYDRATE_EVENTS, NEED_PATCH */))
  }

  script$1D.render = render$f;
  script$1D.__file = "http_src/vue/modal.vue";

  /*
   * (C) 2013-23 - ntop.org
   */

  /* ****************************************************** */

  const regexes = {
      ipv4: String.raw`^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$`,
      ipv6: String.raw`^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$`,
      mac_address: String.raw`^([0-9A-Fa-f]{2}:){5}([0-9A-Fa-f]{2})$`,
      comma_separted_port_regex: String.raw`^(\d{1,5})(,\s*\d{1,5})*$`,
      port_range_regex: String.raw`^(\d{1,5})-(\d{1,5})$`,
  	host_name: String.raw`^(?!\s*$)[a-zA-Z0-9._: \-\/]{1,250}|^[a-zA-Z0-9._: \-\/]{1,250}@[0-9]{0,5}`,
      singleword: String.raw`^(?=[a-zA-Z0-9._:\-]{3,253}$)(?!.*[_.:\-]{2})[^_.:\-].*[^_.:\-]$`,
  };

  /* ****************************************************** */

  const validateIP = (ip) => {
      return (validateIPv4(ip) || validateIPv6(ip));
  };

  /* ****************************************************** */

  const validateIPv4 = (ip) => {
      const ipv4 = new RegExp(regexes.ipv4);

      return ipv4.test(ip);
  };

  /* ****************************************************** */

  const validateIPv6 = (ip) => {
      const ipv6 = new RegExp(regexes.ipv6);

      return ipv6.test(ip);
  };

  const validateHostName = (host_name) => {
  	const host_name_regexp = new RegExp(regexes.host_name);

  	return host_name_regexp.test(host_name);
  };

  /* ****************************************************** */

  const validateCommaSeparatedPortList = (ports) => {
      const port_list = new RegExp(regexes.comma_separted_port_regex);

      return port_list.test(ports);
  };

  const validateSingleWord = (word) => {
      const singelWordRegex = new RegExp(regexes.singleword);

      return singelWordRegex.test(word);
  };

  /* ****************************************************** */

  const validatePortRange = (ports) => {
      const port_array = ports.split("-", 2);
      const low = Number(port_array[0]);
      const high = Number(port_array[1]);

      if ((isNaN(low)) || (isNaN(high)))
          return false;

      if ((low > 0) && (low < high) && (high < 65536))
          return true;
      else
          return false;
  };

  const Utils = NtopUtils$1;
  function get_data_pattern(type) {
      if (type == "text") {
          return `.*`;
      } else if (type == "vlan") {
          let vlan = String.raw`@(([1-9])|([1-9][0-9]{1,2})|([1-3][0-9]{3})|(40[0-8][0-9])|(409[0-5]))`;
          return vlan;
      } else if (type == "ip" || type == "cidr") {
          let vlan = get_data_pattern("vlan");
          let r_ipv4 = Utils.REGEXES.ipv4;
          let r_ipv4_vlan = r_ipv4.replaceAll("$", `${vlan}$`);
          let r_ipv6 = Utils.REGEXES.ipv6;
          let r_ipv6_vlan = r_ipv6.replaceAll("$", `${vlan}$`);
          if (type == "cidr") {
              let network_ipv4 = String.raw`(\/(([1-9])|([1-2][0-9])|(3[0-2])))`;
              let ipv4_cidr = r_ipv4.replaceAll("$", `${network_ipv4}$`);
              let ipv4_cidr_vlan = r_ipv4.replaceAll("$", `${network_ipv4}${vlan}$`);
              let network_ipv6 = String.raw`(\/(([1-9])|([1-9][0-9])|(1[0-1][0-9])|(12[0-8])))`;
              let ipv6_cidr = r_ipv6.replaceAll("$", `${network_ipv6}$`);
              let ipv6_cidr_vlan = r_ipv6.replaceAll("$", `${network_ipv6}${vlan}$`);
              return `(${ipv4_cidr}|${ipv4_cidr_vlan}|${ipv6_cidr}|${ipv6_cidr_vlan})`;
          }
          return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
      } else if (type == "mac") {
          return Utils.REGEXES["macAddress"];
      } else if (type == "ip,cidr") {
          let ip = get_data_pattern("ip");
          let cidr = get_data_pattern("cidr");
          return `(${ip})|(${cidr})`;
      }
      return Utils.REGEXES[type];
  }

  const regexValidation = function () {
      return {
          get_data_pattern,
          validateIP,
          validateIPv4,
          validateIPv6,
  		validateHostName,
          validateCommaSeparatedPortList,
          validatePortRange,
          validateSingleWord,
      };
  }();

  var script$1C = {
      components: {
  	'modal': script$1D,
  	'select-search': script$1I,
      }, 
      props: {
  	id: String,
  	filters_options: Array,
      },
      updated() {
      },
      data() {
  	return {
  	    i18n: (t) => i18n(t),
  	    jQuery: $,
  	    id_modal: `${this.$props.id}_modal`,
  	    filter_type_selected: {},
  	    filter_type_label_selected: null,
  	    operator_selected: {},
  	    option_selected: {},
  	    input_value: null,
  	    input_type: null,
  	    data_pattern_selected: null,
  	    input_required: false,
  	    options_to_show: null,
  	    operators_to_show: [],
  	};
      },
      emits: ["apply"],
      created() {},
      /** This method is the first method called after html template creation. */
      async mounted() {
  	await ntopng_sync.on_ready(this.id_modal);
  	ntopng_events_manager.on_custom_event(this.$props["id"], ntopng_custom_events.SHOW_MODAL_FILTERS, (filter) => this.show(filter));	
  	// notifies that component is ready
  	ntopng_sync.ready(this.$props["id"]);
      },
      methods: {
  	show: function(filter) {
  	    if (this.$props.filters_options == null || this.$props.filters_options.length == 0) { 
  		return; 
  	    }
  	    if (filter != null) {
  	  	this.filter_type_selected = filter;
  		this.change_filter(filter);		
  	    } else {
  		this.filter_type_selected = this.$props.filters_options[0];
  		this.change_filter();
  	    }
  	    this.$refs["modal"].show();
  	},
  	post_change: function(filter, value_type) {
  	    if (filter.id && this.$props.filters_options) {
  		/* Filter type selected, e.g. Alert Type, Application, ecc. */
  		this.filter_type_selected = this.$props.filters_options.find((fo) => fo.id == filter.id);
  	    }
  	    if (filter.value != null) {
  		/* Filter selected for the type, e.g. DNS, ICMP, ecc. */
  		if (this.options_to_show) {
  		    this.option_selected = this.options_to_show.find((fo) => fo.value == filter.value);
  		} else {
  		    this.option_selected = {};
  		    this.input_value = filter.value;
  		    this.data_pattern_selected = this.get_data_pattern(value_type);
  		}
  	    }
  	    if (filter.operator && this.operators_to_show) {
  		/* Operator filter selected, e.g. =, !=, ecc. */
  		this.operator_selected = this.operators_to_show.find((fo) => fo.id == filter.operator);
  	    }
  	},
  	change_operator_type: function(selected_operator_type) {
  	    this.operator_selected = selected_operator_type;
  	},
  	change_data_filter: function(selected_filter) {
  	    this.option_selected = selected_filter;
  	},  
  	change_input_value: function(input) {
  	    this.input_value = input;
  	},
  	change_filter: function(selected_filter) {
  	    this.options_to_show = null;
  	    this.option_selected = null;
  	    this.input_value = null;
  	    let filters_options = this.$props.filters_options;
  	    /* Search the filter selected */
  	    let filter = filters_options.find((fo) => fo.id == this.filter_type_selected.id);
  	    if (filter == null) { 
  		return; 
  	    }
  	    /* Set the correct filters to display */
  	    this.input_type = filter.type;
  	    this.operators_to_show = filter.operators;
  	    this.filter_type_label_selected = filter.label;
  	    if (this.input_type == 'select') {
  		this.options_to_show = filter.options.sort((a, b) => {
  		    if (a == null || a.label == null) { return -1; }
  		    if (b == null || b.label == null) { return 1; }
  		    return a.label.toString().localeCompare(b.label.toString());
  		});
  		this.option_selected = this.options_to_show[0];
  	    } else if (this.input_type == 'select-with-input') {
  		this.options_to_show = filter.options?.sort((a, b) => {
  		    if (a == null || a.label == null) { return -1; }
  		    if (b == null || b.label == null) { return 1; }
  		    return a.label.toString().localeCompare(b.label.toString());
  		});
  		this.option_selected = this.options_to_show[0];
  		this.data_pattern_selected = this.get_data_pattern(filter.value_type);
  	    } else {
  		this.options_to_show = null;
  		this.data_pattern_selected = this.get_data_pattern(filter.value_type);
  	    }
  	    
  	    if(filter.operators && this.operator_selected?.id == null) {
  		this.operator_selected = filter.operators[0];
  	    }
  	    
  	    if (selected_filter != null) { 
  		this.post_change(selected_filter, filter.value_type); 
  	    }
  	},
  	get_data_pattern: function(value_type) {
  	    this.input_required = true;
  	    if (value_type == "text") {
  		this.input_required = false;
  		return `.*`;
  	    }
  	    return regexValidation.get_data_pattern(value_type);
  	    
  	    // else if (value_type == "ip") {
  	    // 	let r_ipv4 = NtopUtils.REGEXES.ipv4;
  	    // 	let r_ipv4_vlan = r_ipv4.replace("$", "@[0-9]{0,5}$");
  	    // 	let r_ipv6 = NtopUtils.REGEXES.ipv6;
  	    // 	let r_ipv6_vlan = r_ipv6.replaceAll("$", "@[0-9]{0,5}$");
  	    // 	return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
  	    // } else if (value_type == "cidr") {
  	    // 	console.log("test");
  	    // }
  	    
  	    // return NtopUtils.REGEXES[value_type];
  	},
  	check_disable_apply: function() {
  	    let regex = new RegExp(this.data_pattern_selected);
  	    let disable_apply = !this.options_to_show && (
  		(this.input_required && (this.input_value == null || this.input_value == ""))
  		    || (regex.test(this.input_value) == false)
  	    );
  	    return disable_apply;
  	},
  	apply: function() {
  	    let value = this.input_value;
  	    let value_label = this.input_value;
  	    if (value == null || (this.option_selected?.value != null)) {
  		let filter = this.filters_options.find((fo) => fo.id == this.filter_type_selected.id);
                  
  		let option = filter.options.find((o) => o.value == this.option_selected.value);
                  if (option == null) {
                      option = this.option_selected;
                  }
  		value = option.value;
  		value_label = option.value_label || option.label;
  	    }
  	    let params = {
  		id: this.filter_type_selected.id,
  		label: this.filter_type_label_selected,
  		operator: this.operator_selected.id,
  		value: value,
  		value_label: value_label,
  	    };
  	    this.$emit("apply", params);
  	    ntopng_events_manager.emit_custom_event(ntopng_custom_events.MODAL_FILTERS_APPLY, params);
  	    this.close();
  	},
  	close: function() {
  	    this.$refs["modal"].close();
  	},
      },
  };

  const _withScopeId$b = n => (pushScopeId("data-v-3119c83e"),n=n(),popScopeId(),n);
  const _hoisted_1$1p = { autocomplete: "off" };
  const _hoisted_2$1i = { class: "form-group row" };
  const _hoisted_3$1f = /*#__PURE__*/ _withScopeId$b(() => /*#__PURE__*/createBaseVNode("label", {
    class: "col-form-label col-sm-3",
    for: "dt-filter-type-select"
  }, [
    /*#__PURE__*/createBaseVNode("b", null, "Filter")
  ], -1 /* HOISTED */));
  const _hoisted_4$1a = { class: "col-sm-8" };
  const _hoisted_5$12 = /*#__PURE__*/ _withScopeId$b(() => /*#__PURE__*/createBaseVNode("hr", null, null, -1 /* HOISTED */));
  const _hoisted_6$T = { class: "dt-filter-template-container form-group row" };
  const _hoisted_7$Q = { class: "col-form-label col-sm-3" };
  const _hoisted_8$P = { class: "col-sm-8" };
  const _hoisted_9$H = { class: "input-group mb-3" };
  const _hoisted_10$E = { class: "input-group-prepend col-sm-3" };
  const _hoisted_11$z = {
    key: 0,
    class: "col-sm-9"
  };
  const _hoisted_12$y = {
    key: 1,
    class: "col-sm-9"
  };
  const _hoisted_13$s = ["pattern", "required"];
  const _hoisted_14$p = {
    style: {"margin":"0px","padding":"0"},
    class: "alert invalid-feedback"
  };
  const _hoisted_15$n = ["disabled"];

  function render$e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_search = resolveComponent("select-search");
    const _component_modal = resolveComponent("modal");

    return (openBlock(), createBlock(_component_modal, {
      id: $data.id_modal,
      ref: "modal"
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString($data.i18n('alerts_dashboard.add_filter')), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("form", _hoisted_1$1p, [
          createBaseVNode("div", _hoisted_2$1i, [
            _hoisted_3$1f,
            createBaseVNode("div", _hoisted_4$1a, [
              createVNode(_component_select_search, {
                selected_option: $data.filter_type_selected,
                "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (($data.filter_type_selected) = $event)),
                id: 'filter_type',
                options: $props.filters_options,
                onSelect_option: _cache[1] || (_cache[1] = $event => ($options.change_filter()))
              }, null, 8 /* PROPS */, ["selected_option", "options"])
            ])
          ]),
          _hoisted_5$12,
          createBaseVNode("div", _hoisted_6$T, [
            createBaseVNode("label", _hoisted_7$Q, [
              createBaseVNode("b", null, toDisplayString($data.filter_type_label_selected), 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_8$P, [
              createBaseVNode("div", _hoisted_9$H, [
                createBaseVNode("div", _hoisted_10$E, [
                  createVNode(_component_select_search, {
                    selected_option: $data.operator_selected,
                    "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => (($data.operator_selected) = $event)),
                    id: 'operator_filter',
                    options: $data.operators_to_show,
                    onSelect_option: $options.change_operator_type
                  }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"])
                ]),
                ($data.input_type == 'select')
                  ? (openBlock(), createElementBlock("div", _hoisted_11$z, [
                      createVNode(_component_select_search, {
                        selected_option: $data.option_selected,
                        "onUpdate:selected_option": _cache[3] || (_cache[3] = $event => (($data.option_selected) = $event)),
                        id: 'data_filter',
                        options: $data.options_to_show,
                        onSelect_option: $options.change_data_filter
                      }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"])
                    ]))
                  : ($data.input_type == 'select-with-input')
                    ? (openBlock(), createElementBlock("div", _hoisted_12$y, [
                        createVNode(_component_select_search, {
                          selected_option: $data.option_selected,
                          "onUpdate:selected_option": _cache[4] || (_cache[4] = $event => (($data.option_selected) = $event)),
                          id: 'data_filter',
                          add_tag: true,
                          pattern: $data.data_pattern_selected,
                          options: $data.options_to_show,
                          onSelect_option: $options.change_data_filter
                        }, null, 8 /* PROPS */, ["selected_option", "pattern", "options", "onSelect_option"])
                      ]))
                    : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                        withDirectives(createBaseVNode("input", {
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => (($data.input_value) = $event)),
                          pattern: $data.data_pattern_selected,
                          name: "value",
                          required: $data.input_required,
                          type: "text",
                          class: "form-control"
                        }, null, 8 /* PROPS */, _hoisted_13$s), [
                          [vModelText, $data.input_value]
                        ]),
                        createBaseVNode("span", _hoisted_14$p, toDisplayString($data.i18n('invalid_value')), 1 /* TEXT */)
                      ], 64 /* STABLE_FRAGMENT */))
              ]),
              createCommentVNode(" end div input-group mb-3 ")
            ]),
            createCommentVNode(" end div form-group-row ")
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          disabled: $options.check_disable_apply(),
          onClick: _cache[6] || (_cache[6] = (...args) => ($options.apply && $options.apply(...args))),
          class: "btn btn-primary"
        }, toDisplayString($data.i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_15$n)
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["id"]))
  }

  var css_248z$n = "\ninput ~ .alert[data-v-3119c83e] {\n  display: none;\n}\ninput:invalid ~ .alert[data-v-3119c83e] {\n  display: block;\n}\n";
  styleInject(css_248z$n);

  script$1C.render = render$e;
  script$1C.__scopeId = "data-v-3119c83e";
  script$1C.__file = "http_src/vue/modal-filters.vue";

  function get_page(alert_stats_page) {
      let page = ntopng_url_manager.get_url_entry("page");
      if (page == null) {
          if (alert_stats_page) {
              page = "all";
          } else {
              page = "overview";
          }
      }
      return page;
  }

  async function get_filter_const(is_alert_stats_url, page) {
      let url_request;
      let query_preset = ntopng_url_manager.get_url_entry("query_preset");
      if (query_preset == null) { query_preset = ""; }
      if (is_alert_stats_url) {
          url_request = `${http_prefix}/lua/rest/v2/get/alert/filter/consts.lua?page=${page}&query_preset=${query_preset}`;
      } else {
          let aggregated = ntopng_url_manager.get_url_entry("aggregated");
          url_request = `${http_prefix}/lua/pro/rest/v2/get/db/filter/consts.lua?page=${page}&query_preset=${query_preset}&aggregated=${aggregated}`;
      }
      let filter_consts = await ntopng_utility.http_request(url_request);
      return filter_consts;
  }

  let FILTERS_CONST$1 = [];
  let TAG_OPERATORS$1;
  let DEFINED_TAGS$1;
  /* Initial Tags */
  let initialTags;
  //let pageHandle = {};
  let TAGIFY;
  let IS_ALERT_STATS_URL = window.location.toString().match(/alert_stats.lua/) != null;
  let STATUS_VIEW = ntopng_url_manager.get_url_entry("status");
  if (STATUS_VIEW == null || STATUS_VIEW == "") {
      STATUS_VIEW = "historical";
  }

  let PAGE = get_page(IS_ALERT_STATS_URL);

  const create_tag_from_filter = function (filter) {
      let f_const = FILTERS_CONST$1.find((f) => f.id == filter.id);
      if (f_const == null) { console.error("create_tag_from_filter: filter const not found;"); }

      let value_label = filter.value;
      if (f_const.options != null) {
          let opt = f_const.options.find((o) => o.value == filter.value);
          if (opt != null) {
              value_label = opt.label;
          }
      }
      const tag = {
          label: f_const.label,
          key: f_const.id,
          value: value_label,
          realValue: filter.value,
          title: `${f_const.label}${filter.operator}${value_label}`,
          selectedOperator: filter.operator,
      };
      if (tag.value == "") { tag.value = "''"; }
      if (tag.realValue == null || tag.selectedOperator == null || tag.selectedOperator == "") {
          return null;
      }
      return tag;
  };

  const load_filters_data = async function () {
      FILTERS_CONST$1 = await get_filter_const(IS_ALERT_STATS_URL, PAGE);
      FILTERS_CONST$1.filter((x) => x.label == null).forEach((x) => { console.error(`label not defined for filter ${JSON.stringify(x)}`); x.label = ""; });
      FILTERS_CONST$1.sort((a, b) => a.label.localeCompare(b.label));
      i18n_ext.tags = {};
      TAG_OPERATORS$1 = {};
      DEFINED_TAGS$1 = {};
      FILTERS_CONST$1.forEach((f_def) => {
          i18n_ext.tags[f_def.id] = f_def.label;
          f_def.operators.forEach((op) => TAG_OPERATORS$1[op.id] = op.label);
          DEFINED_TAGS$1[f_def.id] = f_def.operators.map((op) => op.id);
      });
      let entries = ntopng_url_manager.get_url_entries();
      let filters = [];
      for (const [key, value] of entries) {
          let filter_def = FILTERS_CONST$1.find((fc) => fc.id == key);
          if (filter_def != null) {
              let options_string = value.split(",");
              options_string.forEach((opt_stirng) => {
                  let [value, operator] = opt_stirng.split(";");
                  if (
                      operator == null || value == null || operator == ""
                      || (filter_def.options != null && filter_def.options.find((opt) => opt.value == value) == null)
                  ) {
                      return;
                  }
  		let value_label = value;
  		if (filter_def.value_type == "array") {
  		    value_label = filter_def?.options?.find((opt) => opt.value == value)?.label;
  		}
                  filters.push({ id: filter_def.id, operator: operator, value: value, label: filter_def.label, value_label });
              });
          }
      }
      return filters;
      // "l7proto=XXX;eq"
  };

  var script$1B = {
      props: {
          id: String,
          min_time_interval_id: String,
          round_time: Boolean,
      },
      components: {
          'date-time-range-picker': script$1E,
          'modal-filters': script$1C,
      },
      /**
       * First method called when the component is created.
       */
      created() {
      },
      async mounted() {
          let dt_range_picker_mounted = ntopng_sync.on_ready(this.id_data_time_range_picker);
          ntopng_sync.on_ready(this.id_modal_filters);
          await dt_range_picker_mounted;

          if (this.page != 'all') {
              let filters = await load_filters_data();

              TAGIFY = create_tagify(this);
              ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, { filters });
              ntopng_events_manager.on_event_change(this.$props["id"], ntopng_events.FILTERS_CHANGE, (status) => this.reload_status(status), true);
          }
          this.modal_data = FILTERS_CONST$1;

          //await modal_filters_mounted;
          ntopng_sync.ready(this.$props["id"]);
      },
      data() {
          return {
              i18n: i18n,
              id_modal_filters: `${this.$props.id}_modal_filters`,
              id_data_time_range_picker: `${this.$props.id}_date-time-range-picker`,
              show_filters: false,
              edit_tag: null,
              is_alert_stats_url: IS_ALERT_STATS_URL,
              status_view: STATUS_VIEW,
              page: PAGE,
              modal_data: [],
              last_filters: [],
          };
      },
      methods: {
          is_filter_defined: function (filter) {
              return DEFINED_TAGS$1[filter.id] != null;
          },
          update_status_view: function (status) {
              ntopng_url_manager.set_key_to_url("status", status);
              ntopng_url_manager.reload_url();
          },
          show_modal_filters: function () {
              this.$refs["modal_filters"].show();
          },
          remove_filters: function () {
              let filters = [];
              ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, { filters });
          },
          reload_status: function (status) {
              let filters = status.filters;
              if (filters == null) { return; }
              // delete all previous filter
              ntopng_url_manager.delete_params(FILTERS_CONST$1.map((f) => f.id));
              TAGIFY.tagify.removeAllTags();
              let filters_object = filtersManager.get_filters_object(filters);
              ntopng_url_manager.add_obj_to_url(filters_object);
              filters.forEach((f) => {
                  let tag = create_tag_from_filter(f);
                  if (tag == null) { return; }
                  TAGIFY.addFilterTag(tag);
              });
              this.last_filters = filters;
          },
          apply_modal: function (params) {
              let status = ntopng_status_manager.get_status();
              let filters = status.filters;
              if (filters == null) { filters = []; }
              if (this.edit_tag != null) {
                  filters = filters.filter((f) => f.id != this.edit_tag.key || f.value != this.edit_tag.realValue);
                  this.edit_tag = null;
              }
              filters.push(params);
              // trigger event and then call reload_status
              ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, { filters });
          },
      },
  };

  function create_tagify(range_picker_vue) {
      // create tagify
      const tagify = new Tagify(range_picker_vue.$refs["tagify"], {
          duplicates: true,
          delimiters: null,
          dropdown: {
              enabled: 1, // suggest tags after a single character input
              classname: 'extra-properties' // custom class for the suggestions dropdown
          },
          autoComplete: { enabled: false },
          templates: {
              tag: function (tagData) {
                  try {
                      return `<tag title='${tagData.value}' contenteditable='false' spellcheck="false" class='tagify__tag'>
                        <x title='remove tag' class='tagify__tag__removeBtn'></x>
                        <div>
                           <b>${tagData.label ? tagData.label : tagData.key}</b>&nbsp;
                           <b class='operator'>${tagData.selectedOperator ? TAG_OPERATORS$1[tagData.selectedOperator] : '='}</b>&nbsp;
                            <span class='tagify__tag-text'>${tagData.value}</span>
                        </div>
                    </tag>`
                  }
                  catch (err) {
                      console.error(`An error occured when creating a new tag: ${err}`);
                  }
              },
          },
          validate: function (tagData) {
              return (typeof tagData.key !== 'undefined' &&
                  typeof tagData.selectedOperator !== 'undefined' &&
                  typeof tagData.value !== 'undefined');
          }
      });

      $(document).ready(function () {
          // add existing tags
          tagify.addTags(initialTags);
      }); /* $(document).ready() */

      const addFilterTag = async function (tag) {
          /* Convert values to string (this avoids issues e.g. with 0) */
          if (typeof tag.realValue == 'number') { tag.realValue = '' + tag.realValue; }
          if (typeof tag.value == 'number') { tag.value = '' + tag.value; }

          const existingTagElms = tagify.getTagElms();

          /* Lookup by key, value and operator (do not add the same key and value multiple times) */
          let existingTagElement = existingTagElms.find(htmlTag =>
              htmlTag.getAttribute('key') === tag.key
              && htmlTag.getAttribute('realValue') === tag.realValue
              //&& htmlTag.getAttribute('selectedOperator') === tag.selectedOperator
          );
          let existingTag = tagify.tagData(existingTagElement);
          if (existingTag !== undefined) {
              return;
          }

          // has the tag an operator object?
          if (DEFINED_TAGS$1[tag.key] && !Array.isArray(DEFINED_TAGS$1[tag.key])) {
              tag.operators = DEFINED_TAGS$1[tag.key].operators;
          }

          if (!tag.selectedOperator) {
              tag.selectedOperator = 'eq';
          }
          // add filter!
          tagify.addTags([tag]);
      };

      // when an user remove the tag
      tagify.on('remove', async function (e) {
          const key = e.detail.data.key;
          const value = e.detail.data.realValue;
          const status = ntopng_status_manager.get_status();

          if (key === undefined) { return; }
          if (status.filters == null) { return; }

          const filters = status.filters.filter((f) => (f.id != key || (f.id == key && f.value != value)));
          ntopng_events_manager.emit_event(ntopng_events.FILTERS_CHANGE, { filters });
      });

      tagify.on('add', async function (e) {
          const detail = e.detail;
          if (detail.data === undefined) { return; }
          const tag = detail.data;
          // let's check if the tag has a key field
          if (!tag.key) {
              tagify.removeTags([e.detail.tag]);
              e.preventDefault();
              e.stopPropagation();
              return;
          }
      });

      // Tag 'click' event handler to open the 'Edit' modal. Note: this prevents
      // inline editing of the tag ('edit:updated' is never called as a consequence)
      tagify.on('click', async function (e) {
          const detail = e.detail;
          if (detail.data === undefined) { return; }
          if (detail.data.key === undefined) { return; }
          const tag = detail.data;
          // remember that this tag already exixts
          range_picker_vue.edit_tag = tag;
          // show modal-filters
          ntopng_events_manager.emit_custom_event(ntopng_custom_events.SHOW_MODAL_FILTERS, { id: tag.key, operator: tag.selectedOperator, value: tag.realValue });
      });

      tagify.on('edit:updated', async function (e) {
          console.warn("UPDATED");
          return;
      });

      $(`tags`).on('change', 'select.operator', async function (e) {
          console.warn("TAGS change");
          return;
      });
      return {
          tagify,
          addFilterTag,
      };
  }

  const _withScopeId$a = n => (pushScopeId("data-v-aaee59ea"),n=n(),popScopeId(),n);
  const _hoisted_1$1o = { style: {"width":"100%"} };
  const _hoisted_2$1h = { class: "mb-1" };
  const _hoisted_3$1e = {
    key: 0,
    style: {"margin-right":"0.1rem"},
    class: "d-flex align-items-center me-2"
  };
  const _hoisted_4$19 = {
    class: "btn-group",
    id: "statusSwitch",
    role: "group"
  };
  const _hoisted_5$11 = /*#__PURE__*/ _withScopeId$a(() => /*#__PURE__*/createBaseVNode("i", {
    class: "fa-solid fa-hourglass-half",
    title: "Engaged"
  }, null, -1 /* HOISTED */));
  const _hoisted_6$S = [
    _hoisted_5$11
  ];
  const _hoisted_7$P = /*#__PURE__*/ _withScopeId$a(() => /*#__PURE__*/createBaseVNode("i", {
    class: "fa-regular fa-eye",
    title: "Require Attention"
  }, null, -1 /* HOISTED */));
  const _hoisted_8$O = [
    _hoisted_7$P
  ];
  const _hoisted_9$G = /*#__PURE__*/ _withScopeId$a(() => /*#__PURE__*/createBaseVNode("i", {
    class: "fa-solid fa-inbox",
    title: "All"
  }, null, -1 /* HOISTED */));
  const _hoisted_10$D = [
    _hoisted_9$G
  ];
  const _hoisted_11$y = {
    key: 0,
    class: "d-flex mt-1",
    style: {"width":"100%"}
  };
  const _hoisted_12$x = ["placeholder"];
  const _hoisted_13$r = /*#__PURE__*/ _withScopeId$a(() => /*#__PURE__*/createBaseVNode("span", null, [
    /*#__PURE__*/createBaseVNode("i", {
      class: "fas fa-plus",
      "data-original-title": "",
      title: "Add Filter"
    })
  ], -1 /* HOISTED */));
  const _hoisted_14$o = [
    _hoisted_13$r
  ];
  const _hoisted_15$m = /*#__PURE__*/ _withScopeId$a(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-times" }, null, -1 /* HOISTED */));
  const _hoisted_16$m = [
    _hoisted_15$m
  ];

  function render$d(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_modal_filters = resolveComponent("modal-filters");
    const _component_date_time_range_picker = resolveComponent("date-time-range-picker");

    return (openBlock(), createElementBlock("div", _hoisted_1$1o, [
      createBaseVNode("div", _hoisted_2$1h, [
        createVNode(_component_modal_filters, {
          filters_options: $data.modal_data,
          onApply: $options.apply_modal,
          ref: "modal_filters",
          id: $data.id_modal_filters
        }, null, 8 /* PROPS */, ["filters_options", "onApply", "id"]),
        createVNode(_component_date_time_range_picker, {
          id: $data.id_data_time_range_picker,
          min_time_interval_id: $props.min_time_interval_id,
          round_time: $props.round_time
        }, {
          begin: withCtx(() => [
            ($data.is_alert_stats_url)
              ? (openBlock(), createElementBlock("div", _hoisted_3$1e, [
                  createBaseVNode("div", _hoisted_4$19, [
                    ($data.page != 'flow')
                      ? (openBlock(), createElementBlock("a", {
                          key: 0,
                          href: "#",
                          onClick: _cache[0] || (_cache[0] = $event => ($options.update_status_view('engaged'))),
                          class: normalizeClass(["btn btn-sm", { 'active': $data.status_view == 'engaged', 'btn-seconday': $data.status_view != 'engaged', 'btn-primary': $data.status_view == 'engaged' }])
                        }, _hoisted_6$S, 2 /* CLASS */))
                      : createCommentVNode("v-if", true),
                    createBaseVNode("a", {
                      href: "#",
                      onClick: _cache[1] || (_cache[1] = $event => ($options.update_status_view('historical'))),
                      class: normalizeClass(["btn btn-sm", { 'active': $data.status_view == 'historical' || ($data.page == 'flow' && $data.status_view == 'engaged'), 'btn-seconday': $data.status_view != 'historical', 'btn-primary': $data.status_view == 'historical' || ($data.page == 'flow' && $data.status_view == 'engaged') }])
                    }, _hoisted_8$O, 2 /* CLASS */),
                    createCommentVNode(" <a href=\"#\" @click=\"update_status_view('acknowledged')\" class=\"btn btn-sm\"\n                                :class=\"{ 'active': status_view == 'acknowledged', 'btn-seconday': status_view != 'acknowledged', 'btn-primary': status_view == 'acknowledged' }\"><i class=\"fa-solid fa-check-double\" title=\"Acknowledged\"></i></a>"),
                    createBaseVNode("a", {
                      href: "#",
                      onClick: _cache[2] || (_cache[2] = $event => ($options.update_status_view('any'))),
                      class: normalizeClass(["btn btn-sm", { 'active': $data.status_view == 'any', 'btn-seconday': $data.status_view != 'any', 'btn-primary': $data.status_view == 'any' }])
                    }, _hoisted_10$D, 2 /* CLASS */)
                  ])
                ]))
              : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "begin")
          ]),
          extra_buttons: withCtx(() => [
            renderSlot(_ctx.$slots, "extra_range_buttons")
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["id", "min_time_interval_id", "round_time"])
      ]),
      createCommentVNode(" tagify "),
      ($data.page != 'all')
        ? (openBlock(), createElementBlock("div", _hoisted_11$y, [
            createBaseVNode("input", {
              class: "w-100 form-control h-auto",
              name: "tags",
              ref: "tagify",
              placeholder: $data.i18n('show_alerts.filters')
            }, null, 8 /* PROPS */, _hoisted_12$x),
            withDirectives(createBaseVNode("button", {
              class: "btn btn-link",
              "aria-controls": "flow-alerts-table",
              type: "button",
              id: "btn-add-alert-filter",
              onClick: _cache[3] || (_cache[3] = (...args) => ($options.show_modal_filters && $options.show_modal_filters(...args)))
            }, _hoisted_14$o, 512 /* NEED_PATCH */), [
              [vShow, $data.modal_data && $data.modal_data.length > 0]
            ]),
            withDirectives(createBaseVNode("button", {
              "data-bs-toggle": "tooltip",
              "data-placement": "bottom",
              title: "{{ i18n('show_alerts.remove_filters') }}",
              onClick: _cache[4] || (_cache[4] = (...args) => ($options.remove_filters && $options.remove_filters(...args))),
              class: "btn ms-1 my-auto btn-sm btn-remove-tags"
            }, _hoisted_16$m, 512 /* NEED_PATCH */), [
              [vShow, $data.modal_data && $data.modal_data.length > 0]
            ])
          ]))
        : createCommentVNode("v-if", true),
      createCommentVNode(" end tagify ")
    ]))
  }

  var css_248z$m = "\n.tagify__input[data-v-aaee59ea] {\n    min-width: 175px;\n}\n.tagify__tag[data-v-aaee59ea] {\n    white-space: nowrap;\n    margin: 3px 0px 5px 5px;\n}\n.tagify__tag select.operator[data-v-aaee59ea] {\n    margin: 0px 4px;\n    border: 1px solid #c4c4c4;\n    border-radius: 4px;\n}\n.tagify__tag b.operator[data-v-aaee59ea] {\n    margin: 0px 4px;\n    background-color: white;\n    border: 1px solid #c4c4c4;\n    border-radius: 4px;\n    padding: 0.05em 0.2em;\n}\n.tagify__tag>div[data-v-aaee59ea] {\n    display: flex;\n    align-items: center;\n}\n";
  styleInject(css_248z$m);

  script$1B.render = render$d;
  script$1B.__scopeId = "data-v-aaee59ea";
  script$1B.__file = "http_src/vue/range-picker.vue";

  const _hoisted_1$1n = {
    class: "row",
    style: {"margin-left":"-2px","margin-right":"-2px","margin-top":"1rem","margin-bottom":"-1rem"}
  };
  const _hoisted_2$1g = { class: "col-sm-12 col-md-5" };
  const _hoisted_3$1d = {
    class: "dataTables_info",
    role: "status",
    "aria-live": "polite"
  };
  const _hoisted_4$18 = { class: "col-sm-12 col-md-7" };
  const _hoisted_5$10 = {
    class: "dataTables_paginate paging_simple_numbers",
    style: {"display":"flex","justify-content":"flex-end"}
  };
  const _hoisted_6$R = { class: "pagination" };
  const _hoisted_7$O = { class: "paginate_button page-item previous" };
  const _hoisted_8$N = ["onClick"];
  const _hoisted_9$F = {
    href: "javascript:void(0);",
    "aria-controls": "default-datatable",
    "data-dt-idx": "1",
    tabindex: "0",
    class: "page-link"
  };
  const _hoisted_10$C = { class: "paginate_button page-item previous" };


  var script$1A = {
    __name: 'select_table_page',
    props: {
      total_rows: Number,
      per_page: Number,
  },
    emits: ['change_active_page'],
    setup(__props, { expose, emit }) {

  const props = __props;
  const max_page_buttons = 6;

  const start_page_button = ref(0);
  const num_page_buttons = ref(0);

  const total_pages = ref(0);
  const active_page = ref(0);

  const text_template = "Showing page %active_page of %total_pages: total %total_rows rows";
  const text = ref("");

  onMounted(() => {
      calculate_pages();
  });

  watch(() => [props.total_rows, props.per_page], (cur_value, old_value) => {
      calculate_pages();
  }, { flush: 'pre', immediate: true });

  function calculate_pages() {
      if (props.total_rows == null) { return; }
      let per_page = props.per_page;
      total_pages.value = Number.parseInt((props.total_rows + per_page - 1) / per_page);
      num_page_buttons.value = max_page_buttons;
      if (total_pages.value < num_page_buttons.value) {
  	    num_page_buttons.value = total_pages.value;
      }
      if (active_page.value >= total_pages.value && total_pages.value > 0) {
        //	total_pages.value = total_pages.value + 1;
        /* In case the current active page is higher than the max pages, restart from page 1 */
        active_page.value = total_pages.value - 1;
        start_page_button.value = total_pages.value - num_page_buttons.value;
        /* Redundant call in order to correctly load pages */
        change_active_page(active_page.value);
      }

      set_text();
  }

  const enable_first_page = computed$1(() => {
      if (total_pages.value < max_page_buttons) {
  	return false;
      }
      return active_page.value >= num_page_buttons.value - 1;
  });

  const enable_last_page = computed$1(() => {
      if (total_pages.value < max_page_buttons) {
  	return false;
      }
      return active_page.value < total_pages.value - num_page_buttons.value + 1;
  });


  function next_page() {
      change_active_page(active_page.value + 1);
  }

  function back_page() {
      change_active_page(active_page.value - 1);
  }

  /*  This function is used to set the current active page, if no params is passed
      then it's going to keep the same page.
      This function handles the case where the active page > last page,
      setting the active page as the last page.
   */
  function change_active_page(new_active_page, new_start_page_button) {
    /* In case a new active page is requested, jump to that page */
    if (new_active_page != null) {
      active_page.value = new_active_page;
    } 

    /* Change the table footer button */
    if (new_start_page_button != null) {
      start_page_button.value = new_start_page_button;
    }

    /* Set up the correct start and end page of the table footer */
    if (active_page.value == start_page_button.value && start_page_button.value > 0) {
      start_page_button.value -= 1;
    }
    const end_page_button = start_page_button.value + num_page_buttons.value - 1;
    if (active_page.value == end_page_button && total_pages.value - 1 > end_page_button) {
      start_page_button.value += 1;	
    }
    
    /* Check that the active_page is not greater then the last page */
    /* otherwise set to the last page */
    if(active_page.value > total_pages.value - 1 && total_pages.value != 0) {
      active_page.value = total_pages.value - 1;
      start_page_button.value = active_page.value;
    }

    /* Set the text on the table footer, num_pages, total_rows, ecc. */
    set_text();

    /* Emit the change_active_page event */
    emit('change_active_page', active_page.value);
  }

  function set_text() {
      text.value = text_template.replace("%active_page", format_number(`${active_page.value + 1}`))
  	.replace("%total_pages", format_number(`${total_pages.value}`))
  	.replace("%total_rows", format_number(`${props.total_rows}`))
  	.replace("%per_page", format_number(`${props.per_page}`));
  }

  function format_number(s) {
      return s.replace(/(.)(?=(\d{3})+$)/g,'$1,');
  }

  expose({ change_active_page });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createCommentVNode(" PerPage "),
      createBaseVNode("div", _hoisted_1$1n, [
        createCommentVNode(" div col-md-5 "),
        createBaseVNode("div", _hoisted_2$1g, [
          createBaseVNode("div", _hoisted_3$1d, toDisplayString(text.value), 1 /* TEXT */)
        ]),
        createCommentVNode(" div col-md-5 "),
        createCommentVNode(" start div col-sm-12 "),
        withDirectives(createBaseVNode("div", _hoisted_4$18, [
          createBaseVNode("div", _hoisted_5$10, [
            createBaseVNode("ul", _hoisted_6$R, [
              withDirectives(createBaseVNode("li", _hoisted_7$O, [
                createBaseVNode("a", {
                  href: "javascript:void(0);",
                  onClick: _cache[0] || (_cache[0] = $event => (change_active_page(0, 0))),
                  "aria-controls": "default-datatable",
                  "data-dt-idx": "0",
                  tabindex: "0",
                  class: "page-link"
                }, " « ")
              ], 512 /* NEED_PATCH */), [
                [vShow, unref(enable_first_page)]
              ]),
              createBaseVNode("li", {
                class: normalizeClass(["paginate_button page-item previous", { 'disabled': active_page.value == 0}])
              }, [
                createBaseVNode("a", {
                  href: "javascript:void(0);",
                  onClick: _cache[1] || (_cache[1] = $event => (back_page())),
                  "aria-controls": "default-datatable",
                  "data-dt-idx": "0",
                  tabindex: "0",
                  class: "page-link"
                }, " < ")
              ], 2 /* CLASS */),
              (openBlock(true), createElementBlock(Fragment, null, renderList(num_page_buttons.value, (n) => {
                return (openBlock(), createElementBlock("li", {
                  onClick: $event => (change_active_page(start_page_button.value + n - 1)),
                  class: normalizeClass([{'active': active_page.value == start_page_button.value + n - 1 }, "paginate_button page-item"])
                }, [
                  createBaseVNode("a", _hoisted_9$F, toDisplayString(start_page_button.value + n), 1 /* TEXT */),
                  createCommentVNode("  :key=\"total_rows\"")
                ], 10 /* CLASS, PROPS */, _hoisted_8$N))
              }), 256 /* UNKEYED_FRAGMENT */)),
              createBaseVNode("li", {
                class: normalizeClass(["paginate_button page-item next", { 'disabled': active_page.value == total_pages.value - 1}]),
                id: "default-datatable_next"
              }, [
                createBaseVNode("a", {
                  href: "javascript:void(0);",
                  onClick: _cache[2] || (_cache[2] = $event => (next_page())),
                  "aria-controls": "default-datatable",
                  "data-dt-idx": "7",
                  tabindex: "0",
                  class: "page-link"
                }, " > ")
              ], 2 /* CLASS */),
              withDirectives(createBaseVNode("li", _hoisted_10$C, [
                createBaseVNode("a", {
                  href: "javascript:void(0);",
                  onClick: _cache[3] || (_cache[3] = $event => (change_active_page(total_pages.value - 1, total_pages.value - num_page_buttons.value))),
                  "aria-controls": "default-datatable",
                  "data-dt-idx": "0",
                  tabindex: "0",
                  class: "page-link"
                }, " » ")
              ], 512 /* NEED_PATCH */), [
                [vShow, unref(enable_last_page)]
              ])
            ])
          ])
        ], 512 /* NEED_PATCH */), [
          [vShow, total_pages.value > 0]
        ]),
        createCommentVNode(" end div col-md-7 ")
      ]),
      createCommentVNode(" PerPage ")
    ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
  }
  }

  };

  script$1A.__file = "http_src/vue/select_table_page.vue";

  const _hoisted_1$1m = { class: "text-center" };
  const _hoisted_2$1f = { class: "sr-only position-absolute" };


  var script$1z = {
    __name: 'loading',
    props: {
    styles: String
  },
    setup(__props, { expose }) {

  const loading = i18n('loading');
  const overlay = ref(null);


  /* Show the loading */
  function show_loading(time = 500) {
    $(overlay.value).fadeIn(time);
  }

  /* Hide the loading */
  function hide_loading(time = 500) {
    $(overlay.value).fadeOut(time);
  }

  expose({ hide_loading, show_loading });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", {
      ref_key: "overlay",
      ref: overlay,
      class: "overlay centered-message"
    }, [
      createBaseVNode("div", _hoisted_1$1m, [
        createBaseVNode("div", {
          class: "spinner-border text-primary mt-6",
          style: normalizeStyle(__props.styles),
          role: "status"
        }, [
          createBaseVNode("span", _hoisted_2$1f, toDisplayString(unref(loading)), 1 /* TEXT */)
        ], 4 /* STYLE */)
      ])
    ], 512 /* NEED_PATCH */))
  }
  }

  };

  script$1z.__file = "http_src/vue/loading.vue";

  const _hoisted_1$1l = {
    class: "form-check form-switch ms-1",
    style: {"white-space":"nowrap"}
  };
  const _hoisted_2$1e = ["checked", "title"];
  const _hoisted_3$1c = ["innerHTML"];


  var script$1y = {
    __name: 'switch',
    props: {
      value: Boolean,
      title: String,
      label: String,
  },
    emits: ['update:value', 'change_value'],
    setup(__props, { emit }) {

  const props = __props;





  const value_2 = ref(false);

  onMounted(() => {
      value_2.value = props.value;
  });

  watch(() => props.value, (cur_value, old_value) => {
      value_2.value = props.value;
  }, { flush: 'pre'});

  function change_value() {
      emit('update:value', !value_2.value);
      emit('change_value', !value_2.value);
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$1l, [
      createBaseVNode("input", {
        class: "form-check-input",
        style: {"cursor":"pointer"},
        checked: value_2.value == true,
        onClick: _cache[0] || (_cache[0] = $event => (change_value())),
        type: "checkbox",
        id: "toggle-Begin",
        title: __props.title
      }, null, 8 /* PROPS */, _hoisted_2$1e),
      createBaseVNode("label", {
        class: "form-check-label",
        for: "toggle-Begin",
        innerHTML: __props.label
      }, null, 8 /* PROPS */, _hoisted_3$1c)
    ]))
  }
  }

  };

  script$1y.__file = "http_src/vue/switch.vue";

  const _withScopeId$9 = n => (pushScopeId("data-v-61956e9e"),n=n(),popScopeId(),n);
  const _hoisted_1$1k = ["id"];
  const _hoisted_2$1d = { class: "button-group mb-2 d-flex align-items-center" };
  const _hoisted_3$1b = {
    class: "form-group d-flex align-items-end",
    style: {"flex-wrap":"wrap"}
  };
  const _hoisted_4$17 = {
    style: {"text-align":"right"},
    class: "form-group d-flex align-items-center ms-auto"
  };
  const _hoisted_5$$ = { class: "d-flex align-items-center" };
  const _hoisted_6$Q = {
    key: 0,
    class: "d-inline me-2 ms-auto"
  };
  const _hoisted_7$N = { class: "me-2" };
  const _hoisted_8$M = ["value"];
  const _hoisted_9$E = /*#__PURE__*/ _withScopeId$9(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-columns" }, null, -1 /* HOISTED */));
  const _hoisted_10$B = [
    _hoisted_9$E
  ];
  const _hoisted_11$x = /*#__PURE__*/ _withScopeId$9(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-refresh" }, null, -1 /* HOISTED */));
  const _hoisted_12$w = [
    _hoisted_11$x
  ];
  const _hoisted_13$q = {
    key: 1,
    class: "d-inline-block"
  };
  const _hoisted_14$n = /*#__PURE__*/ _withScopeId$9(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-eye" }, null, -1 /* HOISTED */));
  const _hoisted_15$l = { class: "form-check form-switch ms-1" };
  const _hoisted_16$l = ["checked", "onClick", "id"];
  const _hoisted_17$j = ["for", "innerHTML"];
  const _hoisted_18$j = {
    key: 0,
    class: "centered-message"
  };
  const _hoisted_19$j = ["innerHTML"];
  const _hoisted_20$h = ["data-resizable-columns-id"];
  const _hoisted_21$d = ["onClick", "data-resizable-column-id"];
  const _hoisted_22$d = { style: {"display":"flex"} };
  const _hoisted_23$c = ["innerHTML"];
  const _hoisted_24$c = { class: "fa fa-fw fa-sort-up" };
  const _hoisted_25$a = { class: "fa fa-fw fa-sort-down" };
  const _hoisted_26$a = {
    key: 0,
    scope: "col",
    class: ""
  };
  const _hoisted_27$a = ["innerHTML"];
  const _hoisted_28$8 = {
    key: 0,
    style: {},
    class: "",
    scope: "col"
  };
  const _hoisted_29$8 = /*#__PURE__*/ _withScopeId$9(() => /*#__PURE__*/createBaseVNode("div", { class: "wrap-column" }, null, -1 /* HOISTED */));
  const _hoisted_30$7 = [
    _hoisted_29$8
  ];
  const _hoisted_31$7 = {
    key: 1,
    class: "mt-2"
  };
  const _hoisted_32$6 = { class: "text-end" };
  const _hoisted_33$6 = {
    style: {},
    class: "query text-end"
  };
  const _hoisted_34$5 = { class: "records" };
  const _hoisted_35$3 = { class: "text-start" };
  const _hoisted_36$3 = {
    id: "historical_flows_table-query-time",
    style: {},
    class: "query"
  };
  const _hoisted_37$3 = { class: "seconds" };
  const _hoisted_38$3 = ["title"];

  /* rows_loaded, is emitted every time the rows are loaded,
   * loaded,      is emitted when the table is loaded (mounted)
   */

  var script$1x = {
    __name: 'table',
    props: {
      id: String,
      columns: Array,
      get_rows: Function, // async (active_page: number, per_page: number, columns_wrap: any[], search_map: string, first_get_rows: boolean) => { total_rows: number, rows: any[], query_info: { query_duration_msec: number, num_records_processed: string, query: string } }
      get_column_id: Function,
      print_column_name: Function,
      print_html_row: Function,
      print_vue_node_row: Function,
      f_is_column_sortable: Function,
      f_sort_rows: Function,
      f_get_column_classes: Function,
      f_get_column_style: Function,
      enable_search: Boolean,
      display_empty_rows: Boolean,
      show_autorefresh: Number, // autorefresh seconds, if null or 0 autorefresh switch will not showed
      default_sort: Object, // { column_id: string, sort: number (0, 1, 2) }
      csrf: String,
      paging: Boolean,
      display_message: Boolean,
      message_to_display: String,
  },
    emits: ['custom_event', 'loaded', 'rows_loaded'],
    setup(__props, { expose, emit }) {

  const props = __props;


  const vue_obj = {
      emit,
      h,
      nextTick,
  };



  const _i18n = (t) => i18n(t);

  ref(true);
  const table_container = ref(null);
  const table = ref(null);
  const dropdown = ref(null);
  ref([]);
  let active_page = 0;
  let rows = [];
  const columns_wrap = ref([]);
  const active_rows = ref([]);
  const total_rows = ref(0);
  const per_page_options = [10, 20, 40, 50, 80, 100];
  const per_page = ref(10);
  const store = window.store;
  const map_search = ref("");

  const select_table_page = ref(null);
  const loading = ref(false);
  const query_info = ref(null);
  const query_info_sql_button = ref(null);
  const changing_column_visibility = ref(false);
  const changing_rows = ref(false);
  const enable_autorefresh = ref(false);

  onMounted(async () => {
      if (props.columns != null) {
          load_table();
      }
  });

  const autorefresh_title = computed$1(() => {
      if (props.show_autorefresh == null || props.show_autorefresh <= 0) {
          return "";
      }
      let text = _i18n("table.autorefresh");
      return text.replace("%time", props.show_autorefresh);
  });

  watch(() => [props.id, props.columns], (cur_value, old_value) => {
      load_table();
  }, { flush: 'pre' });

  function get_col_id(col) {
      if(col != null && col.id != null) {
          return col.id;
      } else {
          return "toggle-Begin";
      }
  }
  async function load_table() {
      await set_columns_wrap();
      await set_rows();
      set_columns_resizable();
      dropdown.value.load_menu();
      emit("loaded");
  }

  let autorefresh_interval;
  function update_autorefresh() {
      if (enable_autorefresh.value == false) {
          clearInterval(autorefresh_interval);
          return;
      }
      autorefresh_interval = setInterval(() => {
          change_active_page();
      }, props.show_autorefresh * 1000);
  }

  async function change_columns_visibility(col) {
      changing_column_visibility.value = true;
      col.visible = !col.visible;
      if (props.paging) {
          await set_rows();
      }
      // redraw_table();
      await redraw_table_resizable();
      await set_columns_visibility();
      // set_columns_resizable();
      changing_column_visibility.value = false;
  }

  async function redraw_table_resizable() {
      await redraw_table();
      set_columns_resizable();
  }

  const table_key = ref(0);
  async function redraw_table() {
      table_key.value += 1;
      await nextTick();
  }

  function set_columns_resizable() {
      let options = {
          // selector: table.value,
          // padding: 0,
          store: store,
          minWidth: 72,
          // padding: -50,
          // maxWidth: 150,
      };
      $(table.value).resizableColumns(options);
      // $(table.value).css('width', '100%');
  }

  async function get_columns_visibility_dict() {
      if (props.csrf == null) { return {}; }
      const params = { table_id: props.id };
      const url_params = ntopng_url_manager$1.obj_to_url_params(params);
      const url = `${http_prefix}/lua/rest/v2/get/tables/user_columns_config.lua?${url_params}`;
      let columns_visible = await ntopng_utility$1.http_request(url);
      let columns_visible_dict = {};
      columns_visible.forEach((c) => {
          columns_visible_dict[c.id] = c;
      });
      return columns_visible_dict;
  }

  async function set_columns_visibility() {
      if (props.csrf == null) { return; }
      let params = { table_id: props.id, visible_columns_ids: [], csrf: props.csrf };
      params.visible_columns_ids = columns_wrap.value.map((c, i) => {
          return {
              id: c.id,
              visible: c.visible,
              order: c.order,
              sort: c.sort,
          };
      });
      const url = `${http_prefix}/lua/rest/v2/add/tables/user_columns_config.lua`;
      await ntopng_utility$1.http_post_request(url, params);
  }

  async function set_columns_wrap() {
      let cols_visibility_dict = await get_columns_visibility_dict();
      let is_table_not_sorted = true;
      for (let id in cols_visibility_dict) {
          is_table_not_sorted &= (cols_visibility_dict[id]?.sort);
      }
      columns_wrap.value = props.columns.map((c, i) => {
          let classes = [];
          let style = "";
          if (props.f_get_column_classes != null) {
              classes = props.f_get_column_classes(c);
          }
          if (props.f_get_column_style != null) {
              style = props.f_get_column_style(c);
          }
          let id = props.get_column_id(c);
          let col_opt = cols_visibility_dict[id];
          let sort = col_opt?.sort;
          if (is_table_not_sorted == true && sort == null && props.default_sort != null && id == props.default_sort.column_id) {
              sort = props.default_sort.sort;
          } else if (col_opt?.sort) {
              sort = col_opt?.sort;
          } else {
              sort = 0;
          }
          return {
              id,
              visible: col_opt?.visible == null || col_opt?.visible == true,
              sort: sort,
              sortable: is_column_sortable(c),
              order: col_opt?.order || i,
              classes,
              style,
              data: c,
          };
      });
      await set_columns_visibility();
  }

  async function reset_column_size() {
      props.columns.forEach((c) => {
          let id = `${props.id}-${props.get_column_id(c)}`;
          store.remove(id);
      });
      await redraw_table_resizable();
  }

  function change_per_page() {
      redraw_select_pages();
      change_active_page(0);
  }

  const select_pages_key = ref(0);
  function redraw_select_pages() {
      select_pages_key.value += 1;
  }

  const table_content_id = ref(0);
  function refresh_table_content() {
      table_content_id.value += 1;
  }

  async function change_active_page(new_active_page) {
      if (new_active_page != null) {
          active_page = new_active_page;
      }
      if (active_page == null) {
          active_page = 0;
      }
      if (props.paging == true || force_refresh) {
          await set_rows();
      } else {
          set_active_rows();
      }
      refresh_table_content();
  }

  async function change_column_sort(col, col_index) {
      if (!col.sortable) {
          return;
      }
      col.sort = (col.sort + 1) % 3;
      columns_wrap.value.filter((c, i) => i != col_index).forEach((c) => c.sort = 0);
      if (col.sort == 0) { return; }
      if (props.paging) {
          await set_rows();
      } else {
          set_active_rows();
      }
      await set_columns_visibility();
  }

  function get_sort_function() {
      if (props.f_sort_rows != null) {
          return props.f_sort_rows;
      }
      return (col, r0, r1) => {
          let r0_col = props.print_html_row(col.data, r0);
          let r1_col = props.print_html_row(col.data, r1);
          if (col.sort == 1) {
              return r0_col.localeCompare(r1_col);
          }
          return r1_col.localeCompare(r0_col);
      };
  }

  let force_refresh = false;
  let force_disable_loading = false;

  /* ********************************************* */

  /*  Function used to reload the table contents, 
      set disable_loading to true if no loading is needed and
      consequently do not jump to the first page, but
      just reload the current page
  */
  async function refresh_table(disable_loading) {
      /* NOTE: first refresh_table is called then set_rows */
      force_refresh = true;
      force_disable_loading = disable_loading || false;

      if(force_disable_loading) {
          /* In case of disabled loading, reload the same page */
          select_table_page.value.change_active_page();
      } else {
          /* Otherwise reload from page 1 */
          select_table_page.value.change_active_page(0, 0);
      }
      await nextTick();

      /* Reset the refresh/loading params */
      force_refresh = false;
      force_disable_loading = false;
  }

  /* ********************************************* */

  let first_get_rows = true;
  async function set_rows() {
      // changing_rows.value = true;
      loading.value = !force_disable_loading;
      let res = await props.get_rows(active_page, per_page.value, columns_wrap.value, map_search.value, first_get_rows);
      query_info.value = null;
      if (res.query_info != null) {
          query_info.value = res.query_info;
      }
      first_get_rows = false;
      total_rows.value = res.rows.length;
      if (props.paging == true) {
          total_rows.value = res.total_rows;
      }
      rows = res.rows;
      set_active_rows();
      loading.value = false;
      
      await nextTick();
      emit('rows_loaded', res);
  }

  function is_column_sortable(col) {
      if (props.f_is_column_sortable != null) {
          return props.f_is_column_sortable(col);
      }
      return true;
  }

  function set_active_rows() {
      let start_row_index = 0;
      if (props.paging == false) {
          start_row_index = active_page * per_page.value;
      }
      if (props.paging == false) {
          let f_sort = get_sort_function();
          let col_to_sort = get_column_to_sort();
          rows = rows.sort((r0, r1) => {
              return f_sort(col_to_sort, r0, r1);
          });
      }
      active_rows.value = rows.slice(start_row_index, start_row_index + per_page.value);
  }

  function get_column_to_sort() {
      let col_to_sort = columns_wrap.value.find((c) => c.sort != 0);
      return col_to_sort;
  }

  let map_search_change_timeout;
  async function on_change_map_search() {
      let timeout = 1000;
      if (map_search_change_timeout != null) {
          clearTimeout(map_search_change_timeout);
      } else {
          timeout = 0;
      }
      map_search_change_timeout = setTimeout(async () => {
          await set_rows();
          map_search_change_timeout = null;
      }, timeout);

  }

  function search_value(value) {
      map_search.value = value; /* Add the new value */
      on_change_map_search();
  }

  function copy_query_into_clipboard($event) {
      NtopUtils.copyToClipboard(query_info.value.query, query_info_sql_button.value);
  }

  function get_columns_defs() {
      return columns_wrap.value;
  }

  function get_rows_num() {
      return total_rows.value;
  }

  expose({ load_table, refresh_table, get_columns_defs, get_rows_num, search_value });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(_ctx.$slots, "custom_header2"),
      createBaseVNode("div", {
        ref_key: "table_container",
        ref: table_container,
        id: __props.id
      }, [
        (loading.value)
          ? (openBlock(), createBlock(script$1z, { key: 0 }))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_2$1d, [
          createCommentVNode(" TableHeader "),
          createBaseVNode("div", _hoisted_3$1b, [
            renderSlot(_ctx.$slots, "custom_header")
          ]),
          createBaseVNode("div", _hoisted_4$17, [
            createBaseVNode("div", _hoisted_5$$, [
              (__props.enable_search)
                ? (openBlock(), createElementBlock("div", _hoisted_6$Q, [
                    createBaseVNode("label", null, [
                      createTextVNode(toDisplayString(_i18n('search')) + ": ", 1 /* TEXT */),
                      withDirectives(createBaseVNode("input", {
                        type: "search",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((map_search).value = $event)),
                        onInput: on_change_map_search,
                        class: ""
                      }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                        [vModelText, map_search.value]
                      ])
                    ])
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", _hoisted_7$N, [
                createBaseVNode("label", null, [
                  withDirectives(createBaseVNode("select", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((per_page).value = $event)),
                    onChange: change_per_page
                  }, [
                    (openBlock(), createElementBlock(Fragment, null, renderList(per_page_options, (pp) => {
                      return createBaseVNode("option", { value: pp }, toDisplayString(pp), 9 /* TEXT, PROPS */, _hoisted_8$M)
                    }), 64 /* STABLE_FRAGMENT */))
                  ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                    [vModelSelect, per_page.value]
                  ])
                ])
              ]),
              createBaseVNode("button", {
                class: "btn btn-link",
                type: "button",
                onClick: reset_column_size
              }, _hoisted_10$B),
              createBaseVNode("button", {
                class: "btn btn-link",
                type: "button",
                onClick: _cache[2] || (_cache[2] = $event => (refresh_table()))
              }, _hoisted_12$w),
              (__props.show_autorefresh > 0)
                ? (openBlock(), createElementBlock("div", _hoisted_13$q, [
                    createVNode(script$1y, {
                      value: enable_autorefresh.value,
                      "onUpdate:value": _cache[3] || (_cache[3] = $event => ((enable_autorefresh).value = $event)),
                      class: "me-2 mt-1",
                      title: unref(autorefresh_title),
                      style: {},
                      onChange_value: update_autorefresh
                    }, null, 8 /* PROPS */, ["value", "title"])
                  ]))
                : createCommentVNode("v-if", true),
              createVNode(script$1J, {
                id: __props.id + '_dropdown',
                ref_key: "dropdown",
                ref: dropdown
              }, {
                title: withCtx(() => [
                  _hoisted_14$n
                ]),
                menu: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(columns_wrap.value, (col) => {
                    return (openBlock(), createElementBlock("div", _hoisted_15$l, [
                      createBaseVNode("input", {
                        class: "form-check-input",
                        style: {"cursor":"pointer"},
                        checked: col.visible == true,
                        onClick: $event => (change_columns_visibility(col)),
                        type: "checkbox",
                        id: get_col_id(col)
                      }, null, 8 /* PROPS */, _hoisted_16$l),
                      createBaseVNode("label", {
                        class: "form-check-label",
                        for: get_col_id(col),
                        innerHTML: __props.print_column_name(col.data)
                      }, null, 8 /* PROPS */, _hoisted_17$j)
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["id"]),
              createCommentVNode(" Dropdown columns ")
            ])
          ])
        ]),
        createCommentVNode(" TableHeader "),
        (openBlock(), createElementBlock("div", {
          key: table_key.value,
          style: {"overflow":"auto","width":"100%"}
        }, [
          createCommentVNode(" Table "),
          (__props.display_message == true)
            ? (openBlock(), createElementBlock("div", _hoisted_18$j, [
                createBaseVNode("span", { innerHTML: __props.message_to_display }, null, 8 /* PROPS */, _hoisted_19$j)
              ]))
            : createCommentVNode("v-if", true),
          createBaseVNode("table", {
            ref_key: "table",
            ref: table,
            class: normalizeClass(["table table-striped table-bordered ml-0 mr-0 mb-0 ntopng-table", [(__props.display_message || loading.value) ? 'ntopng-gray-out' : '']]),
            "data-resizable": "true",
            "data-resizable-columns-id": __props.id
          }, [
            createCommentVNode(" Table "),
            createBaseVNode("thead", null, [
              createBaseVNode("tr", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(columns_wrap.value, (col, col_index) => {
                  return (openBlock(), createElementBlock(Fragment, null, [
                    (col.visible)
                      ? (openBlock(), createElementBlock("th", {
                          key: 0,
                          scope: "col",
                          class: normalizeClass({ 'pointer': col.sortable, 'unset': !col.sortable, }),
                          style: {"white-space":"nowrap"},
                          onClick: $event => (change_column_sort(col, col_index)),
                          "data-resizable-column-id": __props.get_column_id(col.data)
                        }, [
                          createBaseVNode("div", _hoisted_22$d, [
                            createBaseVNode("span", {
                              innerHTML: __props.print_column_name(col.data),
                              class: "wrap-column"
                            }, null, 8 /* PROPS */, _hoisted_23$c),
                            createCommentVNode(" <i v-show=\"col.sort == 0\" class=\"fa fa-fw fa-sort\"></i> "),
                            withDirectives(createBaseVNode("i", _hoisted_24$c, null, 512 /* NEED_PATCH */), [
                              [vShow, col.sort == 1 && col.sortable]
                            ]),
                            withDirectives(createBaseVNode("i", _hoisted_25$a, null, 512 /* NEED_PATCH */), [
                              [vShow, col.sort == 2 && col.sortable]
                            ])
                          ])
                        ], 10 /* CLASS, PROPS */, _hoisted_21$d))
                      : createCommentVNode("v-if", true)
                  ], 64 /* STABLE_FRAGMENT */))
                }), 256 /* UNKEYED_FRAGMENT */))
              ])
            ]),
            createBaseVNode("tbody", null, [
              (!changing_column_visibility.value && !changing_rows.value)
                ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(active_rows.value, (row) => {
                    return (openBlock(), createElementBlock("tr", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(columns_wrap.value, (col, col_index) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          (col.visible)
                            ? (openBlock(), createElementBlock("td", _hoisted_26$a, [
                                (__props.print_html_row != null && __props.print_html_row(col.data, row, true) != null)
                                  ? (openBlock(), createElementBlock("div", {
                                      key: 0,
                                      class: normalizeClass([col.classes, "wrap-column"]),
                                      style: normalizeStyle(col.style),
                                      innerHTML: __props.print_html_row(col.data, row)
                                    }, null, 14 /* CLASS, STYLE, PROPS */, _hoisted_27$a))
                                  : createCommentVNode("v-if", true),
                                createBaseVNode("div", {
                                  style: normalizeStyle([col.style, {}]),
                                  class: normalizeClass(["wrap-column margin-sm", col.classes])
                                }, [
                                  (__props.print_vue_node_row != null && __props.print_vue_node_row(col.data, row, vue_obj, true) != null)
                                    ? (openBlock(), createBlock(script$1K, {
                                        key: row,
                                        content: __props.print_vue_node_row(col.data, row, vue_obj)
                                      }, null, 8 /* PROPS */, ["content"]))
                                    : createCommentVNode("v-if", true)
                                ], 6 /* CLASS, STYLE */)
                              ]))
                            : createCommentVNode("v-if", true)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                : createCommentVNode("v-if", true),
              (__props.display_empty_rows && active_rows.value.length < per_page.value)
                ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList((per_page.value - active_rows.value.length), (index) => {
                    return (openBlock(), createElementBlock("tr", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(columns_wrap.value, (col, col_index) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          (col.visible)
                            ? (openBlock(), createElementBlock("td", _hoisted_28$8, _hoisted_30$7))
                            : createCommentVNode("v-if", true)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                : createCommentVNode("v-if", true)
            ])
          ], 10 /* CLASS, PROPS */, _hoisted_20$h),
          createCommentVNode(" Table ")
        ])),
        createCommentVNode(" Table div"),
        createBaseVNode("div", null, [
          (openBlock(), createBlock(script$1A, {
            ref_key: "select_table_page",
            ref: select_table_page,
            key: select_pages_key.value,
            total_rows: total_rows.value,
            per_page: per_page.value,
            onChange_active_page: change_active_page
          }, null, 8 /* PROPS */, ["total_rows", "per_page"]))
        ]),
        (query_info.value != null)
          ? (openBlock(), createElementBlock("div", _hoisted_31$7, [
              createBaseVNode("div", _hoisted_32$6, [
                createBaseVNode("small", _hoisted_33$6, [
                  createBaseVNode("span", _hoisted_34$5, toDisplayString(query_info.value.num_records_processed), 1 /* TEXT */),
                  createTextVNode(".")
                ])
              ]),
              createBaseVNode("div", _hoisted_35$3, [
                createBaseVNode("small", _hoisted_36$3, [
                  createTextVNode("Query performed in "),
                  createBaseVNode("span", _hoisted_37$3, toDisplayString((query_info.value.query_duration_msec / 1000).toFixed(3)), 1 /* TEXT */),
                  createTextVNode(" seconds. "),
                  createBaseVNode("span", {
                    id: "historical_flows_table-query",
                    style: {"cursor":"pointer"},
                    class: "badge bg-secondary",
                    title: query_info.value.query,
                    onClick: copy_query_into_clipboard,
                    ref_key: "query_info_sql_button",
                    ref: query_info_sql_button
                  }, "SQL", 8 /* PROPS */, _hoisted_38$3)
                ])
              ])
            ]))
          : createCommentVNode("v-if", true)
      ], 8 /* PROPS */, _hoisted_1$1k)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  var css_248z$l = "\n.sticky[data-v-61956e9e] {\n    position: sticky;\n    left: 0;\n    background-color: white;\n}\n.wrap-column[data-v-61956e9e] {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden;\n    width: 100%;\n}\n.pointer[data-v-61956e9e] {\n    cursor: pointer;\n}\n.unset[data-v-61956e9e] {\n    cursor: unset;\n}\n.link-button[data-v-61956e9e] {\n    color: var(--bs-dropdown-link-color);\n    cursor: pointer;\n}\n.link-disabled[data-v-61956e9e] {\n    pointer-events: none;\n    color: #ccc;\n}\ntd[data-v-61956e9e] {\n    height: 2.5rem;\n}\n.margin-sm[data-v-61956e9e] {\n    margin-bottom: -0.25rem;\n    margin-top: -0.25rem;\n}\n";
  styleInject(css_248z$l);

  script$1x.__scopeId = "data-v-61956e9e";
  script$1x.__file = "http_src/vue/table.vue";

  var script$1w = {
    __name: 'table-with-config',
    props: {
      table_config_id: String, // name of configuration file in httpdocs/tables_config
      table_id: String, // id of table, same table_config_id can have different table_id and then different columuns visible settins
      csrf: String,
      f_map_config: Function,
      f_map_columns: Function,
      f_sort_rows: Function,
      get_extra_params_obj: Function,
      display_message: Boolean,
      message_to_display: String,
  },
    emits: ['custom_event', 'loaded', 'rows_loaded'],
    setup(__props, { expose, emit }) {

  const props = __props;




  const table_config = ref({});
  const table = ref(null);
  const mount_table = ref(false);

  onMounted(async () => {
      if (props.table_id != null || props.table_config_id != null) {
  	load_table();
      }
  });

  watch(() => [props.table_id, props.table_config_id], (cur_value, old_value) => {
      load_table();
  }, { flush: 'pre'});

  const table_id_2 = computed$1(() => {
      if (props.table_id != null) { return props.table_id; }
      return props.table_config_id;
  });

  async function load_table() {
      mount_table.value = false;
      await nextTick();
      let table_config_id_2 = props.table_config_id;
      if (table_config_id_2 == null) {
  	table_config_id_2 = props.table_id;
      }
      table_config.value = await table_utils.build_table(http_prefix, table_config_id_2, props.f_map_columns, props.get_extra_params_obj);
      if (props.f_map_config != null) {
  	table_config.value = props.f_map_config(table_config.value);
      }
      mount_table.value = true;
      await nextTick();
  }

  function on_loaded() {
      emit('loaded');
  }

  function on_custom_event(event) {
      emit('custom_event', event);
  }

  function rows_loaded(res) {
      emit('rows_loaded', res);
  }

  const refresh_table = (disable_loading) => {
      if(table.value) {
          table.value.refresh_table(disable_loading);
      }
  };

  const get_columns_defs = () => {
      if (table.value == null) { return []; }
      return table.value.get_columns_defs();
  };

  const get_rows_num = () => {
      return table.value.get_rows_num();
  };

  const search_value = (value) => {
      table.value.search_value(value);
  };

  expose({ refresh_table, get_columns_defs, get_rows_num, search_value });


  return (_ctx, _cache) => {
    return (mount_table.value)
      ? (openBlock(), createBlock(script$1x, {
          key: 0,
          ref_key: "table",
          ref: table,
          id: unref(table_id_2),
          columns: table_config.value.columns,
          get_rows: table_config.value.get_rows,
          get_column_id: table_config.value.get_column_id,
          print_column_name: table_config.value.print_column_name,
          print_html_row: table_config.value.print_html_row,
          print_vue_node_row: table_config.value.print_vue_node_row,
          f_is_column_sortable: table_config.value.f_is_column_sortable,
          f_get_column_classes: table_config.value.f_get_column_classes,
          f_get_column_style: table_config.value.f_get_column_style,
          display_empty_rows: table_config.value.display_empty_rows,
          f_sort_rows: __props.f_sort_rows,
          enable_search: table_config.value.enable_search,
          default_sort: table_config.value.default_sort,
          show_autorefresh: table_config.value.show_autorefresh,
          paging: table_config.value.paging,
          csrf: __props.csrf,
          display_message: __props.display_message,
          message_to_display: __props.message_to_display,
          onLoaded: on_loaded,
          onRows_loaded: rows_loaded,
          onCustom_event: on_custom_event
        }, {
          custom_header: withCtx(() => [
            renderSlot(_ctx.$slots, "custom_header")
          ]),
          _: 3 /* FORWARDED */
        }, 8 /* PROPS */, ["id", "columns", "get_rows", "get_column_id", "print_column_name", "print_html_row", "print_vue_node_row", "f_is_column_sortable", "f_get_column_classes", "f_get_column_style", "display_empty_rows", "f_sort_rows", "enable_search", "default_sort", "show_autorefresh", "paging", "csrf", "display_message", "message_to_display"]))
      : createCommentVNode("v-if", true)
  }
  }

  };

  script$1w.__file = "http_src/vue/table-with-config.vue";

  var script$1v = {
    __name: 'spinner',
    props: {
      size: String,
      show: Boolean,
  },
    setup(__props) {



  onMounted(async () => {
  });


  return (_ctx, _cache) => {
    return (__props.show)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "spinner-border text-primary",
          style: normalizeStyle({'width': __props.size, 'height': __props.size}),
          role: "status"
        }, null, 4 /* STYLE */))
      : createCommentVNode("v-if", true)
  }
  }

  };

  script$1v.__file = "http_src/vue/spinner.vue";

  const _hoisted_1$1j = {
    id: "script-description",
    class: "notes bg-light border",
    role: "alert"
  };
  const _hoisted_2$1c = ["innerHTML"];
  const _hoisted_3$1a = { key: 0 };
  const _hoisted_4$16 = ["innerHTML"];


  var script$1u = {
    __name: 'note-list',
    props: {
    note_list: Array,
    sub_note_list: Array,
    add_sub_notes: Boolean,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);



  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$1j, [
      createBaseVNode("b", null, toDisplayString(_i18n('notes')), 1 /* TEXT */),
      createBaseVNode("ul", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.note_list, (note) => {
          return (openBlock(), createElementBlock("li", { innerHTML: note }, null, 8 /* PROPS */, _hoisted_2$1c))
        }), 256 /* UNKEYED_FRAGMENT */)),
        (props.add_sub_notes)
          ? (openBlock(), createElementBlock("ul", _hoisted_3$1a, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(props.sub_note_list, (note) => {
                return (openBlock(), createElementBlock("li", { innerHTML: note }, null, 8 /* PROPS */, _hoisted_4$16))
              }), 256 /* UNKEYED_FRAGMENT */))
            ]))
          : createCommentVNode("v-if", true)
      ])
    ]))
  }
  }

  };

  script$1u.__file = "http_src/vue/note-list.vue";

  var script$1t = defineComponent({
      components: {
  	'modal': script$1D,
      },
      props: {
  	id: String,
      },
      updated() {
      },
      data() {
  	return {
  	    description: "",
  	    invalid_bpf: false,
  	    bpf_filter: "",
  	    extract_now: true,
  	    show_menu: true,
  	    data_available: 0, // 0 == loading, 1 == available, 2 == no data
  	    i18n: (t) => i18n(t),
  	    epoch_interval: null,
  	    id_modal: `${this.$props.id}_modal`,
  	};
      },
      emits: ["apply"],
      created() {
      },
      /** This method is the first method called after html template creation. */
      mounted() {
      },
      methods: {
  	pad2_number: function(number) {
  	    return String(number).padStart(2, '0');
  	},
  	format_date: function(d) {
  	    // let day = this.pad2_number(d.getDate());
  	    // let month = this.pad2_number(d.getMonth());
  	    // let hours = this.pad2_number(d.getHours());
  	    // let minutes = this.pad2_number(d.getMinutes());
  	    // let s = `${day}/${month}/${d.getFullYear()} ${hours}:${minutes}`;
  	    let d_ms = d.valueOf();
  	    return ntopng_utility.from_utc_to_server_date_format(d_ms);
  	},
  	apply: async function() {
  	    if (this.bpf_filter != null && this.bpf_filter != "") {
  		let url_request = `${http_prefix}/lua/pro/rest/v2/check/filter.lua?query=${this.bpf_filter}`;
  		let res = await ntopng_utility.http_request(url_request, null, false, true);
  		this.invalid_bpf = !res.response;
  		if (this.invalid_bpf == true) {
  		    return;
  		}		
  	    }
  	    let url_request_obj = {
  		ifid: ntopng_url_manager.get_url_entry("ifid"),
  		epoch_begin: this.epoch_interval.epoch_begin,
  		epoch_end: this.epoch_interval.epoch_end,
  		bpf_filter: this.bpf_filter,
  	    };
  	    let url_request_params = ntopng_url_manager.obj_to_url_params(url_request_obj);
  	    if (this.extract_now == true) {
  		
  		let url_request = `${http_prefix}/lua/rest/v2/get/pcap/live_extraction.lua?${url_request_params}`;
  		window.open(url_request, '_self', false);
  	    } else {
  		let url_request = `${http_prefix}/lua/rest/v2/create/pcap/extraction/task.lua?${url_request_params}`;
  		let job_info = await ntopng_utility.http_request(url_request);
  		let job_id = job_info.id;
  		let alert_text_html = i18n('traffic_recording.extraction_scheduled');
  		let page_name = i18n('traffic_recording.traffic_extraction_jobs');
  		let ifid = ntopng_url_manager.get_url_entry("ifid");
  		let href = `<a href="/lua/if_stats.lua?ifid=${ifid}&page=traffic_recording&tab=jobs&job_id=${job_id}">${page_name}</a>`; 
  		alert_text_html = alert_text_html.replace('%{page}', href);
  		alert_text_html = `${alert_text_html} ${job_id}`;
  		ntopng_events_manager.emit_custom_event(ntopng_custom_events.SHOW_GLOBAL_ALERT_INFO, { text_html: alert_text_html, type: "alert-success" });
  	    }
  	    this.close();
  	},
  	close: function() {
  	    this.$refs["modal"].close();
  	    setTimeout(() => {
  		this.data_available = 0;
  	    }, 1000);
  	},
  	show: async function(bpf_filter, epoch_interval) {	    
  	    if (epoch_interval == null) {
  		let status = ntopng_status_manager.get_status();
  		if (status.epoch_begin == null || status.epoch_end == null) {
  		    console.error("modal-traffic-extraction: epoch_begin and epoch_end undefined in url");
  		    return;
  		}
  		epoch_interval = { epoch_begin: status.epoch_begin, epoch_end: status.epoch_end };
  	    }
  	    this.epoch_interval = epoch_interval;
  	    let url_params = ntopng_url_manager.obj_to_url_params(epoch_interval);
  	    let url_request = `${http_prefix}/lua/check_recording_data.lua?${url_params}`;
  	    let res = await ntopng_utility.http_request(url_request, null, null, true);
  	    if (res.available == false) {
  		this.data_available = 2;
  		this.description = i18n('traffic_recording.no_recorded_data');
  		this.$refs["modal"].show();
  		return;
  	    }
  	    this.data_available = 1;
  	    let extra_info = "";
  	    if (res.info != null) {
  		extra_info = res.info;
  	    }	    if (bpf_filter == null) {
  		let url_params = ntopng_url_manager.get_url_params();
  		let url_request = `${http_prefix}/lua/pro/rest/v2/get/db/filter/bpf.lua?${url_params}`;
  		let res = await ntopng_utility.http_request(url_request);
  		if (res == null || res.bpf == null) {
  		    console.error(`modal-traffic-extraction: ${url_request} return null value`);
  		    return;
  		}
  		bpf_filter = res.bpf;
  	    }
  	    this.set_descriptions(epoch_interval.epoch_begin, epoch_interval.epoch_end, extra_info);
  	    
  	    // let url_params = ntopng_url_manager.get_url_params();
  	    // let url_request = `${http_prefix}/lua/pro/rest/v2/get/db/filter/bpf.lua?${url_params}`;
  	    // let res = await ntopng_utility.http_request(url_request);
  	    // this.bpf_filter = res.bpf;
  	    this.bpf_filter = bpf_filter;
  	    this.$refs["modal"].show();
  	},
  	set_descriptions: function(epoch_begin, epoch_end, info) {
  	    let date_begin = new Date(epoch_begin * 1000);
  	    let date_end = new Date(epoch_end * 1000);
  	    
  	    let desc = i18n('traffic_recording.about_to_download_flow');
  	    desc = desc.replace('%{date_begin}', this.format_date(date_begin));
  	    desc = desc.replace('%{date_end}', this.format_date(date_end));
  	    desc = desc.replace('%{extra_info}', info);
  	    this.description = desc;
  	},
  	show_hide_menu: function() {
  	    this.show_menu = !this.show_menu;
  	},
      },
  });

  const _withScopeId$8 = n => (pushScopeId("data-v-0be978c4"),n=n(),popScopeId(),n);
  const _hoisted_1$1i = ["innerHTML"];
  const _hoisted_2$1b = {
    key: 0,
    style: {"height":"95%"}
  };
  const _hoisted_3$19 = {
    class: "tab-content",
    style: {"height":"100%"}
  };
  const _hoisted_4$15 = { class: "row" };
  const _hoisted_5$_ = { class: "form-group mb-3 col-md-3 has-feedback" };
  const _hoisted_6$P = { class: "form-group mb-3 col-md-9 text-right asd" };
  const _hoisted_7$M = {
    class: "radio-inline",
    style: {"margin-left":"1rem"}
  };
  const _hoisted_8$L = { class: "radio-inline" };
  const _hoisted_9$D = {
    class: "row",
    id: "pcapDownloadModal_advanced",
    style: {}
  };
  const _hoisted_10$A = { class: "form-group mb-3 col-md-12 has-feedback" };
  const _hoisted_11$w = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
  const _hoisted_12$v = { class: "form-label" };
  const _hoisted_13$p = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("a", {
    class: "ntopng-external-link",
    href: "https://www.ntop.org/guides/n2disk/filters.html"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-external-link-alt" })
  ], -1 /* HOISTED */));
  const _hoisted_14$m = { class: "input-group" };
  const _hoisted_15$k = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("span", { class: "input-group-addon" }, [
    /*#__PURE__*/createBaseVNode("span", { class: "glyphicon glyphicon-filter" })
  ], -1 /* HOISTED */));
  const _hoisted_16$k = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
  const _hoisted_17$i = { class: "form-label" };
  const _hoisted_18$i = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */));
  const _hoisted_19$i = /*#__PURE__*/ _withScopeId$8(() => /*#__PURE__*/createBaseVNode("ul", null, [
    /*#__PURE__*/createBaseVNode("li", null, [
      /*#__PURE__*/createTextVNode("Host: "),
      /*#__PURE__*/createBaseVNode("i", null, "host 192.168.1.2")
    ]),
    /*#__PURE__*/createBaseVNode("li", null, [
      /*#__PURE__*/createTextVNode("HTTP: "),
      /*#__PURE__*/createBaseVNode("i", null, "tcp and port 80")
    ]),
    /*#__PURE__*/createBaseVNode("li", null, [
      /*#__PURE__*/createTextVNode("Traffic between hosts: "),
      /*#__PURE__*/createBaseVNode("i", null, "ip host 192.168.1.1 and 192.168.1.2")
    ]),
    /*#__PURE__*/createBaseVNode("li", null, [
      /*#__PURE__*/createTextVNode("Traffic from an host to another: "),
      /*#__PURE__*/createBaseVNode("i", null, "ip src 192.168.1.1 and dst 192.168.1.2")
    ])
  ], -1 /* HOISTED */));

  function render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_modal = resolveComponent("modal");

    return (openBlock(), createBlock(_component_modal, {
      id: _ctx.id_modal,
      onApply: _ctx.apply,
      ref: "modal"
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.i18n('traffic_recording.pcap_extract')), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", {
          class: normalizeClass(["alert", { 'alert-info': _ctx.data_available != 2, 'alert-warning': _ctx.data_available == 2 }]),
          innerHTML: _ctx.description
        }, null, 10 /* CLASS, PROPS */, _hoisted_1$1i),
        (_ctx.data_available == 1)
          ? (openBlock(), createElementBlock("form", _hoisted_2$1b, [
              createBaseVNode("div", _hoisted_3$19, [
                createBaseVNode("div", _hoisted_4$15, [
                  createBaseVNode("div", _hoisted_5$_, [
                    createBaseVNode("button", {
                      class: "btn btn-sm btn-secondary",
                      type: "button",
                      onClick: _cache[0] || (_cache[0] = (...args) => (_ctx.show_hide_menu && _ctx.show_hide_menu(...args)))
                    }, [
                      createTextVNode(toDisplayString(_ctx.i18n('advanced')), 1 /* TEXT */),
                      createBaseVNode("i", {
                        class: normalizeClass({ 'fas fa-caret-down': _ctx.show_menu, 'fas fa-caret-up': !_ctx.show_menu})
                      }, null, 2 /* CLASS */)
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_6$P, [
                    createBaseVNode("label", _hoisted_7$M, [
                      withDirectives(createBaseVNode("input", {
                        type: "radio",
                        name: "extract_now",
                        "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((_ctx.extract_now) = $event)),
                        value: "true",
                        checked: ""
                      }, null, 512 /* NEED_PATCH */), [
                        [vModelRadio, _ctx.extract_now]
                      ]),
                      createTextVNode(" " + toDisplayString(_ctx.i18n('traffic_recording.extract_now')), 1 /* TEXT */)
                    ]),
                    createBaseVNode("label", _hoisted_8$L, [
                      withDirectives(createBaseVNode("input", {
                        type: "radio",
                        name: "extract_now",
                        "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((_ctx.extract_now) = $event)),
                        value: "false"
                      }, null, 512 /* NEED_PATCH */), [
                        [vModelRadio, _ctx.extract_now]
                      ]),
                      createTextVNode(" " + toDisplayString(_ctx.i18n('traffic_recording.queue_as_job')), 1 /* TEXT */)
                    ])
                  ])
                ]),
                withDirectives(createBaseVNode("div", _hoisted_9$D, [
                  createBaseVNode("div", _hoisted_10$A, [
                    _hoisted_11$w,
                    createBaseVNode("label", _hoisted_12$v, [
                      createTextVNode(toDisplayString(_ctx.i18n('traffic_recording.filter_bpf')) + " ", 1 /* TEXT */),
                      _hoisted_13$p
                    ]),
                    createBaseVNode("div", _hoisted_14$m, [
                      _hoisted_15$k,
                      withDirectives(createBaseVNode("input", {
                        name: "bpf_filter",
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((_ctx.bpf_filter) = $event)),
                        class: "form-control input-sm",
                        "data-bpf": "bpf",
                        autocomplete: "off",
                        spellcheck: "false"
                      }, null, 512 /* NEED_PATCH */), [
                        [vModelText, _ctx.bpf_filter]
                      ]),
                      withDirectives(createBaseVNode("span", {
                        style: {"margin":"0px","padding":"0","display":"block"},
                        class: "invalid-feedback"
                      }, toDisplayString(_ctx.i18n('invalid_value')), 513 /* TEXT, NEED_PATCH */), [
                        [vShow, _ctx.invalid_bpf]
                      ])
                    ]),
                    _hoisted_16$k,
                    createBaseVNode("label", _hoisted_17$i, toDisplayString(_ctx.i18n('traffic_recording.filter_examples')) + ":", 1 /* TEXT */),
                    _hoisted_18$i,
                    _hoisted_19$i
                  ])
                ], 512 /* NEED_PATCH */), [
                  [vShow, _ctx.show_menu]
                ])
              ])
            ]))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        withDirectives(createBaseVNode("button", {
          type: "button",
          onClick: _cache[4] || (_cache[4] = (...args) => (_ctx.apply && _ctx.apply(...args))),
          class: "btn btn-primary"
        }, toDisplayString(_ctx.i18n('apply')), 513 /* TEXT, NEED_PATCH */), [
          [vShow, _ctx.data_available != 2]
        ]),
        withDirectives(createBaseVNode("button", {
          type: "button",
          onClick: _cache[5] || (_cache[5] = (...args) => (_ctx.close && _ctx.close(...args))),
          class: "btn btn-primary"
        }, toDisplayString(_ctx.i18n('ok')), 513 /* TEXT, NEED_PATCH */), [
          [vShow, _ctx.data_available == 2]
        ])
      ]),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["id", "onApply"]))
  }

  var css_248z$k = "\ninput ~ .alert[data-v-0be978c4] {\n  display: none;\n}\ninput:invalid ~ .alert[data-v-0be978c4] {\n  display: block;\n}\n";
  styleInject(css_248z$k);

  script$1t.render = render$c;
  script$1t.__scopeId = "data-v-0be978c4";
  script$1t.__file = "http_src/vue/modal-traffic-extraction.vue";

  const _withScopeId$7 = n => (pushScopeId("data-v-089b0491"),n=n(),popScopeId(),n);
  const _hoisted_1$1h = /*#__PURE__*/ _withScopeId$7(() => /*#__PURE__*/createBaseVNode("a", {
    target: "_newtab",
    href: "#",
    style: {},
    class: "nav-item text-muted"
  }, [
    /*#__PURE__*/createBaseVNode("i", {
      class: "fas fa-question-circle",
      style: {"margin-left":"28rem","padding-top":"0.8rem"}
    })
  ], -1 /* HOISTED */));
  const _hoisted_2$1a = { class: "nav nav-tabs" };
  const _hoisted_3$18 = ["disabled"];
  const _hoisted_4$14 = {
    key: 0,
    style: {"min-height":"8.5rem"}
  };
  const _hoisted_5$Z = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_6$O = { class: "col-form-label col-sm-4" };
  const _hoisted_7$L = { class: "col-sm-6" };
  const _hoisted_8$K = ["pattern"];
  const _hoisted_9$C = {
    key: 1,
    style: {"min-height":"8.5rem"}
  };
  const _hoisted_10$z = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_11$v = { class: "col-form-label col-sm-4" };
  const _hoisted_12$u = { class: "col-sm-8" };
  const _hoisted_13$o = { value: "name" };
  const _hoisted_14$l = { value: "date" };
  const _hoisted_15$j = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_16$j = { class: "col-form-label col-sm-4" };
  const _hoisted_17$h = { class: "col-sm-8" };
  const _hoisted_18$h = ["value"];
  const _hoisted_19$h = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_20$g = { class: "custom-control custom-switch" };
  const _hoisted_21$c = { class: "custom-control-label ms-1 form-check-label" };
  const _hoisted_22$c = ["disabled"];
  const _hoisted_23$b = ["disabled"];
  const _hoisted_24$b = ["disabled"];


  var script$1s = {
    __name: 'modal-snapshot',
    props: {
      csrf: String,
      page: String,
  },
    emits: ['added_snapshot', 'deleted_snapshot', 'deleted_all_snapshots'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const action = ref("add"); // add / select
  const showed = () => {};
  const snapshot_selected = ref("");
  const apply_time = ref(false);
  const apply_time_text = ref("");
  const save_time = ref(true);
  const save_time_text = ref("");
  const snapshot_name = ref("");
  const snapshots = ref([]);
  const order_by = ref("date"); // name / date





  let pattern_singleword = NtopUtils.REGEXES.singleword;

  const disable_add = computed$1(() => {
      let rg = new RegExp(pattern_singleword);
      return !rg.test(snapshot_name.value);
  });

  const disable_select = computed$1(() => {
      return snapshot_selected.value == "";
  });

  const show = () => {
      init();
      modal_id.value.show();
  };

  const update_action = (a) => {
      if (snapshots.value.length == 0 && a == "select") { return; }
      action.value = a;
  };

  function get_page() {
      if (props.page != null) {
  	return props.page;
      }
      let is_alert_stats_url = window.location.toString().match(/alert_stats.lua/) != null;
      let page = "alerts";
      if (!is_alert_stats_url) {
  	page = "flows";
      }
      return page;
  }

  function display_name(snapshot) {
      let utc_ms = snapshot.utc * 1000;
      let date = ntopng_utility.from_utc_to_server_date_format(utc_ms, "DD/MM/YYYY");
      return `${snapshot.name} (${date})`
  }

  let last_order_by = null;
  function sort_snapshots_by() {
      if (last_order_by == order_by.value) { return; }
      
      snapshots.value.sort((a, b) => {
  	if (order_by.value == "name") {
  	    return a.name.localeCompare(b.name);
  	}
  	return a.utc - b.utc;
      });
      if (snapshots.value.length > 0) {
  	snapshot_selected.value = snapshots.value[0];
      }
      last_order_by = order_by.value;    
  }

  let load_snapshots = true;
  async function init() {
      action.value = "add";
      snapshot_name.value = "";
      save_time.value = true;
      apply_time.value = false;
      let status = ntopng_status_manager.get_status();
      let save_time_filter_text = _i18n("snapshots.save_time");
      let begin_time = ntopng_utility.from_utc_to_server_date_format(status.epoch_begin * 1000, "DD/MM/YYYY HH:mm");
      let end_time = ntopng_utility.from_utc_to_server_date_format(status.epoch_end * 1000, "DD/MM/YYYY HH:mm");
      save_time_filter_text = save_time_filter_text.replace(/\%begin_time/, begin_time);
      save_time_filter_text = save_time_filter_text.replace(/\%end_time/, end_time);
      save_time_text.value = save_time_filter_text;
      let apply_time_filter_text = _i18n("snapshots.apply_time");
      apply_time_filter_text = apply_time_filter_text.replace(/\%begin_time/, begin_time);
      apply_time_filter_text = apply_time_filter_text.replace(/\%end_time/, end_time);
      apply_time_text.value = apply_time_filter_text;
      if (load_snapshots) {
  	load_snapshots = false;
  	let page = get_page();
  	let url = `${http_prefix}/lua/pro/rest/v2/get/filters/snapshots.lua?page=${page}`;
  	let snapshots_obj = await ntopng_utility.http_request(url);
  	snapshots.value = ntopng_utility.object_to_array(snapshots_obj);
      }
      sort_snapshots_by();
      if (snapshots.value.length > 0) {
  	snapshot_selected.value = snapshots.value[0];
      }
  }

  const add_snapshot = async () => {
      let filters;
      if (save_time.value) {
  	filters = ntopng_url_manager.get_url_params();
      } else {
  	let params_obj = ntopng_url_manager.get_url_object();
  	delete params_obj.epoch_begin;
  	delete params_obj.epoch_end;
  	filters = ntopng_url_manager.obj_to_url_params(params_obj);
      }
      let page = get_page();
      let params = {
  	snapshot_name: snapshot_name.value,
  	filters,
  	page
      };
      
      params.csrf = props.csrf;
      let url = `${http_prefix}/lua/pro/rest/v2/add/filters/snapshot.lua`;
      try {
  	let headers = {
  	    'Content-Type': 'application/json'
  	};
  	await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
  	load_snapshots = true;
      } catch(err) {
  	console.error(err);
      }
      close();
      emit('added_snapshots', params);
  };

  const select_snapshot = () => {
      close();    
      let filters = snapshot_selected.value.filters;
      if (apply_time.value == true) {
      	let status = ntopng_status_manager.get_status();
      	let params_obj = ntopng_url_manager.get_url_object(filters);
      	params_obj.epoch_begin = status.epoch_begin;
      	params_obj.epoch_end = status.epoch_end;
      	filters = ntopng_url_manager.obj_to_url_params(params_obj);
      }
      ntopng_url_manager.replace_url_and_reload(filters);
  };

  const delete_snapshot = async (delete_all) => {
      let name = snapshot_selected.value.name;
      if (delete_all == true) { name = "*"; }
      let page = get_page();
      let params = {
      	snapshot_name: name,
  	page,
      };
      params.csrf = props.csrf;
      let url = `${http_prefix}/lua/pro/rest/v2/delete/filters/snapshot.lua`;
      try {
      	let headers = {
      	    'Content-Type': 'application/json'
      	};
      	await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
      	load_snapshots = true;
      } catch(err) {
      	console.error(err);
      }
      if (delete_all == true) {
  	emit('deleted_all_snapshots', params);
      } else {
  	emit('deleted_snapshot', params);
      }
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[8] || (_cache[8] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("snapshots.manage")) + " ", 1 /* TEXT */),
        _hoisted_1$1h
      ]),
      body: withCtx(() => [
        createBaseVNode("ul", _hoisted_2$1a, [
          createBaseVNode("li", {
            class: "nav-item",
            onClick: _cache[0] || (_cache[0] = $event => (action.value='add'))
          }, [
            createBaseVNode("a", {
              class: normalizeClass(["nav-link", {'active': action.value == 'add'}]),
              href: "#"
            }, toDisplayString(_i18n("snapshots.add")), 3 /* TEXT, CLASS */)
          ]),
          createBaseVNode("li", {
            class: "nav-item",
            onClick: _cache[1] || (_cache[1] = $event => (update_action('select')))
          }, [
            createBaseVNode("a", {
              disabled: snapshots.value.length == 0,
              class: normalizeClass(["nav-link", {'active': action.value == 'select', 'not-allowed': snapshots.value.length == 0 }]),
              href: "#"
            }, toDisplayString(_i18n("snapshots.manage")), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$18)
          ])
        ]),
        (action.value == 'add')
          ? (openBlock(), createElementBlock("div", _hoisted_4$14, [
              createBaseVNode("div", _hoisted_5$Z, [
                createBaseVNode("label", _hoisted_6$O, [
                  createBaseVNode("b", null, toDisplayString(_i18n("snapshots.name")) + ":", 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_7$L, [
                  withDirectives(createBaseVNode("input", {
                    pattern: unref(pattern_singleword),
                    placeholder: "",
                    required: "",
                    type: "text",
                    class: "form-control",
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((snapshot_name).value = $event))
                  }, null, 8 /* PROPS */, _hoisted_8$K), [
                    [vModelText, snapshot_name.value]
                  ])
                ])
              ]),
              createCommentVNode(" <div class=\"form-group ms-2 me-2 mt-3 row\"> "),
              createCommentVNode(" \t<div class=\"custom-control custom-switch\"> "),
              createCommentVNode(" \t  <input type=\"checkbox\" class=\"custom-control-input whitespace form-check-input\" v-model=\"save_time\"> "),
              createCommentVNode(" \t  <label class=\"custom-control-label ms-1 form-check-label\">{{save_time_text}}</label> "),
              createCommentVNode(" \t</div> "),
              createCommentVNode(" </div>       ")
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" action add "),
        (action.value == 'select')
          ? (openBlock(), createElementBlock("div", _hoisted_9$C, [
              createBaseVNode("div", _hoisted_10$z, [
                createBaseVNode("label", _hoisted_11$v, [
                  createBaseVNode("b", null, toDisplayString(_i18n("snapshots.order_by")), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_12$u, [
                  withDirectives(createBaseVNode("select", {
                    class: "form-select",
                    onChange: _cache[3] || (_cache[3] = $event => (sort_snapshots_by())),
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((order_by).value = $event))
                  }, [
                    createBaseVNode("option", _hoisted_13$o, toDisplayString(_i18n("snapshots.name")), 1 /* TEXT */),
                    createBaseVNode("option", _hoisted_14$l, toDisplayString(_i18n("snapshots.date")), 1 /* TEXT */)
                  ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                    [vModelSelect, order_by.value]
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_15$j, [
                createBaseVNode("label", _hoisted_16$j, [
                  createBaseVNode("b", null, toDisplayString(_i18n("snapshots.select")), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_17$h, [
                  withDirectives(createBaseVNode("select", {
                    class: "form-select",
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((snapshot_selected).value = $event))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(snapshots.value, (item) => {
                      return (openBlock(), createElementBlock("option", { value: item }, toDisplayString(display_name(item)), 9 /* TEXT, PROPS */, _hoisted_18$h))
                    }), 256 /* UNKEYED_FRAGMENT */))
                  ], 512 /* NEED_PATCH */), [
                    [vModelSelect, snapshot_selected.value]
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_19$h, [
                createBaseVNode("div", _hoisted_20$g, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    class: "custom-control-input whitespace form-check-input",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((apply_time).value = $event))
                  }, null, 512 /* NEED_PATCH */), [
                    [vModelCheckbox, apply_time.value]
                  ]),
                  createBaseVNode("label", _hoisted_21$c, toDisplayString(apply_time_text.value), 1 /* TEXT */)
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" action select ")
      ]),
      footer: withCtx(() => [
        (action.value == 'add')
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: add_snapshot,
              disabled: unref(disable_add),
              class: "btn btn-primary"
            }, toDisplayString(_i18n("snapshots.add")), 9 /* TEXT, PROPS */, _hoisted_22$c))
          : createCommentVNode("v-if", true),
        (action.value == 'select')
          ? (openBlock(), createElementBlock("button", {
              key: 1,
              onClick: _cache[7] || (_cache[7] = $event => (delete_snapshot(true))),
              type: "button",
              style: {"text-align":"left","margin-left":"0px"},
              class: "btn btn-danger start-0 position-absolute ms-3"
            }, toDisplayString(_i18n("snapshots.delete_all")), 1 /* TEXT */))
          : createCommentVNode("v-if", true),
        (action.value == 'select')
          ? (openBlock(), createElementBlock("button", {
              key: 2,
              type: "button",
              onClick: delete_snapshot,
              disabled: unref(disable_select),
              class: "btn btn-danger"
            }, toDisplayString(_i18n("snapshots.delete")), 9 /* TEXT, PROPS */, _hoisted_23$b))
          : createCommentVNode("v-if", true),
        (action.value == 'select')
          ? (openBlock(), createElementBlock("button", {
              key: 3,
              type: "button",
              onClick: select_snapshot,
              disabled: unref(disable_select),
              class: "btn btn-primary"
            }, toDisplayString(_i18n("snapshots.apply")), 9 /* TEXT, PROPS */, _hoisted_24$b))
          : createCommentVNode("v-if", true)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$j = "\ninput[data-v-089b0491]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-089b0491] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$j);

  script$1s.__scopeId = "data-v-089b0491";
  script$1s.__file = "http_src/vue/modal-snapshot.vue";

  const _withScopeId$6 = n => (pushScopeId("data-v-19c5b1f1"),n=n(),popScopeId(),n);
  const _hoisted_1$1g = ["innerHTML"];
  const _hoisted_2$19 = { class: "form-group mb-3" };
  const _hoisted_3$17 = ["innerHTML"];
  const _hoisted_4$13 = { class: "alert_label" };
  const _hoisted_5$Y = { class: "form-check" };
  const _hoisted_6$N = { class: "form-check-label" };
  const _hoisted_7$K = {
    key: 0,
    class: "form-check"
  };
  const _hoisted_8$J = { class: "form-check-label" };
  const _hoisted_9$B = { class: "form-check" };
  const _hoisted_10$y = { class: "form-check-label" };
  const _hoisted_11$u = { class: "form-check" };
  const _hoisted_12$t = { class: "form-check-label" };
  const _hoisted_13$n = {
    key: 0,
    class: "exclude-domain-certificate"
  };
  const _hoisted_14$k = { class: "alert_label" };
  const _hoisted_15$i = {
    key: 0,
    class: "form-check"
  };
  const _hoisted_16$i = { class: "form-check-label whitespace" };
  const _hoisted_17$g = ["pattern", "disabled"];
  const _hoisted_18$g = {
    key: 1,
    class: "form-check"
  };
  const _hoisted_19$g = { class: "form-check-label whitespace" };
  const _hoisted_20$f = ["disabled", "pattern"];
  const _hoisted_21$b = {
    key: 0,
    class: "form-group row"
  };
  const _hoisted_22$b = { class: "col-form-label" };
  const _hoisted_23$a = { class: "mt-1" };
  const _hoisted_24$a = ["placeholder"];
  const _hoisted_25$9 = { class: "separator" };
  const _hoisted_26$9 = /*#__PURE__*/ _withScopeId$6(() => /*#__PURE__*/createBaseVNode("hr", { class: "separator" }, null, -1 /* HOISTED */));
  const _hoisted_27$9 = { class: "form-group mb-3" };
  const _hoisted_28$7 = { class: "custom-control custom-switch" };
  const _hoisted_29$7 = { class: "custom-control-label" };
  const _hoisted_30$6 = {
    class: "alert alert-warning border",
    role: "alert"
  };
  const _hoisted_31$6 = ["disabled"];


  var script$1r = {
    __name: 'modal-alerts-filter',
    props: {
      alert: Object,
      page: String,
  },
    emits: ['exclude'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const radio_selected = ref("any");
  const disable_alerts = ref(true);
  const domain = ref(null);
  const tls_certificate = ref(null);
  const comment = ref(null);
  const comment_placeholder = i18n("details.comment_placeholder");




  const showed = () => {};



  watch(() => props.alert, (current_value, old_value) => {
      if (current_value == null) { return; }
      radio_selected.value = "any";
      disable_alerts.value = true;
      domain.value = current_value.info?.value == "" ? null : extract_domain_name_from_info(current_value.info?.value);
      tls_certificate.value = current_value.info?.issuerdn == "" ? null : current_value.info?.issuerdn;
  });

  const extract_domain_name_from_info = (info) => {

    let domain_name = info;
    // remove schema https:// etc
    let info_splitted_ = info.split("://");
    debugger;
    if (info_splitted_.length > 1) domain_name = info_splitted_[1];

    // remove net port
    domain_name = domain_name.split(":")[0];

    // remove www.
    let info_splitted_on_www = domain_name.split("www.");
    if (info_splitted_on_www.length > 1) domain_name = info_splitted_on_www[1];

    // remove path
    domain_name = domain_name.split("/")[0];
    
    return domain_name;

  };
  const check_disable_apply = () => {
      if (radio_selected.value == "domain") {
  	let regex_domain = new RegExp(pattern_domain);
  	return domain.value == null || regex_domain.test(domain.value) == false;
      } else if (radio_selected.value == "certificate") {
  	let regex_certificate = new RegExp(pattern_certificate);
  	return tls_certificate.value == null || regex_certificate.test(tls_certificate.value) == false;
      }
      return false;
  };

  const alert_name = computed$1(() => props.alert?.alert_name);

  const host_addr = computed$1(() => {
      let res = { value: "", label: "" };
      if (props.page != "host" || props.alert == null) { return res; }
      let alert = props.alert;
      res.value = alert.ip.value;
      if (alert.vlan != null && alert.vlan.value != null && alert.vlan.value != 0) {
  	res.value = res.value + '@' + alert.vlan.value;
      }
      res.label = (alert.ip.label) ? `${alert.ip.label} (${alert.ip.value})` : alert.ip.value;
      return res;
  });

  const flow_addr = computed$1(() => {
      let res = { cli_value: "", cli_label: "", srv_value: "", srv_label: "" };
      if (props.page != "flow" || props.alert == null) { return res; }
      let alert = props.alert;
      res.cli_value = alert.flow.cli_ip.value;
      res.srv_value = alert.flow.srv_ip.value;
      let cli_label = `${alert.flow.cli_ip.label || alert.flow.cli_ip.value}`;
      let srv_label = `${alert.flow.srv_ip.label || alert.flow.srv_ip.value}`;

      if(alert.flow.vlan != null && alert.flow.vlan.value != null && alert.flow.vlan.value != 0) {
        cli_label = `${cli_label}@${alert.flow.vlan.label}`;
        srv_label = `${srv_label}@${alert.flow.vlan.label}`;
        res.cli_value = res.cli_value + '@' + alert.flow.vlan.value;
        res.srv_value = res.srv_value + '@' + alert.flow.vlan.value;
      }

      if(cli_label !== res.cli_value) {
        cli_label = `${cli_label} (${res.cli_value})`;
      }
      if(srv_label !== res.srv_value) {
        srv_label = `${srv_label} (${res.srv_value})`;
      }
      
      res.cli_label = cli_label;
      res.srv_label = srv_label;
      return res;
  });

  const show = () => {
      comment.value = "";
      modal_id.value.show();
  };

  function get_type() {
      if (radio_selected.value == "domain" || radio_selected.value == "certificate") {
  	return radio_selected.value;
      }
      return "host";
  }

  let pattern_domain = NtopUtils.REGEXES.domain_name_not_strict;
  let pattern_certificate = NtopUtils.REGEXES.tls_certificate;

  const exclude = () => {
      let page = props.page;
      let type = get_type();
      let params = {
      	delete_alerts: disable_alerts.value,
        label: comment.value,

  	type,	
      };
      let addr = null;
      if (type == "host") {	
  	if (radio_selected.value == "host") {
  	    addr = host_addr.value.value;
  	} else if (radio_selected.value == "server_host") {
  	    addr = flow_addr.value.srv_value;
  	} else if (radio_selected.value == "client_host") {
  	    addr = flow_addr.value.cli_value;
  	}
  	params.alert_addr = addr;
  	if (page == "flow") {
  	    params.flow_alert_key = props.alert.alert_id.value;
  	} else if (page == "host") {
  	    params.host_alert_key = props.alert.alert_id.value;
  	}
      } else if (type == "domain") {
  	params.delete_alerts = false;
  	params.alert_domain = domain.value;
      } else if (type == "certificate") {
  	params.delete_alerts = false;
  	params.alert_certificate = tls_certificate.value;
      }
      close();
      emit('exclude', params);
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[10] || (_cache[10] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n('exclude_check')) + ": ", 1 /* TEXT */),
        createBaseVNode("span", { innerHTML: unref(alert_name) }, null, 8 /* PROPS */, _hoisted_1$1g)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_2$19, [
          createBaseVNode("div", null, [
            createBaseVNode("label", null, [
              createTextVNode(toDisplayString(_i18n('exclude_check')) + " \"", 1 /* TEXT */),
              createBaseVNode("b", { innerHTML: unref(alert_name) }, null, 8 /* PROPS */, _hoisted_3$17),
              createTextVNode("\". "),
              createBaseVNode("span", _hoisted_4$13, toDisplayString(_i18n('exclude_for')) + ":", 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_5$Y, [
              withDirectives(createBaseVNode("input", {
                class: "form-check-input",
                type: "radio",
                value: "any",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((radio_selected).value = $event))
              }, null, 512 /* NEED_PATCH */), [
                [vModelRadio, radio_selected.value]
              ]),
              createBaseVNode("label", _hoisted_6$N, [
                createBaseVNode("span", null, toDisplayString(_i18n('show_alerts.filter_disable_check')), 1 /* TEXT */)
              ])
            ]),
            (__props.page == 'host')
              ? (openBlock(), createElementBlock("div", _hoisted_7$K, [
                  withDirectives(createBaseVNode("input", {
                    class: "form-check-input",
                    type: "radio",
                    value: "host",
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((radio_selected).value = $event))
                  }, null, 512 /* NEED_PATCH */), [
                    [vModelRadio, radio_selected.value]
                  ]),
                  createBaseVNode("label", _hoisted_8$J, [
                    createBaseVNode("span", null, toDisplayString(unref(host_addr).label), 1 /* TEXT */)
                  ])
                ]))
              : createCommentVNode("v-if", true),
            (__props.page == 'flow')
              ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createBaseVNode("div", _hoisted_9$B, [
                    withDirectives(createBaseVNode("input", {
                      class: "form-check-input",
                      type: "radio",
                      value: "client_host",
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((radio_selected).value = $event))
                    }, null, 512 /* NEED_PATCH */), [
                      [vModelRadio, radio_selected.value]
                    ]),
                    createBaseVNode("label", _hoisted_10$y, [
                      createBaseVNode("span", null, toDisplayString(_i18n('client')) + ": " + toDisplayString(unref(flow_addr).cli_label), 1 /* TEXT */)
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_11$u, [
                    withDirectives(createBaseVNode("input", {
                      class: "form-check-input",
                      type: "radio",
                      value: "server_host",
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((radio_selected).value = $event))
                    }, null, 512 /* NEED_PATCH */), [
                      [vModelRadio, radio_selected.value]
                    ]),
                    createBaseVNode("label", _hoisted_12$t, [
                      createBaseVNode("span", null, toDisplayString(_i18n('server')) + ": " + toDisplayString(unref(flow_addr).srv_label), 1 /* TEXT */)
                    ])
                  ])
                ], 64 /* STABLE_FRAGMENT */))
              : createCommentVNode("v-if", true)
          ]),
          (domain.value != null || tls_certificate.value != null)
            ? (openBlock(), createElementBlock("div", _hoisted_13$n, [
                createBaseVNode("label", null, [
                  createBaseVNode("span", _hoisted_14$k, toDisplayString(_i18n('check_exclusion.exclude_all_checks_for')) + ":", 1 /* TEXT */)
                ]),
                (domain.value != null)
                  ? (openBlock(), createElementBlock("div", _hoisted_15$i, [
                      withDirectives(createBaseVNode("input", {
                        class: "form-check-input",
                        type: "radio",
                        value: "domain",
                        "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((radio_selected).value = $event))
                      }, null, 512 /* NEED_PATCH */), [
                        [vModelRadio, radio_selected.value]
                      ]),
                      createBaseVNode("label", _hoisted_16$i, [
                        createBaseVNode("span", null, toDisplayString(_i18n("check_exclusion.domain")) + ":", 1 /* TEXT */)
                      ]),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        pattern: unref(pattern_domain),
                        disabled: radio_selected.value != 'domain',
                        required: "",
                        "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((domain).value = $event)),
                        class: "form-check-label custom-width"
                      }, null, 8 /* PROPS */, _hoisted_17$g), [
                        [vModelText, domain.value]
                      ])
                    ]))
                  : createCommentVNode("v-if", true),
                (tls_certificate.value != null)
                  ? (openBlock(), createElementBlock("div", _hoisted_18$g, [
                      withDirectives(createBaseVNode("input", {
                        class: "form-check-input",
                        type: "radio",
                        value: "certificate",
                        "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((radio_selected).value = $event))
                      }, null, 512 /* NEED_PATCH */), [
                        [vModelRadio, radio_selected.value]
                      ]),
                      createBaseVNode("label", _hoisted_19$g, [
                        createBaseVNode("span", null, toDisplayString(_i18n("check_exclusion.tls_certificate")) + ":", 1 /* TEXT */)
                      ]),
                      withDirectives(createBaseVNode("input", {
                        type: "text",
                        disabled: radio_selected.value != 'certificate',
                        "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => ((tls_certificate).value = $event)),
                        pattern: unref(pattern_certificate),
                        required: "",
                        class: "form-check-label custom-width"
                      }, null, 8 /* PROPS */, _hoisted_20$f), [
                        [vModelText, tls_certificate.value]
                      ])
                    ]))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true)
        ]),
        (radio_selected.value != 'any')
          ? (openBlock(), createElementBlock("div", _hoisted_21$b, [
              createBaseVNode("div", null, [
                createBaseVNode("label", _hoisted_22$b, [
                  createBaseVNode("b", null, toDisplayString(_i18n("show_alerts.add_a_comment")), 1 /* TEXT */)
                ])
              ]),
              createBaseVNode("div", _hoisted_23$a, [
                withDirectives(createBaseVNode("textarea", {
                  placeholder: unref(comment_placeholder),
                  id: "alert-label",
                  name: "label",
                  rows: "3",
                  class: "form-control",
                  type: "text",
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ((comment).value = $event)),
                  maxlength: "450"
                }, null, 8 /* PROPS */, _hoisted_24$a), [
                  [vModelText, comment.value]
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        withDirectives(createBaseVNode("hr", _hoisted_25$9, null, 512 /* NEED_PATCH */), [
          [vShow, disable_alerts.value]
        ]),
        (radio_selected.value != 'domain' && radio_selected.value != 'certificate')
          ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createBaseVNode("div", { class: "message alert alert-danger" }, toDisplayString(_i18n("show_alerts.confirm_delete_filtered_alerts")), 513 /* TEXT, NEED_PATCH */), [
                [vShow, disable_alerts.value]
              ]),
              _hoisted_26$9,
              createBaseVNode("div", _hoisted_27$9, [
                createBaseVNode("div", _hoisted_28$7, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    class: "custom-control-input whitespace",
                    "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => ((disable_alerts).value = $event))
                  }, null, 512 /* NEED_PATCH */), [
                    [vModelCheckbox, disable_alerts.value]
                  ]),
                  createBaseVNode("label", _hoisted_29$7, toDisplayString(_i18n("delete_disabled_alerts")), 1 /* TEXT */)
                ])
              ])
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_30$6, toDisplayString(_i18n("show_alerts.confirm_filter_alert")), 1 /* TEXT */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: exclude,
          disabled: check_disable_apply(),
          class: "btn btn-warning"
        }, toDisplayString(_i18n("filter")), 9 /* TEXT, PROPS */, _hoisted_31$6)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$i = "\n.whitespace[data-v-19c5b1f1] {\n  margin-right: 0.2rem;\n}\n.custom-width[data-v-19c5b1f1] {\n  display: block;\n  min-width: 100%;\n}\ninput[data-v-19c5b1f1]:invalid {\n  border-color: #ff0000;\n}\n.exclude-domain-certificate[data-v-19c5b1f1] {\n  margin-top: 0.4rem;\n}\n";
  styleInject(css_248z$i);

  script$1r.__scopeId = "data-v-19c5b1f1";
  script$1r.__file = "http_src/vue/modal-alerts-filter.vue";

  const _hoisted_1$1f = { class: "form-group row mb-2" };
  const _hoisted_2$18 = { class: "col-sm-6" };
  const _hoisted_3$16 = { class: "col-form-label" };
  const _hoisted_4$12 = { class: "col-sm-6 mt-1" };


  var script$1q = {
    __name: 'modal-acknowledge-alert',
    props: {
      context: Object,
      page: String,
  },
    emits: ["acknowledge"],
    setup(__props, { expose, emit }) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const modal_id = ref(null);
  const alert_info = ref(null);
  const comment = ref("");
  const title_desc = ref("");





  onMounted(() => {
  });

  async function acknowledge() {
      const url = `${http_prefix}/lua/rest/v2/acknowledge/${props.page}/alerts.lua`;
      const params = {
  	csrf: props.context.csrf,
  	ifid: props.context.ifid,
  	label: comment.value,
  	row_id: alert.value.row_id,
      };
      let headers = {
  	'Content-Type': 'application/json'
      };
      await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
      emit("acknowledge");
      close();
  }


  const alert = ref({});
  const show = (_alert) => {
      alert.value = _alert;
      const $type = $(`<span>${_alert.alert_id.label}</span>`);
      title_desc.value = $type.text().trim();
      comment.value = _alert.user_label;
      
      let message_body = _i18n("show_alerts.confirm_acknowledge_alert");
      alert_info.value.show(message_body, "alert-warning");
      modal_id.value.show();
  };

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("show_alerts.acknowledge_alert")) + ": " + toDisplayString(title_desc.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$1f, [
          createBaseVNode("div", _hoisted_2$18, [
            createBaseVNode("label", _hoisted_3$16, [
              createBaseVNode("b", null, toDisplayString(_i18n("show_alerts.add_a_comment")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_4$12, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((comment).value = $event)),
              class: "form-control",
              type: "text",
              maxlength: "255"
            }, null, 512 /* NEED_PATCH */), [
              [vModelText, comment.value]
            ])
          ])
        ]),
        createVNode(script$1G, {
          no_close_button: true,
          ref_key: "alert_info",
          ref: alert_info
        }, null, 512 /* NEED_PATCH */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: acknowledge,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("acknowledge")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$1q.__file = "http_src/vue/modal-acknowledge-alert.vue";

  var script$1p = {
    __name: 'modal-delete-alert',
    props: {
      context: Object,
      page: String,
  },
    emits: ["delete_alert"],
    setup(__props, { expose, emit }) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const modal_id = ref(null);
  const alert_info = ref(null);


  const alert = ref({});
  let status_view = "historical";



  onMounted(() => {
  });

  async function delete_alert() {
      const url = `${http_prefix}/lua/rest/v2/delete/${props.page}/alerts.lua`;
      const params = {
  	csrf: props.context.csrf,
  	ifid: props.context.ifid,
  	status: status_view,
  	row_id: alert.value.row_id,
      };
      let headers = {
  	'Content-Type': 'application/json'
      };
      await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
      emit("delete_alert");
      close();
  }


  const show = (_alert, _status_view) => {
      alert.value = _alert;
      status_view = _status_view;
      let message_body = _i18n("show_alerts.confirm_label_alert");
      alert_info.value.show(message_body, "alert-danger");
      modal_id.value.show();
  };

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("show_alerts.delete_alert")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createVNode(script$1G, {
          no_close_button: true,
          ref_key: "alert_info",
          ref: alert_info
        }, null, 512 /* NEED_PATCH */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: delete_alert,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("delete")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$1p.__file = "http_src/vue/modal-delete-alert.vue";

  const _hoisted_1$1e = { class: "form-group row" };
  const _hoisted_2$17 = { class: "col-sm-6" };
  const _hoisted_3$15 = { class: "col-form-label" };
  const _hoisted_4$11 = { class: "col-sm-6" };
  const _hoisted_5$X = ["value"];
  const _hoisted_6$M = { class: "form-group row mb-2" };
  const _hoisted_7$J = { class: "col-sm-6" };
  const _hoisted_8$I = { class: "col-form-label" };
  const _hoisted_9$A = { class: "col-sm-6 mt-1" };
  const _hoisted_10$x = ["value"];


  var script$1o = {
    __name: 'modal-acknowledge-alerts',
    props: {
      page: String,
      context: Object,    
  },
    emits: ["acknowledge_alerts"],
    setup(__props, { expose, emit }) {

  const props = __props;
  const _i18n = (t) => i18n(t);
  const modal_id = ref(null);
  const alert_info = ref(null);
  const begin_time = ref("");
  const end_time = ref("");
  ref([]);

  onMounted(() => {
  });

  const show = (status) => {
      begin_time.value = ntopng_utility$1.from_utc_to_server_date_format(status.epoch_begin * 1000);
      end_time.value = ntopng_utility$1.from_utc_to_server_date_format(status.epoch_end * 1000);
      let message_body = _i18n("show_alerts.confirm_acknowledge_alerts");
      alert_info.value.show(message_body, "alert-danger");
      modal_id.value.show();
  };

  async function acknowledge_alerts() {
      const url = `${http_prefix}/lua/rest/v2/acknowledge/${props.page}/alerts.lua`;
      const url_params_obj = ntopng_url_manager$1.get_url_object();
      const params = {
  	csrf: props.context.csrf,
  	...url_params_obj,
      };
      await ntopng_utility$1.http_post_request(url, params);
      emit("acknowledge_alerts");
      close();
  }

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("acknowledge_alerts")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$1e, [
          createBaseVNode("div", _hoisted_2$17, [
            createBaseVNode("label", _hoisted_3$15, [
              createBaseVNode("b", null, toDisplayString(_i18n("date_from")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_4$11, [
            createBaseVNode("input", {
              class: "form-control",
              type: "text",
              value: begin_time.value,
              disabled: ""
            }, null, 8 /* PROPS */, _hoisted_5$X)
          ])
        ]),
        createBaseVNode("div", _hoisted_6$M, [
          createBaseVNode("div", _hoisted_7$J, [
            createBaseVNode("label", _hoisted_8$I, [
              createBaseVNode("b", null, toDisplayString(_i18n("date_from")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_9$A, [
            createBaseVNode("input", {
              class: "form-control",
              type: "text",
              value: end_time.value,
              disabled: ""
            }, null, 8 /* PROPS */, _hoisted_10$x)
          ])
        ]),
        createVNode(script$1G, {
          no_close_button: true,
          ref_key: "alert_info",
          ref: alert_info
        }, null, 512 /* NEED_PATCH */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: acknowledge_alerts,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("acknowledge")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$1o.__file = "http_src/vue/modal-acknowledge-alerts.vue";

  const _hoisted_1$1d = { class: "form-group row" };
  const _hoisted_2$16 = { class: "col-sm-6" };
  const _hoisted_3$14 = { class: "col-form-label" };
  const _hoisted_4$10 = { class: "col-sm-6" };
  const _hoisted_5$W = ["value"];
  const _hoisted_6$L = { class: "form-group row" };
  const _hoisted_7$I = { class: "col-sm-6" };
  const _hoisted_8$H = { class: "col-form-label" };
  const _hoisted_9$z = { class: "col-sm-6 mt-1" };
  const _hoisted_10$w = ["value"];
  const _hoisted_11$t = { class: "form-group filters-list mb-2" };
  const _hoisted_12$s = { class: "form-group row" };
  const _hoisted_13$m = { class: "col-sm-6" };
  const _hoisted_14$j = { class: "col-form-label" };
  const _hoisted_15$h = { class: "col-sm-6 mt-1" };
  const _hoisted_16$h = ["value"];


  var script$1n = {
    __name: 'modal-delete-alerts',
    props: {
      page: String,
      context: Object,    
  },
    emits: ["delete_alerts"],
    setup(__props, { expose, emit }) {

  const props = __props;
  const _i18n = (t) => i18n(t);
  const modal_id = ref(null);
  const alert_info = ref(null);
  const begin_time = ref("");
  const end_time = ref("");
  const filters = ref([]);

  onMounted(() => {
  });

  const show = (status) => {
      begin_time.value = ntopng_utility$1.from_utc_to_server_date_format(status.epoch_begin * 1000);
      end_time.value = ntopng_utility$1.from_utc_to_server_date_format(status.epoch_end * 1000);
      const tag_operator_label_dict = filtersManager.tag_operator_label_dict;
      filters.value = status.filters.map((f) => {
  	return {
  	    label: f.label,
  	    value: `${tag_operator_label_dict[f.operator]} ${f.value_label}`,
  	};
      });
      let message_body = _i18n("show_alerts.confirm_delete_alerts");
      alert_info.value.show(message_body, "alert-danger");
      modal_id.value.show();
  };

  async function delete_alerts() {
      const url = `${http_prefix}/lua/rest/v2/delete/${props.page}/alerts.lua`;
      const url_params_obj = ntopng_url_manager$1.get_url_object();
      const params = {
  	csrf: props.context.csrf,
  	...url_params_obj,
      };
      await ntopng_utility$1.http_post_request(url, params);
      emit("delete_alerts");
      close();
  }

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("delete_alerts")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$1d, [
          createBaseVNode("div", _hoisted_2$16, [
            createBaseVNode("label", _hoisted_3$14, [
              createBaseVNode("b", null, toDisplayString(_i18n("date_from")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_4$10, [
            createBaseVNode("input", {
              class: "form-control",
              type: "text",
              value: begin_time.value,
              disabled: ""
            }, null, 8 /* PROPS */, _hoisted_5$W)
          ])
        ]),
        createBaseVNode("div", _hoisted_6$L, [
          createBaseVNode("div", _hoisted_7$I, [
            createBaseVNode("label", _hoisted_8$H, [
              createBaseVNode("b", null, toDisplayString(_i18n("date_from")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_9$z, [
            createBaseVNode("input", {
              class: "form-control",
              type: "text",
              value: end_time.value,
              disabled: ""
            }, null, 8 /* PROPS */, _hoisted_10$w)
          ])
        ]),
        createBaseVNode("div", _hoisted_11$t, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(filters.value, (item) => {
            return (openBlock(), createElementBlock("div", _hoisted_12$s, [
              createBaseVNode("div", _hoisted_13$m, [
                createBaseVNode("label", _hoisted_14$j, [
                  createBaseVNode("b", null, toDisplayString(item.label), 1 /* TEXT */)
                ])
              ]),
              createBaseVNode("div", _hoisted_15$h, [
                createBaseVNode("input", {
                  class: "form-control",
                  type: "text",
                  value: item.value,
                  disabled: ""
                }, null, 8 /* PROPS */, _hoisted_16$h)
              ])
            ]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]),
        createVNode(script$1G, {
          no_close_button: true,
          ref_key: "alert_info",
          ref: alert_info
        }, null, 512 /* NEED_PATCH */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: delete_alerts,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("delete")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$1n.__file = "http_src/vue/modal-delete-alerts.vue";

  const _hoisted_1$1c = { class: "row" };
  const _hoisted_2$15 = { class: "col-12" };
  const _hoisted_3$13 = { class: "mb-2" };
  const _hoisted_4$$ = { class: "w-100" };
  const _hoisted_5$V = { clas: "range-container d-flex flex-wrap" };
  const _hoisted_6$K = { class: "range-picker d-flex m-auto flex-wrap" };
  const _hoisted_7$H = {
    key: 0,
    class: "ms-1 me-2"
  };
  const _hoisted_8$G = ["value"];
  const _hoisted_9$y = ["label"];
  const _hoisted_10$v = ["value"];
  const _hoisted_11$s = ["title"];
  const _hoisted_12$r = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-link" }, null, -1 /* HOISTED */);
  const _hoisted_13$l = [
    _hoisted_12$r
  ];
  const _hoisted_14$i = ["title", "href"];
  const _hoisted_15$g = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-file" }, null, -1 /* HOISTED */);
  const _hoisted_16$g = [
    _hoisted_15$g
  ];
  const _hoisted_17$f = ["title"];
  const _hoisted_18$f = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_19$f = [
    _hoisted_18$f
  ];
  const _hoisted_20$e = ["title"];
  const _hoisted_21$a = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-camera-retro" }, null, -1 /* HOISTED */);
  const _hoisted_22$a = [
    _hoisted_21$a
  ];
  const _hoisted_23$9 = { class: "col-12" };
  const _hoisted_24$9 = { class: "card card-shadow" };
  const _hoisted_25$8 = { class: "card-body" };
  const _hoisted_26$8 = {
    key: 0,
    class: "row"
  };
  const _hoisted_27$8 = {
    class: "col-12 mb-2",
    id: "chart-vue"
  };
  const _hoisted_28$6 = { class: "card h-100 overflow-hidden" };
  const _hoisted_29$6 = /*#__PURE__*/createBaseVNode("div", null, null, -1 /* HOISTED */);
  const _hoisted_30$5 = ["title"];
  const _hoisted_31$5 = ["onClick", "title"];
  const _hoisted_32$5 = { class: "card-footer" };
  const _hoisted_33$5 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa fa-user-check" }, null, -1 /* HOISTED */);
  const _hoisted_34$4 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa fa-trash" }, null, -1 /* HOISTED */);


  var script$1m = {
    __name: 'page-alert-stats',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);



  const alert_info = ref(null);
  const chart = ref(null);
  const table_alerts = ref(null);
  const modal_traffic_extraction = ref(null);
  const modal_snapshot = ref(null);
  const range_picker = ref(null);
  const permanent_link_button = ref(null);
  const modal_alerts_filter = ref(null);
  const modal_acknowledge = ref(null);
  const modal_delete = ref(null);
  const modal_acknowledge_alerts = ref(null);
  const modal_delete_alerts = ref(null);
  const count_page_components_reloaded = ref(0);
  const display_message = ref(false);
  const message_to_display = ref('');

  const current_alert = ref(null);
  const default_ifid = props.context.ifid;
  let page;
  const table_config_id = ref("");
  const table_id = ref("");
  let chart_data_url = `${http_prefix}/lua/pro/rest/v2/get/db/ts.lua`;
  const chart_type = ntopChartApex$1.typeChart.TS_COLUMN;
  const top_table_array = ref([]);
  const top_table_dropdown_array = ref([]);
  const note_list = ref([_i18n('show_alerts.alerts_info')]);
  const selected_query_preset = ref({});
  const query_presets = ref([]);
  const mount_range_picker = ref(false);

  const href_download_records = computed$1(() => {
      if (!props.context.show_chart || table_alerts.value == null) {
          return ``;
      }
      // add impossible if on ref variable to reload this expression every time count_page_components_reloaded.value change
      if (count_page_components_reloaded.value < 0) { throw "never run"; }
      const download_endpoint = props.context.download.endpoint;
      let params = ntopng_url_manager$1.get_url_object();
      let columns = table_alerts.value.get_columns_defs();
      let visible_columns = columns.filter((c) => c.visible).map((c) => c.id).join(",");
      params.format = "txt";
      params.visible_columns = visible_columns;
      const url_params = ntopng_url_manager$1.obj_to_url_params(params);
      return `${location.origin}/${download_endpoint}?${url_params}`;
  });

  onBeforeMount(async () => {
      message_to_display.value = `<div class="alert alert-success alert-dismissable"><span>${i18n('no_alerts_require_attention')}</span></div>`;
      if (props.context.is_va) {
          ntopng_utility$1.check_and_set_default_time_interval("day");
      }
      init_params();
      init_url_params();
      await set_query_presets();
      mount_range_picker.value = true;
      await load_top_table_array_overview();
  });

  onMounted(async () => {
      register_components_on_status_update();
  });

  async function init_params() {
      page = ntopng_url_manager$1.get_url_entry("page");
      const status = ntopng_url_manager$1.get_url_entry("status");
      if (page == null) { page = "all"; }
      if (status == 'engaged' && page == "flow") { ntopng_url_manager$1.set_key_to_url("status", "historical"); }
      chart_data_url = (page == "snmp_device") ? `${http_prefix}/lua/pro/rest/v2/get/snmp/device/alert/ts.lua` : `${http_prefix}/lua/rest/v2/get/${page}/alert/ts.lua`;
      selected_query_preset.value = {
          value: ntopng_url_manager$1.get_url_entry("query_preset"),
          count: ntopng_url_manager$1.get_url_entry("count"),
      };
      if (selected_query_preset.value.value == null) {
          selected_query_preset.value.value = "";
      }
      table_config_id.value = `alert_${page}`;
      table_id.value = `${table_config_id.value}_${selected_query_preset.value.value}`;    
  }

  function init_url_params() {
      if (ntopng_url_manager$1.get_url_entry("ifid") == null) {
          ntopng_url_manager$1.set_key_to_url("ifid", default_ifid);
      }
      if (ntopng_url_manager$1.get_url_entry("epoch_begin") == null
          || ntopng_url_manager$1.get_url_entry("epoch_end") == null) {
          let default_epoch_begin = Number.parseInt((Date.now() - 1000 * 30 * 60) / 1000);
          let default_epoch_end = Number.parseInt(Date.now() / 1000);
          ntopng_url_manager$1.set_key_to_url("epoch_begin", default_epoch_begin);
          ntopng_url_manager$1.set_key_to_url("epoch_end", default_epoch_end);
      }
      if (ntopng_url_manager$1.get_url_entry("page") == "flow"
          && ntopng_url_manager$1.get_url_entry("status") == "engaged") {
          ntopng_url_manager$1.set_key_to_url("status", "historical");
      }
  }

  async function set_query_presets() {
      if (!props.context.is_ntop_enterprise_l || ntopng_url_manager$1.get_url_entry("status") == "engaged") {
  	ntopng_sync$1.ready(get_query_presets_sync_key());
  	return;
      }
      let url_request = `${http_prefix}/lua/pro/rest/v2/get/alert/preset/consts.lua?page=${page}`;
      let res = await ntopng_utility$1.http_request(url_request);
      if (res == null || res.length == 0) {
  	query_presets.value = [];
  	ntopng_url_manager$1.set_key_to_url("query_preset", "");
  	ntopng_url_manager$1.set_key_to_url("count", "");
  	ntopng_sync$1.ready(get_query_presets_sync_key());
  	return;
      }
      
      query_presets.value = res[0].list.map((el) => {
          return {
              value: el.id,
              name: el.name,
              count: el.count,
              builtin: true,
          };
      });
      if (res.length > 1) {
          res[1].list.forEach((el) => {
              let query = {
                  value: el.id,
                  name: el.name,
                  count: el.count,
                  is_preset: true,
              };
              query_presets.value.push(query);
          });
      }
      if (selected_query_preset.value == null || selected_query_preset.value.value == "") {
          selected_query_preset.value = query_presets.value[0];
      } else {
          let q = query_presets.value.find((i) => i.value == selected_query_preset.value.value);
          selected_query_preset.value = q || query_presets.value[0];
      }
      ntopng_url_manager$1.set_key_to_url("query_preset", selected_query_preset.value.value);
      ntopng_url_manager$1.set_key_to_url("count", selected_query_preset.value.count);
      ntopng_sync$1.ready(get_query_presets_sync_key());
  }

  const page_id = "page-alert-stats";
  function get_query_presets_sync_key() {
      return `${page_id}_query_presets`;
  }

  async function load_top_table_array_overview(action) {
      if (props.context.show_cards != true || selected_query_preset.value.is_preset == true) { return; }
      top_table_array.value = await load_top_table_array("overview");
  }

  async function load_top_table_details(top, top_index) {
      top.show_spinner = true;
      await nextTick();
      if (top.data_loaded == false) {
          let new_top_array = await load_top_table_array(top.id);
          top.options = new_top_array.find((t) => t.id == top.id).options;
          await nextTick();
          let dropdown = top_table_dropdown_array.value[top_index];
          dropdown.load_menu();
      }
      top.show_spinner = false;
  }

  async function load_top_table_array(action, top) {
      // top_table.value = [];
      const url_params = ntopng_url_manager$1.get_url_params();
      const url = `${props.context.endpoint_cards}?${url_params}&action=${action}`;
      let res = await ntopng_utility$1.http_request(url);
      return res.map((t) => {
          return {
              id: t.name,
              label: t.label,
              title: t.tooltip,
              show_spinner: false,
              data_loaded: action != 'overview',
              options: t.value,
          };
      });
  }

  const get_open_top_table_dropdown = (top, top_index) => {
      return (d) => {
          load_top_table_details(top, top_index);
      };
  };

  async function register_components_on_status_update() {
      await ntopng_sync$1.on_ready("range_picker");
      //if (show_chart) {      
      chart.value.register_status();
      //}
      //updateDownloadButton();
      ntopng_status_manager$1.on_status_change(page, (new_status) => {
          ntopng_url_manager$1.get_url_params();
          table_alerts.value.refresh_table();
          load_top_table_array_overview();
      }, false);
  }

  function on_table_loaded() {
      register_table_alerts_events();
  }

  function register_table_alerts_events() {
      let jquery_table_alerts = $(`#${table_id.value}`);
      jquery_table_alerts.on('click', `a.tag-filter`, async function (e) {
          add_table_row_filter(e, $(this));
      });
  }

  function update_select_query_presets() {
      ntopng_url_manager$1.get_url_params();
      ntopng_url_manager$1.set_key_to_url("query_preset", selected_query_preset.value.value);
      ntopng_url_manager$1.set_key_to_url("count", selected_query_preset.value.count);
      ntopng_url_manager$1.reload_url();
  }

  const map_table_def_columns = async (columns) => {
      await ntopng_sync$1.on_ready(get_query_presets_sync_key());
      let map_columns = {
          "l7_proto": (proto, row) => {
              let confidence = "";
              if (proto.confidence !== undefined) {
                  const title = proto.confidence;
                  (title == "DPI") ? confidence = `<span class="badge bg-success" title="${title}">${title}</span>` : confidence = `<span class="badge bg-warning" title="${title}">${title}</span>`;
              }
              return DataTableRenders$1.filterize('l7proto', proto.value, proto.label) + " " + `${confidence}`;
          },
          "info": (info, row) => {
              let copy_button = '';
              if(info.value) {
                  copy_button = `<button class="btn btn-light btn-sm border ms-1" data-placement="bottom" onclick="
                    const textArea = document.createElement('textarea');
                    textArea.value = '${info.value}';    
                    textArea.style.position = 'absolute';
                    textArea.style.left = '-999999px';    
                    document.body.prepend(textArea);
                    textArea.select();
                    document.execCommand('copy');"
                    ><i class="fas fa-copy"></i></button>`;
              }
              return `${copy_button} ${DataTableRenders$1.filterize('info', info.value, info.label)}`;
          },
      };
      let set_query_preset_columns = selected_query_preset.value.is_preset && columns.length > 0;
      if (set_query_preset_columns) {
          // add action button that is the first button
          columns = [columns[0]].concat(props.context.columns_def);
      }
      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
  	
          if (c.id == "actions") {
  	    if (set_query_preset_columns == true) {
  		c.button_def_array = [
  		    {
  			"id": "expand",
  			"icon": "fas fa fa-search-plus",
  			"class":["link-button"],
  			"title_i18n": "db_search.expand_button",
  			"event_id": "click_button_expand"
  		    },
  		];
  		return;
  	    }
              const visible_dict = {
                  snmp_info: props.context.actions.show_snmp_info,
                  info: props.context.actions.show_info,
                  historical_data: props.context.actions.show_historical,
                  acknowledge: props.context.actions.show_acknowledge,
                  disable: props.context.actions.show_disable,
                  settings: props.context.actions.show_settings,
                  remove: props.context.actions.show_delete,
              };
              c.button_def_array.forEach((b) => {
                  if (!visible_dict[b.id]) {
                      b.class.push("link-disabled");
                  }
              });
          }
      });
      return columns;
  };

  const add_table_row_filter = (e, a) => {
      e.stopPropagation();

      let key = undefined;
      let realValue = undefined;
      let operator = 'eq';

      // Read tag key and value from the <a> itself if provided
      if (a.data('tagKey') != undefined) key = a.data('tagKey');
      if (a.data('tagRealvalue') != undefined) realValue = a.data('tagRealvalue');
      else if (a.data('tagValue') != undefined) realValue = a.data('tagValue');
      if (a.data('tagOperator') != undefined) operator = a.data('tagOperator');

      let filter = {
          id: key,
          value: realValue,
          operator: operator,
      };
      add_filter(filter);
  };

  function add_top_table_filter(opt, event) {
      event.stopPropagation();
      let filter = {
          id: opt.key,
          value: opt.value,
          operator: opt.operator,
      };
      add_filter(filter);
  }

  function add_filter(filter) {
      if (range_picker.value.is_filter_defined(filter)) {
          ntopng_events_manager.emit_custom_event(ntopng_custom_events$1.SHOW_MODAL_FILTERS, filter);
      } else {
          throw `Filter ${filter.value} not defined`;
      }
  }

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager$1.get_url_object();
      return extra_params;
  };

  function click_navbar_item(item) {
      ntopng_url_manager$1.set_key_to_url('page', item.page_name);
      let is_alert_stats_url = window.location.toString().match(/alert_stats.lua/) != null;
      if (is_alert_stats_url) {
          remove_filters_from_url();
      }
      ntopng_url_manager$1.reload_url();
  }

  function remove_filters_from_url() {
      let status = ntopng_status_manager$1.get_status();
      let filters = status.filters;
      if (filters == null) { return; }
      ntopng_url_manager$1.delete_params(filters.map((f) => f.id));
  }

  function show_modal_alerts_filter(alert) {
      current_alert.value = alert;
      modal_alerts_filter.value.show();
  }

  function get_permanent_link() {
      const $this = $(permanent_link_button.value);
      const placeholder = document.createElement('input');
      placeholder.value = location.href;
      document.body.appendChild(placeholder);
      placeholder.select();

      // copy the url to the clipboard from the placeholder
      document.execCommand("copy");
      document.body.removeChild(placeholder);
      
      $this.attr("title", `${_i18n('copied')}!`)
          .tooltip("dispose")
          .tooltip()
          .tooltip("show");
  }

  function show_modal_traffic_extraction() {
      modal_traffic_extraction.value.show();

  }

  function show_modal_snapshot() {
      modal_snapshot.value.show();
  }

  async function add_exclude(params) {
      params.csrf = props.context.csrf;
      let url = `${http_prefix}/lua/pro/rest/v2/add/alert/exclusion.lua`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          let url_params = ntopng_url_manager$1.get_url_params();
          setTimeout(() => {
              //todo reloadTable($table, url_params);
              ntopng_events_manager.emit_custom_event(ntopng_custom_events$1.SHOW_GLOBAL_ALERT_INFO, { text_html: _i18n('check_exclusion.disable_warn'), type: "alert-info", timeout: 2 });
          }, 1000);
      } catch (err) {
          console.error(err);
      }
  }

  function refresh_page_components() {
      let t = table_alerts.value;
      let c = chart.value;
      setTimeout(() => {
          t.refresh_table();
          c.update_chart();
      }, 1 * 1000);
  }

  /* In case no rows are printed, then the message has to be displayed */
  function rows_loaded(res) {
      if(res?.rows != null) {
          display_message.value = (res.rows.length == 0);
      }
  }

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_snmp_info": click_button_snmp_info,
          "click_button_info": click_button_info,
          "click_button_historical_flows": click_button_historical_flows,
          "click_button_acknowledge": click_button_acknowledge,
          "click_button_disable": click_button_disable,
          "click_button_settings": click_button_settings,
          "click_button_remove": click_button_remove,
          "click_button_expand": click_button_expand,
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  function click_button_expand(event) {
      const alert = event.row;
      ntopng_url_manager$1.set_key_to_url("query_preset", "");
      ntopng_url_manager$1.set_key_to_url("count", "");
      let status = ntopng_status_manager$1.get_status();
      let filters = status.filters;
      let row_filters = alert?.filter?.tag_filters;
      if (row_filters?.length > 0) {
  	row_filters = row_filters.map((f) => {
  	    return {
  		id: f.id,
  		operator: f.op,
  		value: f.value,
  	    };
  	});
  	filters = filters.concat(row_filters);
      }
      // remove duplicate filters
      let filters_dict = {};
      filters.forEach((f) => filters_dict[`${f.id}_${f.operator}_${f.value}`] = f);
      filters = ntopng_utility$1.object_to_array(filters_dict);
      
      let filters_object = filtersManager.get_filters_object(filters);
      ntopng_url_manager$1.add_obj_to_url(filters_object);
      ntopng_url_manager$1.reload_url();
  }

  function show_modal_acknowledge_alerts() {
      let status = ntopng_status_manager$1.get_status();
      modal_acknowledge_alerts.value.show(status);
  }

  function show_modal_delete_alerts() {
      let status = ntopng_status_manager$1.get_status();
      modal_delete_alerts.value.show(status);
  }

  function click_button_remove(event) {
      const alert = event.row;
      let status_view = get_status_view();
      modal_delete.value.show(alert, status_view);
  }

  function click_button_settings(event) {
      const alert = event.row;
      const check_settings_href = $(alert.msg.configset_ref).attr('href');
      window.location.href = check_settings_href;
  }

  function click_button_disable(event) {
      const alert = event.row;
      show_modal_alerts_filter(alert);
  }

  function click_button_acknowledge(event) {
      const alert = event.row;
      modal_acknowledge.value.show(alert, props.context);
  }

  function click_button_historical_flows(event) {
      const alert = event.row;
      if (alert.link_to_past_flows) {
          window.location.href = alert.link_to_past_flows;
      } else {
          window.location.href = `${http_prefix}/lua/pro/db_search.lua`;
      }
  }

  function click_button_snmp_info(event) {
      const alert = event.row;
      let href = ``;
      if (alert.port.value != null) {
          href = `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${alert.ip}&snmp_port_idx=${alert.port.value}`;
      } else {
          href = `${http_prefix}/lua/pro/enterprise/snmp_device_details.lua?host=${alert.ip}`;
      }
      window.open(href, "_blank");
  }

  function click_button_info(event) {
      const alert = event.row;
      let status_view = get_status_view();
      let params_obj = {
          page: page,
          status: status_view,
          row_id: alert.row_id,
          tstamp: alert.tstamp.value,
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params_obj);
      const href = `${props.context.alert_details_url}?${url_params}`;
      window.open(href, "_blank");
  }

  function get_status_view() {
      let status_view = ntopng_url_manager$1.get_url_entry("status");
      if (status_view == null || status_view == "") {
          status_view = "historical";
      }
      return status_view;
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createVNode(script$1H, {
        id: "navbar",
        main_title: __props.context.navbar.main_title,
        base_url: __props.context.navbar.base_url,
        help_link: __props.context.navbar.help_link,
        items_table: __props.context.navbar.items_table,
        onClick_item: click_navbar_item
      }, null, 8 /* PROPS */, ["main_title", "base_url", "help_link", "items_table"]),
      createBaseVNode("div", _hoisted_1$1c, [
        createBaseVNode("div", _hoisted_2$15, [
          createBaseVNode("div", _hoisted_3$13, [
            createBaseVNode("div", _hoisted_4$$, [
              createBaseVNode("div", _hoisted_5$V, [
                createBaseVNode("div", _hoisted_6$K, [
                  createVNode(script$1G, {
                    id: "alert_info",
                    global: true,
                    ref_key: "alert_info",
                    ref: alert_info
                  }, null, 512 /* NEED_PATCH */),
                  createVNode(script$1t, {
                    id: "modal_traffic_extraction",
                    ref_key: "modal_traffic_extraction",
                    ref: modal_traffic_extraction
                  }, null, 512 /* NEED_PATCH */),
                  createVNode(script$1s, {
                    ref_key: "modal_snapshot",
                    ref: modal_snapshot,
                    csrf: __props.context.csrf
                  }, null, 8 /* PROPS */, ["csrf"]),
                  (mount_range_picker.value)
                    ? (openBlock(), createBlock(script$1B, {
                        key: 0,
                        ref_key: "range_picker",
                        ref: range_picker,
                        id: "range_picker"
                      }, {
                        begin: withCtx(() => [
                          (query_presets.value.length > 0)
                            ? (openBlock(), createElementBlock("div", _hoisted_7$H, [
                                withDirectives(createBaseVNode("select", {
                                  class: "me-2 form-select",
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((selected_query_preset).value = $event)),
                                  onChange: _cache[1] || (_cache[1] = $event => (update_select_query_presets()))
                                }, [
                                  (openBlock(true), createElementBlock(Fragment, null, renderList(query_presets.value, (item) => {
                                    return (openBlock(), createElementBlock(Fragment, null, [
                                      (item.builtin == true)
                                        ? (openBlock(), createElementBlock("option", {
                                            key: 0,
                                            value: item
                                          }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_8$G))
                                        : createCommentVNode("v-if", true)
                                    ], 64 /* STABLE_FRAGMENT */))
                                  }), 256 /* UNKEYED_FRAGMENT */)),
                                  (unref(page) != 'analysis')
                                    ? (openBlock(), createElementBlock("optgroup", {
                                        key: 0,
                                        label: _i18n('queries.queries')
                                      }, [
                                        (openBlock(true), createElementBlock(Fragment, null, renderList(query_presets.value, (item) => {
                                          return (openBlock(), createElementBlock(Fragment, null, [
                                            (!item.builtin)
                                              ? (openBlock(), createElementBlock("option", {
                                                  key: 0,
                                                  value: item
                                                }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_10$v))
                                              : createCommentVNode("v-if", true)
                                          ], 64 /* STABLE_FRAGMENT */))
                                        }), 256 /* UNKEYED_FRAGMENT */))
                                      ], 8 /* PROPS */, _hoisted_9$y))
                                    : createCommentVNode("v-if", true)
                                ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                                  [vModelSelect, selected_query_preset.value]
                                ])
                              ]))
                            : createCommentVNode("v-if", true)
                        ]),
                        extra_range_buttons: withCtx(() => [
                          (__props.context.show_permalink)
                            ? (openBlock(), createElementBlock("button", {
                                key: 0,
                                class: "btn btn-link btn-sm",
                                onClick: get_permanent_link,
                                title: _i18n('graphs.get_permanent_link'),
                                ref_key: "permanent_link_button",
                                ref: permanent_link_button
                              }, _hoisted_13$l, 8 /* PROPS */, _hoisted_11$s))
                            : createCommentVNode("v-if", true),
                          (__props.context.show_download)
                            ? (openBlock(), createElementBlock("a", {
                                key: 1,
                                class: "btn btn-link btn-sm",
                                id: "dt-btn-download",
                                title: _i18n('graphs.download_records'),
                                href: unref(href_download_records)
                              }, _hoisted_16$g, 8 /* PROPS */, _hoisted_14$i))
                            : createCommentVNode("v-if", true),
                          (__props.context.show_pcap_download)
                            ? (openBlock(), createElementBlock("button", {
                                key: 2,
                                class: "btn btn-link btn-sm",
                                onClick: show_modal_traffic_extraction,
                                title: _i18n('traffic_recording.pcap_download')
                              }, _hoisted_19$f, 8 /* PROPS */, _hoisted_17$f))
                            : createCommentVNode("v-if", true),
                          (__props.context.is_ntop_enterprise_m)
                            ? (openBlock(), createElementBlock("button", {
                                key: 3,
                                class: "btn btn-link btn-sm",
                                onClick: show_modal_snapshot,
                                title: _i18n('datatable.manage_snapshots')
                              }, _hoisted_22$a, 8 /* PROPS */, _hoisted_20$e))
                            : createCommentVNode("v-if", true)
                        ]),
                        _: 1 /* STABLE */
                      }, 512 /* NEED_PATCH */))
                    : createCommentVNode("v-if", true)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_23$9, [
          createBaseVNode("div", _hoisted_24$9, [
            createBaseVNode("div", _hoisted_25$8, [
              (__props.context.show_chart)
                ? (openBlock(), createElementBlock("div", _hoisted_26$8, [
                    createBaseVNode("div", _hoisted_27$8, [
                      createBaseVNode("div", _hoisted_28$6, [
                        createVNode(script$1F, {
                          ref_key: "chart",
                          ref: chart,
                          id: "chart_alert_stats",
                          chart_type: unref(chart_type),
                          base_url_request: unref(chart_data_url),
                          register_on_status_change: false
                        }, null, 8 /* PROPS */, ["chart_type", "base_url_request"])
                      ])
                    ]),
                    _hoisted_29$6,
                    createVNode(script$1w, {
                      ref_key: "table_alerts",
                      ref: table_alerts,
                      table_config_id: table_config_id.value,
                      table_id: table_id.value,
                      csrf: __props.context.csrf,
                      f_map_columns: map_table_def_columns,
                      get_extra_params_obj: get_extra_params_obj,
                      display_message: display_message.value,
                      message_to_display: message_to_display.value,
                      onLoaded: on_table_loaded,
                      onCustom_event: on_table_custom_event,
                      onRows_loaded: rows_loaded
                    }, {
                      custom_header: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(top_table_array.value, (t, t_index) => {
                          return (openBlock(), createBlock(script$1J, {
                            f_on_open: get_open_top_table_dropdown(t, t_index),
                            ref_for: true,
                            ref: el => { top_table_dropdown_array.value[t_index] = el; }
                          }, {
                            title: withCtx(() => [
                              createVNode(script$1v, {
                                show: t.show_spinner,
                                size: "1rem",
                                class: "me-1"
                              }, null, 8 /* PROPS */, ["show"]),
                              createBaseVNode("a", {
                                class: "ntopng-truncate",
                                title: t.title
                              }, toDisplayString(t.label), 9 /* TEXT, PROPS */, _hoisted_30$5)
                            ]),
                            menu: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (opt) => {
                                return (openBlock(), createElementBlock("a", {
                                  style: {"cursor":"pointer","display":"block"},
                                  onClick: $event => (add_top_table_filter(opt, $event)),
                                  class: "ntopng-truncate tag-filter",
                                  title: opt.value
                                }, toDisplayString(opt.label), 9 /* TEXT, PROPS */, _hoisted_31$5))
                              }), 256 /* UNKEYED_FRAGMENT */))
                            ]),
                            _: 2 /* DYNAMIC */
                          }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["f_on_open"]))
                        }), 256 /* UNKEYED_FRAGMENT */)),
                        createCommentVNode(" Dropdown columns ")
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["table_config_id", "table_id", "csrf", "display_message", "message_to_display"])
                  ]))
                : createCommentVNode("v-if", true)
            ]),
            createCommentVNode(" card body "),
            withDirectives(createBaseVNode("div", _hoisted_32$5, [
              (__props.context.show_acknowledge_all)
                ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    onClick: show_modal_acknowledge_alerts,
                    class: "btn btn-primary me-1"
                  }, [
                    _hoisted_33$5,
                    createTextVNode(" " + toDisplayString(_i18n("acknowledge_alerts")), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              (__props.context.show_delete_all)
                ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    onClick: show_modal_delete_alerts,
                    class: "btn btn-danger"
                  }, [
                    _hoisted_34$4,
                    createTextVNode(" " + toDisplayString(_i18n("delete_alerts")), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true)
            ], 512 /* NEED_PATCH */), [
              [vShow, unref(page) != 'all']
            ]),
            createCommentVNode(" card footer ")
          ]),
          createCommentVNode(" card-shadow ")
        ]),
        createCommentVNode(" div col "),
        createVNode(script$1u, { note_list: note_list.value }, null, 8 /* PROPS */, ["note_list"])
      ]),
      createCommentVNode(" div row "),
      createVNode(script$1q, {
        ref_key: "modal_acknowledge",
        ref: modal_acknowledge,
        context: __props.context,
        page: unref(page),
        onAcknowledge: refresh_page_components
      }, null, 8 /* PROPS */, ["context", "page"]),
      createVNode(script$1p, {
        ref_key: "modal_delete",
        ref: modal_delete,
        context: __props.context,
        page: unref(page),
        onDelete_alert: refresh_page_components
      }, null, 8 /* PROPS */, ["context", "page"]),
      createVNode(script$1o, {
        ref_key: "modal_acknowledge_alerts",
        ref: modal_acknowledge_alerts,
        context: __props.context,
        page: unref(page),
        onAcknowledge_alerts: refresh_page_components
      }, null, 8 /* PROPS */, ["context", "page"]),
      createVNode(script$1n, {
        ref_key: "modal_delete_alerts",
        ref: modal_delete_alerts,
        context: __props.context,
        page: unref(page),
        onDelete_alerts: refresh_page_components
      }, null, 8 /* PROPS */, ["context", "page"]),
      createVNode(script$1r, {
        alert: current_alert.value,
        page: unref(page),
        onExclude: add_exclude,
        ref_key: "modal_alerts_filter",
        ref: modal_alerts_filter
      }, null, 8 /* PROPS */, ["alert", "page"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$1m.__file = "http_src/vue/page-alert-stats.vue";

  const _hoisted_1$1b = { class: "row" };
  const _hoisted_2$14 = { class: "col-12" };
  const _hoisted_3$12 = { class: "mb-2" };
  const _hoisted_4$_ = { class: "w-100" };
  const _hoisted_5$U = { clas: "range-container d-flex flex-wrap" };
  const _hoisted_6$J = { class: "range-picker d-flex m-auto flex-wrap" };
  const _hoisted_7$G = { class: "ms-1 me-2" };
  const _hoisted_8$F = ["value"];
  const _hoisted_9$x = ["label"];
  const _hoisted_10$u = ["value"];
  const _hoisted_11$r = ["title"];
  const _hoisted_12$q = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-link" }, null, -1 /* HOISTED */);
  const _hoisted_13$k = [
    _hoisted_12$q
  ];
  const _hoisted_14$h = ["title", "href"];
  const _hoisted_15$f = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-file" }, null, -1 /* HOISTED */);
  const _hoisted_16$f = [
    _hoisted_15$f
  ];
  const _hoisted_17$e = ["title"];
  const _hoisted_18$e = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_19$e = [
    _hoisted_18$e
  ];
  const _hoisted_20$d = ["title"];
  const _hoisted_21$9 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-camera-retro" }, null, -1 /* HOISTED */);
  const _hoisted_22$9 = [
    _hoisted_21$9
  ];
  const _hoisted_23$8 = { class: "col-12" };
  const _hoisted_24$8 = { class: "card card-shadow" };
  const _hoisted_25$7 = { class: "card-body" };
  const _hoisted_26$7 = { class: "row" };
  const _hoisted_27$7 = {
    key: 0,
    class: "col-12 mb-2",
    id: "chart-vue"
  };
  const _hoisted_28$5 = ["title"];
  const _hoisted_29$5 = ["onClick", "title"];
  const _hoisted_30$4 = {
    key: 0,
    class: "card-footer"
  };
  const _hoisted_31$4 = {
    key: 0,
    id: "dt-btn-acknowledge",
    disabled: true,
    "data-bs-target": "#dt-acknowledge-modal",
    "data-bs-toggle": "modal",
    class: "btn btn-primary me-1"
  };
  const _hoisted_32$4 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa fa-user-check" }, null, -1 /* HOISTED */);
  const _hoisted_33$4 = {
    key: 1,
    id: "dt-btn-delete",
    disabled: true,
    "data-bs-target": "#dt-delete-modal",
    "data-bs-toggle": "modal",
    class: "btn btn-danger"
  };
  const _hoisted_34$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa fa-trash" }, null, -1 /* HOISTED */);


  var script$1l = {
    __name: 'page-flow-historical',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);



  const page_id = "page-flow-historical";
  const alert_info = ref(null);
  const chart = ref(null);
  const table_flows = ref(null);
  const modal_traffic_extraction = ref(null);
  const modal_snapshot = ref(null);
  const range_picker = ref(null);
  const permanent_link_button = ref(null);
  const modal_alerts_filter = ref(null);
  const modal_acknowledge = ref(null);
  const modal_delete = ref(null);

  const current_alert = ref(null);
  const default_ifid = props.context.ifid;
  const page = ref("");
  const table_config_id = ref("");
  const table_id = computed$1(() => {
      if (selected_query_preset.value?.value == null) { return table_config_id.value; }
      let id = `${table_config_id.value}_${selected_query_preset.value.value}`;
      return id;
  });

  const href_download_records = computed$1(() => {
      // add impossible if on ref variable to reload this expression every time count_page_components_reloaded.value change
      if (count_page_components_reloaded.value < 0) { throw "never run"; }
      const download_endpoint = props.context.download.endpoint;
      let params = ntopng_url_manager$1.get_url_object();
      let columns = table_flows.value.get_columns_defs();
      let visible_columns = columns.filter((c) => c.visible).map((c) => c.id).join(",");
      params.format = "txt";
      params.visible_columns = visible_columns;
      const url_params = ntopng_url_manager$1.obj_to_url_params(params);
      return `${location.origin}/${download_endpoint}?${url_params}`;
  });

  let chart_data_url = `${http_prefix}/lua/pro/rest/v2/get/db/ts.lua`;

  const chart_style = computed$1(() => {
      if (props.context?.chart_type == "topk-timeseries") {
          return "height:450px!important";
      }
      return "height:300px!important";

  });
  const chart_type = computed$1(() => {
      /* Chart type defined the json template (defaults in db_search.lua) */
      if (props.context?.chart_type == "topk-timeseries") {
          return ntopChartApex$1.typeChart.TS_STACKED;
      }
      return ntopChartApex$1.typeChart.TS_COLUMN;
  });

  const top_table_array = ref([]);
  const top_table_dropdown_array = ref([]);

  const selected_query_preset = ref({});
  const query_presets = ref([]);
  ref([]);
  const mount_range_picker = ref(false);

  const flows_aggregated = ref(false);
  const flow_type_label = ref(_i18n("datatable.aggregated"));
  const min_time_interval_id = ref(null);
  const round_time = ref(false);
  const count_page_components_reloaded = ref(0);

  onBeforeMount(async () => {
      init_params();
      init_url_params();
      await set_query_presets();
      mount_range_picker.value = true;
  });

  onMounted(async () => {
      register_components_on_status_update();
      load_top_table_array_overview();
  });

  function init_params() {
      page.value = ntopng_url_manager$1.get_url_entry("page");
      if (page.value == null) { page.value = "overview"; }
      chart_data_url = `${http_prefix}/lua/pro/rest/v2/get/db/ts.lua`;

      selected_query_preset.value = {
          value: ntopng_url_manager$1.get_url_entry("query_preset"),
      };
      if (selected_query_preset.value.value == null) {
          selected_query_preset.value.value = "";
      }
      table_config_id.value = `flow_historical`;
      const aggregated = ntopng_url_manager$1.get_url_entry("aggregated");
      if (aggregated == "true") {
          table_config_id.value = `flow_historical_aggregated`;
          flows_aggregated.value = true;
          min_time_interval_id.value = "hour";
          round_time.value = true;
      }
  }

  function init_url_params() {
      if (ntopng_url_manager$1.get_url_entry("ifid") == null) {
          ntopng_url_manager$1.set_key_to_url("ifid", default_ifid);
      }
      // 30 min default
      // chiamare set default_time interval
      if (flows_aggregated.value == false) {
          ntopng_utility$1.check_and_set_default_time_interval();
      }
      else {
          const f_check_last_minute_epoch_end = (epoch) => {
              let min_time_interval = ntopng_utility$1.get_timeframe_from_timeframe_id(min_time_interval_id.value);
              return epoch.epoch_end - epoch.epoch_begin < min_time_interval;
          };
          const epoch_interval = ntopng_utility$1.check_and_set_default_time_interval(min_time_interval_id.value, f_check_last_minute_epoch_end);
          if (epoch_interval != null) {
              epoch_interval.epoch_begin = ntopng_utility$1.round_time_by_timeframe_id(epoch_interval.epoch_begin, min_time_interval_id.value);
              epoch_interval.epoch_end = ntopng_utility$1.round_time_by_timeframe_id(epoch_interval.epoch_end, min_time_interval_id.value);
              ntopng_url_manager$1.set_key_to_url("epoch_begin", epoch_interval.epoch_begin);
              ntopng_url_manager$1.set_key_to_url("epoch_end", epoch_interval.epoch_end);
          }
      }

      if (ntopng_url_manager$1.get_url_entry("page") == "flow"
          && ntopng_url_manager$1.get_url_entry("status") == "engaged") {
          ntopng_url_manager$1.set_key_to_url("status", "historical");
      }
      if (ntopng_url_manager$1.get_url_entry("aggregated") == null) {
          ntopng_url_manager$1.set_key_to_url("aggregated", "false");
      }

  }

  function get_chart_config_from_preset_const(preset_const) {
      let chart = preset_const?.chart;
      if (chart != null && chart.length > 0) {
          return chart[0];
      }
      return {};
  }

  async function set_query_presets() {
      let url_request = `${http_prefix}/lua/pro/rest/v2/get/db/preset/consts.lua?page=${page.value}&aggregated=${flows_aggregated.value}`;
      let res = await ntopng_utility$1.http_request(url_request);

      query_presets.value = res[0].list.map((el) => {
          let chart_config = get_chart_config_from_preset_const(el);
          return {
              value: el.id, //== null ? "flow" : el.id,
              name: el.name,
              count: chart_config?.params?.count,
              chart_config: chart_config,
              builtin: true,
          };
      });
      if (res.length > 1) {
          res[1].list.forEach((el) => {
              let chart_config = get_chart_config_from_preset_const(el);
              let query = {
                  value: el.id,
                  name: el.name,
                  count: chart_config?.params?.count,
                  chart_config: chart_config,
                  is_preset: true,
              };
              query_presets.value.push(query);
          });
      }
      if (selected_query_preset.value == null || selected_query_preset.value.value == "") {
          selected_query_preset.value = query_presets.value[0];
      } else {
          let q = query_presets.value.find((i) => i.value == selected_query_preset.value.value);
          selected_query_preset.value = q || query_presets.value[0];
      }
      ntopng_url_manager$1.set_key_to_url("query_preset", selected_query_preset.value.value);
      ntopng_url_manager$1.set_key_to_url("count", selected_query_preset.value.count);
      ntopng_sync$1.ready(get_query_presets_sync_key());
  }

  const f_map_chart_options = async (chart_options) => {
      await ntopng_sync$1.on_ready(get_query_presets_sync_key());
      let formatter_type = selected_query_preset.value.chart_config?.unit_measure;
      if (formatter_type == null) {
          formatter_type = "number";
      }
      chart_options.yaxis.labels.formatter = formatterUtils.getFormatter(formatter_type);
      return chart_options;
  };

  function change_flow_type() {
      // if (flows_aggregated.value == false) {
      // 	ntopng_url_manager.delete_params(["aggregated"]);	
      // 	table_config_id.value = "flow_historical";
      // } else {
      // 	ntopng_url_manager.set_key_to_url("aggregated", "true");
      // 	table_config_id.value = "flow_historical_aggregated";
      // }
      // refresh_page_components(true);
      // load_top_table_array_overview();

      // currently we can't refresh component without reload the page because we need refresh props.context
      if (flows_aggregated.value == false) {
          ntopng_url_manager$1.delete_params(["aggregated"]);
      } else {
          ntopng_url_manager$1.set_key_to_url("aggregated", "true");
      }
      ntopng_url_manager$1.reload_url();
  }

  function update_select_query_presets() {
      ntopng_url_manager$1.get_url_params();
      ntopng_url_manager$1.set_key_to_url("query_preset", selected_query_preset.value.value);
      ntopng_url_manager$1.set_key_to_url("count", selected_query_preset.value.count);
      ntopng_url_manager$1.reload_url();
  }

  async function load_top_table_array_overview(action) {
      if (props.context.show_cards != true) { return; }
      top_table_array.value = await load_top_table_array("overview");
  }

  async function load_top_table_details(top, top_index) {
      top.show_spinner = true;
      await nextTick();
      if (top.data_loaded == false) {
          let new_top_array = await load_top_table_array(top.id);
          top.options = new_top_array.find((t) => t.id == top.id).options;
          await nextTick();
          let dropdown = top_table_dropdown_array.value[top_index];
          dropdown.load_menu();
      }
      top.show_spinner = false;
  }

  async function load_top_table_array(action, top) {
      // top_table.value = [];
      const url_params = ntopng_url_manager$1.get_url_params();
      const url = `${http_prefix}/lua/pro/rest/v2/get/flow/top.lua?${url_params}&action=${action}`;
      let res = await ntopng_utility$1.http_request(url);
      return res.map((t) => {
          return {
              id: t.action || t.name,
              label: t.label,
              title: t.tooltip,
              show_spinner: false,
              data_loaded: action != 'overview',
              options: t.value,
          };
      });
  }

  const get_open_top_table_dropdown = (top, top_index) => {
      return (d) => {
          load_top_table_details(top, top_index);
      };
  };

  async function register_components_on_status_update() {
      await ntopng_sync$1.on_ready("range_picker");
      if (props.context.show_chart) {
          chart.value.register_status();
      }
      //updateDownloadButton();
      ntopng_status_manager$1.on_status_change(page.value, (new_status) => {
          ntopng_url_manager$1.get_url_params();
          table_flows.value.refresh_table();
          load_top_table_array_overview();
          count_page_components_reloaded.value += 1;
      }, false);
  }

  function on_table_loaded() {
      register_table_flows_events();
  }

  function register_table_flows_events() {
      let jquery_table_flows = $(`#${table_id.value}`);
      jquery_table_flows.on('click', `a.tag-filter`, async function (e) {
          add_table_row_filter(e, $(this));
      });
  }

  const map_table_def_columns = async (columns) => {
      await ntopng_sync$1.on_ready(get_query_presets_sync_key());
      const f_print_asn = (key, asn, row) => {
          if (asn !== undefined && asn.value != 0) {
              return `<a class='tag-filter' data-tag-key='${key}' data-tag-value='${asn.value}' title='${asn.title}' href='javascript:void(0)'>${asn.label}</a>`;
          }
          return "";
      };
      const f_print_latency = (key, latency, row) => {
          if (latency == null || latency == 0) { return ""; }
          return `<a class='tag-filter' data-tag-key='${key}' data-tag-value='${latency}' href='javascript:void(0)'>${NtopUtils$1.msecToTime(latency)}</a>`;
      };
      const f_print_state = (key, state, row) => {
          if (state == null || state == 0) { return ""; }
          return `<a class='tag-filter' data-tag-key='${key}' data-tag-value='${state.value}' href='javascript:void(0)'>${state.title}</a>`;

      };
      let map_columns = {
          "first_seen": (first_seen, row) => {
              if (first_seen !== undefined)
                  return first_seen.time;
          },
          "DURATION": (duration, row) => {
              return NtopUtils$1.secondsToTime(duration)
          },
          "THROUGHPUT": (throughput, row) => {
              return formatterUtils.getFormatter("bps_no_scale")(throughput);
          },
          "l7proto": (proto, row) => {
              let confidence = "";
              if (proto.confidence !== undefined) {
                  const title = proto.confidence;
                  (title == "DPI") ? confidence = `<span class="badge bg-success" title="${title}">${title}</span>` : confidence = `<span class="badge bg-warning" title="${title}">${title}</span>`;
              }
              return DataTableRenders$1.filterize('l7proto', proto.value, proto.label) + " " + `${confidence}`;
          },
          "asn": (asn, row) => f_print_asn("asn", asn),
          "cli_asn": (cli_asn, row) => f_print_asn("cli_asn", cli_asn),
          "srv_asn": (srv_asn, row) => f_print_asn("srv_asn", srv_asn),
          "flow_risk": (flow_risks, row) => {
              if (flow_risks == null) { return ""; }
              let res = [];

              for (let i = 0; i < flow_risks.length; i++) {
                  const flow_risk = flow_risks[i];
                  const flow_risk_label = (flow_risk.label || flow_risk.value);
                  const flow_risk_help = (flow_risk.help);
                  res.push(`${flow_risk_label} ${flow_risk_help}`);
              }
              return res.join(', ');
          },
          "cli_nw_latency": (cli_nw_latency, row) => f_print_latency("cli_nw_latency", cli_nw_latency),
          "srv_nw_latency": (srv_nw_latency, row) => f_print_latency("srv_nw_latency", srv_nw_latency),
          "major_connection_state": (major_connection_state, row) => f_print_state("major_connection_state", major_connection_state ),
          "minor_connection_state": (minor_connection_state, row) => f_print_state("minor_connection_state", minor_connection_state ),
          "info": (info, row) => {
              if (info == null) { return ""; }
              return `<a class='tag-filter' data-tag-key='info' data-tag-value='${info.title}' title='${info.title}' href='javascript:void(0)'>${info.label}</a>`;
          },
      };
      columns = columns.filter((c) => props.context?.visible_columns[c.data_field] != false);
      if (selected_query_preset.value.is_preset && columns.length > 0) {
          // add action button that is the first button
          columns = [columns[0]].concat(props.context.columns_def);
      }

      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];

          if (c.id == "actions") {
              const visible_dict = {
                  info: props.context.actions.show_info,
                  historical_data: props.context.actions.show_historical,
                  flow_alerts: props.context.actions.show_alerts,
                  pcap_download: props.context.actions.show_pcap_download,
                  row_data: props.context.is_enterprise_xl && flows_aggregated.value,
              };
              c.button_def_array.forEach((b) => {
                  // if is not defined is enabled
                  if (visible_dict[b.id] != null && visible_dict[b.id] == false) {
                      b.class.push("link-disabled");
                  }
              });
          }
      });
      // console.log(columns);
      return columns;
  };

  const add_table_row_filter = (e, a) => {
      e.stopPropagation();

      let key = undefined;
      let realValue = undefined;
      let operator = 'eq';

      // Read tag key and value from the <a> itself if provided
      if (a.data('tagKey') != undefined) key = a.data('tagKey');
      if (a.data('tagRealvalue') != undefined) realValue = a.data('tagRealvalue');
      else if (a.data('tagValue') != undefined) realValue = a.data('tagValue');
      if (a.data('tagOperator') != undefined) operator = a.data('tagOperator');

      let filter = {
          id: key,
          value: realValue,
          operator: operator,
      };
      add_filter(filter);
  };

  function add_top_table_filter(opt, event) {
      event.stopPropagation();
      let filter = {
          id: opt.key,
          value: opt.value,
          operator: opt.operator,
      };
      add_filter(filter);
  }

  function add_filter(filter) {
      if (range_picker.value.is_filter_defined(filter)) {
          ntopng_events_manager.emit_custom_event(ntopng_custom_events$1.SHOW_MODAL_FILTERS, filter);
      } else {
          ntopng_url_manager$1.set_key_to_url("query_preset", "");
          ntopng_url_manager$1.set_key_to_url(filter.id, `${filter.value};${filter.operator}`);
          ntopng_url_manager$1.reload_url();
      }
  }

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager$1.get_url_object();
      return extra_params;
  };

  function click_navbar_item(item) {
      ntopng_url_manager$1.set_key_to_url('page', item.page_name);
      ntopng_url_manager$1.reload_url();
  }

  function get_permanent_link() {
      const $this = $(permanent_link_button.value);
      const placeholder = document.createElement('input');
      placeholder.value = location.href;
      document.body.appendChild(placeholder);
      placeholder.select();

      // copy the url to the clipboard from the placeholder
      document.execCommand("copy");
      document.body.removeChild(placeholder);
      $this.attr("title", `${_i18n('copied')}!`)
          .tooltip("dispose")
          .tooltip()
          .tooltip("show");
  }

  function show_modal_traffic_extraction() {
      modal_traffic_extraction.value.show();
  }

  function show_modal_snapshot() {
      modal_snapshot.value.show();
  }

  async function add_exclude(params) {
      params.csrf = props.context.csrf;
      let url = `${http_prefix}/lua/pro/rest/v2/add/alert/exclusion.lua`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          let url_params = ntopng_url_manager$1.get_url_params();
          setTimeout(() => {
              //todo reloadTable($table, url_params);
              ntopng_events_manager.emit_custom_event(ntopng_custom_events$1.SHOW_GLOBAL_ALERT_INFO, { text_html: _i18n('check_exclusion.disable_warn'), type: "alert-info", timeout: 2 });
          }, 1000);
      } catch (err) {
          console.error(err);
      }
  }

  function refresh_page_components(not_refresh_table) {
      let t = table_flows.value;
      let c = chart.value;
      setTimeout(() => {
          if (!not_refresh_table) {
              t.refresh_table();
          }
          c.update_chart();
      }, 1 * 1000);
  }

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_info": click_button_info,
          "click_button_flow_alerts": click_button_flow_alerts,
          "click_button_historical_flows": click_button_historical_flows,
          "click_button_pcap_download": click_button_pcap_download,
          "click_button_flows": click_button_flows,
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  function click_button_info(event) {
      const flow = event.row;
      const href = `${http_prefix}/lua/pro/db_flow_details.lua?row_id=${flow.rowid}&tstamp=${flow.tstamp}&instance_name=${flow.NTOPNG_INSTANCE_NAME}`;
      window.open(href, "_blank");
  }

  function click_button_pcap_download(event) {
      const flow = event.row;
      const epoch_interval = { epoch_begin: flow?.filter?.epoch_begin, epoch_end: flow?.filter?.epoch_end };
      modal_traffic_extraction.value.show(flow?.filter?.bpf, epoch_interval);
  }

  function click_button_historical_flows(event) {
      const flow = event.row;
      let filters_params_object = {};
      for (let key in flow) {
          let filter_key = key;
          if (flow[key].tag_key != null && flow[key].tag_key != "") {
              filter_key = flow[key].tag_key;
          }
          if (flow[key].value == null && flow[key].value != "") { continue; }
          let filter = `${flow[key].value};eq`;
          filters_params_object[filter_key] = filter;
      }
      ntopng_url_manager$1.set_key_to_url("query_preset", "");
      ntopng_url_manager$1.add_obj_to_url(filters_params_object);
      ntopng_url_manager$1.reload_url();
  }

  function click_button_flow_alerts(event) {
      const flow = event.row;
      if (flow.alerts_url) {
          ntopng_url_manager$1.go_to_url(flow.alerts_url);
      }
  }

  function click_button_flows(event) {
      const row_data = event.row;
      const epoch_begin = row_data.filter.epoch_begin;
      const epoch_end = row_data.filter.epoch_end;
      const cli_ip = row_data.flow.cli_ip.value;
      const srv_ip = row_data.flow.srv_ip.value;
      const srv_port = row_data.flow.srv_port;
      const probe_ip = row_data.probe_ip.value;
      const instance_name = row_data.NTOPNG_INSTANCE_NAME;

      const vlan_id = row_data.vlan_id.value;
      let as_vlan = vlan_id != 0;

      const output_snmp = row_data.output_snmp.value;
      let as_output_snmp = output_snmp != 0;
      const input_snmp = row_data.input_snmp.value;
      let as_input_snmp = input_snmp != 0;

      let url = `${http_prefix}/lua/pro/db_search.lua?aggregated=false&epoch_begin=${epoch_begin}&epoch_end=${epoch_end}&cli_ip=${cli_ip};eq&srv_ip=${srv_ip};eq&srv_port=${srv_port};eq&probe_ip=${probe_ip};eq&instance_name=${instance_name}`;
      if (as_vlan) {
          url = url + `&vlan_id=${vlan_id};eq`;
      }

      if (as_input_snmp) {
          url = url + `&input_snmp=${input_snmp};eq`;
      }

      if (as_output_snmp) {
          url = url + `&output_snmp=${output_snmp};eq`;
      }

      ntopng_url_manager$1.go_to_url(url);
  }

  function get_query_presets_sync_key() {
      return `${page_id}_query_presets`;
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createVNode(script$1H, {
        id: "navbar",
        main_title: __props.context.navbar.main_title,
        base_url: __props.context.navbar.base_url,
        help_link: __props.context.navbar.help_link,
        items_table: __props.context.navbar.items_table,
        onClick_item: click_navbar_item
      }, null, 8 /* PROPS */, ["main_title", "base_url", "help_link", "items_table"]),
      createBaseVNode("div", _hoisted_1$1b, [
        createBaseVNode("div", _hoisted_2$14, [
          createBaseVNode("div", _hoisted_3$12, [
            createBaseVNode("div", _hoisted_4$_, [
              createBaseVNode("div", _hoisted_5$U, [
                createBaseVNode("div", _hoisted_6$J, [
                  createVNode(script$1G, {
                    id: "alert_info",
                    global: true,
                    ref_key: "alert_info",
                    ref: alert_info
                  }, null, 512 /* NEED_PATCH */),
                  (mount_range_picker.value)
                    ? (openBlock(), createBlock(script$1B, {
                        key: 0,
                        ref_key: "range_picker",
                        ref: range_picker,
                        id: "range_picker",
                        min_time_interval_id: min_time_interval_id.value,
                        round_time: round_time.value
                      }, {
                        begin: withCtx(() => [
                          (props.context.is_enterprise_xl)
                            ? (openBlock(), createBlock(script$1y, {
                                key: 0,
                                value: flows_aggregated.value,
                                "onUpdate:value": _cache[0] || (_cache[0] = $event => ((flows_aggregated).value = $event)),
                                class: "me-2 mt-1",
                                change_label_side: true,
                                label: flow_type_label.value,
                                style: {},
                                onChange_value: change_flow_type
                              }, null, 8 /* PROPS */, ["value", "label"]))
                            : createCommentVNode("v-if", true),
                          createBaseVNode("div", _hoisted_7$G, [
                            withDirectives(createBaseVNode("select", {
                              class: "me-2 form-select",
                              style: {"min-width":"8rem"},
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((selected_query_preset).value = $event)),
                              onChange: _cache[2] || (_cache[2] = $event => (update_select_query_presets()))
                            }, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(query_presets.value, (item) => {
                                return (openBlock(), createElementBlock(Fragment, null, [
                                  (item.builtin == true)
                                    ? (openBlock(), createElementBlock("option", {
                                        key: 0,
                                        value: item
                                      }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_8$F))
                                    : createCommentVNode("v-if", true)
                                ], 64 /* STABLE_FRAGMENT */))
                              }), 256 /* UNKEYED_FRAGMENT */)),
                              (page.value != 'analysis')
                                ? (openBlock(), createElementBlock("optgroup", {
                                    key: 0,
                                    label: _i18n('queries.queries')
                                  }, [
                                    (openBlock(true), createElementBlock(Fragment, null, renderList(query_presets.value, (item) => {
                                      return (openBlock(), createElementBlock(Fragment, null, [
                                        (!item.builtin)
                                          ? (openBlock(), createElementBlock("option", {
                                              key: 0,
                                              value: item
                                            }, toDisplayString(item.name), 9 /* TEXT, PROPS */, _hoisted_10$u))
                                          : createCommentVNode("v-if", true)
                                      ], 64 /* STABLE_FRAGMENT */))
                                    }), 256 /* UNKEYED_FRAGMENT */))
                                  ], 8 /* PROPS */, _hoisted_9$x))
                                : createCommentVNode("v-if", true)
                            ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                              [vModelSelect, selected_query_preset.value]
                            ])
                          ])
                        ]),
                        extra_range_buttons: withCtx(() => [
                          (__props.context.show_permalink)
                            ? (openBlock(), createElementBlock("button", {
                                key: 0,
                                class: "btn btn-link btn-sm",
                                onClick: get_permanent_link,
                                title: _i18n('graphs.get_permanent_link'),
                                ref_key: "permanent_link_button",
                                ref: permanent_link_button
                              }, _hoisted_13$k, 8 /* PROPS */, _hoisted_11$r))
                            : createCommentVNode("v-if", true),
                          (__props.context.show_download)
                            ? (openBlock(), createElementBlock("a", {
                                key: 1,
                                class: "btn btn-link btn-sm",
                                title: _i18n('graphs.download_records'),
                                href: unref(href_download_records)
                              }, _hoisted_16$f, 8 /* PROPS */, _hoisted_14$h))
                            : createCommentVNode("v-if", true),
                          (__props.context.show_pcap_download)
                            ? (openBlock(), createElementBlock("button", {
                                key: 2,
                                class: "btn btn-link btn-sm",
                                onClick: show_modal_traffic_extraction,
                                title: _i18n('traffic_recording.pcap_download')
                              }, _hoisted_19$e, 8 /* PROPS */, _hoisted_17$e))
                            : createCommentVNode("v-if", true),
                          (__props.context.is_ntop_enterprise_m)
                            ? (openBlock(), createElementBlock("button", {
                                key: 3,
                                class: "btn btn-link btn-sm",
                                onClick: show_modal_snapshot,
                                title: _i18n('datatable.manage_snapshots')
                              }, _hoisted_22$9, 8 /* PROPS */, _hoisted_20$d))
                            : createCommentVNode("v-if", true)
                        ]),
                        _: 1 /* STABLE */
                      }, 8 /* PROPS */, ["min_time_interval_id", "round_time"]))
                    : createCommentVNode("v-if", true)
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_23$8, [
          createBaseVNode("div", _hoisted_24$8, [
            createBaseVNode("div", _hoisted_25$7, [
              createBaseVNode("div", _hoisted_26$7, [
                (__props.context.show_chart)
                  ? (openBlock(), createElementBlock("div", _hoisted_27$7, [
                      createBaseVNode("div", {
                        class: "card overflow-hidden",
                        style: normalizeStyle(unref(chart_style))
                      }, [
                        createCommentVNode(" <div class=\"card h-300 overflow-hidden\"> "),
                        createVNode(script$1F, {
                          ref_key: "chart",
                          ref: chart,
                          id: "chart_0",
                          chart_type: unref(chart_type),
                          base_url_request: unref(chart_data_url),
                          map_chart_options: f_map_chart_options,
                          register_on_status_change: false,
                          min_time_interval_id: min_time_interval_id.value,
                          round_time: round_time.value
                        }, null, 8 /* PROPS */, ["chart_type", "base_url_request", "min_time_interval_id", "round_time"])
                      ], 4 /* STYLE */)
                    ]))
                  : createCommentVNode("v-if", true),
                createVNode(script$1w, {
                  ref_key: "table_flows",
                  ref: table_flows,
                  table_id: unref(table_id),
                  table_config_id: table_config_id.value,
                  csrf: __props.context.csrf,
                  f_map_columns: map_table_def_columns,
                  get_extra_params_obj: get_extra_params_obj,
                  onLoaded: on_table_loaded,
                  onCustom_event: on_table_custom_event
                }, {
                  custom_header: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(top_table_array.value, (t, t_index) => {
                      return (openBlock(), createBlock(script$1J, {
                        f_on_open: get_open_top_table_dropdown(t, t_index),
                        ref_for: true,
                        ref: el => { top_table_dropdown_array.value[t_index] = el; }
                      }, {
                        title: withCtx(() => [
                          createVNode(script$1v, {
                            show: t.show_spinner,
                            size: "1rem",
                            class: "me-1"
                          }, null, 8 /* PROPS */, ["show"]),
                          createBaseVNode("a", {
                            class: "ntopng-truncate",
                            title: t.title
                          }, toDisplayString(t.label), 9 /* TEXT, PROPS */, _hoisted_28$5)
                        ]),
                        menu: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (opt) => {
                            return (openBlock(), createElementBlock("a", {
                              style: {"cursor":"pointer","display":"block"},
                              onClick: $event => (add_top_table_filter(opt, $event)),
                              class: "ntopng-truncate tag-filter",
                              title: opt.value
                            }, toDisplayString(opt.label), 9 /* TEXT, PROPS */, _hoisted_29$5))
                          }), 256 /* UNKEYED_FRAGMENT */))
                        ]),
                        _: 2 /* DYNAMIC */
                      }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["f_on_open"]))
                    }), 256 /* UNKEYED_FRAGMENT */)),
                    createCommentVNode(" Dropdown columns ")
                  ]),
                  _: 1 /* STABLE */
                }, 8 /* PROPS */, ["table_id", "table_config_id", "csrf"])
              ])
            ]),
            createCommentVNode(" card body "),
            (props.context.show_acknowledge_all || props.context.show_delete_all)
              ? (openBlock(), createElementBlock("div", _hoisted_30$4, [
                  (props.context.show_acknowledge_all)
                    ? (openBlock(), createElementBlock("button", _hoisted_31$4, [
                        _hoisted_32$4,
                        createTextVNode(" Acknowledge Alerts ")
                      ]))
                    : createCommentVNode("v-if", true),
                  (props.context.show_delete_all)
                    ? (openBlock(), createElementBlock("button", _hoisted_33$4, [
                        _hoisted_34$3,
                        createTextVNode(" Delete Alerts ")
                      ]))
                    : createCommentVNode("v-if", true)
                ]))
              : createCommentVNode("v-if", true),
            createCommentVNode(" card footer ")
          ]),
          createCommentVNode(" card-shadow ")
        ]),
        createCommentVNode(" div col ")
      ]),
      createCommentVNode(" div row "),
      createVNode(script$1t, {
        id: "modal_traffic_extraction",
        ref_key: "modal_traffic_extraction",
        ref: modal_traffic_extraction
      }, null, 512 /* NEED_PATCH */),
      createVNode(script$1s, {
        ref_key: "modal_snapshot",
        ref: modal_snapshot,
        csrf: __props.context.csrf
      }, null, 8 /* PROPS */, ["csrf"]),
      createVNode(script$1q, {
        ref_key: "modal_acknowledge",
        ref: modal_acknowledge,
        context: __props.context,
        onAcknowledge: refresh_page_components
      }, null, 8 /* PROPS */, ["context"]),
      createVNode(script$1p, {
        ref_key: "modal_delete",
        ref: modal_delete,
        context: __props.context,
        onDelete_alert: refresh_page_components
      }, null, 8 /* PROPS */, ["context"]),
      createVNode(script$1r, {
        alert: current_alert.value,
        page: page.value,
        onExclude: add_exclude,
        ref_key: "modal_alerts_filter",
        ref: modal_alerts_filter
      }, null, 8 /* PROPS */, ["alert", "page"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$1l.__file = "http_src/vue/page-flow-historical.vue";

  var script$1k = {
  	components: {
  	},
  	props: {
  		id: String,
  		chart_type: String,
  		register_on_status_change: Boolean,
  		base_url_request: String,
  		get_params_url_request: Function,
  		get_custom_chart_options: Function,
  		disable_pointer_events: Boolean,
  	},
  	emits: ["apply", "hidden", "showed", "chart_reloaded", "zoom"],
  	/** This method is the first method of the component called, it's called before html template creation. */
  	created() { },
  	beforeUnmount() { },
  	data() {
  		return {
  			chart: null,
  			chart_options: null,
  			from_zoom: false,
  			timeseries_visibility: null,
  			timeseries_list: [],
  			//i18n: (t) => i18n(t),
  		};
  	},
  	/** This method is the first method called after html template creation. */
  	async mounted() {
  		await this.init();
  		ntopng_sync.ready(this.$props["id"]);
  	},
  	methods: {
  		init: async function () {
  			let status = ntopng_status_manager.get_status();
  			let url_request = this.get_url_request(status);
  			if (this.register_on_status_change) {
  				this.register_status(status);
  			}
  			await this.draw_chart(url_request);
  		},
  		get_image: function (image) {
  			return Dygraph.Export.asPNG(this.chart, image, this.$refs["chart"]);
  		},
  		change_visibility: function (visible, id) {
  			if (this.timeseries_list[id] != null) {
  				this.timeseries_list[id]["checked"] = visible;
  				this.chart.setVisibility(id, visible);
  			}
  		},
  		register_status: function (status) {
  			let url_request = this.get_url_request(status);
  			ntopng_status_manager.on_status_change(this.id, (new_status) => {
  				if (this.from_zoom == true) {
  					this.from_zoom = false;
  					//return;
  				}
  				let new_url_request = this.get_url_request(new_status);
  				if (new_url_request == url_request) {
  					url_request = new_url_request;
  					return;
  				}
  				url_request = new_url_request;
  				this.update_chart(new_url_request);
  			}, false);
  		},
  		get_url_request: function (status) {
  			let url_params;
  			if (this.$props.get_params_url_request != null) {
  				if (status == null) {
  					status = ntopng_status_manager.get_status();
  				}
  				url_params = this.$props.get_params_url_request(status);
  			} else {
  				url_params = ntopng_url_manager.get_url_params();
  			}

  			return `${this.$props.base_url_request || ''}?${url_params}`;
  		},
  		get_chart_options: async function (url_request) {
  			let chart_options = null;
  			const date_format = await ntopng_utility.get_date_format(false, this.$props.csrf, http_prefix);

  			/* Retrieve the chart options */
  			if (this.$props.get_custom_chart_options == null) {
  				chart_options = await ntopng_utility.http_request(url_request);
  			} else {
  				chart_options = await this.$props.get_custom_chart_options(url_request);
  			}
  			/* Set the date depending on the server date */
  			if (!chart_options?.axes?.x?.axisLabelFormatter) {
  				chart_options.axes.x.axisLabelFormatter = function (date) {
  					return ntopng_utility.from_utc_to_server_date_format(date, date_format);
  				};
  			}
  			if (!chart_options?.axes.x?.valueFormatter) {
  				chart_options.axes.x.valueFormatter = function (date) {
  					return ntopng_utility.from_utc_to_server_date_format(date, date_format);
  				};
  			}
  			/* Emit the chart_reloaded event */
  			this.$emit('chart_reloaded', chart_options);
  			return chart_options;
  		},
  		draw_chart: async function (url_request) {
  			let chart_options = await this.get_chart_options(url_request);
  			const data = chart_options.data || [];
  			chart_options.data = null;
  			chart_options.zoomCallback = this.on_zoomed;
  			this.timeseries_list = [];
  			let id = 0;
  			if (!chart_options.disableTsList) {
  				for (const key in chart_options.series) {
  					this.timeseries_list.push({ name: key, checked: true, id: id, color: chart_options.colors[id] + "!important" });
  					id = id + 1;
  				}
  			}
  			this.chart = new Dygraph(this.$refs["chart"], data, chart_options);
  		},
  		update_chart: async function (url_request) {
  			if (this.chart) {
  				let chart_options = await this.get_chart_options(url_request);
  				this.chart.updateChart(chart_options);
  			}
  		},
  		update_chart_options: function (chart_options) {
  			if (this.chart) {
  				this.chart.updateChart(chart_options);
  			}
  		},
  		update_chart_series: function (series) {
  			if (series == null) { return; }
  			if (this.chart) {
  				this.chart.updateOptions({ 'file': series });
  			}
  		},
  		on_zoomed: function (minDate, maxDate) {
  			this.from_zoom = true;
  			const begin = moment(minDate);
  			const end = moment(maxDate);
  			// the timestamps are in milliseconds, convert them into seconds
  			let new_epoch_status = { epoch_begin: Number.parseInt(begin.unix()), epoch_end: Number.parseInt(end.unix()) };
  			ntopng_events_manager.emit_event(ntopng_events.EPOCH_CHANGE, new_epoch_status, this.id);
  			this.$emit('zoom', new_epoch_status);
  		},
  	},
  };

  const _hoisted_1$1a = {
    style: {"width":"100% height:380px"},
    class: "text-end mb-2"
  };
  const _hoisted_2$13 = { class: "form-check-label form-control-sm" };
  const _hoisted_3$11 = ["onClick", "checked"];
  const _hoisted_4$Z = {
    key: 0,
    class: "mb-3",
    style: {"width":"100%","pointer-events":"none"},
    ref: "chart"
  };
  const _hoisted_5$T = {
    key: 1,
    class: "mb-3",
    style: {"width":"100%"},
    ref: "chart"
  };

  function render$b(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$1a, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.timeseries_list, (item, i) => {
          return (openBlock(), createElementBlock("label", _hoisted_2$13, [
            createBaseVNode("input", {
              type: "checkbox",
              class: "form-check-input align-middle mt-0",
              onClick: $event => ($options.change_visibility(!item.checked, i)),
              checked: item.checked,
              style: normalizeStyle([{"border-color":"#0d6efd"}, { backgroundColor: item.color }])
            }, null, 12 /* STYLE, PROPS */, _hoisted_3$11),
            createTextVNode(" " + toDisplayString(item.name), 1 /* TEXT */)
          ]))
        }), 256 /* UNKEYED_FRAGMENT */))
      ]),
      ($props.disable_pointer_events == true)
        ? (openBlock(), createElementBlock("div", _hoisted_4$Z, null, 512 /* NEED_PATCH */))
        : (openBlock(), createElementBlock("div", _hoisted_5$T, null, 512 /* NEED_PATCH */))
    ], 64 /* STABLE_FRAGMENT */))
  }

  var css_248z$h = "\n.dygraph-legend {\n\tcolor: #111111;\n\tbackground-color: #FFFFFF !important;\n\tborder-color: #a7a6a6;\n\tborder-style: solid;\n\tborder-width: thin;\n\tz-index: 80 !important;\n\tbox-shadow: 0 0.5rem 1rem rgba(0, 0, 0, .15);\n\tborder-radius: 0.375rem;\n\tposition: fixed;\n\twidth: auto;\n\tword-wrap: break-word;\n\tpadding: 8px !important;\n}\n.dygraph-legend>span {\n\tcolor: #111111;\n\tpadding-left: 5px;\n\tpadding-right: 2px;\n\tmargin-left: -5px;\n\tbackground-color: #FFFFFF !important;\n}\n.dygraph-legend>span:first-child {\n\tmargin-top: 2px;\n}\n";
  styleInject(css_248z$h);

  script$1k.render = render$b;
  script$1k.__file = "http_src/vue/timeseries-chart.vue";

  const _withScopeId$5 = n => (pushScopeId("data-v-185590b6"),n=n(),popScopeId(),n);
  const _hoisted_1$19 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$12 = { class: "col-11" };
  const _hoisted_3$10 = { class: "col-form-label" };
  const _hoisted_4$Y = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    class: "btn border"
  }, [
    /*#__PURE__*/createBaseVNode("span", null, [
      /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" })
    ])
  ], -1 /* HOISTED */));
  const _hoisted_5$S = [
    _hoisted_4$Y
  ];
  const _hoisted_6$I = { class: "container" };
  const _hoisted_7$F = { class: "row custom-ms me-2 mt-1" };
  const _hoisted_8$E = { class: "col-5" };
  const _hoisted_9$w = ["onUpdate:modelValue"];
  const _hoisted_10$t = { class: "custom-control-label ms-1 form-check-label" };
  const _hoisted_11$q = { class: "col-2" };
  const _hoisted_12$p = ["onUpdate:modelValue"];
  const _hoisted_13$j = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "Past ", -1 /* HOISTED */));
  const _hoisted_14$g = { class: "col-2" };
  const _hoisted_15$e = ["onUpdate:modelValue"];
  const _hoisted_16$e = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "Avg ", -1 /* HOISTED */));
  const _hoisted_17$d = { class: "col-3" };
  const _hoisted_18$d = ["onUpdate:modelValue"];
  const _hoisted_19$d = /*#__PURE__*/ _withScopeId$5(() => /*#__PURE__*/createBaseVNode("label", { class: "custom-control-label ms-1 form-check-label" }, "95th Perc ", -1 /* HOISTED */));


  var script$1j = {
    __name: 'list-timeseries',
    props: {
      id: String,
      timeseries: Array,
      title: String,
      show_delete_button: Boolean,
  },
    emits: ['delete_ts', 'update:timeseries'],
    setup(__props, { emit }) {

  const props = __props;





  function update_timeseries() {
      emit('update:timeseries', props.timeseries);
  }

  function delete_ts() {
      emit('delete_ts', props.id);
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", null, [
      createBaseVNode("div", _hoisted_1$19, [
        createBaseVNode("div", _hoisted_2$12, [
          createBaseVNode("label", _hoisted_3$10, [
            createBaseVNode("b", null, toDisplayString(__props.title), 1 /* TEXT */)
          ])
        ]),
        (__props.show_delete_button)
          ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "col-1",
              onClick: delete_ts
            }, _hoisted_5$S))
          : createCommentVNode("v-if", true)
      ]),
      createBaseVNode("div", _hoisted_6$I, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.timeseries, (item) => {
          return (openBlock(), createElementBlock("div", _hoisted_7$F, [
            createBaseVNode("div", _hoisted_8$E, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                class: "custom-control-input whitespace form-check-input",
                onChange: update_timeseries,
                "onUpdate:modelValue": $event => ((item.raw) = $event)
              }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_9$w), [
                [vModelCheckbox, item.raw]
              ]),
              createBaseVNode("label", _hoisted_10$t, toDisplayString(item.label), 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_11$q, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                class: "custom-control-input whitespace form-check-input",
                onChange: update_timeseries,
                "onUpdate:modelValue": $event => ((item.past) = $event)
              }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_12$p), [
                [vModelCheckbox, item.past]
              ]),
              _hoisted_13$j
            ]),
            createBaseVNode("div", _hoisted_14$g, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                class: "custom-control-input whitespace form-check-input",
                onChange: update_timeseries,
                "onUpdate:modelValue": $event => ((item.avg) = $event)
              }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_15$e), [
                [vModelCheckbox, item.avg]
              ]),
              _hoisted_16$e
            ]),
            createBaseVNode("div", _hoisted_17$d, [
              withDirectives(createBaseVNode("input", {
                type: "checkbox",
                class: "custom-control-input whitespace form-check-input",
                onChange: update_timeseries,
                "onUpdate:modelValue": $event => ((item.perc_95) = $event)
              }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_18$d), [
                [vModelCheckbox, item.perc_95]
              ]),
              _hoisted_19$d
            ])
          ]))
        }), 256 /* UNKEYED_FRAGMENT */))
      ])
    ]))
  }
  }

  };

  var css_248z$g = "\n.custom-ms[data-v-185590b6] {\n  margin-left: 2rem !important;\n}\n.inline-block[data-v-185590b6] {\n    display: inline-block;\n    margin-right: 1rem;\n}\n.border[data-v-185590b6] {\n    border-style: solid !important;\n}\n";
  styleInject(css_248z$g);

  script$1j.__scopeId = "data-v-185590b6";
  script$1j.__file = "http_src/vue/list-timeseries.vue";

  const bytesToSizeFormatter$2 = formatterUtils.getFormatter(formatterUtils.types.bytes.id);
  const handlerIdAddLink$2 = "page-stats-action-link";
  const handlerIdJumpHistorical = "page-stats-action-jump-historical";

  const top_application$1 = {
      table_value: "interface",
      title: i18n('page_stats.top.top_applications'),
      view: "top_protocols",
      default_sorting_columns: 1,
      default: true,
      columnDefs: [
        { type: "file-size", targets: 1 },
      ],
      columns: [{
  	    columnName: i18n("application"), name: 'application', data: 'protocol', handlerId: handlerIdAddLink$2,
  	    render: function(data, type, service) {
  		let context = this;
  		let handler = {
  		    handlerId: handlerIdAddLink$2,
  		    onClick: function() {
  			// console.log(data);
  			// console.log(service);
  			let schema = `top:${service.ts_schema}`;
  			context.add_metric_from_metric_schema(schema, service.ts_query);
  		    },
  		};
  		return DataTableUtils$1.createLinkCallback({ text: data.label, handler });
  	    },
  	}, {
  	    columnName: i18n("traffic"), name: 'traffic', className: 'text-end', data: 'traffic', orderable: true,
  	    render: (data) => {
  	    	//return bytesToSizeFormatter(data);
  	    	return NtopUtils$1.bytesToSize(data)
  	    },
  	}, {
  	    columnName: i18n("percentage"), name: 'traffic_perc', className: 'text-center', data: 'percentage', orderable: false,
  	    render: (data) => {
  		const percentage = data.toFixed(1);
  		return NtopUtils$1.createProgressBar(percentage)
  	    }
  	}, {
  	    columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId: handlerIdJumpHistorical,
  	    render_if: function(context) { return context.is_history_enabled },
  	    render: function(data, type, service) {
  		let context = this;
  		const jump_to_historical = {
  		    handlerId: handlerIdJumpHistorical,
  		    onClick: function() {
  			let l7_proto = ntopng_url_manager$1.serialize_param("l7proto", `${service.protocol.id};eq`);
  			let historical_flows_url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}&${l7_proto}`;
  			let source_type = context.source_type;
  			let source_array = context.source_array;
  			
  			let params = "";
  			let params_array = source_type.source_def_array.map((source_def, i) => {
  			    let source = source_array[i];
  			    if (source_def.value == "ifid") {
  				return ntopng_url_manager$1.serialize_param("ifid", source.value);
  			    } else if (source_def.value == "host") {
  				return ntopng_url_manager$1.serialize_param("ip", `${source.value};eq`);
  			    }
  			});
  			params = params_array.join("&");
  			historical_flows_url = `${historical_flows_url}&${params}`;
  			// console.log(historical_flows_url);
  			window.open(historical_flows_url);
  		    }
  		};
  		return DataTableUtils$1.createActionButtons([
  		    { class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical },
  		]);
  	    }
  	},],
  };

  const top_categories = {
      table_value: "interface",
      title: i18n('page_stats.top.top_categories'),
      view: "top_categories",
      default_sorting_columns: 2,
      columnDefs: [
        { type: "file-size", targets: 1 },
      ],
      columns: [{
  	    columnName: i18n("category"), name: 'category', data: 'category', handlerId: handlerIdAddLink$2,
  	    render: function(data, type, service) {
  		let context = this;
  		let handler = {
  		    handlerId: handlerIdAddLink$2,
  		    onClick: function() {
  			// console.log(data);
  			// console.log(service);
  			let schema = `top:${service.ts_schema}`;
  			context.add_metric_from_metric_schema(schema, service.ts_query);
  		    },
  		};
  		return DataTableUtils$1.createLinkCallback({ text: data.label, handler });
  	    },
  	}, {
  	    columnName: i18n("traffic"), name: 'traffic', className: 'text-end', data: 'traffic', orderable: true,
  	    render: (data) => {
  	    	return bytesToSizeFormatter$2(data);
  	    	//return NtopUtils.bytesToSize(data)
  	    },
  	}, {
  	    columnName: i18n("percentage"), name: 'traffic_perc', className: 'text-center', data: 'percentage',
  	    render: (data) => {
  		const percentage = data.toFixed(1);
  		return NtopUtils$1.createProgressBar(percentage)
  	    }
  	}, {
  	    columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId: handlerIdJumpHistorical,
  	    render_if: function(context) { return context.is_history_enabled },
  	    render: function(data, type, service) {
  		let context = this;
  		const jump_to_historical = {
  		    handlerId: handlerIdJumpHistorical,
  		    onClick: function() {
  			let category = ntopng_url_manager$1.serialize_param("l7cat", `${service.category.id};eq`);
  			let historical_flows_url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}&${category}`;
  			let source_type = context.source_type;
  			let source_array = context.source_array;
  			
  			let params = "";
  			let params_array = source_type.source_def_array.map((source_def, i) => {
  			    let source = source_array[i];
  			    if (source_def.value == "ifid") {
  				return ntopng_url_manager$1.serialize_param("ifid", source.value);
  			    } else if (source_def.value == "host") {
  				return ntopng_url_manager$1.serialize_param("ip", `${source.value};eq`);
  			    }
  			});
  			params = params_array.join("&");
  			historical_flows_url = `${historical_flows_url}&${params}`;
  			// console.log(historical_flows_url);
  			window.open(historical_flows_url);
  		    }
  		};
  		return DataTableUtils$1.createActionButtons([
  		    { class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical },
  		]);
  	    }
  	},],
  };

  const top_senders = {
      table_value: "interface",
      title: i18n('page_stats.top.top_senders'),
      view: "top_senders",
      default_sorting_columns: 1,
      columnDefs: [
        { type: "file-size", targets: 1 },
      ],
      columns: [{
  	columnName: i18n("page_stats.top.host_name"), name: 'host_name', data: 'host', handlerId: handlerIdAddLink$2,
  	render: function(data, type, service) {
  	    let context = this;
        let label = data.label;
        let host_ref = '';
  	    let handler = {
  		handlerId: handlerIdAddLink$2,
  		onClick: async function() {
  		    // console.log(data);
  		    // console.log(service);
  		    let schema = `host:traffic`;
  		    context.add_ts_group_from_source_value_dict("host", service.tags, schema);
  		},
  	    };
  	    if (context.sources_types_enabled["host"] && data.is_local) {
          label = DataTableUtils$1.createLinkCallback({ text: data.label, handler });
  	    }
        if (data.is_available) {
          host_ref = ` <a href="/lua/host_details.lua?host=${data.id}" data-bs-toggle="tooltip" title=""><i class="fas fa-laptop"></i></a>`;
        }
        
  	    return `${label}${host_ref}`;
  	},
      }, {
  	columnName: i18n("page_stats.top.sent"), name: 'sent', className: 'text-end', data: 'traffic', orderable: true,
  	render: (data) => {
  	    return bytesToSizeFormatter$2(data);
  	    //return NtopUtils.bytesToSize(data)
  	},
      }, // {
  	      // 	columnName: i18n("percentage"), name: 'traffic_perc', data: 'percentage',
  	      // 	render: (data) => {
  	      // 	    const percentage = data.toFixed(1);
  	      // 	    return NtopUtils.createProgressBar(percentage)
  	      // 	}
  	      // },
  	      {
  		  columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId: handlerIdJumpHistorical,
  		  render_if: function(context) { return context.is_history_enabled },
  		  render: function(data, type, service) {
  		      let context = this;
            const host = service.host.id;
            const host_ts_available= service.host.is_local;
  		      const jump_to_historical = {
              handlerId: handlerIdJumpHistorical,
              onClick: function() {
                  let historical_flows_url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}`;
                  
                  let params = "";			    
                  let params_array = [];
                  for (let key in service.tags) {
                let value = service.tags[key];
                let p_url = "";
                if (key == "ifid") {
                    p_url = ntopng_url_manager$1.serialize_param(key, value);
                } else if (key == "host") {
                    p_url = ntopng_url_manager$1.serialize_param("ip", `${value};eq`);
                }
                params_array.push(p_url);
                  }
                  params = params_array.join("&");
                  historical_flows_url = `${historical_flows_url}&${params}`;
                  // console.log(historical_flows_url);
                  window.open(historical_flows_url);
              }
            };
                
            const jump_to_host = {
              handlerId: handlerIdJumpHistorical,
              onClick: function() {
                  const ifid = ntopng_url_manager$1.get_url_entry('ifid');
                  const host_url = `${http_prefix}/lua/host_details.lua?host=${host}&page=historical&ts_query=ifid:${ifid},host:${host}&ts_schema=host:details&epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}`;
                  
                  window.open(host_url);
              }
            };

            const dropdown = [{ class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical }];
  	        if (context.sources_types_enabled["host"] && host_ts_available) {
              dropdown.push({ class: 'dropdown-item', href: '#', title: i18n('db_explorer.host_data'), handler: jump_to_host });
            }

  		      return DataTableUtils$1.createActionButtons(dropdown);
  		  }
  	      },],
  };

  const top_receivers = {
      table_value: "interface",
      title: i18n('page_stats.top.top_receivers'),
      view: "top_receivers",
      default_sorting_columns: 1,
      columnDefs: [
        { type: "file-size", targets: 1 },
      ],
      columns: [{
  	columnName: i18n("page_stats.top.host_name"), name: 'host_name', data: 'host', handlerId: handlerIdAddLink$2,
  	render: function(data, type, service) {
  	    let context = this;
        let label = data.label;
        let host_ref = '';
  	    let handler = {
  		handlerId: handlerIdAddLink$2,
  		onClick: async function() {
  		    // console.log(data);
  		    // console.log(service);
  		    let schema = `host:traffic`;
  		    context.add_ts_group_from_source_value_dict("host", service.tags, schema);
  		},
  	    };
  	    if (context.sources_types_enabled["host"] && data.is_local) {
          label = DataTableUtils$1.createLinkCallback({ text: data.label, handler });
  	    }
        if (data.is_available) {
          host_ref = ` <a href="/lua/host_details.lua?host=${data.id}" data-bs-toggle="tooltip" title=""><i class="fas fa-laptop"></i></a>`;
        }
        
  	    return `${label}${host_ref}`;
  	},
      }, {
  	columnName: i18n("page_stats.top.received"), name: 'received', className: 'text-end', data: 'traffic', orderable: true,
  	render: (data) => {
  	    return bytesToSizeFormatter$2(data);
  	    //return NtopUtils.bytesToSize(data)
  	},
      }, // {
  	      // 	columnName: i18n("percentage"), name: 'traffic_perc', data: 'percentage',
  	      // 	render: (data) => {
  	      // 	    const percentage = data.toFixed(1);
  	      // 	    return NtopUtils.createProgressBar(percentage)
  	      // 	}
  	      // },
  	      {
  		  columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId: handlerIdJumpHistorical,
  		  render_if: function(context) { return context.is_history_enabled },
  		  render: function(data, type, service) {
  		      let context = this;
            const host = service.host.id;
            const host_ts_available= service.host.is_local;
  		      const jump_to_historical = {
  			  handlerId: handlerIdJumpHistorical,
  			  onClick: function() {
  			      let historical_flows_url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}`;
  			      
  			      let params = "";
  			      let params_array = [];
  			      for (let key in service.tags) {
  				  let value = service.tags[key];
  				  let p_url = "";
  				  if (key == "ifid") {
  				      p_url = ntopng_url_manager$1.serialize_param(key, value);
  				  } else if (key == "host") {
  				      p_url = ntopng_url_manager$1.serialize_param("ip", `${value};eq`);
  				  }
  				  params_array.push(p_url);
  			      }
  			      params = params_array.join("&");
  			      historical_flows_url = `${historical_flows_url}&${params}`;
  			      // console.log(historical_flows_url);
  			      window.open(historical_flows_url);
  			  }
  		      };
                
            const jump_to_host = {
              handlerId: handlerIdJumpHistorical,
              onClick: function() {
                  const ifid = ntopng_url_manager$1.get_url_entry('ifid');
                  const host_url = `${http_prefix}/lua/host_details.lua?host=${host}&page=historical&ts_query=ifid:${ifid},host:${host}&ts_schema=host:details&epoch_begin=${context.status.epoch_begin}&epoch_end=${context.status.epoch_end}`;
                  
                  window.open(host_url);
              }
            };

            const dropdown = [{ class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical }];
  	        if (context.sources_types_enabled["host"] && host_ts_available) {
              dropdown.push({ class: 'dropdown-item', href: '#', title: i18n('db_explorer.host_data'), handler: jump_to_host });
            }

  		      return DataTableUtils$1.createActionButtons(dropdown);
  		  },
  	      },],
  };

  const interface_top_tables = [top_application$1, top_categories, top_senders, top_receivers];

  let top_application_interface = interface_top_tables.find((t) => t.view == "top_protocols");
  if (top_application_interface != null) {
      top_application_interface = ntopng_utility$1.clone(top_application_interface);
      top_application_interface.table_value = "host";
  }

  const top_application = top_application_interface;

  const host_top_tables = [top_application];

  const bytesToSizeFormatter$1 = formatterUtils.getFormatter(formatterUtils.types.bytes.id);
  const bpsFormatter$1 = formatterUtils.getFormatter(formatterUtils.types.bps.id);
  const handlerIdAddLink$1 = "page-stats-action-link";

  const top_snmp_interface = {
  	table_value: "snmp",
  	table_source_def_value_dict: { ifid: true, device: true, if_index: false },
  	title: i18n('page_stats.top.top_interfaces'),
  	view: "top_snmp_ifaces",
  	default_sorting_columns: 4,
  	columnDefs: [
  		{ type: "file-size", targets: 1 },
  		{ type: "file-size", targets: 2 },
  		{ type: "file-size", targets: 3 },
  	],
  	f_get_label: (ts_group) => {
  		let source_def_array = ts_group.source_type.source_def_array;
  		let source_label;
  		for (let i = 0; i < source_def_array.length; i += 1) {
  			if (source_def_array[i].value != "device") { continue; }
  			source_label = ts_group.source_array[i].label;
  			break;
  		}
  		return `${i18n('page_stats.top.top_interfaces')} - SNMP ${i18n('page_stats.source_def.device')} ${source_label}`;
  	},
  	default: true,

  	columns: [{
  		columnName: i18n("interface_name"), name: 'interface', data: 'interface', handlerId: handlerIdAddLink$1,
  		render: function (data, type, service) {
  			let context = this;
  			let handler = {
  				handlerId: handlerIdAddLink$1,
  				onClick: function () {
  					let schema = `snmp_if:traffic`;
  					context.add_ts_group_from_source_value_dict("snmp_interface", service.tags, schema);
  				},
  			};
  			let label_text = `${data.name}`;
  			return DataTableUtils$1.createLinkCallback({ text: label_text, handler });
  		},
  	}, {
  		columnName: i18n("interface_alias"), name: 'interface', data: 'interface', handlerId: handlerIdAddLink$1,
  		render: function (data) {
  			let label_text = `${data.alias}`;
  			return label_text;
  		},
  	}, {
  		columnName: i18n("page_stats.top.sent"), name: 'sent', className: 'text-end', data: 'sent', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter$1(data);
  			//return NtopUtils.bytesToSize(data)
  		},
  	}, {
  		columnName: i18n("page_stats.top.received"), name: 'received', className: 'text-end', data: 'rcvd', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter$1(data);
  			//return NtopUtils.bytesToSize(data)
  		},
  	}, {
  		columnName: i18n("traffic"), name: 'traffic', className: 'text-end', data: 'total', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter$1(data);
  			//return NtopUtils.bytesToSize(data)
  		},
  	}, {
  		columnName: i18n("last_downlink_usage"), name: 'traffic_perc', className: 'text-center no-wrap', data: 'downlink_usage_percentage',
  		render: (data) => {
  			let percentage = data.toFixed(1);
  			if (percentage > 100) percentage = 100;
  			return NtopUtils$1.createProgressBar(percentage)
  		}
  	}, {
  		columnName: i18n("last_uplink_usage"), name: 'traffic_perc', className: 'text-center no-wrap', data: 'uplink_usage_percentage',
  		render: (data) => {
  			let percentage = data.toFixed(1);
  			if (percentage > 100) percentage = 100;
  			return NtopUtils$1.createProgressBar(percentage)
  		}
  	}, {
  		columnName: i18n("page_stats.top.throughput"), name: 'throughput', className: 'text-end', data: 'throughput', orderable: true,
  		render: (data) => {
  			return bpsFormatter$1(data);
  			//return NtopUtils.bytesToSize(data)
  		},
  	},],
  };

  const snmp_interface_top_tables = [top_snmp_interface];

  const bytesToSizeFormatter = formatterUtils.getFormatter(formatterUtils.types.bytes.id);
  const bpsFormatter = formatterUtils.getFormatter(formatterUtils.types.bps.id);
  const handlerIdAddLink = "page-stats-action-link";

  const top_flow_interface = {
  	table_value: "flowdevice",
  	table_source_def_value_dict: { ifid: true, device: true, if_index: false },
  	title: i18n('page_stats.top.top_interfaces'),
  	view: "top_flowdev_ifaces",
  	default_sorting_columns: 4,
  	columnDefs: [
  		{ type: "file-size", targets: 1 },
  		{ type: "file-size", targets: 2 },
  		{ type: "file-size", targets: 3 },
  	],
  	f_get_label: (ts_group) => {
  		let source_def_array = ts_group.source_type.source_def_array;
  		let source_label;
  		for (let i = 0; i < source_def_array.length; i += 1) {
  			if (source_def_array[i].value != "device") { continue; }
  			source_label = ts_group.source_array[i].label;
  			break;
  		}
  		return `${i18n('page_stats.top.top_interfaces')} - Flow Exporter ${source_label}`;
  	},
  	default: true,

  	columns: [{
  		columnName: i18n("interface_name"), name: 'interface', data: 'interface', handlerId: handlerIdAddLink,
  		render: function (data, type, service) {
  			let context = this;
  			let handler = {
  				handlerId: handlerIdAddLink,
  				onClick: function () {
  					let schema = `flowdev_port:traffic`;
  					context.add_ts_group_from_source_value_dict("flow_interface", service.tags, schema);
  				},
  			};
  			let label_text = `${data.label}`;
  			return DataTableUtils$1.createLinkCallback({ text: label_text, handler });
  		},
  	},  {
  		columnName: i18n("page_stats.top.sent"), name: 'sent', className: 'text-end', data: 'sent', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter(data);
  		},
  	}, {
  		columnName: i18n("page_stats.top.received"), name: 'received', className: 'text-end', data: 'rcvd', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter(data);
  		},
  	}, {
  		columnName: i18n("traffic"), name: 'traffic', className: 'text-end', data: 'total', orderable: true,
  		render: (data) => {
  			return bytesToSizeFormatter(data);
  		},
  	}, {
  		columnName: i18n("percentage"), name: 'traffic_perc', className: 'text-center', data: 'percentage',
  		render: (data) => {
  			const percentage = data.toFixed(1);
  			return NtopUtils$1.createProgressBar(percentage)
  		}
  	}, {
  		columnName: i18n("page_stats.top.throughput"), name: 'throughput', className: 'text-end', data: 'throughput', orderable: true,
  		render: (data) => {
  			return bpsFormatter(data);
  		},
  	},],
  };

  const flow_dev_top_tables = [top_flow_interface];

  const available_interfaces = async (host) => {
      const params = {
          host: host
      };
      const url_params = ntopng_url_manager$1.obj_to_url_params(params);
      const snmp_device_port_url = `${http_prefix}/lua/pro/rest/v2/get/snmp/device/available_interfaces.lua?${url_params}`;
      const interfaces_list = await ntopng_utility$1.http_request(snmp_device_port_url);
      return interfaces_list;
  };

  const snmp_device_ports = async (host) => {
      let interfaces = await available_interfaces(host);
      let result_interfaces = interfaces.map((iface) => {
          if(iface.name != null && iface.name != "" && iface.name != iface.id) {
              return { label: `${iface.name} (${iface.id})`, id: iface.id, name: iface.name };
          }
          return { label: iface.id, id: iface.id,  name: iface.id };
      });

      return result_interfaces.sort(NtopUtils$1.sortAlphabetically)
  };

  const proxy_snmp = function () {
      return {
          available_interfaces,
          snmp_device_ports,
      };
  }();

  const ui_types$1 = {
  	hide: "hide",
  	select: "select",
  	input: "input",
  	input: "input_confirm",
  };

  const sources_url_el_to_source$1 = {
      ifid: (s) => {
  	let label = s.ifname;
  	if (s.name != null) {
  	    label = s.name;
  	}
  	return {
  	    label,
  	    value: s.ifid,
  	};
      },
      pool: (p) => {
  	let label = p.pool_id;
  	if (p.name != null) { label = p.name; }
  	return {
  	    label,
  	    value: p.pool_id,
  	};
      },
      am_host: (am) => {
  	let label = `${am.label} ${am.measurement}`;
  	let value = `${am.host},metric:${am.measurement_key}`;
  	return {
  	    label,
  	    value,
  	};
      },
      blacklist: (b) => {
          let label = `${b.column_name}`;
          let value = label;
          return {
              label,
              value,
          };
      },
      device: (device) => {
  	let label = `${device.name}`;
  	let value = `${device.ip}`;
  	return {
  	    label,
  	    value,
  	};
      },
      if_index: (index) => {
  	return '';
  	/*	let label = `${index.name}`;
  		let value = `${index.ip}`;
  		return {
  		label,
  		value,
  		};*/
      }
  };

  const sources_types_tables$1 = {
  	interface: interface_top_tables,
  	host: host_top_tables,
  	snmp_interface: snmp_interface_top_tables,
  	snmp_device: snmp_interface_top_tables,
  	flow_device: flow_dev_top_tables,
  	flow_interface: flow_dev_top_tables,
  };

  const sources_types$1 = [
  	{
  	    id: "interface", //unique id
  	    regex_page_url: "lua\/if_stats", // regex to match url page
  	    label: i18n("page_stats.source_def.interface"),
  	    query: "iface",
              f_map_ts_options: null, // convert rest result
  	    source_def_array: [{
  		main_source_def: true,
  		label: i18n("page_stats.source_def.interface"),
  		regex_type: null,
                  refresh_on_sources_change: false, // if true sources list are realoaded every time some selected sources changed 
  		sources_url: "lua/rest/v2/get/ntopng/interfaces.lua", // url to get sources list
  		sources_function: null, // custom function that return sources_list, overwrite sources_url
  		value: "ifid", // used in tsQuery parameter, to get init and set value in url
  		value_url: null, // overwrite value to get and set value in url
  		value_map_sources_res: null,
  		disable_tskey: null,
  		f_get_value_url: null, // overwrite value and value_url to get start value from url
  		f_set_value_url: null, // overwrite value and value_url to set start value in url
  		ui_type: ui_types$1.select,
  	    }],
  	},
  	{
  	    id: "blacklist", //unique id
  	    regex_page_url: "lua\/blacklists_stats", // regex to match url page
  	    label: i18n("page_stats.source_def.blacklist"),
  	    query: "blacklist",
              f_map_ts_options: (ts_options, ts_group) => {
                  if (ts_options.series == null) {                    
                      return ts_options;
                  }
                  ts_options.series.forEach((s) => {
                      if (ts_group.metric.query != null) {
                          s.name = ts_group.metric.label;
                      } else {
                          s.name = s.name.replaceAll("_", " ");
                          s.type = undefined;
                      }
                  });
                  return ts_options;
              },
              // display_full_name: true,
  	    source_def_array: [{
  		label: i18n("page_stats.source_def.interface"),
  		sources_function: () => { return [{ label: "System", value: -1 }] },
  		value: "ifid",
  		ui_type: ui_types$1.hide,
  	    },]
  	},
  	{
  		id: "vulnerability_scan", //unique id
  		regex_page_url: "lua\/vulnerability_scan", // regex to match url page
  		label: i18n("page_stats.source_def.vuln_scan"),
  		query: "am_vuln_scan",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "System", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}]
  		
  	},
  	{
  		id: "host",
  		regex_page_url: "lua\/host_details",
  		label: i18n("page_stats.source_def.host"),
  		table_value: "host",
  		query: "host",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.host"),
  			regex_type: "ip",
  			value: "host",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "mac",
  		regex_page_url: "lua\/mac_details",
  		label: i18n("page_stats.source_def.mac"),
  		query: "mac",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.mac"),
  			regex_type: "macAddress",
  			value: "mac",
  			value_url: "host",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "network",
  		regex_page_url: "lua\/network_details",
  		label: i18n("page_stats.source_def.network"),
  		query: "subnet",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.network"),
  			regex_type: "text",
  			value: "subnet",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "as",
  		regex_page_url: "lua\/as_details",
  		label: i18n("page_stats.source_def.as"),
  		query: "asn",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.as"),
  			regex_type: "text",
  			value: "asn",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "country",
  		regex_page_url: "lua\/country_details",
  		label: i18n("page_stats.source_def.country"),
  		query: "country",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.country"),
  			regex_type: "text",
  			value: "country",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "os",
  		regex_page_url: "lua\/os_details",
  		label: i18n("page_stats.source_def.os"),
  		query: "os",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.os"),
  			regex_type: "text",
  			value: "os",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "vlan",
  		regex_page_url: "lua\/vlan_details",
  		label: i18n("page_stats.source_def.vlan"),
  		query: "vlan",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.vlan"),
  			regex_type: "text",
  			value: "vlan",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "pool",
  		regex_page_url: "lua\/pool_details",
  		label: i18n("page_stats.source_def.pool"),
  		query: "host_pool",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.pool"),
  			sources_url: "lua/rest/v2/get/host/pools.lua",
  			value: "pool",
  			ui_type: ui_types$1.select,
  		}],
  	},
  	{
  		id: "system",
  		regex_page_url: "lua\/system_stats",
  		label: i18n("page_stats.source_def.system"),
  		query: "system",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "System", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}],
  	},
  	{
  		id: "profile",
  		regex_page_url: "lua\/profile_details",
  		label: i18n("page_stats.source_def.profile"),
  		query: "profile",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.profile"),
  			regex_type: "text",
  			value: "profile",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "redis",
  		regex_page_url: "lua\/monitor\/redis_monitor.lua",
  		label: i18n("page_stats.source_def.redis"),
  		query: "redis",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "Redis", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}],
  	},
  	{
  		id: "influx",
  		regex_page_url: "lua\/monitor\/influxdb_monitor.lua",
  		label: i18n("page_stats.source_def.influx"),
  		query: "influxdb",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "Influx", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}],
  	},
  	{
  		id: "active_monitoring",
  		regex_page_url: "lua\/monitor\/active_monitoring_monitor.lua",
  		label: i18n("page_stats.source_def.active_monitoring"),
  		query: "am",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.active_monitoring"),
  			sources_url: "lua/rest/v2/get/am_host/list.lua",
  			value: "host",
  			disable_tskey: true,
  			value_map_sources_res: "am_host",
  			ui_type: ui_types$1.select,
  		}],
  	},
  	{
  	    id: "snmp_interface",
  	    id_group: "snmp",
  	    // disable_stats: true,
  	    regex_page_url: "lua\/pro\/enterprise\/snmp_interface_details",
  	    label: i18n("page_stats.source_def.snmp_interface"),
  	    query: "snmp_interface",
              f_map_ts_options: (ts_options, ts_group) => {
                  return ts_options;
              },
              source_def_array: [{
  		label: i18n("page_stats.source_def.interface"),
  		sources_function: () => { return [{ label: "", value: -1 }] },
  		value: "ifid",
  		ui_type: ui_types$1.hide,
  	    }, {
  		label: i18n("page_stats.source_def.device"),
  		regex_type: "ip",
  		sources_url: "lua/pro/rest/v2/get/snmp/device/list.lua", // url to get sources list
  		value: "device",
  		value_url: "host",
                  // refresh_i18n: 'modal_timeseries.snmp_confirm_device',
  		// ui_type: ui_types.input_confirm,
                  ui_type: ui_types$1.select,
  	    }, {
  		main_source_def: true,
  		label: i18n("page_stats.source_def.snmp_interface"),
  		regex_type: "text",
                  refresh_on_sources_change: true,
  		sources_function: async (selected_source_value_array) => {
                      const device_host = selected_source_value_array[1];
                      let snmp_interfaces = await proxy_snmp.available_interfaces(device_host);
                      return snmp_interfaces.map((iface) => { return { label: iface.name, value: iface.id }; });
                  },
  		value: "if_index",
  		value_url: "snmp_port_idx",
  		ui_type: ui_types$1.select,
  	    }],
  	},
  	{
  		id: "snmp_device",
  		id_group: "snmp",
  		// disable_stats: true,
  		regex_page_url: "lua\/pro\/enterprise\/snmp_device_details",
  		label: i18n("page_stats.source_def.snmp_device"),
  		query: "snmp_device",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_function: () => { return [{ label: "", value: -1 }] },
  			value: "ifid",
  			ui_type: ui_types$1.hide,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.device"),
  			regex_type: "ip",
  			sources_url: "lua/pro/rest/v2/get/snmp/device/list.lua", // url to get sources list
  			value: "device",
  			value_url: "host",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "flow_device",
  		regex_page_url: "lua\/pro\/enterprise\/flowdevices_stats",
  		label: i18n("page_stats.source_def.flow_device"),
  		query: "flowdev",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.device"),
  			sources_url: "lua/pro/rest/v2/get/flowdevices/list.lua", // url to get sources list
  			regex_type: "ip",
  			value: "device",
  			value_url: "ip",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "flow_interface",
  		regex_page_url: "lua\/pro\/enterprise\/flowdevice_interface_details",
  		label: i18n("page_stats.source_def.flow_interface"),
  		query: "flowdev_port",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			label: i18n("page_stats.source_def.device"),
  			regex_type: "ip",
  			value: "device",
  			value_url: "ip",
  			ui_type: ui_types$1.input,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.port"),
  			regex_type: "port",
  			value: "port",
  			value_url: "snmp_port_idx",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "sflow_device",
  		regex_page_url: "lua\/pro\/enterprise\/sflowdevices_stats",
  		label: i18n("page_stats.source_def.sflow_device"),
  		query: "sflowdev",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.device"),
  			regex_type: "ip",
  			value: "device",
  			value_url: "ip",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "sflow_interface",
  		regex_page_url: "lua\/pro\/enterprise\/sflowdevice_interface_details",
  		label: i18n("page_stats.source_def.sflow_interface"),
  		query: "sflowdev_port",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			label: i18n("page_stats.source_def.device"),
  			regex_type: "ip",
  			value: "device",
  			value_url: "ip",
  			ui_type: ui_types$1.input,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.port"),
  			regex_type: "port",
  			value: "port",
  			value_url: "snmp_port_idx",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "observation_point",
  		regex_page_url: "lua\/pro\/enterprise\/observation_points",
  		label: i18n("page_stats.source_def.observation_point"),
  		query: "obs_point",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.observation_point"),
  			regex_type: "text",
  			value: "obs_point",
  			value_url: "observation_point",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		//todo_test
  		id: "pod",
  		regex_page_url: "lua\/pod_details",
  		label: i18n("page_stats.source_def.pod"),
  		query: "pod",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.pod"),
  			regex_type: "text",
  			value: "pod",
  			ui_type: ui_types$1.input,
  		}],
  	}, {
  		//todo_test
  		id: "container",
  		regex_page_url: "lua\/container_details",
  		label: i18n("page_stats.source_def.container"),
  		query: "container",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			sources_url: "lua/rest/v2/get/ntopng/interfaces.lua",
  			value: "ifid",
  			ui_type: ui_types$1.select,
  		}, {
  			main_source_def: true,
  			label: i18n("page_stats.source_def.container"),
  			regex_type: "text",
  			value: "container",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	{
  		id: "nedge",
  		regex_page_url: "lua\/pro\/nedge\/if_stats.lua",
  		label: i18n("page_stats.source_def.nedge"),
  		query: "nedge",
  		source_def_array: [{
  			label: i18n("page_stats.source_def.interface"),
  			regex_type: "text",
  			value: "ifid",
  			value_url: "ifname",
  			ui_type: ui_types$1.input,
  		}],
  	},
  	// {
  	// 	id: "n_edge_interface",
  	// 	regex_page_url: "lua\/pro\/nedge\/if_stats.lua",
  	// 	label: "Profile nEdge",
  	// 	value: "ifid",
  	// 	regex_type: "text",
  	// 	ui_type: ui_types.select_and_input,
  	// 	query: "iface:nedge",
  	// },
  ];

  const metricsConsts = function () {
  	return {
  		ui_types: ui_types$1,
  		sources_url_el_to_source: sources_url_el_to_source$1,
  		sources_types: sources_types$1,
  		sources_types_tables: sources_types_tables$1,
  	};
  }();

  /**
      (C) 2022 - ntop.org
  */

  const set_timeseries_groups_in_url = (timeseries_groups) => {
      let params_timeseries_groups = [];
      timeseries_groups.forEach((ts_group) => {
          let param = get_ts_group_url_param(ts_group);
          params_timeseries_groups.push(param);
      });
      let url_timeseries_groups = params_timeseries_groups.join(";;");
      ntopng_url_manager$1.set_key_to_url("timeseries_groups", url_timeseries_groups);
  };

  function get_ts_group_url_param(ts_group) {
      let timeseries = [];
      ts_group.timeseries.forEach((ts) => {
          timeseries.push(`${ts.id}=${ts.raw}:${ts.past}:${ts.avg}:${ts.perc_95}`);
      });
      let metric_schema_query = ts_group.metric.schema;
      if (ts_group.metric.query != null) {
          metric_schema_query = `${metric_schema_query}+${ts_group.metric.query}`;
      }
      let timeseries_param = timeseries.join("|");
      let source_value_array_query = ts_group.source_array.map((source) => source.value).join("+");
      let param = `${ts_group.source_type.id};${source_value_array_query};${metric_schema_query};${timeseries_param}`;
      return param;
  }

  const get_timeseries_groups_from_url = async (http_prefix, url_timeseries_groups) => {
      if (url_timeseries_groups == null) {
          url_timeseries_groups = ntopng_url_manager$1.get_url_entry("timeseries_groups");
      }
      if (url_timeseries_groups == null || url_timeseries_groups == "") {
          return null;
      }
      let groups = url_timeseries_groups.split(";;");
      groups.map(async (g) => {
          let ts_group = await get_url_param_from_ts_group(g);
          return ts_group;
      });
      let timeseries_groups = Promise.all(groups.map(async (g) => {
          let ts_group = await get_url_param_from_ts_group(g);
          return ts_group;
      }));
      return timeseries_groups;
  };

  const get_ts_group = (source_type, source_array, metric, customized_ts) => {
      let ts_config = {
          raw: true,
          past: true, /* By default enable the past serie */
          avg: false,
          perc_95: false,
      };

      if(customized_ts && customized_ts.raw != null) ts_config.raw = customized_ts.raw;
      if(customized_ts && customized_ts.past != null) ts_config.past = customized_ts.past;
      if(customized_ts && customized_ts.avg != null) ts_config.avg = customized_ts.avg;
      if(customized_ts && customized_ts.perc_95 != null) ts_config.perc_95 = customized_ts.perc_95;

      let id = get_ts_group_id(source_type, source_array, metric);
      let timeseries = [];
      for (let key in metric.timeseries) {
          let ts = metric.timeseries[key];
          ts_config.id = key;
          ts_config.label = ts.label;
          timeseries.push(ts_config);
      }
      return {
          id, source_type, source_array, metric, timeseries,
      };
  };

  const get_default_timeseries_groups = async (http_prefix, metric_ts_schema, metric_query) => {
      let source_type = get_current_page_source_type();
      let source_array = await get_default_source_array(http_prefix, source_type);
      let metrics = await get_metrics(http_prefix, source_type, source_array);
      let metric = get_default_metric(metrics, metric_ts_schema, metric_query);
      let ts_group = get_ts_group(source_type, source_array, metric);
      return [ts_group];
  };

  async function get_url_param_from_ts_group(ts_group_url_param) {
      let g = ts_group_url_param;
      let info = g.split(";");
      let source_type_id = info[0];
      let source_value_query = info[1];
      let source_value_array = source_value_query.split("+");

      let metric_schema_query = info[2];
      let metric_schema_query_array = metric_schema_query.split("+");
      if (metric_schema_query_array.length < 2) {
          metric_schema_query_array.push(null);
      }

      let timeseries_url = info[3];

      let source_type = get_source_type_from_id(source_type_id);
      let source_array = await get_source_array_from_value_array(http_prefix, source_type, source_value_array);
      let metric = await get_metric_from_schema(http_prefix, source_type, source_array, metric_schema_query_array[0], metric_schema_query_array[1]);
      let timeseries = get_timeseries(timeseries_url, metric);
      return {
          id: get_ts_group_id(source_type, source_array, metric),
          source_type,
          source_array,
          metric,
          timeseries,
      };
  }

  const get_ts_group_id = (source_type, source_array, metric, enable_source_def_value_dict, set_source_type_id_group) => {
      let metric_id = "";
      if (metric != null) {
          metric_id = metric.schema;
          if (metric.query != null) {
              metric_id = `${metric_id} - ${metric.query}`;
          }
      }
      let source_def_array = source_type.source_def_array;
      let source_value_array = source_array.map((source, i) => {
          let source_def_value = source_def_array[i].value;
          if (enable_source_def_value_dict != null && !enable_source_def_value_dict[source_def_value]) { return null; }
          return source.value;
      }).filter((s) => s != null).join("_");
      let source_type_id = source_type.id;
      if (set_source_type_id_group && source_type.id_group != null) {
          source_type_id = source_type.id_group;
      }
      return `${source_type_id} - ${source_value_array} - ${metric_id}`;
  };

  function get_timeseries(timeseries_url, metric) {
      let ts_url_array = timeseries_url.split("|");
      let r = /(.+)=(.+):(.+):(.+):(.+)/;
      let timeseries = [];
      ts_url_array.forEach((ts_url) => {
          let values = r.exec(ts_url);
          if(values.length > 0) {
              let id = values[1];
              let label = metric.timeseries[id].label;
              let raw = JSON.parse(values[2]);
              let past = JSON.parse(values[3]);
              let avg = JSON.parse(values[4]);
              let perc_95 = JSON.parse(values[5]);
              timeseries.push({
                  id, label, raw, past, avg, perc_95,
              });    
          }
      });
      return timeseries;
  }

  const ui_types = metricsConsts.ui_types;

  // dictionary of functions to convert an element of source_url rest result to a source ({label, value })
  const sources_url_el_to_source = metricsConsts.sources_url_el_to_source;

  const sources_types = metricsConsts.sources_types;
  const sources_types_tables = metricsConsts.sources_types_tables;

  const get_source_type_from_id = (source_type_id) => {
      return sources_types.find((st) => st.id == source_type_id);
  };

  const get_default_source_array = async (http_prefix, source_type) => {
      let source_value_array = get_default_source_value_array(source_type);
      let source_array = await get_source_array_from_value_array(http_prefix, source_type, source_value_array);
      return source_array;
  };

  async function get_source_array_from_value_dict(http_prefix, source_type, source_value_dict) {
      let source_value_array = source_type.source_def_array.map((source_def) => source_value_dict[source_def.value]);
      let source_array = await get_source_array_from_value_array(http_prefix, source_type, source_value_array);
      return source_array;
  }

  const get_source_array_from_value_array = async (http_prefix, source_type, source_value_array) => {
      if (source_type == null) {
          source_type = get_current_page_source_type();
      }
      let source_array = [];
      let source;
      for (let i = 0; i < source_value_array.length; i++) {
          let source_value = source_value_array[i];
          let source_def = source_type.source_def_array[i];
          if (source_def.sources_url || source_def.sources_function) {
              let sources = [];
              sources = await get_sources(http_prefix, source_type.id, source_def, source_value_array);
              source = sources.find((s) => s.value == source_value);
              if (source == null) {
                  source = sources[0];
              }
          } else {
              source = { label: source_value, value: source_value };
          }
          source_array.push(source);
      }
      return source_array;
  };

  let cache_sources = {};

  function get_source_def_key(id, source_def, selected_source_value_array) {
      let key = `${id}_${source_def.value}`;
      if (!source_def.refresh_on_sources_change) {
          return key;
      }
      const value_array = selected_source_value_array.join("_");
      key = `${key}_${value_array}`;
      return key;
  }

  const get_sources = async (http_prefix, id, source_def, selected_source_value_array) => {
      let key = get_source_def_key(id, source_def, selected_source_value_array);
      if (cache_sources[key] == null) {
          if (source_def.sources_url) {
              let url = `${http_prefix}/${source_def.sources_url}`;
              cache_sources[key] = ntopng_utility$1.http_request(url);
          } else if (source_def.sources_function) {
              cache_sources[key] = source_def.sources_function(selected_source_value_array);
          } else {
              return [];
          }
      }
      let sources = await cache_sources[key];
      if (source_def.sources_url) {
          let f_map_source_element = sources_url_el_to_source[source_def.value_map_sources_res];
          if (f_map_source_element == null) {
              f_map_source_element = sources_url_el_to_source[source_def.value];
          }
          if (f_map_source_element == null) {
              throw `:Error: metrics-manager.js, missing sources_url_to_source ${source_def.value} key`;
          }
          sources = sources.map((s) => f_map_source_element(s));
      }
      return sources.sort(NtopUtils$1.sortAlphabetically);
  };

  function set_source_value_object_in_url(source_type, source_value_object) {
      source_type.source_def_array.forEach((source_def) => {
          let source_value = source_value_object[source_def.value];
          if (source_value == null) { return; }
          if (source_def.f_set_value_url != null) {
              source_def.f_set_value_url();
          } else if (source_def.value_url != null) {
              ntopng_url_manager$1.set_key_to_url(source_def.value_url, source_value);
          } else {
              ntopng_url_manager$1.set_key_to_url(source_def.value, source_value);
          }
      });
  }

  const get_default_source_value_array = (source_type) => {
      if (source_type == null) {
          source_type = get_current_page_source_type();
      }
      let source_value_array = source_type.source_def_array.map((source_def) => {
          if (source_def.f_get_value_url != null) {
              return source_def.f_get_value_url();
          }
          let source_def_value = source_def.value_url;
          if (source_def_value == null) {
              source_def_value = source_def.value;
          }
          let source_value = ntopng_url_manager$1.get_url_entry(source_def_value);
          return source_value;
      });
      return source_value_array;
  };

  function get_metrics_url(http_prefix, source_type, source_array, epoch) {
      let params = source_type.source_def_array.map((source_def, i) => {
          return `${source_def.value}=${source_array[i].value}`;
      }).join("&");
      let epoch_string = ``;
      if (epoch != null) {
          epoch_string = `epoch_end=${epoch.epoch_end}&epoch_begin=${epoch.epoch_begin}`;
      }
      let url = `${http_prefix}/lua/rest/v2/get/timeseries/type/consts.lua?query=${source_type.query}&${params}&${epoch_string}`;
      return url;
  }

  function get_metric_key(source_type, source_array) {
      let source_array_key = source_array.map((source) => source.value).join("_");
      let key = `${source_type.id}_${source_array_key}`;
      return key;
  }

  let cache_metrics = {};
  let last_metrics_time_interval = null;
  const get_metrics = async (http_prefix, source_type, source_array, status) => {
      let epoch_begin = status?.epoch_begin || ntopng_url_manager$1.get_url_entry("epoch_begin");
      let epoch_end = status?.epoch_end || ntopng_url_manager$1.get_url_entry("epoch_end");
      let current_last_metrics_time_interval = `${epoch_begin}_${epoch_end}`;
      if (source_type == null) {
          source_type = get_current_page_source_type();
      }
      if (source_array == null) {
          source_array = await get_default_source_array(http_prefix, source_type);
      }
      // let url = `${http_prefix}/lua/rest/v2/get/timeseries/type/consts.lua?query=${source_type.value}`;
      let url = get_metrics_url(http_prefix, source_type, source_array, { epoch_begin: epoch_begin, epoch_end: epoch_end });
      let key = get_metric_key(source_type, source_array);
      if (current_last_metrics_time_interval != last_metrics_time_interval) {
          cache_metrics[key] = null;
          last_metrics_time_interval = current_last_metrics_time_interval;
      }
      if (cache_metrics[key] == null) {
          cache_metrics[key] = ntopng_utility$1.http_request(url);
      }
      let metrics = await cache_metrics[key];
      if (metrics == null || metrics.length == 0) { return [{}]; }
      if (metrics.some((m) => m.default_visible == true) == false) {
          metrics[0].default_visible = true;
      }
      return ntopng_utility$1.clone(metrics);
  };

  const get_current_page_source_type = () => {
      let pathname = window.location.pathname;
      for (let i = 0; i < sources_types.length; i += 1) {
          let regExp = new RegExp(sources_types[i].regex_page_url);
          if (regExp.test(pathname) == true) {
              return sources_types[i];
          }
      }
      throw `source_type not found for ${pathname}`;
  };

  const get_metric_from_schema = async (http_prefix, source_type, source_array, metric_schema, metric_query, status) => {
      let metrics = await get_metrics(http_prefix, source_type, source_array, status);
      return metrics.find((m) => m.schema == metric_schema && m.query == metric_query);
  };

  const get_metric_query_from_ts_query = (ts_query, source_type) => {
      if (source_type == null) {
          source_type = get_current_page_source_type();
      }
      let source_def_dict = {};
      source_type.source_def_array.forEach((s_def) => source_def_dict[s_def.value] = true);
      let ts_query_array = ts_query.split(",");
      for (let i = 0; i < ts_query_array.length; i += 1) {
          let ts_val_key = ts_query_array[i].split(":")[0];
          if (source_def_dict[ts_val_key] == null) {
              return ts_query_array[i];
          }
      }
      return null;
  };

  const get_default_metric = (metrics, metric_ts_schema, metric_query) => {
      let default_metric;
      if (metric_ts_schema != null) {
          default_metric = metrics.find((m) => m.schema == metric_ts_schema && (metric_query == null || m.query == metric_query));
      }
      if (default_metric == null) {
          default_metric = metrics.find((m) => m.default_visible == true);
      }
      if (default_metric != null) {
          return default_metric;
      }
      return metrics[0];
  };

  const metricsManager = function () {
      return {
          set_timeseries_groups_in_url,
          get_timeseries_groups_from_url,
          get_default_timeseries_groups,
          get_ts_group,
          get_ts_group_id,

          sources_types,
          sources_types_tables,
          get_source_type_from_id,
          get_current_page_source_type,

          get_sources,
          get_default_source_array,
          get_source_array_from_value_dict,
          get_source_array_from_value_array,
          get_default_source_value_array,

          get_metrics,
          get_metric_from_schema,
          get_metric_query_from_ts_query,
          get_default_metric,

          set_source_value_object_in_url,

          ui_types,
      };
  }();

  /**
  		(C) 2023 - ntop.org
  */

  /* Override Dygraph plugins to have a better legend */
  Dygraph.Plugins.Legend.prototype.select = function (e) {
  	var xValue = e.selectedX;
  	var points = e.selectedPoints;
  	var row = e.selectedRow;

  	var legendMode = e.dygraph.getOption('legend');
  	if (legendMode === 'never') {
  		this.legend_div_.style.display = 'none';
  		return;
  	}

  	var html = Dygraph.Plugins.Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);
  	if (html instanceof Node && html.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
  		this.legend_div_.innerHTML = '';
  		this.legend_div_.appendChild(html);
  	} else
  		this.legend_div_.innerHTML = html;
  	// must be done now so offsetWidth isn’t 0…
  	this.legend_div_.style.display = '';

  	if (legendMode === 'follow') {
  		// create floating legend div
  		var area = e.dygraph.plotter_.area;
  		var labelsDivWidth = this.legend_div_.offsetWidth;
  		var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');
  		// find the closest data point by checking the currently highlighted series,
  		// or fall back to using the first data point available
  		var highlightSeries = e.dygraph.getHighlightSeries();
  		var point;
  		if (highlightSeries) {
  			point = points.find(p => p.name === highlightSeries);
  			if (!point)
  				point = points[0];
  		} else
  			point = points[0];

  		// determine floating [left, top] coordinates of the legend div
  		// within the plotter_ area
  		// offset 50 px to the right and down from the first selection point
  		// 50 px is guess based on mouse cursor size
  		const followOffsetX = e.dygraph.getNumericOption('legendFollowOffsetX');
  		const x = (point?.x != null) ? point.x : 1;
  		var leftLegend = x * area.w + followOffsetX;

  		// if legend floats to end of the chart area, it flips to the other
  		// side of the selection point
  		if ((leftLegend + labelsDivWidth + 1) > area.w) {
  			leftLegend = leftLegend - 2 * followOffsetX - labelsDivWidth - (yAxisLabelWidth - area.x);
  		}

  		this.legend_div_.style.left = yAxisLabelWidth + leftLegend + "px";
  		document.addEventListener("mousemove", (e) => {
  			localStorage.setItem('timeseries-mouse-top-position', e.clientY + 50 + "px");
  		});
  		this.legend_div_.style.top = localStorage.getItem('timeseries-mouse-top-position');
  	} else if (legendMode === 'onmouseover' && this.is_generated_div_) {
  		// synchronise this with Legend.prototype.predraw below
  		var area = e.dygraph.plotter_.area;
  		var labelsDivWidth = this.legend_div_.offsetWidth;
  		this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + "px";
  		this.legend_div_.style.top = area.y + "px";
  	}
  };

  /**
      (C) 2023 - ntop.org
  */

  /* *********************************************** */

  const MAX_BAR_WIDTH = 90; /* 100 px */
  const FILL_COLORS = [
    'rgb(144, 238, 144)',
    'rgb(25, 135, 84)',
    'rgb(255, 193, 7)',
    'rgb(220, 53, 69)'
  ];

  /* *********************************************** */

  function darkenColor(colorStr) {
    const color = Dygraph.toRGB_(colorStr);
    color.r = Math.floor((255 + color.r) / 2);
    color.g = Math.floor((255 + color.g) / 2);
    color.b = Math.floor((255 + color.b) / 2);
    return 'rgb(' + color.r + ',' + color.g + ',' + color.b + ', 0.9)';
  }

  /* *********************************************** */

  function getColor(current_value, max_value, default_color) {
    if(!max_value || !current_value) {
      return darkenColor(default_color);
    }
    /* Security check */
    if(current_value > max_value) {
      current_value = max_value;
    }

    const colors_module = max_value / FILL_COLORS.length;
    for(let i = 1; i < FILL_COLORS.length + 1; i++) {
      if(current_value <= colors_module * i) {
        return FILL_COLORS[i - 1];
      }
    }
  }

  /* *********************************************** */

  /* This function is used to create a bar chart instead of a line chart */
  function barChartPlotter(e) {
    const ctx = e.drawingContext;
    const points = e.points;
    const y_bottom = e.dygraph.toDomYCoord(0);
    const max_value = e.dygraph.user_attrs_.valueRange[1];
    const default_color = e.color;
    
    /* Find the minimum separation between x-values.
     * This determines the bar width.
     */
    let min_sep = Infinity;
    for (let i = 1; i < points.length; i++) {
      const sep = points[i].canvasx - points[i - 1].canvasx;
      if (sep < min_sep) min_sep = sep;
    }

    if(min_sep > MAX_BAR_WIDTH) {
      min_sep = MAX_BAR_WIDTH;
    }

    /* Keep just a little distance between the bars */
    const bar_width = Math.floor(0.95 * min_sep);

    /* Do the actual plotting */
    for (var i = 0; i < points.length; i++) {
      const p = points[i];
      const center_x = p.canvasx;
      const current_value = p.yval;
      ctx.fillStyle = getColor(Math.abs(current_value), Math.abs(max_value), default_color);
      ctx.fillRect(center_x - bar_width / 2, p.canvasy,
        bar_width, y_bottom - p.canvasy);
      ctx.strokeRect(center_x - bar_width / 2, p.canvasy,
        bar_width, y_bottom - p.canvasy);
    }
  }

  /* *********************************************** */

  const dygraphPlotters = function () {
    return {
      barChartPlotter,
    };
  }();

  /**
      (C) 2022 - ntop.org    
  */


  /* ***************************************** */

  function transformColors(colors) {
      let colorsPositionDict = {};
      colors.forEach((c, i) => {
  	if (colorsPositionDict[c] == null) {
  	    colorsPositionDict[c] = [i];
  	} else {
  	    colorsPositionDict[c].push(i);
  	}
      });
      // clone colors
      let newColors = ntopng_utility$1.clone(colors);
      
      for (let color in colorsPositionDict) {
  	let colorsPosition = colorsPositionDict[color];
  	let n = colorsPosition.length;
  	// colorsGenerated.length == colorsPosition.length always true
  	let colorsGenerated = getColorsFromColor(color, n);
  	colorsGenerated.forEach((c, i) => {
  	    let cPosition = colorsPosition[i];
  	    newColors[cPosition] = c;
  	});
      }
      return newColors;
  }

  /* ***************************************** */

  function getColorsFromColor(color, n) {
      return [...Array(n).keys()].map((c, i) => {
  	return generateColor(color, i + 1, n);
      });
  }

  /* ***************************************** */

  /**
   * Generate a color that represent the index-th tint of n of baseColor.
   * @param {baseColor} string color in hex format.
   * @param {index} integer in interval [1, n].
   * @param {n} total number of colors to generate
  **/
  function generateColor(baseColor, index, n) {
      let sourceColor = baseColor.replace("#", "");

      let redSource = parseInt(sourceColor.substring(0, 2), 16);
      let greenSource = parseInt(sourceColor.substring(2, 4), 16);
      let blueSource = parseInt(sourceColor.substring(4, 6), 16);

      let cRed = getColorInterpolation(redSource, index, n);
      let cGreen = getColorInterpolation(greenSource, index, n);
      let cBlue = getColorInterpolation(blueSource, index, n);

      return rgbToHex(cRed, cGreen, cBlue);
  }

  /* ***************************************** */

  function getColorInterpolation(colorSource, i, n) {    
      if (n <= 1) {
  	return colorSource;
      }
      let colorStart = Math.trunc(colorSource / 2);
      let colorEnd = Math.trunc(colorSource + ((255 - colorSource) / 2));
      let interval = Math.trunc((colorEnd - colorStart) / n);

      return colorStart + i * interval;
      // return colorStart + (n - i) * interval;
  }

  /* ***************************************** */

  function rgbToHex(r, g, b) {
      return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }

  /* ***************************************** */

  function componentToHex(c) {
      let hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
  }

  /* ***************************************** */

  const colorsInterpolation = function() {
      return {
  	    transformColors,
      };
  }();

  /**
      (C) 2023 - ntop.org
  */

  /* ***************************************** */

  /* This function return the default config for dygraph charts */
  function getDefaultConfig() {
    return {
      labelsSeparateLines: true,
      legend: "follow",
      connectSeparatedPoints: true,
      includeZero: true,
      drawPoints: true,
      highlightSeriesBackgroundAlpha: 0.7,
      highlightSeriesOpts: {
        strokeWidth: 2,
        pointSize: 3,
        highlightCircleSize: 6,
      },
      axisLabelFontSize: 12,
      axes: {
        x: {
          axisLabelWidth: 90
        }
      },
    };
  }

  /* ***************************************** */

  /* This function put the correct formatters in the configuration */
  function changeFormatters(config, options) {
    if (options.formatters.length > 1) {
      /* Multiple formatters */
      /* NOTE: at most 2 formatters can be used */
      config.axes.y1 = getAxisConfiguration(formatterUtils.getFormatter(options.formatters[0]));
      config.axes.y2 = getAxisConfiguration(formatterUtils.getFormatter(options.formatters[1]));
    } else if (options.formatters.length == 1) {
      /* Single formatter */
      config.axes.y = getAxisConfiguration(formatterUtils.getFormatter(options.formatters[0]));
    }
  }

  /* ***************************************** */

  /* This function return the color of the serie when highlighted */
  function getHighlightColor() {
    const is_dark_mode = document.getElementsByClassName('body dark').length > 0;
    let highlight_color = 'rgb(255, 255, 255)';
    if (is_dark_mode) {
      highlight_color = 'rgb(13, 17, 23)';
    }
    return highlight_color;
  }

  /* ***************************************** */

  /* This function is used to format the value on the legend */
  function getAxisConfiguration(formatter) {
    return {
      axisLabelFormatter: formatter,
      valueFormatter: function (num_or_millis, opts, seriesName, dygraph, row, col) {
        const serie_point = dygraph?.rawData_?.[row][col];
        let data = '';
        if (typeof (serie_point) == "object") {
          /* This is the case for the serie with bounds */
          serie_point.forEach((el) => {
            data = `${data} / ${formatter(el || 0)}`;
          });
          data = data.substring(3); /* Remove the first three characters ' / ' */
        } else {
          /* This is the standard case */
          data = formatter(num_or_millis);
        }
        return (data);
      },
      axisLabelWidth: 80,
    }
  }

  /* ***************************************** */

  /* This function merges the default config with the options requested */
  function buildChartOptions(options) {
    const interpolated_colors = colorsInterpolation.transformColors(options.colors);
    const highlight_color = getHighlightColor();
    const config = getDefaultConfig();

    config.customBars = options.customBars;
    config.labels = options.labels;
    config.series = options.properties;
    config.data = options.serie;
    config.stackedGraph = options.stacked;
    config.valueRange = options.value_range;
    config.highlightSeriesBackgroundColor = highlight_color;
    config.colors = interpolated_colors;
    config.disableTsList = options.disable_ts_list;
    config.yRangePad = options.yRangePad || 1;

    /* Change the plotter */
    if (options.plotter) {
      config.plotter = options.plotter;
    }

    changeFormatters(config, options);

    return config;
  }

  /* ***************************************** */

  function formatSerieProperties(type) {
    switch (type) {
      case 'dash':
        return {
          fillGraph: false,
          customBars: false,
          strokePattern: Dygraph.DASHED_LINE
        };
      case 'point':
        return {
          fillGraph: false,
          customBars: false,
          strokeWidth: 0.0,
          pointSize: 2.0,
        };
      case 'bounds':
        return {
          fillGraph: false,
          strokeWidth: 1.0,
          pointSize: 1.5,
          fillAlpha: 0.5
        };
      case 'line':
        return {
          fillGraph: false,
          customBars: false,
          strokeWidth: 1.5,
          pointSize: 1.5,
        };
      default:
        return {
          fillGraph: true,
          customBars: false,
          strokeWidth: 1.0,
          pointSize: 1.5,
          fillAlpha: 0.5
        };
    }
  }

  /* ***************************************** */

  const dygraphConfig = function () {
    return {
      buildChartOptions,
      formatSerieProperties
    };
  }();

  /**
      (C) 2023 - ntop.org
  */


  /* ***************************************** */

  const defaultColors = [
    "#C6D9FD",
    "#90EE90",
    "#EE8434",
    "#C95D63",
    "#AE8799",
    "#717EC3",
    "#496DDB",
    "#5A7ADE",
    "#6986E1",
    "#7791E4",
    "#839BE6",
    "#8EA4E8",
  ];

  /* ***************************************** */

  const constant_serie_colors = {
    "default_color": "#C6D9FD",
    "95_perc": "#8EA4E8",
    "avg": "#839BE6",
  };

  /* ***************************************** */

  function getSerieId$1(serie) {
    return `${serie.id}`;
  }

  /* ***************************************** */

  function formatSerieColors(palette_list) {
    let colors_list = palette_list;
    let count0 = 0, count1 = 0;
    let colors0 = defaultColors;
    let colors1 = d3v7.schemeCategory10;
    colors_list.forEach((s, index) => {
      if (s.palette == 0) {
        if (palette_list.find((element, j) => (element.color === s.color && j !== index))) {
          palette_list[index] = colors0[count0 % colors0.length];
        } else {
          palette_list[index] = s.color;
        }
        count0 += 1;
      } else if (s.palette == 1) {
        palette_list[index] = colors1[count1 % colors1.length];
        count1 += 1;
      }
    });
  }

  /* *********************************************** */

  /* Return the formatted serie name */
  function getSerieName$1(name, id, tsGroup, useFullName) {
    if (name == null) {
      name = id;
    }
    let name_more_space = "";
    if (name != null) {
      name_more_space = `${name}`;
    }
    if (useFullName == false) {
      return name;
    }
    let source_index = 0;
    let source_def_array = tsGroup.source_type.source_def_array;
    for (let i = 0; i < source_def_array.length; i += 1) {
      let source_def = source_def_array[i];
      if (source_def.main_source_def == true) {
        source_index = i;
        break;
      }
    }

    let source = tsGroup.source_array[source_index];
    let prefix = `${source.label}`;
    return `${prefix} - ${name_more_space}`;
  }

  /* *********************************************** */

  /* Given all the info about a timeserie, return the correct name to be displayed */
  function getName(ts_info, metadata) {
    let name = (metadata.use_serie_name == true) ? ts_info.name : metadata.label;

    if (ts_info.ext_label) {
      name = ts_info.ext_label;
    }
    return name
  }

  /* *********************************************** */

  /* This function return the plotting function */
  function getPlotter(chart_type) {
    switch (chart_type) {
      case 'bar':
        return dygraphPlotters.barChartPlotter;
    }
  }

  /* *********************************************** */

  function addNewSerie(serie_name, chart_type, color, config) {
    config.labels.push(serie_name);
    if(config.properties == null) 
      config.properties = {};
    config.properties[serie_name] = {};
    config.properties[serie_name] = dygraphConfig.formatSerieProperties(chart_type);
    config.colors.push(color);
  }

  /* *********************************************** */

  /* This function given a serie, format the array needed */
  function compactSerie(config, ts_info, extra_timeseries, serie, past_serie, scalar, step, epoch_begin, names) {
    const avg_value = ts_info.statistics["average"];
    const perc_value = ts_info.statistics["95th_percentile"];
    let time = epoch_begin;

    /* Now format the timeserie */
    for (let point = 0; point < serie.length; point++) {
      const serie_point = serie[point];
      /* If the point is inserted for the first time, add the time before everything else */
      if (!config.serie[time]) {
        config.serie[time] = [{ value: new Date(time * 1000), name: "Time" }];
      }
      /* Add the point to the array or NaN if it's null */
      (serie_point !== null) ?
        config.serie[time].push({ value: serie_point * scalar, name: names.serie_name }) :
        config.serie[time].push({ value: NaN, name: names.serie_name });

      /* Add extra series, avg, 95th and past timeseries */
      if (extra_timeseries?.avg == true) {
        config.serie[time].push({ value: avg_value * scalar, name: names.avg_name });
      }
      if (extra_timeseries?.perc_95 == true) {
        config.serie[time].push({ value: perc_value * scalar, name: names.perc_name });
      }
      if (extra_timeseries?.past == true) {
        const past_value = (past_serie) ? past_serie[point] : null;
        (past_value) ?
          config.serie[time].push({ value: past_value * scalar, name: names.past_name }) :
          config.serie[time].push({ value: NaN, name: names.past_label });
      }

      /* Increase the time using the step */
      time = time + step;
    }
  }

  /* *********************************************** */

  /* This function format the Bound type serie in the correct format */
  function splitBoundSerie(series, timeserie_info) {
    let color = {};
    let formatter = null;
    let serie_name = null;
    let properties = {};
    let full_serie = [];

    /* A bound timeserie should be composed by 3 timeseries:
     *    - metric (main)
     *    - lower_bound (the lower bound)
     *    - upper_bound (the upper bound)
     */
    series.forEach((ts_info, j) => {
      const ts_id = getSerieId$1(ts_info);
      const serie = ts_info.data || []; /* Safety check */
      const metadata = timeserie_info.metric.timeseries[ts_id];
      const scalar = (metadata?.invert_direction === true) ? 1 : -1;

      /* Just add the name, properties, colors, ecc, for the 
       * "main" timeserie and not for the bounds ones 
       */
      if (metadata.type == "metric") {
        serie_name = getSerieName$1(metadata.label, ts_id, timeserie_info, true);
        properties = dygraphConfig.formatSerieProperties('bounds');
        color = { color: metadata.color, palette: 0 };
        formatter = timeserie_info.metric.measure_unit;
      }
      for (let point = 0; point < serie.length; point++) {
        let serie_point = (serie[point] === null) ? NaN : serie[point];
        if (full_serie[point] == null) {
          full_serie[point] = [0, NaN, 0];
        }

        if (metadata.type == "lower_bound") {
          full_serie[point][0] = serie_point * scalar;
        } else if (metadata.type == "metric") {
          full_serie[point][1] = serie_point * scalar;
        } else if (metadata.type == "upper_bound") {
          full_serie[point][2] = serie_point * scalar;
        }
      }
    });

    return { serie: full_serie, color: color, formatter: formatter, serie_name: serie_name, properties: properties };
  }

  /* *********************************************** */

  /* This function, given a serie format the bounds serie */
  function formatBoundsSerie(timeserie_info, timeserie_options, config) {
    /* By default the chart type is line */
    const chart_type = timeserie_info.metric.chart_type || "filled";
    const series = timeserie_options.series || [];
    const epoch_begin = timeserie_options.metadata.epoch_begin;
    const step = timeserie_options.metadata.epoch_step;
    const { serie, color, formatter, serie_name, properties } = splitBoundSerie(series, timeserie_info);
    let time = epoch_begin;
    /* TODO: add avg, past, ecc. timeseries to the bounds one */

    /* Update the config */
    const formatted_name = `${serie_name} ${i18n('lower_value_upper')}`;
    const formatter_found = config.formatters.find(el => el == formatter);
    if (!formatter_found)
      config.formatters.push(formatter);
    config.plotter = getPlotter(chart_type);
    config.customBars = true;
    config.colors.push(color);
    config.labels.push(formatted_name);
    config.properties[formatted_name] = properties;

    /* Update the serie */
    Object.keys(serie).forEach((key) => {
      if (!config.serie[time]) {
        config.serie[time] = [
          { value: new Date(time * 1000), name: "Time" },
          { value: serie[key], name: formatted_name }
        ];
      }

      time = time + step;
    });
  }

  /* *********************************************** */

  function formatStandardSerie(timeserie_info, timeserie_options, config, tsCompare) {
    /* Iterate all the timeseries currently contained inside the single ts:
     * e.g. in the Traffic timeseries we have the Bytes sent and Bytes rcvd
     */
    const series = timeserie_options.series || [];
    const chart_type = timeserie_info.metric.chart_type || "filled";
    const epoch_begin = timeserie_options.metadata.epoch_begin;
    const step = timeserie_options.metadata.epoch_step;
    const formatter = timeserie_info.metric.measure_unit;
    const max_value = timeserie_info.metric.max_value || null;
    const min_value = timeserie_info.metric.min_value || null;
    const past_serie = timeserie_options.additional_series;

    config.value_range = [min_value, max_value];
    config.plotter = getPlotter(chart_type);
    if (!config.stacked) {
      config.stacked = timeserie_info.metric.draw_stacked || false;
    }

    series.forEach((ts_info, j) => {
      const serie = ts_info.data || []; /* Safety check */
      const extra_timeseries = timeserie_info.timeseries[0]; /* e.g. the Average */
      const ts_id = getSerieId$1(ts_info);
      const metadata = timeserie_info.metric.timeseries[ts_id];
      const scalar = (metadata.invert_direction === true) ? -1 : 1;
      const timeserie_name = getName(ts_info, metadata);
      const serie_name = getSerieName$1(timeserie_name, ts_id, timeserie_info, config.use_full_name);
      const avg_name = getSerieName$1(timeserie_name + " Avg", ts_id, timeserie_info, config.use_full_name);
      const perc_name = getSerieName$1(timeserie_name + " 95th Perc", ts_id, timeserie_info, config.use_full_name);
      const past_name = getSerieName$1(timeserie_name + " " + tsCompare + " Ago", ts_id, timeserie_info, config.use_full_name);
      const past_value = (past_serie) ? past_serie[`${tsCompare}_ago`]?.series[j]?.data : null;
      /* An option used to not display a timeserie */
      if (metadata.hidden) {
        return;
      }

      /* Search for the formatter in the array, if not found, add it. */
      const formatter_found = config.formatters.find(el => el == formatter);
      if (!formatter_found)
        config.formatters.push(formatter);

      /* Add the serie */
      addNewSerie(serie_name, chart_type, { color: metadata.color, palette: 0 }, config);

      /* Adding the extra timeseries, 30m ago, avg and 95th */
      if (extra_timeseries?.avg == true) {
        addNewSerie(avg_name, "point", { color: constant_serie_colors["avg"], palette: 1 }, config);
      }
      if (extra_timeseries?.perc_95 == true) {
        addNewSerie(perc_name, "point", { color: constant_serie_colors["perc_95"], palette: 1 }, config);
      }
      if (extra_timeseries?.past == true) {
        addNewSerie(past_name, "dash", { color: constant_serie_colors["past"], palette: 1 }, config);
      }

      /* ************************************** */

      compactSerie(config, ts_info, extra_timeseries, serie, past_value, scalar, step, epoch_begin, {
        serie_name: serie_name,
        avg_name: avg_name,
        perc_name: perc_name,
        past_name: past_name
      });
    });
  }

  /* ************************************** */

  /* This function finally format the timeseries and compact it togheter */
  function formatFullSerie(config) {
    const full_serie = [];
    const serie_keys = Object.keys(config.serie);

    /* Iterate the serie and for each label, get the value and set to null in case it does not exists */
    serie_keys.forEach((key, index) => {
      full_serie[index] = [];
      config.labels.forEach((label) => {
        let found = false;
        for (let j = 0; j < config.serie[key].length; j++) {
          if (config.serie[key][j].name == label) {
            full_serie[index].push(config.serie[key][j].value);
            found = true;
            break;
          }
        }

        /* Push null if no value is found */
        if (found == false) {
          full_serie[index].push(null);
        }
      });
    });
    config.serie = full_serie;
  }

  /* ************************************** */

  function formatSingleSerie(timeserie_info, timeserie_options, tsCompare, config) {
    if (timeserie_info.source_type.f_map_ts_options != null) {
      const f_map_ts_options = timeserie_info.source_type.f_map_ts_options;
      timeserie_options = f_map_ts_options(timeserie_options, timeserie_info);
    }

    /* Format the data */

    /* the data in Dygraphs should be formatted as follow:
     * { [ time_1, serie1_1, serie2_1 ], [ time_2, serie1_2, serie2_2 ] } 
     */
    const bounds = timeserie_info.metric.bounds || false;

    /* The serie can possibly have multiple timeseries, like for the 
     * bytes, we have sent and rcvd, so compact them 
     */
    if (bounds == true) {
      formatBoundsSerie(timeserie_info, timeserie_options, config);
    } else {
      formatStandardSerie(timeserie_info, timeserie_options, config, tsCompare);
    }
  }

  /* *********************************************** */

  function formatSimpleSerie$1(data, serie_name, chart_type, formatters, value_range) {
    let counter = 1;
    const tmp_serie = [];
    data.serie.forEach((value) => {
      tmp_serie.push([counter, value]);
      counter++;
    });

    /* To not have an error, just add a null value */
    if(tmp_serie.length == 0) {
      tmp_serie.push([1, null]);
    }

    const config = {
      serie: tmp_serie,
      formatters: formatters,
      labels: ["index"],
      colors: [],
      stacked: false,
      customBars: false,
      use_full_name: false,
      plotter: getPlotter(chart_type),
      value_range: value_range,
      disable_ts_list: true,
    };

    if (typeof(serie_name) === "string") {
      addNewSerie(serie_name, chart_type, { color: constant_serie_colors["default_color"], palette: 0 }, config);
    } else {
      serie_name.forEach((el) => {
        addNewSerie(el, chart_type, { color: constant_serie_colors["default_color"], palette: 0 }, config);
      });
    }
    formatSerieColors(config.colors);  
    return dygraphConfig.buildChartOptions(config);
  }

  /* *********************************************** */

  function formatSerie(tsOptionsArray, tsGroupsArray, tsCompare, useFullName) {
    const config = {
      serie: [],
      formatters: [],
      labels: ["Time"],
      colors: [],
      properties: [],
      stacked: false,
      customBars: false,
      use_full_name: (useFullName != null) ? useFullName : false
    };

    /* Go throught each serie */
    tsOptionsArray.forEach((tsOptions, i) => {
      formatSingleSerie(tsGroupsArray[i], tsOptions, tsCompare, config);
    });

    /* Need to finally format the serie as requested by Dygraph, with
       NULL as value in case the serie has NOT THAT POINT (e.g. with a 5 minutes frequency, the user
        is confronting a chart with 1 minute frequency, there are 4 minutes with no existing points)
     */
    formatFullSerie(config);
    formatSerieColors(config.colors);
    return dygraphConfig.buildChartOptions(config);
  }

  /* *********************************************** */

  const dygraphFormat = function () {
    return {
      formatSerie,
      formatSimpleSerie: formatSimpleSerie$1,
      getSerieId: getSerieId$1,
      getSerieName: getSerieName$1,
    };
  }();

  /**
  		(C) 2022 - ntop.org
  */

  function getSerieId(serie) {
  	return dygraphFormat.getSerieId(serie);
  }

  function getSerieName(name, id, tsGroup, useFullName) {
  	return dygraphFormat.getSerieName(name, id, tsGroup, useFullName);
  }

  function getYaxisId(metric) {
  	return `${metric.measure_unit}_${metric.scale}`;
  }

  const groupsOptionsModesEnum = {
  	'1_chart_x_metric': { value: "1_chart_x_metric", label: i18n('page_stats.layout_1_per_1') },
  	'1_chart_x_yaxis': { value: "1_chart_x_yaxis", label: i18n('page_stats.layout_1_per_y') },
  };

  function getGroupOptionMode(group_id) {
  	return groupsOptionsModesEnum[group_id] || null;
  }
  /* This function is going to translate the response sent from the server to the formatted data needed from the chart library */
  function tsArrayToOptionsArray(tsOptionsArray, tsGroupsArray, groupsOptionsMode, tsCompare) {
  	/* One chart per metric requested */
  	if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart_x_metric"].value) {
  		return tsArrayToOptionsArrayRaw(tsOptionsArray, tsGroupsArray, groupsOptionsMode, tsCompare);
  	}
  	let splittedTsArray = splitTsArrayStacked(tsOptionsArray, tsGroupsArray);
  	let DygraphOptionsStacked = tsArrayToOptionsArrayRaw(splittedTsArray.stacked.tsOptionsArray, splittedTsArray.stacked.tsGroupsArray, groupsOptionsMode, tsCompare);
  	let DygraphOptionsNotStacked = tsArrayToOptionsArrayRaw(splittedTsArray.not_stacked.tsOptionsArray, splittedTsArray.not_stacked.tsGroupsArray, groupsOptionsMode, tsCompare);
  	//console.log([...DygraphOptionsStacked, ...DygraphOptionsNotStacked])
  	return [...DygraphOptionsStacked, ...DygraphOptionsNotStacked];
  }

  function splitTsArrayStacked(tsOptionsArray, tsGroupsArray) {
  	let tsOptionsArrayStacked = [];
  	let tsGroupsArrayStacked = [];
  	let tsOptionsArrayNotStacked = [];
  	let tsGroupsArrayNotStacked = [];
  	tsGroupsArray.forEach((tsGroup, i) => {
  		if (tsGroup.metric.draw_stacked == true) {
  			tsOptionsArrayStacked.push(tsOptionsArray[i]);
  			tsGroupsArrayStacked.push(tsGroup);
  		} else {
  			tsOptionsArrayNotStacked.push(tsOptionsArray[i]);
  			tsGroupsArrayNotStacked.push(tsGroup);
  		}
  	});
  	return {
  		stacked: {
  			tsOptionsArray: tsOptionsArrayStacked,
  			tsGroupsArray: tsGroupsArrayStacked,
  		},
  		not_stacked: {
  			tsOptionsArray: tsOptionsArrayNotStacked,
  			tsGroupsArray: tsGroupsArrayNotStacked,
  		},
  	};
  }

  function tsArrayToOptionsArrayRaw(tsOptionsArray, tsGroupsArray, groupsOptionsMode, tsCompare) {
  	let useFullName = false;
  	if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart_x_yaxis"].value) {
  		let tsDict = {};
  		tsGroupsArray.forEach((tsGroup, i) => {
  			let yaxisId = getYaxisId(tsGroup.metric);
  			let tsEl = { tsGroup, tsOptions: tsOptionsArray[i] };
  			if (tsDict[yaxisId] == null) {
  				tsDict[yaxisId] = [tsEl];
  			} else {
  				tsDict[yaxisId].push(tsEl);
  			}
  		});
  		useFullName = tsGroupsArray.length > 1 || (tsGroupsArray.length > 0
  			&& tsGroupsArray[0].source_type.display_full_name === true);
  		let DygraphOptionsArray = [];
  		for (let key in tsDict) {
  			let tsArray = tsDict[key];
  			let tsOptionsArray2 = tsArray.map((ts) => ts.tsOptions);
  			let tsGroupsArray2 = tsArray.map((ts) => ts.tsGroup);
  			let DygraphOptions = tsArrayToOptions(tsOptionsArray2, tsGroupsArray2, tsCompare, useFullName);
  			DygraphOptionsArray.push(DygraphOptions);
  		}
  		return DygraphOptionsArray;
  	} else if (groupsOptionsMode.value == groupsOptionsModesEnum["1_chart_x_metric"].value) {
  		useFullName = tsOptionsArray.length > 1 || (tsGroupsArray.length > 0
  			&& tsGroupsArray[0].source_type.display_full_name === true);
  		let optionsArray = [];
  		tsOptionsArray.forEach((tsOptions, i) => {
  			let options = tsArrayToOptions([tsOptions], [tsGroupsArray[i]], tsCompare, useFullName);
  			optionsArray.push(options);
  		});
  		return optionsArray;
  	}
  	return [];
  }

  /* *********************************************** */

  /* This function is used to format a simple timeseries given an array 
   */
  function formatSimpleSerie(data, serie_name, chart_type, formatters, value_range) {
  	return dygraphFormat.formatSimpleSerie(data, serie_name, chart_type, formatters, value_range);
  }

  /* *********************************************** */

  /* Given an array of timeseries, it compacts them into a single array 
   * and return the configuration for the timeserie with the data 
   */
  function tsArrayToOptions(tsOptionsArray, tsGroupsArray, tsCompare, useFullName) {
  	return dygraphFormat.formatSerie(tsOptionsArray, tsGroupsArray, tsCompare, useFullName);
  }

  /* *********************************************** */

  function getTsQuery(tsGroup, not_metric_query, enable_source_def_value_dict) {
  	let tsQuery = tsGroup.source_type.source_def_array.map((source_def, i) => {
  		if (enable_source_def_value_dict != null && !enable_source_def_value_dict[source_def.value]) { return null; }
  		let source_value = tsGroup.source_array[i].value;
  		return `${source_def.value}:${source_value}`;
  	}).filter((s) => s != null).join(",");

  	if (!not_metric_query && tsGroup.metric.query != null) {
  		tsQuery = `${tsQuery},${tsGroup.metric.query}`;
  	}
  	return tsQuery;
  }

  function getMainSourceDefIndex(tsGroup) {
  	let source_def_array = tsGroup.source_type.source_def_array;
  	for (let i = 0; i < source_def_array.length; i += 1) {
  		let source_def = source_def_array[i];
  		if (source_def.main_source_def == true) { return i; }
  	}
  	return 0;

  }

  function getTsChartsDataUrl(httpPrefix, epochStatus, tsCompare, timeseriesGroups, isPro) {
  	let paramsEpochObj = { epoch_begin: epochStatus.epoch_begin, epoch_end: epochStatus.epoch_end };
  	let url_and_body = {};
  	if (!isPro) {
  		let tsDataUrl = `${httpPrefix}/lua/rest/v2/get/timeseries/ts.lua`;
  		let paramsUrlRequest = `ts_compare=${tsCompare}&version=4&zoom=${tsCompare}&limit=180`;
  		let tsGroup = timeseriesGroups[0];
  		let main_source_index = getMainSourceDefIndex(tsGroup);
  		let tsQuery = getTsQuery(tsGroup);
  		let pObj = {
  			...paramsEpochObj,
  			ts_query: tsQuery,
  			ts_schema: `${tsGroup.metric.schema}`,
  		};
  		if (!tsGroup.source_type.source_def_array[main_source_index].disable_tskey) {
  			pObj.tskey = tsGroup.source_array[main_source_index].value;
  		}
  		let pUrlRequest = ntopng_url_manager$1.add_obj_to_url(pObj, paramsUrlRequest);
  		url_and_body.url = `${tsDataUrl}?${pUrlRequest}`;
  	} else {
  		let paramsChart = {
  			zoom: tsCompare,
  			limit: 180,
  			version: 4,
  			ts_compare: tsCompare,
  		};

  		let tsRequests = timeseriesGroups.map((tsGroup) => {
  			let main_source_index = getMainSourceDefIndex(tsGroup);
  			let tsQuery = getTsQuery(tsGroup);
  			let pObj = {
  				ts_query: tsQuery,
  				ts_schema: `${tsGroup.metric.schema}`,
  			};
  			if (!tsGroup.source_type.source_def_array[main_source_index].disable_tskey) {
  				pObj.tskey = tsGroup.source_array[main_source_index].value;
  			}
  			return pObj;
  		});			
  		url_and_body.url = `${httpPrefix}/lua/pro/rest/v2/get/timeseries/ts_multi.lua`;
  		url_and_body.body = { ts_requests: tsRequests, ...paramsEpochObj, ...paramsChart };
  	}

  	return url_and_body;
  }

  async function getTsChartsOptions(httpPrefix, epochStatus, tsCompare, timeseriesGroups, isPro) {

  	let tsChartsOptions;
  	const url_and_body = getTsChartsDataUrl(httpPrefix, epochStatus, tsCompare, timeseriesGroups, isPro);

  	if (!isPro) {
  		let tsChartOption = await ntopng_utility$1.http_request(url_and_body.url);
  		tsChartsOptions = [tsChartOption];
  	} else {
  		let headers = {
  			'Content-Type': 'application/json'
  		};
  		tsChartsOptions = await ntopng_utility$1.http_request(url_and_body.url, { method: 'post', headers, body: JSON.stringify(url_and_body.body) });
  	}
  	return tsChartsOptions;
  }

  const timeseriesUtils = function () {
  	return {
  		groupsOptionsModesEnum,
  		tsArrayToOptions,
  		formatSimpleSerie,
  		tsArrayToOptionsArray,
  		getGroupOptionMode,
  		getSerieId,
  		getSerieName,
  		getTsChartsOptions,
  		getTsChartsDataUrl,
  		getTsQuery,
  		getMainSourceDefIndex,
  	};
  }();

  const _withScopeId$4 = n => (pushScopeId("data-v-103cd911"),n=n(),popScopeId(),n);
  const _hoisted_1$18 = { class: "nav nav-tabs" };
  const _hoisted_2$11 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_3$$ = { class: "form-group row" };
  const _hoisted_4$X = { class: "col-form-label col-sm-4" };
  const _hoisted_5$R = { class: "col-sm-8" };
  const _hoisted_6$H = {
    key: 0,
    class: "form-group ms-2 me-2 mb-2 mt-3 row"
  };
  const _hoisted_7$E = { class: "form-group row" };
  const _hoisted_8$D = { class: "col-form-label col-sm-4" };
  const _hoisted_9$v = { class: "col-sm-8" };
  const _hoisted_10$s = ["title"];
  const _hoisted_11$p = {
    key: 0,
    class: "form-group mt-2 row"
  };
  const _hoisted_12$o = { class: "col-form-label col-sm-4" };
  const _hoisted_13$i = { class: "col-sm-8" };
  const _hoisted_14$f = {
    key: 1,
    class: "form-group mt-2 row"
  };
  const _hoisted_15$d = { class: "col-form-label col-sm-4" };
  const _hoisted_16$d = { class: "col-sm-8" };
  const _hoisted_17$c = ["onInput", "onUpdate:modelValue", "pattern"];
  const _hoisted_18$c = {
    key: 2,
    class: "form-group mt-2 row"
  };
  const _hoisted_19$c = { class: "col-form-label col-sm-4" };
  const _hoisted_20$c = { class: "col-sm-7" };
  const _hoisted_21$8 = ["onInput", "onUpdate:modelValue", "pattern"];
  const _hoisted_22$8 = { class: "col-sm-1" };
  const _hoisted_23$7 = ["onClick", "title", "disabled"];
  const _hoisted_24$7 = /*#__PURE__*/ _withScopeId$4(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-refresh" }, null, -1 /* HOISTED */));
  const _hoisted_25$6 = [
    _hoisted_24$7
  ];
  const _hoisted_26$6 = {
    class: "form-group row mt-2",
    style: {"text-align":"end"}
  };
  const _hoisted_27$6 = { class: "col-sm-12" };
  const _hoisted_28$4 = ["disabled"];
  const _hoisted_29$4 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_30$3 = { class: "form-group row" };
  const _hoisted_31$3 = { class: "col-form-label col-sm-4" };
  const _hoisted_32$3 = { class: "col-sm-8" };
  const _hoisted_33$3 = ["disabled"];


  var script$1i = {
    __name: 'modal-timeseries',
    props: {
      sources_types_enabled: Object,
  },
    emits: ['apply'],
    setup(__props, { expose, emit }) {

  const props = __props;



  const modal_id = ref(null);
  const select_search_metrics = ref(null);

  const showed = () => {};

  const action = ref("select"); // add/select 

  let current_page_source_type = metricsManager.get_current_page_source_type();

  const sources_types = metricsManager.sources_types;
  const selected_source_type = ref(current_page_source_type);

  const ui_types = metricsManager.ui_types;
  const sources_array = ref([]); // array of sources, each element is the sources list of source_type.source_def_array[i]
  const selected_source_array = ref([]);
  const selected_source_text_array = ref([]); // array of source_value binding with input text
  // const sub_sources = ref([]);
  // const selected_sub_source = ref({});
  const selected_sources_union_label = ref("");
  const source_text_validation_array = ref ([]);

  const is_selected_source_changed = ref(false);
  const enable_apply_source = computed$1(() => {
      if (is_selected_source_changed.value == false) {
  	return false;
      }
      for (let i = 0; i < source_text_validation_array.value.length; i += 1) {
  	let rg_text = source_text_validation_array.value[i];
  	if (rg_text == null) { continue; }
  	let regex = new RegExp(rg_text);
  	let source_text = selected_source_text_array.value[i];
  	if (regex.test(source_text) == false) {
  	    return false;
  	}	
      }
      return true;
  });
  const hide_sources = ref(false);

  const metrics = ref([]);
  const selected_metric = ref({});

  const timeseries_groups_added = ref([]);

  const timeseries_to_add = ref([]);



  let wait_init = null;

  onBeforeMount(() => {
      sources_types.forEach((source_type) => {
  	props.sources_types_enabled[source_type.id];
      });    
  });

  onMounted(async () => {
      wait_init = init();
  });

  const show = async (timeseries_groups) => {
      timeseries_groups_added.value = timeseries_groups;
      await wait_init;
      action.value = "select";
      modal_id.value.show();
  };

  function change_action(a) {
      action.value = a;
  }

  async function change_source_type() {
      is_selected_source_changed.value = false;
      set_regex();
      set_hide_sources();
      await set_sources_array();
      await set_metrics();
  }

  function set_hide_sources() {
      let source_type = selected_source_type.value;
      hide_sources.value = source_type.source_def_array.map((sd) => sd.ui_type == ui_types.hide).every((hide) => hide == true);
  }

  async function apply_source_array() {
      is_selected_source_changed.value = false;
      selected_source_text_array.value.forEach((source_value, i) => {
  	let source_def = selected_source_type.value.source_def_array[i];
  	if (source_def.ui_type == ui_types.input) {
  	    let source = selected_source_array.value[i];
              set_source_input(source, source_value);
  	}
      });    
      await change_source_array();
      set_selected_sources_union_label();
  }

  function set_source_input(source, source_value) {
      source.value = source_value;
      source.label = source_value;
  }

  async function change_source_array() {
      // reload metrics 
      await set_metrics();
  }

  function change_selected_source(source_def, source_def_index, force_reload_sources) {
      is_selected_source_changed.value = true;
      if (force_reload_sources == true) {
          reload_sources(source_def, source_def_index);
      }
  }

  // reload all sources for each source_def with refresh_on_sources_change == true
  async function reload_sources(source_def, source_def_index) {
      if (source_def.ui_type == ui_types.input_confirm) {
          set_source_input(selected_source_array.value[source_def_index], selected_source_text_array.value[source_def_index]);
      }
      let source_def_array = selected_source_type.value.source_def_array;
      let source_value_array = selected_source_array.value.map((s) => s.value);
      for (let i = source_def_index + 1; i < source_def_array.length; i += 1) {
          const source_def = source_def_array[i];
          if (!source_def.refresh_on_sources_change) { continue; }

          let sources = await metricsManager.get_sources(http_prefix, selected_source_type.value.id, source_def, source_value_array);
          sources_array.value[i] = sources;
          if (sources.length > 0) {
              selected_source_array.value[i] = sources[0];
          } else {
              selected_source_array.value[i] = { label: "", value: "" };
              console.warn(`No sources availables to select for ${selected_source_type.value.id} sorce_def`);
          }
      }
  }

  function set_regex() {
      let regex_source_array = selected_source_type.value?.source_def_array.map((source_def) => source_def.regex_type);
      if (regex_source_array == null) { regex_source_array = []; }
      source_text_validation_array.value = regex_source_array.map((regex_source) => {
  	if (regex_source == null) { return  null; }
  	return regexValidation.get_data_pattern(regex_source);
      });
  }

  function get_selected_sources_union_label() {
      let source_label_array = selected_source_array.value.filter((source) => source.label != null && source.label != "").map((source) => source.label);
      let label = source_label_array.join(" - ");
      return `${label}`;
  }

  function set_selected_sources_union_label() {
      selected_sources_union_label.value = get_selected_sources_union_label();
  }

  async function set_sources_array() {
      let source_def_array = selected_source_type.value.source_def_array;
      let sources_array_temp = [];
      let default_source_array = await metricsManager.get_default_source_array(http_prefix, selected_source_type.value);
      let default_soruce_value_array = default_source_array.map((s) => s.value);
      for (let i = 0; i < source_def_array.length; i += 1) {
  	let sources = await metricsManager.get_sources(http_prefix, selected_source_type.value.id, source_def_array[i], default_soruce_value_array);
  	sources_array_temp.push(sources);
      }
      selected_source_array.value = default_source_array;
      sources_array.value = sources_array_temp;
      selected_source_text_array.value = default_soruce_value_array;
      set_selected_sources_union_label();
  }

  async function set_metrics() {
      metrics.value = await metricsManager.get_metrics(http_prefix, selected_source_type.value, selected_source_array.value);
      metrics.value.sort(NtopUtils.sortAlphabetically);
      selected_metric.value = metricsManager.get_default_metric(metrics.value);
      update_timeseries_to_add();    
  }

  async function init() {
      await change_source_type();
      // take default visible
      update_timeseries_to_add();
      //emit('apply', timeseries_groups_added.value);
  }

  function update_timeseries_to_add(default_config) {
      timeseries_to_add.value = [];
      let timeseries = selected_metric.value.timeseries;
      for (let ts_id in timeseries) {
      	timeseries_to_add.value.push({
      	    id: ts_id,
      	    label: timeseries[ts_id].label,
      	    raw: true,
  	    past: false,
      	    avg: false,
      	    perc_95: false,
      	});
      }
  }

  function get_timeseries_group_name(ts_group) {
      let source_type_name = ts_group.source_type.label;
      let source_def_index = timeseriesUtils.getMainSourceDefIndex(ts_group);
      let source = ts_group.source_array[source_def_index];
      let source_name = source.label;
      let metric_name = ts_group.metric.label;
      return `${source_type_name} - ${source_name} - ${metric_name}`;
  }

  function get_timeseries_group_id(ts_group) {
      let source_type, source_array, metric;
      if (ts_group == null) {
  	source_type = selected_source_type.value;
  	source_array = selected_source_array.value;
  	metric = selected_metric.value;
      } else {
  	source_type = ts_group.source_type;
  	source_array = ts_group.source_array;
  	metric = ts_group.metric;
      }
      let id = metricsManager.get_ts_group_id(source_type, source_array, metric);
      return id;
  }

  const delete_ts = (ts_group_id) => {
      timeseries_groups_added.value = timeseries_groups_added.value.filter((ts_group) => get_timeseries_group_id(ts_group) != ts_group_id);
  };

  const set_timeseries_groups = (timeseries_groups, emit_apply) => {
      timeseries_groups_added.value = timeseries_groups;
      if (emit_apply) {
  	emit('apply', timeseries_groups_added.value);
      }
  };

  const add_ts_group = (ts_group_to_add, emit_apply) => {
      let ts_group_index = timeseries_groups_added.value.findIndex((ts_group) => ts_group.id == ts_group_to_add.id);
      if (ts_group_index < 0) {
  	timeseries_groups_added.value.push(ts_group_to_add);
      } else {
  	timeseries_groups_added.value[ts_group_index] = ts_group_to_add;
      }

      if (emit_apply) {
  	emit('apply', timeseries_groups_added.value);
      }
  };

  const apply = () => {
      if (action.value == "add") {
  	let ts_group_id = get_timeseries_group_id();
  	let ts_group = {
  	    id: ts_group_id,
  	    source_type: selected_source_type.value,
  	    source_array: ntopng_utility$1.clone(selected_source_array.value),
  	    metric: selected_metric.value,
  	    timeseries: ntopng_utility$1.clone(timeseries_to_add.value),
  	};
  	add_ts_group(ts_group);
      }
      emit('apply', timeseries_groups_added.value);
      close();
  };

  const close = () => {
      modal_id.value.close();
  };
  const _i18n = (t) => i18n(t);

  expose({ show, close, add_ts_group, set_timeseries_groups });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[8] || (_cache[8] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("modal_timeseries.title")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("ul", _hoisted_1$18, [
          createBaseVNode("li", {
            class: "nav-item",
            onClick: _cache[0] || (_cache[0] = $event => (change_action('add')))
          }, [
            createBaseVNode("a", {
              class: normalizeClass(["nav-link", {'active': action.value == 'add'}]),
              href: "#"
            }, toDisplayString(_i18n("modal_timeseries.add_timeseries")), 3 /* TEXT, CLASS */)
          ]),
          createBaseVNode("li", {
            class: "nav-item",
            onClick: _cache[1] || (_cache[1] = $event => (change_action('select')))
          }, [
            createBaseVNode("a", {
              class: normalizeClass(["nav-link", {'active': action.value == 'select' }]),
              href: "#"
            }, toDisplayString(_i18n("modal_timeseries.manage_timeseries")), 3 /* TEXT, CLASS */)
          ])
        ]),
        createCommentVNode(" action add "),
        (action.value == 'add')
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" Sources Types "),
              createBaseVNode("div", _hoisted_2$11, [
                createBaseVNode("div", _hoisted_3$$, [
                  createBaseVNode("label", _hoisted_4$X, [
                    createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source_type")), 1 /* TEXT */)
                  ]),
                  createBaseVNode("div", _hoisted_5$R, [
                    createVNode(script$1I, {
                      selected_option: selected_source_type.value,
                      "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_source_type).value = $event)),
                      onSelect_option: _cache[3] || (_cache[3] = $event => (change_source_type())),
                      options: unref(sources_types)
                    }, null, 8 /* PROPS */, ["selected_option", "options"])
                  ])
                ])
              ]),
              createCommentVNode(" Sources "),
              (!hide_sources.value)
                ? (openBlock(), createElementBlock("div", _hoisted_6$H, [
                    createBaseVNode("div", _hoisted_7$E, [
                      createBaseVNode("label", _hoisted_8$D, [
                        createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.source")), 1 /* TEXT */)
                      ]),
                      createBaseVNode("div", _hoisted_9$v, [
                        withDirectives(createBaseVNode("input", {
                          class: "form-control",
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((selected_sources_union_label).value = $event)),
                          title: selected_sources_union_label.value,
                          style: {"overflow":"hidden","text-overflow":"ellipsis","white-space":"nowrap"},
                          type: "text",
                          disabled: ""
                        }, null, 8 /* PROPS */, _hoisted_10$s), [
                          [vModelText, selected_sources_union_label.value]
                        ])
                      ])
                    ]),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(selected_source_type.value.source_def_array, (source_def, source_def_index) => {
                      return (openBlock(), createElementBlock(Fragment, null, [
                        createCommentVNode(" select "),
                        (source_def.ui_type == unref(ui_types).select)
                          ? (openBlock(), createElementBlock("div", _hoisted_11$p, [
                              createBaseVNode("label", _hoisted_12$o, [
                                createBaseVNode("b", null, toDisplayString(source_def.label), 1 /* TEXT */)
                              ]),
                              createBaseVNode("div", _hoisted_13$i, [
                                createVNode(script$1I, {
                                  selected_option: selected_source_array.value[source_def_index],
                                  "onUpdate:selected_option": $event => ((selected_source_array.value[source_def_index]) = $event),
                                  onSelect_option: $event => (change_selected_source(source_def, source_def_index, true)),
                                  options: sources_array.value[source_def_index]
                                }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "onSelect_option", "options"])
                              ])
                            ]))
                          : createCommentVNode("v-if", true),
                        createCommentVNode(" end select "),
                        createCommentVNode(" input text "),
                        (source_def.ui_type == unref(ui_types).input)
                          ? (openBlock(), createElementBlock("div", _hoisted_14$f, [
                              createBaseVNode("label", _hoisted_15$d, [
                                createBaseVNode("b", null, toDisplayString(source_def.label), 1 /* TEXT */)
                              ]),
                              createBaseVNode("div", _hoisted_16$d, [
                                withDirectives(createBaseVNode("input", {
                                  class: "form-control",
                                  onInput: $event => (change_selected_source(source_def, source_def_index)),
                                  "onUpdate:modelValue": $event => ((selected_source_text_array.value[source_def_index]) = $event),
                                  pattern: source_text_validation_array.value[source_def_index],
                                  required: "",
                                  type: "text",
                                  placeholder: ""
                                }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_17$c), [
                                  [vModelText, selected_source_text_array.value[source_def_index]]
                                ])
                              ])
                            ]))
                          : createCommentVNode("v-if", true),
                        createCommentVNode(" input text "),
                        createCommentVNode(" input confirm text "),
                        (source_def.ui_type == unref(ui_types).input_confirm)
                          ? (openBlock(), createElementBlock("div", _hoisted_18$c, [
                              createBaseVNode("label", _hoisted_19$c, [
                                createBaseVNode("b", null, toDisplayString(source_def.label), 1 /* TEXT */)
                              ]),
                              createBaseVNode("div", _hoisted_20$c, [
                                withDirectives(createBaseVNode("input", {
                                  class: "form-control",
                                  onInput: $event => (change_selected_source(source_def, source_def_index)),
                                  "onUpdate:modelValue": $event => ((selected_source_text_array.value[source_def_index]) = $event),
                                  pattern: source_text_validation_array.value[source_def_index],
                                  required: "",
                                  type: "text",
                                  placeholder: ""
                                }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_21$8), [
                                  [vModelText, selected_source_text_array.value[source_def_index]]
                                ])
                              ]),
                              createBaseVNode("div", _hoisted_22$8, [
                                createBaseVNode("button", {
                                  type: "button",
                                  class: "btn btn-link btn-sm",
                                  onClick: $event => (reload_sources(source_def, source_def_index)),
                                  title: _i18n(source_def.refresh_i18n),
                                  disabled: !unref(enable_apply_source)
                                }, _hoisted_25$6, 8 /* PROPS */, _hoisted_23$7)
                              ])
                            ]))
                          : createCommentVNode("v-if", true),
                        createCommentVNode(" input confirm text ")
                      ], 64 /* STABLE_FRAGMENT */))
                    }), 256 /* UNKEYED_FRAGMENT */)),
                    withDirectives(createBaseVNode("div", _hoisted_26$6, [
                      createBaseVNode("div", _hoisted_27$6, [
                        createBaseVNode("button", {
                          type: "button",
                          onClick: apply_source_array,
                          disabled: unref(enable_apply_source) == false,
                          class: "btn btn-primary"
                        }, toDisplayString(_i18n("modal_timeseries.apply_source")), 9 /* TEXT, PROPS */, _hoisted_28$4)
                      ])
                    ], 512 /* NEED_PATCH */), [
                      [vShow, unref(enable_apply_source)]
                    ])
                  ]))
                : createCommentVNode("v-if", true),
              createCommentVNode(" end Sources "),
              createCommentVNode(" Metrics "),
              createBaseVNode("div", _hoisted_29$4, [
                createBaseVNode("div", _hoisted_30$3, [
                  createBaseVNode("label", _hoisted_31$3, [
                    createBaseVNode("b", null, toDisplayString(_i18n("modal_timeseries.metric")), 1 /* TEXT */)
                  ]),
                  createBaseVNode("div", _hoisted_32$3, [
                    createVNode(script$1I, {
                      ref_key: "select_search_metrics",
                      ref: select_search_metrics,
                      onSelect_option: _cache[5] || (_cache[5] = $event => (update_timeseries_to_add())),
                      selected_option: selected_metric.value,
                      "onUpdate:selected_option": _cache[6] || (_cache[6] = $event => ((selected_metric).value = $event)),
                      options: metrics.value
                    }, null, 8 /* PROPS */, ["selected_option", "options"])
                  ])
                ])
              ]),
              createVNode(script$1j, {
                title: _i18n('modal_timeseries.timeseries_list'),
                timeseries: timeseries_to_add.value,
                "onUpdate:timeseries": _cache[7] || (_cache[7] = $event => ((timeseries_to_add).value = $event))
              }, null, 8 /* PROPS */, ["title", "timeseries"])
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" action == add "),
        createCommentVNode(" action select"),
        (action.value == 'select')
          ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(timeseries_groups_added.value, (item) => {
                return (openBlock(), createBlock(script$1j, {
                  id: get_timeseries_group_id(item),
                  title: get_timeseries_group_name(item),
                  timeseries: item.timeseries,
                  "onUpdate:timeseries": $event => ((item.timeseries) = $event),
                  show_delete_button: timeseries_groups_added.value.length > 1,
                  onDelete_ts: delete_ts
                }, null, 8 /* PROPS */, ["id", "title", "timeseries", "onUpdate:timeseries", "show_delete_button"]))
              }), 256 /* UNKEYED_FRAGMENT */)),
              createCommentVNode(" v-for timeseries_groups_added ")
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" action == select ")
      ]),
      footer: withCtx(() => [
        withDirectives(createBaseVNode("button", {
          type: "button",
          onClick: apply,
          disabled: unref(enable_apply_source),
          class: "btn btn-primary"
        }, toDisplayString(_i18n("modal_timeseries.add")), 9 /* TEXT, PROPS */, _hoisted_33$3), [
          [vShow, action.value == 'add']
        ]),
        withDirectives(createBaseVNode("button", {
          type: "button",
          onClick: apply,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("modal_timeseries.apply")), 513 /* TEXT, NEED_PATCH */), [
          [vShow, action.value == 'select']
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$f = "\ninput[data-v-103cd911]:invalid {\n  border-color: #ff0000;\n}\n.custom-margin[data-v-103cd911] {\nmargin-left: -0.4rem;\n}\n.warn[data-v-103cd911] {\nborder-color: #ffd500;\nborder-style: solid;\n}\n";
  styleInject(css_248z$f);

  script$1i.__scopeId = "data-v-103cd911";
  script$1i.__file = "http_src/vue/modal-timeseries.vue";

  const _hoisted_1$17 = { class: "form-group mt-2 row" };
  const _hoisted_2$10 = { class: "col-form-label col-sm-4" };
  const _hoisted_3$_ = { class: "col-sm-6" };
  const _hoisted_4$W = { class: "col-form-label col-sm-2" };
  const _hoisted_5$Q = ["disabled"];


  var script$1h = {
    __name: 'modal-download-file',
    props: {
    title: String,
    ext: String,
  },
    emits: ["download"],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const filename = ref("");
  const filename_validation = String.raw`^[a-zA-Z_\-1-9]*$`;

  const enable_download = computed$1(() => {
    let rg_text = filename_validation;
    let regex = new RegExp(rg_text);
    return regex.test(filename.value);
  });






  const show = (name) => {
    if (name == null) { name = ""; }
    /* Replace all characters with _ for EXCEPT number and letters */
    name = name.replaceAll(/[^a-zA-Z0-9]/g, '_');
    filename.value = name;
    modal_id.value.show();
  };

  function download() {
    let name = `${filename.value}.${props.ext}`;
    emit('download', name);
    close();
  }

  const close = () => {
    modal_id.value.close();
  };

  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$17, [
          createBaseVNode("label", _hoisted_2$10, [
            createBaseVNode("b", null, toDisplayString(_i18n("modal_download_file.filename")) + ":", 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$_, [
            withDirectives(createBaseVNode("input", {
              class: "form-control",
              pattern: filename_validation,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((filename).value = $event)),
              type: "text",
              required: ""
            }, null, 512 /* NEED_PATCH */), [
              [vModelText, filename.value]
            ])
          ]),
          createBaseVNode("label", _hoisted_4$W, " ." + toDisplayString(props.ext), 1 /* TEXT */)
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: download,
          class: "btn btn-primary",
          disabled: unref(enable_download) == false
        }, toDisplayString(_i18n("modal_download_file.download")), 9 /* TEXT, PROPS */, _hoisted_5$Q)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$e = "\ninput[data-v-59120eb8]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-59120eb8] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$e);

  script$1h.__scopeId = "data-v-59120eb8";
  script$1h.__file = "http_src/vue/modal-download-file.vue";

  const _hoisted_1$16 = { key: 0 };
  const _hoisted_2$$ = { class: "text-center" };
  const _hoisted_3$Z = /*#__PURE__*/createBaseVNode("tbody", null, null, -1 /* HOISTED */);


  var script$1g = {
    __name: 'datatable',
    props: {
  	id: String,
  	table_buttons: Array,
  	columns_config: Array,
  	data_url: String,
  	enable_search: Boolean,
  	filter_buttons: {
  type: Array,
  required: false,
  	},
  	table_config: {
  type: Object,
  required: false,
  	},
  	base_url: String,
  	base_params: Object, 
  },
    emits: ['drawed'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const instance = getCurrentInstance();

  const slots = useSlots();




  /* Add last sorting preferences to the browser cache in order to reload it the next time */
  const save_last_sort = (last_sorting, id) => {
  	if(id || props.id) {
  		/* Do not save the sorting if the direction is undefined */
  		if(last_sorting.dir != undefined) {
  			const sorting_pref = [last_sorting.col, last_sorting.dir];
  			const sorting_key = `${id || props.id}_sorting_preferences`;
  			
  			/* Use the local storage for the sorting preferences */
  			localStorage.setItem(sorting_key, sorting_pref);
  		}
  	}
  };

  const load_last_sort = (id) => {
  	let sorting_pref = null;
  	if(id || props.id) {
  		const sorting_key = `${id || props.id}_sorting_preferences`;

  		/* Use the local storage for the sorting preferences */
  		const unformatted_pref = localStorage.getItem(sorting_key);
  		if(unformatted_pref) {
  			const splitted_pref = unformatted_pref.split(',');
  			if(splitted_pref.length == 2) {
  				sorting_pref = [ Number(splitted_pref[0]), splitted_pref[1] ];
  			}
  		}
  	}

  	return sorting_pref;
  };

  let new_params = props.base_params;
  const table_id = ref(null);
  /* In case no sorting is provided use the default_sorting */
  const last_sorting = load_last_sort() || [0, "asc"];

  function loadDatatable() {
      let updated = false;
      /* Create a datatable with the buttons */
      let extend_config = {
  	serverSide: false,
  	scrollX: false,
  	destroy: true,
  	searching: props.enable_search,
  	order: [last_sorting],
  	pagingType: 'full_numbers',
  	//columnDefs: props.columns_config,
  	columns: props.columns_config,
  	autoWidth: false,
  	responsive: true,
  	ajax: {
  	    method: 'get',
  	    url: props.data_url,
  	    dataSrc: 'rsp',
  	    data: (data, settings) => {
  		if(Object.keys(data).length == 0) {
  		    return;
  		}
  		
  		const tableApi = settings.oInstance.api();
  		const orderColumnIndex = data.order[0].column;
  		const orderColumnName = tableApi.column(orderColumnIndex).name() || undefined;
  		
  		if (data.order) {
  		    data.order = data.order[0].dir;
  		    data.sort = orderColumnName;
  		}
  		
  		if (data.columns !== undefined) {
  		    delete data.columns;
  		}
  		
  		if (data.search !== undefined) {
  		    data.map_search = data.search.value;
  		    delete data.search;
  		}
  		
  		return data;
  	    },
  	    beforeSend: function() {
  		NtopUtils.showOverlays();
  	    },
  	},
  	drawCallback: function (settings) {
  	    NtopUtils.hideOverlays();
  	    emit('drawed');
  	    ntopng_events_manager.emit_custom_event(ntopng_custom_events.DATATABLE_LOADED);		 
  		 save_last_sort(settings.aLastSort[0]);
  	}
      };
      for (const item in (props.table_config || {})) {
  	extend_config[item] = props.table_config[item];
      }
      
      let config = DataTableUtils.getStdDatatableConfig(props.table_buttons);
      config = DataTableUtils.extendConfig(config, extend_config);
      table = $(table_id.value).DataTable(config);
  	 load_table_menu();
      for (const filter of (props.filter_buttons || [])) {
  	/* Set filters to active if available in the url */
  	const curr_value = ntopng_url_manager$1.get_url_entry(filter.filterMenuKey);
  	if(curr_value && curr_value != '') {
  	    let num_non_active_entries = 0;
  	    filter.filters.forEach((i) => {
  		i.currently_active = false;
  		num_non_active_entries += 1;
  		if(i.id == curr_value) {
  		    i.currently_active = true;
  		    num_non_active_entries -= 1;
  		}
  	    });
  	    
  	    if(num_non_active_entries == filter.filters.length) {
  		ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, '');
  		updated = true;
  	    }
  	}
  	
  	new DataTableFiltersMenu({
  	    filterTitle: filter.filterTitle,
  	    tableAPI: table,
  	    filters: filter.filters,
  	    filterMenuKey: filter.filterMenuKey,
  	    columnIndex: filter.columnIndex,
  	    url: props.data_url,
  	    id: filter.id,
  	    removeAllEntry: filter.removeAllEntry,
  	    callbackFunction: filter.callbackFunction
  	}).init();
      }
      
      if(updated && props.base_params) {
  	const entries = ntopng_url_manager$1.get_url_entries();
  	for(const [key, value] of (entries)) {
  	    new_params[key] = value;
  	}
  	table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, new_params));
  	reload();
      }
  }

  let table = null;
  onMounted(() => {
      loadDatatable();
  });

  function get_table_default_menu() {
      if (table == null) { return; }
      let table_wrapper = $(table.context[0].nTableWrapper);
      return $($(".row .text-end", table_wrapper).children()[0]);}

  function search_value(value_to_search) {
  	if (table == null) { return; }
  	table.search(value_to_search).draw();
  }

  let table_default_menu = null;
  function load_table_menu() {
      if (table_default_menu == null) {
  	table_default_menu = get_table_default_menu();
      }
      if (slots == null || slots.menu == null) { return; }
      let menu_array = slots.menu();
      if (menu_array == null || menu_array.length == 0) { return; }
      let node = slots.menu()[0];
      let element = $("<div class='d-inline-block'></div>")[0];
      const { vNode, el } = render_component(node, { app:  instance?.appContext?.app, element });
      // const { vNode, el } = render_component(Test, { app:  instance.appContext.app });
      let table_wrapper = $(table.context[0].nTableWrapper);
      $($(".row .text-end", table_wrapper).children()[0]).append(el);
  }

  const reload = () => {
      if (table == null) { return; }
      table.ajax.reload();
  };

  const update_url = (new_url) => {
      if (table == null) { return; }
      table.ajax.url(new_url);
  };

  const delete_button_handlers = (handlerId) => {
      DataTableUtils.deleteButtonHandlers(handlerId);
  };

  let is_destroyed = false;

  const destroy_table = () => {
      table.clear();
      table.destroy(true);
      is_destroyed = true;
      props.columns_config.filter((config) => config.handlerId != null).forEach((config) => {
  	delete_button_handlers(config.handlerId);
      });
  };

  const refresh_menu = () => {
      let table_wrapper = $(table.context[0].nTableWrapper);
      $($(".row .text-end", table_wrapper).children()[0]).html("");
      load_table_menu();
  };

  const is_last_sorting_available = (id) => {
  	return load_last_sort(id) != null;
  };

  expose({ reload, delete_button_handlers, destroy_table, update_url, refresh_menu, is_last_sorting_available, load_last_sort, save_last_sort, search_value });

  onBeforeUnmount(() => {
      if (is_destroyed == true) { return; }
      destroy_table();
      // table.destroy(true);
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      (openBlock(), createElementBlock("div", _hoisted_1$16, [
            createCommentVNode(" <slot name=\"menu\"></slot> ")
          ]))
        ,
      createBaseVNode("div", null, [
        createBaseVNode("table", {
          ref_key: "table_id",
          ref: table_id,
          class: "table w-100 table-striped table-hover table-bordered"
        }, [
          createBaseVNode("thead", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns_config, (item) => {
                return (openBlock(), createElementBlock("th", _hoisted_2$$, toDisplayString(item.columnName), 1 /* TEXT */))
              }), 256 /* UNKEYED_FRAGMENT */))
            ])
          ]),
          _hoisted_3$Z
        ], 512 /* NEED_PATCH */)
      ])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$1g.__file = "http_src/vue/datatable.vue";

  const _hoisted_1$15 = {
    key: 0,
    class: "table table-striped table-bordered col-sm-12",
    style: {}
  };
  const _hoisted_2$_ = ["innerHTML"];
  const _hoisted_3$Y = { class: "" };
  const _hoisted_4$V = ["innerHTML"];
  const _hoisted_5$P = ["innerHTML"];
  const _hoisted_6$G = { class: "table table-striped table-bordered" };
  const _hoisted_7$D = ["innerHTML"];
  const _hoisted_8$C = ["colspan", "innerHTML"];


  var script$1f = {
    __name: 'bootstrap-table',
    props: {
    id: String,
    columns: Array,
    rows: Array,
    print_html_column: Function,
    print_html_row: Function,
    print_html_title: Function,
    horizontal: Boolean,
    wrap_columns: Boolean,
  },
    setup(__props) {





  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createCommentVNode(" Normal table "),
      (!(__props.horizontal) || (__props.horizontal == false))
        ? (openBlock(), createElementBlock("table", _hoisted_1$15, [
            createBaseVNode("thead", null, [
              createBaseVNode("tr", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (col) => {
                  return (openBlock(), createElementBlock("th", {
                    scope: "col",
                    class: normalizeClass(col.class),
                    innerHTML: __props.print_html_column(col)
                  }, null, 10 /* CLASS, PROPS */, _hoisted_2$_))
                }), 256 /* UNKEYED_FRAGMENT */))
              ])
            ]),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(__props.rows, (row) => {
                return (openBlock(), createElementBlock("tr", _hoisted_3$Y, [
                  (__props.wrap_columns == true)
                    ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.columns, (col) => {
                        return (openBlock(), createElementBlock("td", {
                          scope: "col",
                          style: {"height":"2.5rem"},
                          class: normalizeClass(col.class)
                        }, [
                          createBaseVNode("div", {
                            class: "wrap-column",
                            style: normalizeStyle(col.style),
                            innerHTML: __props.print_html_row(col, row)
                          }, null, 12 /* STYLE, PROPS */, _hoisted_4$V)
                        ], 2 /* CLASS */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(__props.columns, (col) => {
                        return (openBlock(), createElementBlock("td", {
                          scope: "col",
                          class: normalizeClass([col.class, "wrap_column"]),
                          style: normalizeStyle(col.style),
                          innerHTML: __props.print_html_row(col, row)
                        }, null, 14 /* CLASS, STYLE, PROPS */, _hoisted_5$P))
                      }), 256 /* UNKEYED_FRAGMENT */))
                ]))
              }), 256 /* UNKEYED_FRAGMENT */))
            ])
          ]))
        : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createCommentVNode(" Horizontal table, with th on the rows "),
            createBaseVNode("table", _hoisted_6$G, [
              createBaseVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.rows, (row) => {
                  return (openBlock(), createElementBlock("tr", null, [
                    createBaseVNode("th", {
                      class: "col 5",
                      innerHTML: __props.print_html_title(row.name)
                    }, null, 8 /* PROPS */, _hoisted_7$D),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row.values, (value) => {
                      return (openBlock(), createElementBlock("td", {
                        colspan: [(row.values.length <= 1) ? 2 : 1],
                        innerHTML: __props.print_html_row(value)
                      }, null, 8 /* PROPS */, _hoisted_8$C))
                    }), 256 /* UNKEYED_FRAGMENT */))
                  ]))
                }), 256 /* UNKEYED_FRAGMENT */))
              ])
            ])
          ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
    ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
  }
  }

  };

  var css_248z$d = "\n.wrap-column[data-v-0533335c] {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  max-width:100%;\n}\n";
  styleInject(css_248z$d);

  script$1f.__scopeId = "data-v-0533335c";
  script$1f.__file = "http_src/vue/bootstrap-table.vue";

  const _withScopeId$3 = n => (pushScopeId("data-v-937058e4"),n=n(),popScopeId(),n);
  const _hoisted_1$14 = { class: "col-12 mb-2 mt-2" };
  const _hoisted_2$Z = { class: "card h-100 overflow-hidden" };
  const _hoisted_3$X = ["title"];
  const _hoisted_4$U = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-camera-retro" }, null, -1 /* HOISTED */));
  const _hoisted_5$O = [
    _hoisted_4$U
  ];
  const _hoisted_6$F = ["title"];
  const _hoisted_7$C = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-download" }, null, -1 /* HOISTED */));
  const _hoisted_8$B = [
    _hoisted_7$C
  ];
  const _hoisted_9$u = ["disabled", "title"];
  const _hoisted_10$r = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-file-image" }, null, -1 /* HOISTED */));
  const _hoisted_11$o = [
    _hoisted_10$r
  ];
  const _hoisted_12$n = ["title"];
  const _hoisted_13$h = /*#__PURE__*/ _withScopeId$3(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-lg fa-table" }, null, -1 /* HOISTED */));
  const _hoisted_14$e = [
    _hoisted_13$h
  ];
  const _hoisted_15$c = { class: "form-group ms-1 mt-2 d-flex align-items-center" };
  const _hoisted_16$c = { class: "inline select2-size me-2" };
  const _hoisted_17$b = { class: "inline select2-size me-2" };
  const _hoisted_18$b = {
    key: 0,
    class: "mt-4 card card-shadow"
  };
  const _hoisted_19$b = { class: "card-body" };
  const _hoisted_20$b = {
    key: 1,
    class: "mt-4 card card-shadow"
  };
  const _hoisted_21$7 = { class: "card-body" };
  const _hoisted_22$7 = {
    key: 0,
    class: "inline select2-size me-2 mt-2"
  };


  var script$1e = {
    __name: 'page-stats',
    props: {
      csrf: String,
      is_ntop_pro: Boolean,
      source_value_object: Object,
      sources_types_enabled: Object,
      sources_types_top_enabled: Object,
      enable_snapshots: Boolean,
      is_history_enabled: Boolean,
      traffic_extraction_permitted: Boolean,
      is_dark_mode: Boolean,
  },
    setup(__props) {

  const props = __props;



  //ntopng_utility.check_and_set_default_time_interval();

  const _i18n = (t) => i18n(t);
  let id_chart = "chart";
  let id_date_time_picker = "date_time_picker";
  let chart_type = ntopChartApex.typeChart.TS_LINE;
  ref({});
  ref(false);
  const charts = ref([]);
  const date_time_picker = ref(null);
  const top_table_ref = ref(null);
  const modal_timeseries = ref(null);
  const modal_snapshot = ref(null);
  const modal_download_file = ref(null);

  const is_safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  const image_button_title = is_safari ? _i18n('page_stats.download_image_disabled') : _i18n('page_stats.title_modal_download_file');

  const min_time_interval_id = ref(null);
  const metrics = ref([]);
  const selected_metric = ref({});
  metricsManager.get_current_page_source_type();

  const enable_stats_table = ref(false);
  ref(false);

  /**
   * { key: identifier of Chart component, if change Chart will be destroyed and recreated,
   *  chart_options: chart options }[]
   **/
  const charts_options_items = ref([]);

  /**
   * Modes that represent how it's possible display timeseries.
   */
  const groups_options_modes = ntopng_utility$1.object_to_array(timeseriesUtils.groupsOptionsModesEnum);
  /**
   * Current display timeseries mode.
   */
  const current_groups_options_mode = ref(init_groups_option_mode());

  let last_timeseries_groups_loaded = null;

  const custom_metric = { label: i18n('page_stats.custom_metrics'), currently_active: false };

  const page_snapshots = "timeseries";

  const ts_menu_ready = ref(false);
  const time_preset_list = [
      { value: "10_min", label: i18n('show_alerts.presets.10_min'), currently_active: false },
      { value: "30_min", label: i18n('show_alerts.presets.30_min'), currently_active: true },
      { value: "hour", label: i18n('show_alerts.presets.hour'), currently_active: false },
      { value: "2_hours", label: i18n('show_alerts.presets.2_hours'), currently_active: false },
      { value: "6_hours", label: i18n('show_alerts.presets.6_hours'), currently_active: false },
      { value: "12_hours", label: i18n('show_alerts.presets.12_hours'), currently_active: false },
      { value: "day", label: i18n('show_alerts.presets.day'), currently_active: false },
      { value: "week", label: i18n('show_alerts.presets.week'), currently_active: false },
      { value: "month", label: i18n('show_alerts.presets.month'), currently_active: false },
      { value: "year", label: i18n('show_alerts.presets.year'), currently_active: false },
      { value: "custom", label: i18n('show_alerts.presets.custom'), currently_active: false, disabled: true, },
  ];

  function init_groups_option_mode() {
      let groups_mode = ntopng_url_manager$1.get_url_entry("timeseries_groups_mode");
      if (groups_mode != null && groups_mode != "") {
          return timeseriesUtils.getGroupOptionMode(groups_mode);
      }
      return groups_options_modes[0];
  }

  function set_default_source_object_in_url() {
      if (props.source_value_object == null) { return; }
      let source_type = metricsManager.get_current_page_source_type();
      metricsManager.set_source_value_object_in_url(source_type, props.source_value_object);
  }

  onBeforeMount(async () => {
      
      if (ntopng_url_manager$1.get_url_entry("page") == "va_historical") {
          let columns_tmp = [];
          stats_columns.forEach((item) => {
              if (item.va) {
                  columns_tmp.push(item);
              }
          });
          
          stats_columns = columns_tmp;
      }
      
      if (props.source_value_object.is_va) {
          min_time_interval_id.value = "hour";
          ntopng_utility$1.check_and_set_default_time_interval("day");
      }    
      set_default_source_object_in_url();
  });

  onMounted(async () => {
      init();
      await Promise.all([
          ntopng_sync.on_ready(id_date_time_picker),
      ]);
      // chart.value.register_status();
  });

  async function init() {
      //get_default_timeseries_groups
      let push_custom_metric = true;
      let timeseries_groups = await metricsManager.get_timeseries_groups_from_url(http_prefix);
      let metric_ts_schema;
      let metric_query;
      if (timeseries_groups == null) {
          push_custom_metric = false;
          metric_ts_schema = ntopng_url_manager$1.get_url_entry("ts_schema");
          let ts_query = ntopng_url_manager$1.get_url_entry("ts_query");
          if (ts_query != null && ts_query != "") {
              metric_query = metricsManager.get_metric_query_from_ts_query(ts_query);
          }
          if (metric_ts_schema == "") { metric_ts_schema = null; }
          timeseries_groups = await metricsManager.get_default_timeseries_groups(http_prefix, metric_ts_schema, metric_query);
      }
      metrics.value = await get_metrics(push_custom_metric);
      
      if (push_custom_metric == true) {
          selected_metric.value = custom_metric;
      } else {
          selected_metric.value = metricsManager.get_default_metric(metrics.value, metric_ts_schema, metric_query);
      }
      ts_menu_ready.value = true;
      await load_page_stats_data(timeseries_groups, true, true);
  }

  let last_push_custom_metric = null;
  async function get_metrics(push_custom_metric, force_refresh) {
      let metrics = await metricsManager.get_metrics(http_prefix);
      if (!force_refresh && last_push_custom_metric == push_custom_metric) { return metrics.value; }
      
      if (push_custom_metric) {
          metrics.push(custom_metric);
      }
      if (cache_snapshots == null || force_refresh) {
          cache_snapshots = await get_snapshots_metrics();
      }
      if (props.enable_snapshots) {
          let snapshots_metrics = cache_snapshots;
          snapshots_metrics.forEach((sm) => metrics.push(sm));
      }
      /* Order Metrics */
      if (metrics.length > 0)
          metrics.sort(NtopUtils$1.sortAlphabetically);
      
      return metrics;
  }

  async function get_snapshots_metrics() {
      if (!props.enable_snapshots) { return; }
      let url = `${http_prefix}/lua/pro/rest/v2/get/filters/snapshots.lua?page=${page_snapshots}`;
      
      let snapshots_obj = await ntopng_utility$1.http_request(url);
      let snapshots = ntopng_utility$1.object_to_array(snapshots_obj);
      let metrics_snapshots = snapshots.map((s) => {
          return {
              ...s,
              is_snapshot: true,
              label: `${s.name}`,
              group: "Snapshots",
          };
      });
      return metrics_snapshots;
  }

  async function get_selected_timeseries_groups() {
      let metric = selected_metric.value;
      return get_timeseries_groups_from_metric(metric);
  }

  async function get_timeseries_groups_from_metric(metric) {
      let source_type = metricsManager.get_current_page_source_type();
      let source_array = await metricsManager.get_default_source_array(http_prefix, source_type);
      let ts_group = metricsManager.get_ts_group(source_type, source_array, metric);
      let timeseries_groups = [ts_group];
      return timeseries_groups;
  }

  const add_ts_group_from_source_value_dict = async (source_type_id, source_value_dict, metric_schema) => {
      let source_type = metricsManager.get_source_type_from_id(source_type_id);
      let source_array = await metricsManager.get_source_array_from_value_dict(http_prefix, source_type, source_value_dict);
      let metric = await metricsManager.get_metric_from_schema(http_prefix, source_type, source_array, metric_schema);
      let ts_group = metricsManager.get_ts_group(source_type, source_array, metric);
      add_ts_group(ts_group);
  };

  const add_metric_from_metric_schema = async (metric_schema, metric_query) => {
      let metric = metrics.value.find((m) => m.schema == metric_schema && m.query == metric_query);
      if (metric == null) {
          console.error(`metric = ${metric_schema}, query = ${metric_query} not found.`);
          return;
      }
      let timeseries_groups = await get_timeseries_groups_from_metric(metric);
      // modal_timeseries.value.set_timeseries_groups(last_timeseries_groups_loaded);
      // modal_timeseries.value.add_ts_group(timeseries_groups[0], true);
      add_ts_group(timeseries_groups[0]);
  };

  function add_ts_group(ts_group) {
      modal_timeseries.value.set_timeseries_groups(last_timeseries_groups_loaded);
      modal_timeseries.value.add_ts_group(ts_group, true);
  }

  async function select_metric(metric) {
      if (metric.is_snapshot == true) {
          let url_parameters = metric.filters;
          let timeseries_url_params = ntopng_url_manager$1.get_url_entry("timeseries_groups", url_parameters);
          let timeseries_groups = await metricsManager.get_timeseries_groups_from_url(http_prefix, timeseries_url_params);
          current_groups_options_mode.value = timeseriesUtils.getGroupOptionMode(ntopng_url_manager$1.get_url_entry("timeseries_groups_mode", url_parameters));
          await load_page_stats_data(timeseries_groups, true, false);
      } else {
          await load_selected_metric_page_stats_data();
          refresh_metrics(false);
      }
  }

  async function load_selected_metric_page_stats_data() {
      let timeseries_groups = await get_selected_timeseries_groups();
      await load_page_stats_data(timeseries_groups, true, false);
  }

  function epoch_change(new_epoch) {
      let push_custom_metric = selected_metric.value.label == custom_metric.label;
      load_page_stats_data(last_timeseries_groups_loaded, true, false, new_epoch.refresh_data);
      refresh_top_table();
      refresh_metrics(push_custom_metric, true);
  }

  function chart_reloaded(chart_options) {
  }

  function show_modal_snapshot() {
      modal_snapshot.value.show();
  }

  function show_manage_timeseries() {
      if (last_timeseries_groups_loaded == null) { return; }
      modal_timeseries.value.show(last_timeseries_groups_loaded);
  }
  /**
   * Function called by Chart component to draw or update that return chart options.
   **/
  function get_f_get_custom_chart_options(chart_index) {
      return async (url) => {
          return charts_options_items.value[chart_index].chart_options;
      }
  }

  let cache_snapshots = null;
  function refresh_snapshots() {
      let push_custom_metric = selected_metric.value.label == custom_metric.label;
      refresh_metrics(push_custom_metric, true);
  }

  async function refresh_metrics(push_custom_metric, force_refresh) {
      metrics.value = await get_metrics(push_custom_metric, force_refresh);
      if (push_custom_metric) {
          selected_metric.value = custom_metric;
      }
  }

  async function apply_modal_timeseries(timeseries_groups) {
      refresh_metrics(true);
      await load_page_stats_data(timeseries_groups, true, true);
  }

  function change_groups_options_mode() {
      load_page_stats_data(last_timeseries_groups_loaded, false, false);
  }

  let ts_charts_options;
  /* This function load the chart data and options, doing the request and then setting the options */
  async function load_page_stats_data(timeseries_groups, reload_charts_data, reload_top_table_options, refreshed_time_interval) {
      /* Get the information necessary for the request, like epoch ecc. */
      let status = ntopng_status_manager$1.get_status();
      let ts_compare = get_ts_compare(status);
      if (reload_charts_data) {
          /* Do the request to the backend; the answer is formatted as
           *  [  
           *      {   
           *          metadata: { ... }       // Containing various info regarding the series returned
           *          series: { ... }         // Containing the series with the data, labels and statistics
           *      }
           *  ]
           */
          if (timeseries_groups == null) {
              timeseries_groups = [];
              console.warn("Empty timeseries_groups request");
              return;
          }
          ts_charts_options = await timeseriesUtils.getTsChartsOptions(http_prefix, status, ts_compare, timeseries_groups, props.is_ntop_pro);
      }

      /* Update timeseries label to display */
      set_timeseries_groups_source_label(timeseries_groups, ts_charts_options);

      /* Format the options for the timeseries library */
      let charts_options = timeseriesUtils.tsArrayToOptionsArray(ts_charts_options, timeseries_groups, current_groups_options_mode.value, ts_compare);
      if (refreshed_time_interval) {
          update_charts(charts_options);
      } else {
          set_charts_options_items(charts_options);
      }
      set_stats_rows(ts_charts_options, timeseries_groups);
      if (reload_top_table_options) {
          set_top_table_options(timeseries_groups, status);
      }
      // set last_timeseries_groupd_loaded
      last_timeseries_groups_loaded = timeseries_groups;
      // update url params
      update_url_params();
  }

  /* This function returns set the label of the timeseries; if available it should be
   * found in response.metadata.label field
   */
  function set_timeseries_groups_source_label(timeseries_groups, ts_charts_options) {
      timeseries_groups.forEach((ts_group, i) => {
          let ts_options = ts_charts_options[i];
          let label = ts_options?.metadata?.label;
          if (label != null) {
              let source_index = timeseriesUtils.getMainSourceDefIndex(ts_group);
              let source = ts_group.source_array[source_index];
              source.label = label;
          }
      });
  }

  function update_url_params() {
      ntopng_url_manager$1.set_key_to_url("timeseries_groups_mode", current_groups_options_mode.value.value);
      metricsManager.set_timeseries_groups_in_url(last_timeseries_groups_loaded);
  }

  function update_charts(charts_options) {
      charts_options.forEach((options, i) => {
          // charts.value[i].update_chart_options({ yaxis: options.yaxis });
          charts.value[i].update_chart_series(options?.serie);
      });
  }

  function set_charts_options_items(charts_options) {
      charts_options_items.value = charts_options.map((options, i) => {
          return {
              key: ntopng_utility$1.get_random_string(),
              chart_options: options,
          };
      });
  }

  function get_ts_compare(status) {
      // 5m, 30m, 1h, 1d, 1w, 1M, 1Y
      let r = Number.parseInt((status.epoch_end - status.epoch_begin) / 60);
      if (r <= 5) {
          return "5m";
      } else if (r <= 30) {
          return "30m";
      } else if (r <= 60) {
          return "1h";
      } else if (r <= 60 * 24) {
          return "1d";
      } else if (r <= 60 * 24 * 7) {
          return "1w";
      } else if (r <= 60 * 24 * 30) {
          return "1M";
      } else {
          return "1Y";
      }
  }

  function get_top_table_url(ts_group, table_value, table_view, table_source_def_value_dict, status) {
      if (status == null) {
          status = ntopng_status_manager$1.get_status();
      }
      let ts_query = timeseriesUtils.getTsQuery(ts_group, true, table_source_def_value_dict);
      let v = table_value;
      let data_url = `${http_prefix}/lua/pro/rest/v2/get/${v}/top/ts_stats.lua`;
      //todo: get ts_query
      let p_obj = {
          zoom: '5m',
          ts_query,
          // ts_query: `ifid:${ntopng_url_manager.get_url_entry('ifid')}`,
          epoch_begin: `${status.epoch_begin}`,
          epoch_end: `${status.epoch_end}`,
          detail_view: `${table_view}`,
          new_charts: `true`
      };

      let p_url_request = ntopng_url_manager$1.add_obj_to_url(p_obj, '');
      return `${data_url}?${p_url_request}`;
  }

  async function refresh_top_table() {
      if (!props.is_ntop_pro) { return; }
      let table_config = selected_top_table.value?.table_config_def;
      if (table_config == null) { return; }
      // NtopUtils.showOverlays();
      let data_url = get_top_table_url(table_config.ts_group, table_config.table_def.table_value, table_config.table_def.view, table_config.table_source_def_value_dict);
      top_table_ref.value.update_url(data_url);
      top_table_ref.value.reload();
      // NtopUtils.hideOverlays();

  }

  const top_table_options = ref([]);
  const selected_top_table = ref({});
  function set_top_table_options(timeseries_groups, status) {
      if (!props.is_ntop_pro) { return; }
      if (timeseries_groups == null) {
          timeseries_groups = last_timeseries_groups_loaded;
      }
      if (status == null) {
          status = ntopng_status_manager$1.get_status();
      }

      let sources_types_tables = metricsManager.sources_types_tables;
      let ts_group_dict = {}; // dictionary with 1 ts_group for each (source_type, source_array)
      timeseries_groups.forEach((ts_group) => {
          ts_group.source_type;
          // let source_type_tables = sources_types_tables[source_type.id];
          // let table_source_def_value_dict = source_type_tables.table_source_def_value_dict

          let id = metricsManager.get_ts_group_id(ts_group.source_type, ts_group.source_array);
          ts_group_dict[id] = ts_group;
      });
      let top_table_id_dict = {};
      top_table_options.value = [];
      for (let id in ts_group_dict) {
          let ts_group = ts_group_dict[id];
          let main_source_index = timeseriesUtils.getMainSourceDefIndex(ts_group);
          let main_source = ts_group.source_array[main_source_index];
          let source_type = ts_group.source_type;
          let source_type_tables = sources_types_tables[source_type.id];
          if (source_type_tables == null) { continue; }

          source_type_tables.forEach((table_def) => {
              let enables_table_value = props.sources_types_top_enabled[table_def.table_value];
              if (enables_table_value == null) { return; }
              let enable_table_def = enables_table_value[table_def.view];
              if (!enable_table_def) { return; }
              let table_source_def_value_dict = table_def.table_source_def_value_dict;

              let data_url = get_top_table_url(ts_group, table_def.table_value, table_def.view, table_source_def_value_dict, status);
              let table_id = metricsManager.get_ts_group_id(ts_group.source_type, ts_group.source_array, null, table_source_def_value_dict, true);
              table_id = `${table_id}_${table_def.view}`;
              if (top_table_id_dict[table_id] != null) { return; }
              top_table_id_dict[table_id] = true;

              let value = `${table_def.table_value}_${table_def.view}_${table_id}`;
              let label;
              if (table_def.f_get_label == null) {
                  label = `${table_def.title} - ${source_type.label} ${main_source.label}`;
              } else {
                  label = table_def.f_get_label(ts_group);
              }
              const table_config_def = {
                  ts_group,
                  table_def,
                  // table_value: table_def.table_value,
                  // table_view: table_def.view,

                  table_buttons: [],
                  data_url,
                  enable_search: true,
                  table_config: {
                      serverSide: false,
                      order: [[table_def.default_sorting_columns, 'desc']],
                      columnDefs: table_def.columnDefs || [],
                  }
              };
              // it should be here in this instance the vuetify object with its properties
              table_config_def.columns_config = table_def.columns.map((column) => {
                  let render_if_context = {
                      is_history_enabled: props.is_history_enabled
                  };
                  let c = {
                      visible: !column.render_if || column.render_if(render_if_context),
                      ...column,
                  };
                  if (c.className == null) { c.className = "text-nowrap"; }
                  if (c.responsivePriority == null) { c.responsivePriority = 1; }
                  c.render = column.render.bind({
                      add_metric_from_metric_schema,
                      add_ts_group_from_source_value_dict,
                      sources_types_enabled: props.sources_types_enabled,
                      status, source_type, source_array: ts_group.source_array,
                  });
                  return c;
              });
              let option = { value, label, table_config_def };
              top_table_options.value.push(option);
          });
      }
      if (selected_top_table.value != null && top_table_options.value.find((option) => option.value == selected_top_table.value.value)) {
          return;
      }

      selected_top_table.value = top_table_options.value.find((option) => option.table_config_def.default == true);
      if (selected_top_table.value == null) {
          selected_top_table.value = top_table_options.value[0];
      }
  }

  let stats_columns = [
      { id: "metric", label: _i18n("page_stats.metric"), va: true},
      { id: "avg", label: _i18n("page_stats.average"), class: "text-end", va: true },
      { id: "perc_95", label: _i18n("page_stats.95_perc"), class: "text-end", va: true },
      { id: "max", label: _i18n("page_stats.max"), class: "text-end", va: true},
      { id: "min", label: _i18n("page_stats.min"), class: "text-end", va: true },
      { id: "total", label: _i18n("page_stats.total"), class: "text-end", va: false },
  ];

  const stats_rows = ref([]);

  function set_stats_rows(ts_charts_options, timeseries_groups, status) {
      const extend_serie_name = ts_charts_options.length > 1;
      enable_stats_table.value = timeseries_groups.map((ts_group) => !ts_group.source_type.disable_stats).reduce((res, el) => res | el, false);
      if (!enable_stats_table.value) { return; }
      const f_get_total_formatter_type = (type) => {
          let map_type = {
              "bps": "bytes",
              "fps": "flows",
              "alertps": "alerts",
              "hitss": "hits",
              "pps": "packets",
          };
          if (map_type[type] != null) {
              return map_type[type];
          }
          return type;
      };
      stats_rows.value = [];
      ts_charts_options.forEach((options, i) => {
          let ts_group = timeseries_groups[i];
          if (ts_group.source_type.disable_stats == true) { return; }
          options.series?.forEach((s, j) => {
              let ts_id = timeseriesUtils.getSerieId(s);
              let s_metadata = ts_group.metric.timeseries[ts_id];
              let formatter = formatterUtils.getFormatter(ts_group.metric.measure_unit);
              let ts_stats;
              let name = s_metadata.label;
              if (s_metadata.hidden) {
                  /* Skip in case it's requested to hide the Timeserie */
                  return;
              }
              if (s_metadata.use_serie_name == true) {
                  name = s.name;
              }
              if (s?.data.length > j) {
                  ts_stats = s.statistics;
              }
              if (ts_stats == null) {
                  return;
              }
              if (s.ext_label) {
                  name = s.ext_label;
              }
              name = timeseriesUtils.getSerieName(name, ts_id, ts_group, extend_serie_name);
              let total_formatter_type = f_get_total_formatter_type(ts_group.metric.measure_unit);
              let total_formatter = formatterUtils.getFormatter(total_formatter_type);
              let row = {
                  metric: name,
                  // total: total_formatter(total),
                  total: total_formatter(ts_stats.total),
                  perc_95: formatter(ts_stats["95th_percentile"]),
                  avg: formatter(ts_stats.average),
                  max: formatter(ts_stats.max_val),
                  min: formatter(ts_stats.min_val),
              };
              stats_rows.value.push(row);
          });
      });
  }

  function print_stats_column(col) {
      return col.label;
  }

  function print_stats_row(col, row) {
      let label = row[col.id];
      return label;
  }

  function jump_to_historical_flows() {
      let status = ntopng_status_manager$1.get_status();
      let params = { epoch_begin: status.epoch_begin, epoch_end: status.epoch_end };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params);
      const historical_url = `${http_prefix}/lua/pro/db_search.lua?${url_params}`;
      ntopng_url_manager$1.go_to_url(historical_url);
  }

  const modal_traffic_extraction = ref(null);
  function show_modal_traffic_extraction() {
      modal_traffic_extraction.value.show();
  }

  function show_modal_download_file() {
      if (!ts_charts_options?.length) { return; }
      let ts_group = last_timeseries_groups_loaded[0];
      let filename = timeseriesUtils.getSerieName(null, null, ts_group);
      modal_download_file.value.show(filename);
  }

  async function download_chart_png(filename) {
      let chart_image_array_promise = charts.value.map(async (chart) => {
          let canvas = new Image();
          chart.get_image(canvas);
          return new Promise(async (resolve, reject) => {
              canvas.onload = function () {
                  resolve(canvas);
              };
          });
      });
      let height = 0;
      let chart_image_array = await Promise.all(chart_image_array_promise);
      chart_image_array.forEach((image) => {
          height += image.height;
      });
      let canvas = document.createElement('canvas');
      let canvas_context = canvas.getContext('2d');
      canvas.width = chart_image_array[0].width;
      canvas.height = height;
      height = 0;
      chart_image_array.forEach((image) => {
          canvas_context.drawImage(image, 0, height, image.width, image.height);
          height += image.height;
      });
      ntopng_utility$1.download_URI(canvas.toDataURL(), filename);
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$14, [
        createVNode(script$1G),
        createBaseVNode("div", _hoisted_2$Z, [
          createVNode(script$1E, {
            style: {"margin-top":"0.5rem"},
            class: "ms-1",
            id: unref(id_date_time_picker),
            enable_refresh: true,
            ref_key: "date_time_picker",
            ref: date_time_picker,
            onEpoch_change: epoch_change,
            min_time_interval_id: min_time_interval_id.value,
            custom_time_interval_list: time_preset_list
          }, {
            begin: withCtx(() => []),
            extra_buttons: withCtx(() => [
              (__props.enable_snapshots)
                ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    class: "btn btn-link btn-sm",
                    onClick: show_modal_snapshot,
                    title: _i18n('page_stats.manage_snapshots_btn')
                  }, _hoisted_5$O, 8 /* PROPS */, _hoisted_3$X))
                : createCommentVNode("v-if", true),
              (__props.traffic_extraction_permitted)
                ? (openBlock(), createElementBlock("button", {
                    key: 1,
                    class: "btn btn-link btn-sm",
                    onClick: show_modal_traffic_extraction,
                    title: _i18n('traffic_recording.pcap_download')
                  }, _hoisted_8$B, 8 /* PROPS */, _hoisted_6$F))
                : createCommentVNode("v-if", true),
              createBaseVNode("button", {
                disabled: unref(is_safari),
                class: "btn btn-link btn-sm",
                onClick: show_modal_download_file,
                title: unref(image_button_title)
              }, _hoisted_11$o, 8 /* PROPS */, _hoisted_9$u),
              (__props.is_history_enabled)
                ? (openBlock(), createElementBlock("button", {
                    key: 2,
                    class: "btn btn-link btn-sm",
                    onClick: jump_to_historical_flows,
                    title: _i18n('page_stats.historical_flows')
                  }, _hoisted_14$e, 8 /* PROPS */, _hoisted_12$n))
                : createCommentVNode("v-if", true)
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["id", "min_time_interval_id"]),
          createCommentVNode(" select metric "),
          withDirectives(createBaseVNode("div", _hoisted_15$c, [
            createBaseVNode("div", _hoisted_16$c, [
              createVNode(script$1I, {
                selected_option: selected_metric.value,
                "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_metric).value = $event)),
                options: metrics.value,
                onSelect_option: select_metric
              }, null, 8 /* PROPS */, ["selected_option", "options"])
            ]),
            createBaseVNode("div", _hoisted_17$b, [
              createVNode(script$1I, {
                selected_option: current_groups_options_mode.value,
                "onUpdate:selected_option": _cache[1] || (_cache[1] = $event => ((current_groups_options_mode).value = $event)),
                options: unref(groups_options_modes),
                onSelect_option: change_groups_options_mode
              }, null, 8 /* PROPS */, ["selected_option", "options"])
            ]),
            (__props.is_ntop_pro)
              ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  onClick: show_manage_timeseries,
                  class: "btn btn-sm btn-primary inline",
                  style: {"vertical-align":"super"}
                }, " Manage Timeseries "))
              : createCommentVNode("v-if", true)
          ], 512 /* NEED_PATCH */), [
            [vShow, ts_menu_ready.value]
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(charts_options_items.value, (item, i) => {
            return (openBlock(), createBlock(script$1k, {
              key: item.key,
              id: unref(id_chart) + i,
              ref_for: true,
              ref: el => { charts.value[i] = el; },
              chart_type: unref(chart_type),
              register_on_status_change: false,
              get_custom_chart_options: get_f_get_custom_chart_options(i),
              onZoom: epoch_change,
              onChart_reloaded: chart_reloaded
            }, null, 8 /* PROPS */, ["id", "chart_type", "get_custom_chart_options"]))
          }), 128 /* KEYED_FRAGMENT */))
        ]),
        (enable_stats_table.value)
          ? (openBlock(), createElementBlock("div", _hoisted_18$b, [
              createBaseVNode("div", _hoisted_19$b, [
                createVNode(script$1f, {
                  id: "page_stats_bootstrap_table",
                  columns: unref(stats_columns),
                  rows: stats_rows.value,
                  print_html_column: (col) => print_stats_column(col),
                  print_html_row: (col, row) => print_stats_row(col, row)
                }, null, 8 /* PROPS */, ["columns", "rows", "print_html_column", "print_html_row"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (__props.is_ntop_pro)
          ? (openBlock(), createElementBlock("div", _hoisted_20$b, [
              createBaseVNode("div", _hoisted_21$7, [
                (selected_top_table.value?.table_config_def)
                  ? (openBlock(), createElementBlock("div", _hoisted_22$7, [
                      createVNode(script$1I, {
                        selected_option: selected_top_table.value,
                        "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_top_table).value = $event)),
                        options: top_table_options.value
                      }, null, 8 /* PROPS */, ["selected_option", "options"])
                    ]))
                  : createCommentVNode("v-if", true),
                (selected_top_table.value?.table_config_def)
                  ? (openBlock(), createBlock(script$1g, {
                      key: selected_top_table.value?.value,
                      ref_key: "top_table_ref",
                      ref: top_table_ref,
                      table_buttons: selected_top_table.value.table_config_def.table_button,
                      columns_config: selected_top_table.value.table_config_def.columns_config,
                      data_url: selected_top_table.value.table_config_def.data_url,
                      enable_search: selected_top_table.value.table_config_def.enable_search,
                      table_config: selected_top_table.value.table_config_def.table_config
                    }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
                  : createCommentVNode("v-if", true)
              ])
            ]))
          : createCommentVNode("v-if", true)
      ]),
      (__props.enable_snapshots)
        ? (openBlock(), createBlock(script$1s, {
            key: 0,
            ref_key: "modal_snapshot",
            ref: modal_snapshot,
            csrf: __props.csrf,
            page: page_snapshots,
            onAdded_snapshot: refresh_snapshots,
            onDeleted_snapshots: refresh_snapshots,
            onDeleted_all_snapshots: refresh_snapshots
          }, null, 8 /* PROPS */, ["csrf"]))
        : createCommentVNode("v-if", true),
      (__props.is_ntop_pro)
        ? (openBlock(), createBlock(script$1i, {
            key: 1,
            ref_key: "modal_timeseries",
            ref: modal_timeseries,
            sources_types_enabled: __props.sources_types_enabled,
            onApply: apply_modal_timeseries
          }, null, 8 /* PROPS */, ["sources_types_enabled"]))
        : createCommentVNode("v-if", true),
      createVNode(script$1t, {
        id: "page_stats_modal_traffic_extraction",
        ref_key: "modal_traffic_extraction",
        ref: modal_traffic_extraction
      }, null, 512 /* NEED_PATCH */),
      createVNode(script$1h, {
        ref_key: "modal_download_file",
        ref: modal_download_file,
        title: _i18n('page_stats.title_modal_download_file'),
        ext: "png",
        onDownload: download_chart_png
      }, null, 8 /* PROPS */, ["title"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  var css_248z$c = "\n.inline[data-v-937058e4] {\n    display: inline-block;\n}\n.select2-size[data-v-937058e4] {\n    min-width: 18rem;\n}\n";
  styleInject(css_248z$c);

  script$1e.__scopeId = "data-v-937058e4";
  script$1e.__file = "http_src/vue/page-stats.vue";

  var script$1d = defineComponent({
    components: {
    },
    props: {
      id: String,
      tab_list: Array,
    },
    emits: ["click_item"],
    /** This method is the first method of the component called, it's called before html template creation. */
    created() {
    },
    data() {
      return {
        old_tab: null
      };
    },
    /** This method is the first method called after html template creation. */
    mounted() {
      let tmp = null;
      this.$props.tab_list.forEach(function(tab) {
        if(tab.active) {
          tmp = tab;
        }
      });
      this.old_tab = tmp || this.$props.tab_list[0];

      ntopng_sync.ready(this.$props["id"]);
    },
    methods: {
      change_tab: function(tab) {
        if((tab.id != null && this.old_tab.id != tab.id) ||
           (tab.name != null && this.old_tab.name != tab.name)) {
          this.old_tab = tab;
          this.$emit('click_item', tab);
        }
      }
    },
  });

  const _hoisted_1$13 = { class: "card-header mb-2" };
  const _hoisted_2$Y = {
    class: "nav nav-tabs card-header-tabs",
    role: "tablist"
  };
  const _hoisted_3$W = ["onClick"];
  const _hoisted_4$T = ["onClick"];

  function render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("div", _hoisted_1$13, [
      createBaseVNode("ul", _hoisted_2$Y, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tab_list, (tab) => {
          return (openBlock(), createElementBlock(Fragment, null, [
            (tab.active)
              ? (openBlock(), createElementBlock("li", {
                  key: 0,
                  onClick: $event => (_ctx.change_tab(tab)),
                  class: normalizeClass([{ 'active': tab.active }, "nav-item nav-link"])
                }, toDisplayString(tab.title), 11 /* TEXT, CLASS, PROPS */, _hoisted_3$W))
              : (openBlock(), createElementBlock("a", {
                  key: 1,
                  onClick: $event => (_ctx.change_tab(tab)),
                  href: "#",
                  class: "nav-item nav-link"
                }, toDisplayString(tab.title), 9 /* TEXT, PROPS */, _hoisted_4$T))
          ], 64 /* STABLE_FRAGMENT */))
        }), 256 /* UNKEYED_FRAGMENT */))
      ])
    ]))
  }

  script$1d.render = render$a;
  script$1d.__file = "http_src/vue/tab-list.vue";

  var script$1c = {
    __name: 'modal-delete-confirm',
    props: {
      body: String,
      title: String,
  },
    emits: ['delete','delete_all'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);


  const showed = () => {};
  let body_delete = ref("");
  let title_delete = ref("");

  const show = (body, title) => {

    if (body != null && title != null) {

      body_delete.value = body;
      title_delete.value = title;
    } else {

      body_delete.value = props.body;
      title_delete.value = props.title;
    }
    modal_id.value.show();
  };

  const delete_ = () => {
      emit('delete');

      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[0] || (_cache[0] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title_delete)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(unref(body_delete)), 1 /* TEXT */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: delete_,
          class: "btn btn-danger"
        }, toDisplayString(_i18n('delete')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$1c.__file = "http_src/vue/modal-delete-confirm.vue";

  const change_asset_table_tab_event = "change_asset_table_tab_event";

  var script$1b = {
    components: {	  
      'datatable': script$1g,
      'modal-delete-confirm': script$1c,
      'tab-list': script$1d,
      NoteList: script$1u
    },
    props: {
      page_csrf: String,
      url_params: Object,
      view: String,
      table_filters: Array,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      ntopng_url_manager$1.set_key_to_url('asset_family', this.$props.url_params.asset_family);
      this.asset_table_tab = ntopng_url_manager$1.get_url_entry('view') || 'centrality';
      ntopng_url_manager$1.set_key_to_url('view', this.service_table_tab);
      this.tab_list.forEach((i) => {
        if(this.asset_table_tab == i.id)
          i.active = true;
      });
      start_datatable$5(this);
    },
    mounted() {
      ntopng_events_manager$1.on_custom_event("page_asset_table", ntopng_custom_events.DATATABLE_LOADED, () => {
        if(ntopng_url_manager$1.get_url_entry('host'))
          this.hide_dropdowns();
      });
      ntopng_events_manager$1.on_custom_event("change_asset_table_tab", change_asset_table_tab_event, (tab) => {
  	    let table = this.get_active_table();
        ntopng_url_manager$1.set_key_to_url('view', tab);
        table.destroy_table();
        this.asset_table_tab = tab;
      });

      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
    },    
    data() {
      return {
        i18n: (t) => i18n(t),
        config_devices_standard: null,
        config_devices_centrality: null,
        title_delete: i18n('map_page.delete_assets'),
        body_delete: i18n('map_page.delete_assets_message'),
        title_download: i18n('map_page.download'),
        body_download: i18n('map_page.download_message'),
        get_url: null,
        asset_table_tab: null,
        notes: [i18n('map_page.table_note_asset_map')],
        tab_list: [
          { 
            title: i18n('map_page.standard_view'),
            active: (view == 'standard'),
            id: 'standard'
          },
          { 
            title: i18n('map_page.centrality_view'),
            active: (view == 'centrality'),
            id: 'centrality'
          },
        ]
      };
    },
    methods: {
      destroy: function() {
        let table = this.get_active_table();
        table.destroy_table();
      },
      /* Method used to switch active table tab */
      click_item: function(item) {
        this.tab_list.forEach((i) => i.active = false);
        item.active = true;
        ntopng_events_manager$1.emit_custom_event(change_asset_table_tab_event, item.id);
      },
      delete_all: async function() {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.url_params.ifid,
          action: 'reset',
          page: this.url_params.page,
          csrf: this.$props.page_csrf,
          map: this.url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          this.reload_table();
        } catch(err) {
          this.reload_table();  
        }      
      },
      create_action_button_historical_flow_link: function(_, type, rowData) {
      let historical_flow_link = {
        handlerId: "historical_flow_link",
        onClick: () => {
          historical_flow$2(rowData);
        },
      };

      return DataTableUtils.createActionButtons([
        { class: `pointer`, handler: historical_flow_link, icon: 'fas fa-stream', title: i18n('db_explorer.historical_data') },
      ]);
      
      },
      hide_dropdowns: function() {      
        $(`#network_dropdown`).removeClass('d-inline');
        $(`#vlan_id_dropdown`).removeClass('d-inline');
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
      }, 
      reload_table: function() {
        let table = this.get_active_table();
        NtopUtils.showOverlays();
        table.reload();
        NtopUtils.hideOverlays();
      },
      get_active_table: function() {
        return this.$refs[`table_asset_${this.asset_table_tab}`];
      },
      show_delete_all_dialog: function() {
        this.$refs["modal_delete_all"].show();
      },
    },
  };  

  function historical_flow$2(row) {
    const client_ip = row.client.split("host=")[1].split("&")[0];
    const server_ip = row.server.split("host=")[1].split("&")[0];
    const epoch_end = row.epoch_end;
    const epoch_begin = row.epoch_begin;

    const params = {
      epoch_begin: epoch_begin,
      epoch_end: epoch_end,
      srv_ip: `${server_ip};eq`,
      cli_ip: `${client_ip};eq`,
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);
    ntopng_url_manager$1.go_to_url(`${http_prefix}/lua/pro/db_search.lua?${url_params}`);

  }
  function start_datatable$5(DatatableVue) {
    const datatableButton = [];
    let columns = [];
    
    DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
    
    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        DatatableVue.reload_table();
      }
    });
    
    let tmp_params = url_params;
    tmp_params['view'] = 'standard';
    
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      columns_config: [],
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
      enable_search: true,
    };

    let table_filters = [];
    for (let filter of (DatatableVue.$props.table_filters || [])) {
      filter.callbackFunction = (table, value) => {
        tmp_params['view'] = DatatableVue.asset_table_tab;
        tmp_params[filter.filterMenuKey] = value.id;
        ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
        table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
        NtopUtils.showOverlays();
        table.ajax.reload();
        NtopUtils.hideOverlays();
      },
      table_filters.push(filter);
    }
    
    /* Standard table configuration */  

    columns = [
      { columnName: i18n("actions"), name: 'actions',  className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) {
          return DatatableVue.create_action_button_historical_flow_link(_, type,rowData);
        }
      }, { columnName: i18n("map_page.client"), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("map_page.server"), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("map_page.asset_family"), name: 'family', data: 'family', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("map_page.last_seen"), name: 'last_seen', data: 'last_seen',  className: 'text-center', responsivePriority: 2 },
    ];
    
    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_config = { serverSide: false, order: [[ 4 /* Last Seen */, 'desc' ]] };
    configDevices.columns_config = columns;
    configDevices.table_filters = table_filters;
    DatatableVue.config_devices_standard = configDevices;


    /* Centrality table configuration */

    tmp_params['view'] = 'centrality';  
    defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params);

    columns = [
      { columnName: i18n("map_page.host"), name: 'host', data: 'host', className: 'text-nowrap', render: (data, type) => { return data.label }, responsivePriority: 1 },
      { columnName: i18n("map_page.asset_total_edges"), name: 'total_edges', data: 'total_edges', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("map_page.asset_in_edges"), name: 'in_edges', data: 'in_edges', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("map_page.asset_out_edges"), name: 'out_edges', data: 'out_edges',  className: 'text-center', responsivePriority: 2 },
    ];

    
    
    let centralityConfigDevices = ntopng_utility.clone(defaultDatatableConfig);
    centralityConfigDevices.table_config = { serverSide: false, order: [[ 1 /* Total Edges */, 'desc' ]] };
    centralityConfigDevices.columns_config = columns;
    centralityConfigDevices.table_filters = table_filters;

    console.log(configDevices);
    console.log(centralityConfigDevices);
    
    DatatableVue.config_devices_centrality = centralityConfigDevices;
  }

  const _hoisted_1$12 = { class: "row" };
  const _hoisted_2$X = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$V = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$S = { class: "card" };
  const _hoisted_5$N = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_6$E = { class: "card-body" };
  const _hoisted_7$B = { id: "table_asset" };
  const _hoisted_8$A = { class: "card-footer" };
  const _hoisted_9$t = {
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_10$q = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_11$n = ["href"];
  const _hoisted_12$m = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_13$g = [
    _hoisted_12$m
  ];

  function render$9(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_tab_list = resolveComponent("tab-list");
    const _component_datatable = resolveComponent("datatable");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$12, [
      createBaseVNode("div", _hoisted_2$X, [
        _hoisted_3$V,
        createBaseVNode("div", _hoisted_4$S, [
          _hoisted_5$N,
          createBaseVNode("div", _hoisted_6$E, [
            createBaseVNode("div", _hoisted_7$B, [
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_tab_list, {
                ref: "asset_tab_list",
                id: "asset_tab_list",
                tab_list: $data.tab_list,
                onClick_item: $options.click_item
              }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
              ($data.asset_table_tab == 'standard')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 0,
                    ref: "table_asset_standard",
                    table_buttons: $data.config_devices_standard.table_buttons,
                    columns_config: $data.config_devices_standard.columns_config,
                    data_url: $data.config_devices_standard.data_url,
                    enable_search: $data.config_devices_standard.enable_search,
                    filter_buttons: $data.config_devices_standard.table_filters
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" :table_config=\"config_devices_standard.table_config\"> ")
                    ]),
                    _: 1 /* STABLE */
                  }, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons"]))
                : createCommentVNode("v-if", true),
              ($data.asset_table_tab == 'centrality')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 1,
                    ref: "table_asset_centrality",
                    table_buttons: $data.config_devices_centrality.table_buttons,
                    columns_config: $data.config_devices_centrality.columns_config,
                    data_url: $data.config_devices_centrality.data_url,
                    enable_search: $data.config_devices_centrality.enable_search,
                    filter_buttons: $data.config_devices_centrality.table_filters
                  }, {
                    default: withCtx(() => [
                      createTextVNode(" :table_config=\"config_devices_centrality.table_config\"> ")
                    ]),
                    _: 1 /* STABLE */
                  }, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons"]))
                : createCommentVNode("v-if", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$A, [
            createBaseVNode("button", _hoisted_9$t, [
              _hoisted_10$q,
              createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_assets")), 1 /* TEXT */)
            ]),
            createBaseVNode("a", {
              href: $data.get_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "asset_map.json",
              target: "_blank"
            }, _hoisted_13$g, 8 /* PROPS */, _hoisted_11$n)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$1b.render = render$9;
  script$1b.__file = "http_src/vue/page-asset-table.vue";

  var script$1a = {
    components: {	  
      'datatable': script$1g,
      'modal-delete-confirm': script$1c,
      NoteList: script$1u
    },
    props: {
      page_csrf: String,
      url_params: Object,
      view: String,
      table_filters: Array,
      is_admin: Boolean,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_datatable$4(this);
    },
    mounted() {  
      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
      
      ntopng_events_manager.on_custom_event("page_periodicity_table", ntopng_custom_events.DATATABLE_LOADED, () => {
        if(ntopng_url_manager$1.get_url_entry('host'))
          this.hide_dropdowns();
      });
    },    
    data() {
      return {
        i18n: (t) => i18n(t),
        base_url: `${http_prefix}/lua/pro/enterprise/get_map.lua`,
        config_devices_standard: null,
        config_devices_centrality: null,
        title_delete: i18n('map_page.delete_services'),
        body_delete: i18n('map_page.delete_services_message'),
        title_download: i18n('map_page.download'),
        body_download: i18n('map_page.download_message'),
        notes: [i18n('map_page.table_note_periodicity_map')],
        get_url: null,
      };
    },
    methods: { 
      hide_dropdowns: function() {
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
        $(`#network_dropdown`).removeClass('d-inline');
        $(`#vlan_id_dropdown`).removeClass('d-inline');
      }, 
      create_action_button_historical_flow_link: function(_, type, rowData) {
      let historical_flow_link = {
        handlerId: "historical_flow_link",
        onClick: () => {
          historical_flow$1(rowData);
        },
      };
      let live_flow_link = {
        handlerId: "live_flow_link",
        onClick: () => {
          live_flow(rowData);
        },
      };

      return DataTableUtils.createActionButtons([
        { class: `pointer`, handler: historical_flow_link, icon: 'fas fa-stream', title: i18n('db_explorer.historical_data') },
        { class: `pointer`, handler: live_flow_link, icon: 'fas fa-stream', title: i18n('live_flows') },

      ]);
      
      },
      delete_all: async function() {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.url_params.ifid,
          action: 'reset',
          page: this.url_params.page,
          csrf: this.$props.page_csrf,
          map: this.url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          this.reload_table();
        } catch(err) {
          this.reload_table();  
        }      
      },
      reload_table: function() {
        let table = this.get_active_table();
        NtopUtils.showOverlays();
        table.reload();
        NtopUtils.hideOverlays();
      },
      destroy: function() {
        let table = this.get_active_table();
        table.destroy_table();
      },
      get_active_table: function() {
        return this.$refs[`table_periodicity`];
      },
      show_delete_all_dialog: function() {
        this.$refs["modal_delete_all"].show();
      },  
    },
  };  

  function historical_flow$1(row) {
    const client_ip = row.client.split("host=")[1].split(">")[0];
    const client = client_ip.substring(0, client_ip.length - 1);
    const server_ip = row.server.split("host=")[1].split(">")[0];
    const server = server_ip.substring(0, server_ip.length - 1);
    const port = row.port;

    const epoch_begin = row.first_seen;
    const epoch_end = row.last_seen.epoch_end;

    const params = {
      epoch_begin: epoch_begin,
      epoch_end: epoch_end,
      srv_ip: `${server};eq`,
      cli_ip: `${client};eq`,
      srv_port: `${port};eq`,
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);
    const url = `${http_prefix}/lua/pro/db_search.lua?${url_params}`;
    ntopng_url_manager$1.go_to_url(url);

  }

  function live_flow(row) {
    const client_ip = row.client.split("host=")[1].split(">")[0];
    const client = client_ip.substring(0, client_ip.length - 1);
    const server_ip = row.server.split("host=")[1].split(">")[0];
    const server = server_ip.substring(0, server_ip.length - 1);
    const port = row.port;


    const params = {
      server: `${server}`,
      client: `${client}`,
      port: `${port}`,
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);
    const url = `${http_prefix}/lua/flows_stats.lua?${url_params}`;
    ntopng_url_manager$1.go_to_url(url);
  }

  function start_datatable$4(DatatableVue) {
    const datatableButton = [];
    let columns = [];
    let default_sorting_columns = 0;
    DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
    
    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        DatatableVue.reload_table();
      }
    });
    
    let tmp_params = ntopng_utility.clone(url_params);
    tmp_params['view'] = null;
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      columns_config: [],
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
      enable_search: true,
    };

    let table_filters = [];
    for (let filter of (DatatableVue.$props.table_filters || [])) {
      filter.callbackFunction = (table, value) => {
        tmp_params[filter.filterMenuKey] = value.id;
        ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
        table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
        NtopUtils.showOverlays();
        table.ajax.reload();
        NtopUtils.hideOverlays();
      },
      table_filters.push(filter);
    }
    
    /* Standard table configuration */  

    columns = [
      { columnName: i18n("actions"), name: 'actions',  className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) {
          return DatatableVue.create_action_button_historical_flow_link(_, type,rowData);
        },
      },
      { columnName: i18n('map_page.last_seen'), name: 'last_seen', data: 'last_seen', className: 'text-center text-nowrap', render: (data, type) => { return data.value }, responsivePriority: 2 },
      { columnName: i18n('map_page.client'), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n('map_page.server'), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n('map_page.port'), name: 'port', data: 'port',  className: 'text-center', responsivePriority: 4 },
      { columnName: i18n('map_page.protocol'), name: 'l7proto', data: 'protocol', className: 'text-nowrap', responsivePriority: 3 },
      { columnName: i18n('map_page.first_seen'), name: 'first_seen', data: 'first_seen', visible: false, responsivePriority: 3 },
      { columnName: i18n('duration'), name: 'duration', data: 'duration', className: 'text-center text-nowrap',  responsivePriority: 3, orderable: true,  },
      { columnName: i18n('map_page.observations'), name: 'observations', data: 'observations', className: 'text-center', responsivePriority: 4 },
      { columnName: i18n('map_page.frequency'), name: 'frequency', data: 'frequency', className: 'text-center', orderable: true, responsivePriority: 4, render: ( data, type, row ) => {
          return (type == "sort" || type == 'type') ? data : data + " sec"; 
        }
      },
    ];

    default_sorting_columns = 8; /* Observation column */

    /* Extra table configuration */
    let table_config = {
      serverSide: true,
      order: [[ default_sorting_columns, 'desc' ]]
    };
    
    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
    configDevices.data_url = `${configDevices.data_url}`;
    configDevices.columns_config = columns;
    configDevices.table_filters = table_filters;
    configDevices.table_config = ntopng_utility.clone(table_config);
    DatatableVue.config_devices_standard = configDevices;
  }

  const _hoisted_1$11 = { class: "row" };
  const _hoisted_2$W = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$U = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$R = { class: "card" };
  const _hoisted_5$M = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_6$D = { class: "card-body" };
  const _hoisted_7$A = { id: "periodicity-table" };
  const _hoisted_8$z = { class: "card-footer" };
  const _hoisted_9$s = {
    key: 0,
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_10$p = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_11$m = ["href"];
  const _hoisted_12$l = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_13$f = [
    _hoisted_12$l
  ];

  function render$8(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_datatable = resolveComponent("datatable");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$11, [
      createBaseVNode("div", _hoisted_2$W, [
        _hoisted_3$U,
        createBaseVNode("div", _hoisted_4$R, [
          _hoisted_5$M,
          createBaseVNode("div", _hoisted_6$D, [
            createBaseVNode("div", _hoisted_7$A, [
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_datatable, {
                ref: "table_periodicity",
                table_buttons: $data.config_devices_standard.table_buttons,
                columns_config: $data.config_devices_standard.columns_config,
                data_url: $data.config_devices_standard.data_url,
                enable_search: $data.config_devices_standard.enable_search,
                filter_buttons: $data.config_devices_standard.table_filters,
                table_config: $data.config_devices_standard.table_config,
                base_url: $data.base_url,
                base_params: $props.url_params
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config", "base_url", "base_params"])
            ])
          ]),
          createBaseVNode("div", _hoisted_8$z, [
            ($props.is_admin)
              ? (openBlock(), createElementBlock("button", _hoisted_9$s, [
                  _hoisted_10$p,
                  createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
                ]))
              : createCommentVNode("v-if", true),
            createBaseVNode("a", {
              href: $data.get_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "periodicity_map.json",
              target: "_blank"
            }, _hoisted_13$f, 8 /* PROPS */, _hoisted_11$m)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$1a.render = render$8;
  script$1a.__file = "http_src/vue/page-periodicity-table.vue";

  /**
      (C) 2022 - ntop.org    
  */


  const defaultOptions = { 
    autoResize: true, /* By default already true */
    nodes: { 
      shape: "dot", 
      scaling: {
        min: 10,
        max: 30,
        label: {
          enabled: true,
          min: 8,
          max: 30,
          drawThreshold: 12,
        },
      },
      font: {
        color: "#212529"
      },
      shadow: false,
    },
    edges: {
      width: 0.2,
      color: { inherit: "from" },
      smooth: {
          type: "continuous",
          roundness: 0
      },
      arrows: {
        to: {
          enabled: true,
          scaleFactor: 0.3,
        }
      },
      arrowStrikethrough: false,
      scaling: {
        min: 1,
        max: 5,
      }
    },
    layout: {
      improvedLayout: false,
    },
    interaction: {
      hideEdgesOnDrag: false,
      hideEdgesOnZoom: true,
      hover: false,
      tooltipDelay: 0,
    },
    physics: {
      enabled: true,
      solver: "forceAtlas2Based",
      stabilization: {
        iterations: 300,
        enabled: true // This is here just to see what's going on from the very beginning.
      },
      forceAtlas2Based: {
        centralGravity: 0.01,
        springLength: 100,
      }
    },
    groups: {
        unknown: {
            shape: "dot",
        },
        printer: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf02f',
            size: 50,
            weight: 700,
          },
        },

        video: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf03d',
            size: 50,
            weight: 700,
          },
        },

        workstation: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf109',
            size: 50,
            weight: 700,
          },
        },

        laptop: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf109',
            size: 50,
            weight: 700,
          },
        },

        tablet: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf10a',
            size: 50,
            weight: 700,
          },
        },

        phone: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf10b',
            size: 50,
            weight: 700,
          },
        },

        tv: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf26c',
            size: 50,
            weight: 700,
          },
        },

        networking: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf0b2',
            size: 50,
            weight: 700,
          },
        },

        wifi: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf1eb',
            size: 50,
            weight: 700,
          },
        },

        nas: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf1c0',
            size: 50,
            weight: 700,
          },
        },

        multimedia: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\uf001',
            size: 50,
            weight: 700,
          },
        },

        iot: {
          shape: "icon",
          icon: {
            face: 'FontAwesome',
            code: '\ue012',
            size: 50,
            weight: 700,
          },
        },

    },
  };

  const ntopng_map_manager = {
    /**
     * Change the status of a service.
     * @param {string} service_id id of the service.
     * @param {string} new_state id of the new status of the service.
     * @param {function} callback function to be called on success.
     */
    toggle_state: function(service_id, new_state, callback, csrf) {
      const request = $.post(`${http_prefix}/lua/pro/enterprise/switch_service_state.lua`, { 
        service_id: service_id, service_status: new_state, csrf: csrf
      });
      request.then((data) => {
        if(data.success && callback) 
          callback();
      });
    },
    get_default_options: function() {
      return defaultOptions;
    },
  };

  const change_service_table_tab_event = "change_service_table_tab_event";

  var script$19 = {
    components: {	  
      'datatable': script$1g,
      'modal-delete-confirm': script$1c,
      'tab-list': script$1d,
      NoteList: script$1u
    },
    props: {
      page_csrf: String,
      url_params: Object,
      view: String,
      table_filters: Array,
      is_admin: Boolean,
      service_acceptance: Array,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      this.service_table_tab = ntopng_url_manager$1.get_url_entry('view') || 'standard';
      ntopng_url_manager$1.set_key_to_url('view', this.service_table_tab);
      this.tab_list.forEach((i) => {
        if(this.service_table_tab == i.id)
          i.active = true;
      });
      start_datatable$3(this);
    },
    mounted() {
      ntopng_events_manager$1.on_custom_event("page_service_table", ntopng_custom_events.DATATABLE_LOADED, () => {
        if(ntopng_url_manager$1.get_url_entry('host'))
          this.hide_dropdowns();
      });

      ntopng_events_manager$1.on_custom_event("change_service_table_tab", change_service_table_tab_event, (tab) => {
  	    let table = this.get_active_table();
        ntopng_url_manager$1.set_key_to_url('view', tab);
        table.delete_button_handlers(this.service_table_tab);
        table.destroy_table();
        this.service_table_tab = tab;
      });
      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
    },    
    data() {
      return {
        i18n: (t) => i18n(t),
        config_devices_standard: null,
        config_devices_centrality: null,
        title_delete: i18n('map_page.delete_services'),
        body_delete: i18n('map_page.delete_services_message'),
        get_url: null,
        service_table_tab: null,
        notes: [i18n('map_page.table_note_service_map')],
        tab_list: [
          { 
            title: i18n('map_page.standard_view'),
            active: (view == 'standard'),
            id: 'standard'
          },
          { 
            title: i18n('map_page.centrality_view'),
            active: (view == 'centrality'),
            id: 'centrality'
          },
        ]
      };
    },
    methods: { 
      hide_dropdowns: function() {
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
        $(`#network_dropdown`).removeClass('d-inline');
        $(`#vlan_id_dropdown`).removeClass('d-inline');
      }, 
      destroy: function() {
        let table = this.get_active_table();
        table.delete_button_handlers(this.service_table_tab);
        table.destroy_table();
      },
      /* Method used to switch active table tab */
      click_item: function(item) {
        this.tab_list.forEach((i) => i.active = false);
        item.active = true;
        ntopng_events_manager$1.emit_custom_event(change_service_table_tab_event, item.id);
      },
      create_action_buttons: function(data, type, service) {
        const reload = this.reload_table;
        const csrf = this.$props.page_csrf;
        const toggle_allowed_state = {
          onClick: () => {
            ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[0].id, reload, csrf);
          }
        };
        const toggle_denied_state = {
          onClick: () => {
            ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[1].id, reload, csrf);
          }
        };
        const toggle_undecided_state = {
          onClick: () => {
            ntopng_map_manager.toggle_state(service.hash_id, this.$props.service_acceptance[2].id, reload, csrf);
          }
        };

        if (type !== "display") return data;
        const currentStatus = service.acceptance;
        const allowedButton = { class: 'dropdown-item', href: '#', title: this.$props.service_acceptance[0].label, handler: toggle_allowed_state };
        const deniedButton = { class: 'dropdown-item', href: '#', title: this.$props.service_acceptance[1].label, handler: toggle_denied_state };
        const undecidedButton = { class: 'dropdown-item disabled', href: '#', title: this.$props.service_acceptance[2].label, handler: toggle_undecided_state };
        
        switch (currentStatus) {
          case 0: /* Allowed */   { allowedButton.class = 'dropdown-item active'; break; }
          case 1: /* Denied */    { deniedButton.class = 'dropdown-item active'; break; }
          case 2: /* Undecided */ { undecidedButton.class = 'dropdown-item active disabled'; break; }
        }
        return DataTableUtils.createActionButtons([undecidedButton, allowedButton, deniedButton]);
      },

      create_action_button_historical_flow_link: function(_, type, rowData) {
      let historical_flow_link = {
        handlerId: "historical_flow_link",
        onClick: () => {
          historical_flow(rowData);
        },
      };

      return DataTableUtils.createActionButtons([
        { class: `pointer`, handler: historical_flow_link, icon: 'fas fa-stream', title: i18n('db_explorer.historical_data') },
      ]);
      
      },
      delete_all: async function() {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.url_params.ifid,
          action: 'reset',
          page: this.url_params.page,
          csrf: this.$props.page_csrf,
          map: this.url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          this.reload_table();
        } catch(err) {
          this.reload_table();  
        }      
      },
      reload_table: function() {
        let table = this.get_active_table();
        NtopUtils.showOverlays();
        table.reload();
        NtopUtils.hideOverlays();
      },
      get_active_table: function() {
        return this.$refs[`table_service_${this.service_table_tab}`];
      },
      switch_to_standard: function() {
        let new_url = this.url_params;
        new_url['view'] = 'standard';
        document.location.href = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/network_maps.lua`, url_params);
      },
      switch_to_centrality: function() {
        let new_url = this.url_params;
        new_url['view'] = 'centrality';
        document.location.href = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/network_maps.lua`, url_params);
      },
      show_delete_all_dialog: function() {
        this.$refs["modal_delete_all"].show();
      },  
    },
  };  

  function historical_flow(row) {
    const client_ip = row.client.split("host=")[1].split(">")[0];
    const client = client_ip.substring(0, client_ip.length - 1);
    const server_ip = row.server.split("host=")[1].split(">")[0];
    const server = server_ip.substring(0, server_ip.length - 1);
    const port = row.port;

    const epoch_begin = row.first_seen;
    const epoch_end = row.last_seen.epoch_end;

    const params = {
      epoch_begin: epoch_begin,
      epoch_end: epoch_end,
      srv_ip: `${server};eq`,
      cli_ip: `${client};eq`,
      srv_port: `${port};eq`,
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);
    const url = `${http_prefix}/lua/pro/db_search.lua?${url_params}`;
    ntopng_url_manager$1.go_to_url(url);

  }

  function start_datatable$3(DatatableVue) {
    const datatableButton = [];
    let columns = [];
    let default_sorting_columns = 0;
    DatatableVue.get_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, url_params);
    
    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        DatatableVue.reload_table();
      }
    });
    
    let tmp_params = url_params;
    tmp_params['view'] = 'standard';
    
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      columns_config: [],
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params),
      enable_search: true,
    };

    let table_filters = [];
    for (let filter of (DatatableVue.$props.table_filters || [])) {
      filter.callbackFunction = (table, value) => {
        tmp_params['view'] = DatatableVue.service_table_tab;
        tmp_params[filter.filterMenuKey] = value.id;
        ntopng_url_manager$1.set_key_to_url(filter.filterMenuKey, value.id);
        table.ajax.url(NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params));
        NtopUtils.showOverlays();
        table.ajax.reload();
        NtopUtils.hideOverlays();
      },
      table_filters.push(filter);
    }
    
    /* Standard table configuration */  

    columns = [
      { columnName: i18n("actions"), name: 'actions', data: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) {
          return DatatableVue.create_action_button_historical_flow_link(_, type,rowData);
        }, createdCell: DataTableRenders.applyCellStyle
      }, { columnName: i18n("map_page.last_seen"), name: 'last_seen', data: 'last_seen', className: 'text-center text-nowrap', render: (data, type) => { return data.value }, responsivePriority: 2 },
      { columnName: i18n("map_page.client"), name: 'client', data: 'client', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("map_page.server"), name: 'server', data: 'server', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("map_page.port"), name: 'port', data: 'port',  className: 'text-center', responsivePriority: 4 },
      { columnName: i18n("map_page.protocol"), name: 'l7proto', data: 'protocol', className: 'text-nowrap', responsivePriority: 3 },
      { columnName: i18n("map_page.first_seen"), name: 'first_seen', data: 'first_seen', visible: false, responsivePriority: 3 },
      { columnName: i18n("map_page.num_uses"), name: 'num_uses', data: 'num_uses',  className: 'text-center text-nowrap', responsivePriority: 4 },
      { columnName: i18n("map_page.info"), name: 'info', data: 'info', responsivePriority: 5 },
    ];

    default_sorting_columns = 7; /* Num Uses */

    if(DatatableVue.is_admin) {
      columns.push({ columnName: i18n("map_page.status"), name: 'service_acceptance', data: 'service_acceptance', className: 'text-center', orderable: false, responsivePriority: 1, render: (data, type, service) => {
          return DatatableVue.create_action_buttons(data, type, service);
        }
      });


    }
    
    /* Extra table configuration */
    let table_config = {
      serverSide: true,
      order: [[ default_sorting_columns, 'desc' ]]
    };
    
    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
    configDevices.data_url = `${configDevices.data_url}`;
    configDevices.columns_config = columns;
    configDevices.table_filters = table_filters;
    configDevices.table_config = ntopng_utility.clone(table_config);
    DatatableVue.config_devices_standard = configDevices;

    /* Centrality table configuration */

    tmp_params['view'] = 'centrality';  
    defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/pro/enterprise/get_map.lua`, tmp_params);

    columns = [
      { columnName: i18n("map_page.host"), name: 'host', data: 'host', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("map_page.total_edges"), name: 'total_edges', data: 'total_edges', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("map_page.rank"), name: 'rank', data: 'rank', className: 'text-center', responsivePriority: 2 },
      { columnName: i18n("map_page.in_edges"), name: 'in_edges', data: 'in_edges', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("map_page.out_edges"), name: 'out_edges', data: 'out_edges',  className: 'text-center', responsivePriority: 2 },
    ];
    
    default_sorting_columns = 2; /* Rank */
    table_config.order = [[ default_sorting_columns, 'desc' ]];
    configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
    configDevices.data_url = `${configDevices.data_url}`;
    configDevices.columns_config = columns;
    configDevices.table_filters = table_filters;
    configDevices.table_config = ntopng_utility.clone(table_config);
    DatatableVue.config_devices_centrality = configDevices;
  }

  const _hoisted_1$10 = { class: "row" };
  const _hoisted_2$V = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$T = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$Q = { class: "card" };
  const _hoisted_5$L = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_6$C = { class: "card-body" };
  const _hoisted_7$z = { id: "table_service" };
  const _hoisted_8$y = { class: "card-footer" };
  const _hoisted_9$r = {
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_10$o = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_11$l = ["href"];
  const _hoisted_12$k = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_13$e = [
    _hoisted_12$k
  ];

  function render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_tab_list = resolveComponent("tab-list");
    const _component_datatable = resolveComponent("datatable");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$10, [
      createBaseVNode("div", _hoisted_2$V, [
        _hoisted_3$T,
        createBaseVNode("div", _hoisted_4$Q, [
          _hoisted_5$L,
          createBaseVNode("div", _hoisted_6$C, [
            createBaseVNode("div", _hoisted_7$z, [
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_tab_list, {
                ref: "service_tab_list",
                id: "service_tab_list",
                tab_list: $data.tab_list,
                onClick_item: $options.click_item
              }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
              ($data.service_table_tab == 'standard')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 0,
                    ref: "table_service_standard",
                    table_buttons: $data.config_devices_standard.table_buttons,
                    columns_config: $data.config_devices_standard.columns_config,
                    data_url: $data.config_devices_standard.data_url,
                    enable_search: $data.config_devices_standard.enable_search,
                    filter_buttons: $data.config_devices_standard.table_filters,
                    table_config: $data.config_devices_standard.table_config
                  }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config"]))
                : createCommentVNode("v-if", true),
              ($data.service_table_tab == 'centrality')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 1,
                    ref: "table_service_centrality",
                    table_buttons: $data.config_devices_centrality.table_buttons,
                    columns_config: $data.config_devices_centrality.columns_config,
                    data_url: $data.config_devices_centrality.data_url,
                    enable_search: $data.config_devices_centrality.enable_search,
                    filter_buttons: $data.config_devices_centrality.table_filters,
                    table_config: $data.config_devices_centrality.table_config
                  }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "filter_buttons", "table_config"]))
                : createCommentVNode("v-if", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_8$y, [
            createCommentVNode("\n        {% if is_admin then %}\n          <form class=\"d-inline\" id='switch-state-form'>\n            <div class=\"form-group mb-3 d-inline\">\n              <label>{* i18n(\"map_page.set_state\", {label = \"<span class='count'></span>\"}) *}</label>\n              <select name=\"new_state\" class=\"form-select d-inline\" style=\"width: 16rem\" {{ ternary(map.services_num == 0, \"disabled='disabled'\", \"\") }}>\n              {% for _, status in pairsByField(map.filters.service_status_filters, label, asc_insensitive) do %}\n                <option value=\"{{ status.id }}\">{* status.label *}</option>\n              {% end %}\n              </select>\n              <button class=\"btn btn-secondary d-inline\" class=\"btn-switch-state\" {{ ternary(map.services_num == 0, \"disabled='disabled'\", \"\") }}>\n                <i class=\"fas fa-random\"></i> {{ i18n(\"set\") }}\n              </button>\n            </div>\n          </form>\n        {% end %}\n    "),
            createBaseVNode("button", _hoisted_9$r, [
              _hoisted_10$o,
              createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
            ]),
            createBaseVNode("a", {
              href: $data.get_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "service_map.json",
              target: "_blank"
            }, _hoisted_13$e, 8 /* PROPS */, _hoisted_11$l)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$19.render = render$7;
  script$19.__file = "http_src/vue/page-service-table.vue";

  const _hoisted_1$$ = {
    key: 0,
    class: "alert alert-info"
  };
  const _hoisted_2$U = ["id"];


  var script$18 = {
    __name: 'network-map',
    props: {
    empty_message: String,
    event_listeners: Object,
    page_csrf: String,
    url: String,
    url_params: Object,
    map_id: String,
  },
    setup(__props, { expose }) {

  const props = __props;



  const dataRequest = { 
    ifid: props.url_params.ifid, 
    action: 'load_graph', 
    map: props.url_params.map_id
  };

  let nodes_dataset = {};
  let edges_dataset = {};
  let highlightActive = false;
  let network = null;
  const max_entries_reached = ref(false);
  const empty_map = ref(true);
  const is_destroyed = ref(false);
  const url_params = ref({});
  const datasets = ref(null);
  const options = ref(null);
  const all_nodes = ref(null);

  onMounted(async () => {
    const container = document.getElementById(props.map_id);
    load_scale();
    await request_info();
    options.value = ntopng_map_manager.get_default_options();
    network = new vis.Network(container, datasets.value, options.value);
    set_event_listener();
  });

  onBeforeUnmount(() => {
    if (is_destroyed.value == true) { 
      return; 
    }
    destroy();
  });

  const generate_html_tooltip = (x) => {
    const container = document.createElement("div");
    /* Necessary, otherwise it will go in conflict with other css */
    //container.style.color = "#111111";
    container.innerHTML = `<b>${x.label}</b><br><br>${i18n('db_explorer.host_data')}: ${x.id}`;
    return container;
  };

  /* This function is used to perform the request */
  const request_info = async() => {
    /* if an host has been defined inside the URL query then add it to the request */
    url_params.value = props.url_params;
    const url = NtopUtils.buildURL(props.url, url_params.value); 
    await $.get(url, dataRequest, async function(response) {
      const { nodes, edges, max_entry_reached } = response.rsp;
      max_entries_reached.value = max_entry_reached;
      /* Adding tooltip to each node */
      nodes_dataset = new vis.DataSet(nodes.map((x) => {
        x.title = generate_html_tooltip(x);
        return x;
      }));
      edges_dataset = new vis.DataSet(edges);
      datasets.value = {
        nodes: nodes_dataset, 
        edges: edges_dataset
      };
      all_nodes.value = nodes_dataset.get({ returnType: "Object" });
      empty_network();
  	});
  };

  /* Add the host to the url and jump to the host */
  const jump_to_host = async (params) => {
    const host_info = params.id.split('@');
    url_params.value['host'] = host_info[0]; /* Host IP */
    url_params.value['vlan_id'] = host_info[1]; /* VLAN ID */
    ntopng_url_manager$1.set_key_to_url('host', url_params.value['host']);
    ntopng_url_manager$1.set_key_to_url('vlan_id', url_params.value['vlan_id']);
    ntopng_events_manager$1.emit_custom_event(ntopng_custom_events.CHANGE_PAGE_TITLE, params);
    await reload();
  };

  /* In case of empty network enable the "Empty Network" message */
  const empty_network = () => {
    if(datasets.value?.nodes.length == 0 
      && datasets.value?.edges.length == 0) {
      empty_map.value = true;
    } else {
      empty_map.value = false;
    }
  };

  /* Fix the resizable width/height of the container */
  const load_scale = () => {
    const oldScale = NtopUtils.loadElementScale($(`.resizable-y-container`));

    if(oldScale == null) {
      const scale = {width: $(`.resizable-y-container`).width(), height: $(`.resizable-y-container`).height()};
      NtopUtils.saveElementScale($(this), scale);
      return;
    }

    $(`.resizable-y-container`).width(oldScale.width);
    $(`.resizable-y-container`).height(oldScale.height);
    $(`.resizable-y-container`).on('mouseup', function() {
      const scale = {width: $(`.resizable-y-container`).width(), height: $(`.resizable-y-container`).height()};
      NtopUtils.saveElementScale($(this), scale);
    });
  };    

  function neighbourhoodHighlight(params) {
    // if something is selected:
    if (params.nodes.length > 0) {
      highlightActive = true;
      var i, j;
      var selectedNode = params.nodes[0];
      var degrees = 2;

      // mark all nodes as hard to read.
      for (var nodeId in all_nodes.value) {
        if(!all_nodes.value[nodeId].old_color) {
          all_nodes.value[nodeId].old_color = 
            all_nodes.value[nodeId].color;
        }
        if(!all_nodes.value[nodeId].old_icon_color) {
          all_nodes.value[nodeId].old_icon_color = 
            all_nodes.value[nodeId].icon;
        }
        all_nodes.value[nodeId].color = "#c8c8c8";
        all_nodes.value[nodeId].icon = {
          color: "#c8c8c8"
        };
        if (all_nodes.value[nodeId].hiddenLabel === undefined) {
          all_nodes.value[nodeId].hiddenLabel = all_nodes.value[nodeId].label;
          all_nodes.value[nodeId].label = undefined;
        }
      }
      var connectedNodes = network.getConnectedNodes(selectedNode);
      var allConnectedNodes = [];

      // get the second degree nodes
      for (i = 1; i < degrees; i++) {
        for (j = 0; j < connectedNodes.length; j++) {
          allConnectedNodes = allConnectedNodes.concat(
            network.getConnectedNodes(connectedNodes[j])
          );
        }
      }

      // all first degree nodes get their own color and their label back
      for (i = 0; i < connectedNodes.length; i++) {
        all_nodes.value[connectedNodes[i]].color = 
          all_nodes.value[connectedNodes[i]].old_color;
        all_nodes.value[connectedNodes[i]].icon = 
          all_nodes.value[connectedNodes[i]].old_icon_color;
        if (all_nodes.value[connectedNodes[i]].hiddenLabel !== undefined) {
          all_nodes.value[connectedNodes[i]].label =
            all_nodes.value[connectedNodes[i]].hiddenLabel;
          all_nodes.value[connectedNodes[i]].hiddenLabel = undefined;
        }
      }

      // the main node gets its own color and its label back.
      all_nodes.value[selectedNode].color = 
        all_nodes.value[selectedNode].old_color;
      all_nodes.value[selectedNode].icon = 
        all_nodes.value[selectedNode].old_icon_color;
      if (all_nodes.value[selectedNode].hiddenLabel !== undefined) {
        all_nodes.value[selectedNode].label = all_nodes.value[selectedNode].hiddenLabel;
        all_nodes.value[selectedNode].hiddenLabel = undefined;
      }
    } else if (highlightActive === true) {
      // reset all nodes
      for (var nodeId in all_nodes.value) {
        all_nodes.value[nodeId].color = 
          all_nodes.value[nodeId].old_color;
        all_nodes.value[nodeId].icon = 
          all_nodes.value[nodeId].old_icon_color;
        if (all_nodes.value[nodeId].hiddenLabel !== undefined) {
          all_nodes.value[nodeId].label = all_nodes.value[nodeId].hiddenLabel;
          all_nodes.value[nodeId].hiddenLabel = undefined;
        }
      }
      highlightActive = false;
    }

    // transform the object into an array
    var updateArray = [];
    for (nodeId in all_nodes.value) {
      if (all_nodes.value.hasOwnProperty(nodeId)) {
        updateArray.push(all_nodes.value[nodeId]);
      }
    }
    nodes_dataset.update(updateArray);
  }


  /* Set the event lister used for callbacks */
  const set_event_listener = () => {
    network.on("stabilizationIterationsDone", function() {
      network.setOptions( { physics: false } );
    });
    network.on("click", function(node) {
      neighbourhoodHighlight(node);
    });

    network.on("doubleClick", function (params) {
      jump_to_host(nodes_dataset.get(params.nodes[0]));
    });

    network.on("afterDrawing", function(e) {
      ntopng_events_manager$1.emit_custom_event(ntopng_custom_events.VIS_DATA_LOADED);
    });

    /* Given event listeners */
    for (const item in (props.event_listeners || {})) {
      network.on(item, props.event_listeners[item]);
    }
  };

  /* Function used to autolayout/stabilize the network */
  const autolayout = () => {
    if (network == null) {
      console.error("The network is undefined!");
      return;
    }

    if (!(network instanceof vis.Network)) {
      console.error("Not a vis.Network instance!");
      return;
    }

    network.stabilize();
  };

  /* Destroy the network if it's not null */
  const destroy = () => {
    if(network != null)
      network.destroy(true);

    is_destroyed.value = true;
  };

  /* This return true if the maximum number of nodes/edges has been reached */
  const is_max_entry_reached = () => {
    return max_entries_reached.value;
  };

  /* Function used to update the params */
  const update_url_params = (new_url_params) => {
    url_params.value = new_url_params;
  };

  /* Function used to reload the map */
  const reload = async () => {
    await request_info();
    if(network != null) {
      /* Reload of the physics is done due to a possible bug,
       * with many nodes, the physics could stuck infinitely 
       */
      network.setOptions({ physics: options.value.physics });
      network.setData(datasets.value);
    }
  };


  expose({ reload, destroy, is_max_entry_reached, autolayout, update_url_params });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      (empty_map.value)
        ? (openBlock(), createElementBlock("div", _hoisted_1$$, toDisplayString(__props.empty_message), 1 /* TEXT */))
        : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        class: "d-flex justify-content-center align-items-center resizable-y-container",
        style: {"width":"100%","height":"60vh"},
        id: __props.map_id
      }, null, 8 /* PROPS */, _hoisted_2$U)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$18.__file = "http_src/vue/network-map.vue";

  var script$17 = {
    __name: 'modal-autolayout-confirm',
    props: {
      body: String,
      title: String,
  },
    emits: ['autolayout'],
    setup(__props, { expose, emit }) {

  const modal_id = ref(null);


  const showed = () => {};



  const show = () => {
      modal_id.value.show();
  };

  const autolayout_ = () => {
      emit('autolayout');
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[0] || (_cache[0] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(__props.body), 1 /* TEXT */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: autolayout_,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('confirm')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$17.__file = "http_src/vue/modal-autolayout-confirm.vue";

  const change_filter_event$2 = "change_filter_event";

  var script$16 = {
    components: {
      'network-map': script$18,
      'modal-delete-confirm': script$1c,
      'modal-autolayout-confirm': script$17,
      'select-search': script$1I,
      NoteList: script$1u
  },
    props: {
      page_csrf: String,
      ifid: Number,
      url_params: Object,
      map_id: String,
      is_admin: Boolean,
      all_filter_list: Object,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_vis_network_map$2(this);
    },
    mounted() {
      const max_entries_reached = this.max_entry_reached;
      const reload_map = this.reload_map;
      if (this.$props.url_params.host && this.$props.url_params.host != '') {
        this.hide_dropdowns();
      }

      ntopng_events_manager$1.on_custom_event("page_service_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
        this.hide_dropdowns();
      });

      ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event$2, (filter) => {
        this.active_filter_list.forEach((filter_el, i) => {
          if (filter_el.filter_name == filter.filter_name) {
            this.active_filter_list[i] = filter;
          }
        });
        ntopng_url_manager.set_key_to_url(filter.filter_name, filter.key);
        this.url_params[filter.filter_name] = filter.key;
        this.update_and_reload_map();
      });

      ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
        if (max_entries_reached()) {
          $(`#max-entries-reached`).removeAttr('hidden');
        } else {
          $(`#max-entries-reached`).attr('hidden', 'hidden');
        }
        NtopUtils.hideOverlays();
      });

      /* Remove invalid filters */
      let entries = ntopng_url_manager.get_url_entries();
      for (const [key, value] of entries) {
        this.url_params[key] = value;
      }

      //this.update_and_reload_map()

      $(`#reload-graph`).click(function (e) {
        reload_map();
      });

      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
      $("#autolayout").click(() => this.show_autolayout_dialog());
    },
    data() {

      return {
        i18n: (t) => i18n(t),
        container: null,
        update_view_state_id: null,
        get_url: null,
        download_url: null,
        filter_list: [],
        active_filter_list: [],
        event_listeners: {},
        title_delete: i18n('map_page.delete_services'),
        body_delete: i18n('map_page.delete_services_message'),
        title_autolayout: i18n('map_page.autolayout_services'),
        body_autolayout: i18n('map_page.autolayout_services_message'),
        no_services_message: i18n('map_page.no_services'),
        max_entry_title: i18n('max_entries_reached'),
        notes: [i18n('map_page.graph_note_service_map')]
      };
    },
    methods: {
      destroy: function () {
        let map = this.get_map();
        map.destroy();
      },
      /* Method used to switch active table tab */
      click_item: function (filter) {
        ntopng_events_manager$1.emit_custom_event(change_filter_event$2, filter);
      },
      get_map: function () {
        return this.$refs[`service_map`];
      },
      max_entry_reached: function () {
        let map = this.get_map();
        return map.is_max_entry_reached();
      },
      reload_map: async function () {
        NtopUtils.showOverlays();
        let map = this.get_map();
        await map.reload();
      },
      update_and_reload_map: async function () {
        let map = this.get_map();
        NtopUtils.showOverlays();
        map.update_url_params(this.url_params);
        await map.reload();
      },
      autolayout: function () {
        let map = this.get_map();
        map.autolayout();
      },
      show_delete_all_dialog: function () {
        this.$refs["modal_delete_all"].show();
      },
      show_autolayout_dialog: function () {
        this.$refs["modal_autolayout"].show();
      },
      hide_dropdowns: function () {
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
      },
      delete_all: async function () {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.url_params.ifid,
          action: 'reset',
          csrf: this.$props.page_csrf,
          map: this.url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
        } finally {
          this.reload_map();
        }
      },
    },
  };

  function start_vis_network_map$2(NetworkMapVue) {
    /* Format the filter list, to add the dropdowns */
    for (const filter_name in NetworkMapVue.$props.all_filter_list) {
      NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
      const active_filter = ntopng_url_manager.get_url_entry(filter_name);
      /* Put the filter name into the filters */
      for (let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
        value['filter_name'] = filter_name;
        if (active_filter) {
          /* If there is a filter selected in the url push that as active */
          if (value.id == active_filter)
            NetworkMapVue.active_filter_list.push(value);
        } else {
          /* push the default filter as active */
          if (value.currently_active == true)
            NetworkMapVue.active_filter_list.push(value);
        }
      }
    }

    NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
    NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.$props.url_params);
    NetworkMapVue.event_listeners = {};
  }

  const _hoisted_1$_ = { class: "row" };
  const _hoisted_2$T = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$S = { class: "card card-shadow" };
  const _hoisted_4$P = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$K = { class: "card-body" };
  const _hoisted_6$B = { id: "table_service" };
  const _hoisted_7$y = { class: "d-flex align-items-center justify-content-end mb-2" };
  const _hoisted_8$x = ["title"];
  const _hoisted_9$q = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
  const _hoisted_10$n = [
    _hoisted_9$q
  ];
  const _hoisted_11$k = { class: "d-flex ms-auto" };
  const _hoisted_12$j = { class: "m-1" };
  const _hoisted_13$d = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "reload-graph",
    class: "btn btn-link btn-reload-graph"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_14$d = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "autolayout",
    class: "btn btn-link btn-stabilize"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
  ], -1 /* HOISTED */);
  const _hoisted_15$b = { class: "card-footer" };
  const _hoisted_16$b = {
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_17$a = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_18$a = ["href"];
  const _hoisted_19$a = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_20$a = [
    _hoisted_19$a
  ];

  function render$6(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_search = resolveComponent("select-search");
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
    const _component_network_map = resolveComponent("network-map");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$_, [
      createBaseVNode("div", _hoisted_2$T, [
        createBaseVNode("div", _hoisted_3$S, [
          _hoisted_4$P,
          createBaseVNode("div", _hoisted_5$K, [
            createBaseVNode("div", _hoisted_6$B, [
              createBaseVNode("div", _hoisted_7$y, [
                createBaseVNode("button", {
                  id: "max-entries-reached",
                  type: "button",
                  class: "btn btn-link",
                  title: $data.max_entry_title,
                  disabled: "",
                  hidden: ""
                }, _hoisted_10$n, 8 /* PROPS */, _hoisted_8$x),
                createBaseVNode("div", _hoisted_11$k, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
                    return (openBlock(), createElementBlock("div", _hoisted_12$j, [
                      createVNode(_component_select_search, {
                        selected_option: $data.active_filter_list[index],
                        "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
                        options: $data.filter_list[index],
                        onSelect_option: $options.click_item
                      }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _hoisted_13$d,
                _hoisted_14$d
              ]),
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_modal_autolayout_confirm, {
                ref: "modal_autolayout",
                title: $data.title_autolayout,
                body: $data.body_autolayout,
                onAutolayout: $options.reload_map
              }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
              createVNode(_component_network_map, {
                ref: "service_map",
                empty_message: $data.no_services_message,
                event_listeners: $data.event_listeners,
                page_csrf: $props.page_csrf,
                url: $data.get_url,
                url_params: $props.url_params,
                map_id: $props.map_id
              }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$b, [
            createBaseVNode("button", _hoisted_16$b, [
              _hoisted_17$a,
              createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
            ]),
            createBaseVNode("a", {
              href: $data.download_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "service_map.json",
              target: "_blank"
            }, _hoisted_20$a, 8 /* PROPS */, _hoisted_18$a)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$16.render = render$6;
  script$16.__file = "http_src/vue/page-service-map.vue";

  const change_filter_event$1 = "change_filter_event";

  var script$15 = {
    components: {
      'network-map': script$18,
      'modal-delete-confirm': script$1c,
      'modal-autolayout-confirm': script$17,
      'select-search': script$1I,
      NoteList: script$1u
    },
    props: {
      page_csrf: String,
      ifid: Number,
      url_params: Object,
      map_id: String,
      is_admin: Boolean,
      all_filter_list: Object,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_vis_network_map$1(this);
    },
    mounted() {
      this.updated_url_params = this.$props.url_params;
      /* Remove invalid filters */
      let entries = ntopng_url_manager.get_url_entries();
      for (const [key, value] of entries) {
        this.updated_url_params[key] = value;
      }

      const max_entries_reached = this.max_entry_reached;
      const reload_map = this.reload_map;
      this.update_and_reload_map();
      if (this.$props.url_params.host && this.$props.url_params.host != '') {
        this.hide_dropdowns();
      }

      ntopng_events_manager$1.on_custom_event("page_periodicity_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
        this.hide_dropdowns();
      });

      ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event$1, (filter) => {
        this.active_filter_list.forEach((filter_el, i) => {
          if (filter_el.filter_name == filter.filter_name) {
            this.active_filter_list[i] = filter;
          }
        });
        ntopng_url_manager.set_key_to_url(filter.filter_name, filter.key);
        this.url_params[filter.filter_name] = filter.key;
        this.update_and_reload_map();
      });

      ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
        if (max_entries_reached()) {
          $(`#max-entries-reached`).removeAttr('hidden');
        } else {
          $(`#max-entries-reached`).attr('hidden', 'hidden');
        }
        NtopUtils.hideOverlays();
      });

      $(`#reload-graph`).click(function (e) {
        reload_map();
      });

      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
      $("#autolayout").click(() => this.show_autolayout_dialog());
    },
    data() {
      return {
        i18n: (t) => i18n(t),
        container: null,
        update_view_state_id: null,
        get_url: null,
        download_url: null,
        updated_url_params: {},
        filter_list: [],
        active_filter_list: [],
        event_listeners: {},
        title_delete: i18n('map_page.delete_services'),
        body_delete: i18n('map_page.delete_services_message'),
        title_autolayout: i18n('map_page.autolayout_services'),
        body_autolayout: i18n('map_page.autolayout_services_message'),
        no_services_message: i18n('map_page.no_services'),
        max_entry_title: i18n('max_entries_reached'),      
        notes: [i18n('map_page.graph_note_periodicity_map')]

      };
    },
    methods: {
      destroy: function () {
        let map = this.get_map();
        map.destroy();
      },
      /* Method used to switch active table tab */
      click_item: function (filter) {
        ntopng_events_manager$1.emit_custom_event(change_filter_event$1, filter);
      },
      get_map: function () {
        return this.$refs[`periodicity_map`]
      },
      max_entry_reached: function () {
        let map = this.get_map();
        return map.is_max_entry_reached();
      },
      reload_map: async function () {
        NtopUtils.showOverlays();
        let map = this.get_map();
        await map.reload();
      },
      hide_dropdowns: function () {
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
      },
      update_and_reload_map: async function () {
        let map = this.get_map();
        NtopUtils.showOverlays();
        map.update_url_params(this.updated_url_params);
        await map.reload();
      },
      autolayout: function () {
        let map = this.get_map();
        map.autolayout();
      },
      show_delete_all_dialog: function () {
        this.$refs["modal_delete_all"].show();
      },
      show_autolayout_dialog: function () {
        this.$refs["modal_autolayout"].show();
      },
      delete_all: async function () {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.updated_url_params.ifid,
          action: 'reset',
          csrf: this.$props.page_csrf,
          map: this.updated_url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
        } finally {
          this.reload_map();
        }
      },
    },
  };

  function start_vis_network_map$1(NetworkMapVue) {
    /* Format the filter list, to add the dropdowns */
    for (const filter_name in NetworkMapVue.$props.all_filter_list) {
      NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
      const active_filter = ntopng_url_manager.get_url_entry(filter_name);
      /* Put the filter name into the filters */
      for (let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
        value['filter_name'] = filter_name;
        if (active_filter) {
          /* If there is a filter selected in the url push that as active */
          if (value.id == active_filter)
            NetworkMapVue.active_filter_list.push(value);
        } else {
          /* push the default filter as active */
          if (value.currently_active == true)
            NetworkMapVue.active_filter_list.push(value);
        }
      }
    }

    NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
    NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.updated_url_params);
    NetworkMapVue.event_listeners = {};
  }

  const _hoisted_1$Z = { class: "row" };
  const _hoisted_2$S = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$R = { class: "card card-shadow" };
  const _hoisted_4$O = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$J = { class: "card-body" };
  const _hoisted_6$A = { id: "table_periodicity" };
  const _hoisted_7$x = { class: "d-flex align-items-center justify-content-end mb-2" };
  const _hoisted_8$w = ["title"];
  const _hoisted_9$p = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
  const _hoisted_10$m = [
    _hoisted_9$p
  ];
  const _hoisted_11$j = { class: "d-flex ms-auto" };
  const _hoisted_12$i = { class: "m-1" };
  const _hoisted_13$c = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "reload-graph",
    class: "btn btn-link btn-reload-graph"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_14$c = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "autolayout",
    class: "btn btn-link btn-stabilize"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
  ], -1 /* HOISTED */);
  const _hoisted_15$a = { class: "card-footer" };
  const _hoisted_16$a = {
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_17$9 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_18$9 = ["href"];
  const _hoisted_19$9 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_20$9 = [
    _hoisted_19$9
  ];

  function render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_search = resolveComponent("select-search");
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
    const _component_network_map = resolveComponent("network-map");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$Z, [
      createBaseVNode("div", _hoisted_2$S, [
        createBaseVNode("div", _hoisted_3$R, [
          _hoisted_4$O,
          createBaseVNode("div", _hoisted_5$J, [
            createBaseVNode("div", _hoisted_6$A, [
              createBaseVNode("div", _hoisted_7$x, [
                createBaseVNode("button", {
                  id: "max-entries-reached",
                  type: "button",
                  class: "btn btn-link",
                  title: $data.max_entry_title,
                  disabled: "",
                  hidden: ""
                }, _hoisted_10$m, 8 /* PROPS */, _hoisted_8$w),
                createBaseVNode("div", _hoisted_11$j, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
                    return (openBlock(), createElementBlock("div", _hoisted_12$i, [
                      createVNode(_component_select_search, {
                        selected_option: $data.active_filter_list[index],
                        "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
                        options: $data.filter_list[index],
                        onSelect_option: $options.click_item
                      }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _hoisted_13$c,
                _hoisted_14$c
              ]),
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_modal_autolayout_confirm, {
                ref: "modal_autolayout",
                title: $data.title_autolayout,
                body: $data.body_autolayout,
                onAutolayout: $options.reload_map
              }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
              createVNode(_component_network_map, {
                ref: "periodicity_map",
                empty_message: $data.no_services_message,
                event_listeners: $data.event_listeners,
                page_csrf: $props.page_csrf,
                url: $data.get_url,
                url_params: $props.url_params,
                map_id: $props.map_id
              }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$a, [
            createBaseVNode("button", _hoisted_16$a, [
              _hoisted_17$9,
              createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
            ]),
            createBaseVNode("a", {
              href: $data.download_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "periodicity_map.json",
              target: "_blank"
            }, _hoisted_20$9, 8 /* PROPS */, _hoisted_18$9)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$15.render = render$5;
  script$15.__file = "http_src/vue/page-periodicity-map.vue";

  const change_filter_event = "change_filter_event";

  var script$14 = {
    components: {
      'network-map': script$18,
      'modal-delete-confirm': script$1c,
      'modal-autolayout-confirm': script$17,
      'select-search': script$1I,
      NoteList: script$1u
    },
    props: {
      page_csrf: String,
      ifid: Number,
      url_params: Object,
      map_id: String,
      is_admin: Boolean,
      all_filter_list: Object,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_vis_network_map(this);
    },
    mounted() {
      const max_entries_reached = this.max_entry_reached;
      const reload_map = this.reload_map;
      if (this.$props.url_params.host && this.$props.url_params.host != '') {
        this.hide_dropdowns();
      }

      ntopng_events_manager$1.on_custom_event("page_service_map", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
        this.hide_dropdowns();
      });

      ntopng_events_manager$1.on_custom_event("change_filter_event", change_filter_event, (filter) => {
        this.active_filter_list.forEach((filter_el, i) => {
          if (filter_el.filter_name == filter.filter_name) {
            this.active_filter_list[i] = filter;
          }
        });
        ntopng_url_manager$1.set_key_to_url(filter.filter_name, filter.key);
        this.url_params[filter.filter_name] = filter.key;
        this.update_and_reload_map();
      });

      ntopng_events_manager$1.on_custom_event(this.get_map(), ntopng_custom_events.VIS_DATA_LOADED, (filter) => {
        if (max_entries_reached()) {
          $(`#max-entries-reached`).removeAttr('hidden');
        } else {
          $(`#max-entries-reached`).attr('hidden', 'hidden');
        }

        NtopUtils.hideOverlays();
      });

      /* Remove invalid filters */
      let entries = ntopng_url_manager$1.get_url_entries();
      for (const [key, value] of entries) {
        this.url_params[key] = value;
      }

      $(`#reload-graph`).click(function (e) {
        reload_map();
      });

      $("#btn-delete-all").click(() => this.show_delete_all_dialog());
      $("#autolayout").click(() => this.show_autolayout_dialog());
    },
    data() {
      return {
        i18n: (t) => i18n(t),
        container: null,
        update_view_state_id: null,
        get_url: null,
        download_url: null,
        filter_list: [],
        active_filter_list: [],
        event_listeners: {},
        title_delete: i18n('map_page.delete_services'),
        body_delete: i18n('map_page.delete_services_message'),
        title_autolayout: i18n('map_page.autolayout_services'),
        body_autolayout: i18n('map_page.autolayout_services_message'),
        no_services_message: i18n('map_page.no_services'),
        max_entry_title: i18n('max_entries_reached'),
        notes: [i18n('map_page.graph_note_asset_map')],
      };
    },
    methods: {
      destroy: function () {
        let map = this.get_map();
        map.destroy();
      },
      /* Method used to switch active table tab */
      click_item: function (filter) {
        ntopng_events_manager$1.emit_custom_event(change_filter_event, filter);
      },
      get_map: function () {
        return this.$refs[`asset_map`];
      },
      hide_dropdowns: function () {
        $(`#network_dropdown`).attr('hidden', 'hidden');
        $(`#vlan_id_dropdown`).attr('hidden', 'hidden');
      },
      max_entry_reached: function () {
        let map = this.get_map();
        return map.is_max_entry_reached();
      },
      reload_map: async function () {
        NtopUtils.showOverlays();
        let map = this.get_map();
        await map.reload();
      },
      update_and_reload_map: async function () {
        let map = this.get_map();
        NtopUtils.showOverlays();
        map.update_url_params(this.url_params);
        await map.reload();
      },
      autolayout: function () {
        let map = this.get_map();
        map.autolayout();
      },
      show_delete_all_dialog: function () {
        this.$refs["modal_delete_all"].show();
      },
      show_autolayout_dialog: function () {
        this.$refs["modal_autolayout"].show();
      },
      delete_all: async function () {
        let url = `${http_prefix}/lua/pro/enterprise/network_maps.lua`;
        let params = {
          ifid: this.url_params.ifid,
          action: 'reset',
          csrf: this.$props.page_csrf,
          map: this.url_params.map
        };
        try {
          let headers = {
            'Content-Type': 'application/json'
          };
          await ntopng_utility.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
        } finally {
          NtopUtils.showOverlays();
          this.reload_map();
        }
      },
    },
  };

  function start_vis_network_map(NetworkMapVue) {
    /* Format the filter list, to add the dropdowns */
    for (const filter_name in NetworkMapVue.$props.all_filter_list) {
      NetworkMapVue.filter_list.push(NetworkMapVue.$props.all_filter_list[filter_name]);
      const active_filter = ntopng_url_manager$1.get_url_entry(filter_name);
      /* Put the filter name into the filters */
      for (let [_, value] of Object.entries(NetworkMapVue.$props.all_filter_list[filter_name])) {
        value['filter_name'] = filter_name;
        if (active_filter) {
          /* If there is a filter selected in the url push that as active */
          if (value.id == active_filter)
            NetworkMapVue.active_filter_list.push(value);
        } else {
          /* push the default filter as active */
          if (value.currently_active == true)
            NetworkMapVue.active_filter_list.push(value);
        }
      }
    }

    NetworkMapVue.get_url = `${http_prefix}/lua/pro/rest/v2/get/interface/map/data.lua`;
    NetworkMapVue.download_url = NtopUtils.buildURL(NetworkMapVue.get_url, NetworkMapVue.$props.url_params);
    NetworkMapVue.event_listeners = {};
  }

  const _hoisted_1$Y = { class: "row" };
  const _hoisted_2$R = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$Q = { class: "card card-shadow" };
  const _hoisted_4$N = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$I = { class: "card-body" };
  const _hoisted_6$z = { id: "table_asset" };
  const _hoisted_7$w = { class: "d-flex align-items-center justify-content-end mb-2" };
  const _hoisted_8$v = ["title"];
  const _hoisted_9$o = /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" }, null, -1 /* HOISTED */);
  const _hoisted_10$l = [
    _hoisted_9$o
  ];
  const _hoisted_11$i = { class: "d-flex ms-auto" };
  const _hoisted_12$h = { class: "m-1" };
  const _hoisted_13$b = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "reload-graph",
    class: "btn btn-link btn-reload-graph"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_14$b = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    id: "autolayout",
    class: "btn btn-link btn-stabilize"
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-magic" })
  ], -1 /* HOISTED */);
  const _hoisted_15$9 = { class: "card-footer" };
  const _hoisted_16$9 = {
    type: "button",
    id: "btn-delete-all",
    class: "btn btn-danger me-1"
  };
  const _hoisted_17$8 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_18$8 = ["href"];
  const _hoisted_19$8 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_20$8 = [
    _hoisted_19$8
  ];

  function render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_select_search = resolveComponent("select-search");
    const _component_modal_delete_confirm = resolveComponent("modal-delete-confirm");
    const _component_modal_autolayout_confirm = resolveComponent("modal-autolayout-confirm");
    const _component_network_map = resolveComponent("network-map");
    const _component_NoteList = resolveComponent("NoteList");

    return (openBlock(), createElementBlock("div", _hoisted_1$Y, [
      createBaseVNode("div", _hoisted_2$R, [
        createBaseVNode("div", _hoisted_3$Q, [
          _hoisted_4$N,
          createBaseVNode("div", _hoisted_5$I, [
            createBaseVNode("div", _hoisted_6$z, [
              createBaseVNode("div", _hoisted_7$w, [
                createBaseVNode("button", {
                  id: "max-entries-reached",
                  type: "button",
                  class: "btn btn-link",
                  title: $data.max_entry_title,
                  disabled: "",
                  hidden: ""
                }, _hoisted_10$l, 8 /* PROPS */, _hoisted_8$v),
                createBaseVNode("div", _hoisted_11$i, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.filter_list, (_, index) => {
                    return (openBlock(), createElementBlock("div", _hoisted_12$h, [
                      createVNode(_component_select_search, {
                        selected_option: $data.active_filter_list[index],
                        "onUpdate:selected_option": $event => (($data.active_filter_list[index]) = $event),
                        options: $data.filter_list[index],
                        onSelect_option: $options.click_item
                      }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "onSelect_option"])
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _hoisted_13$b,
                _hoisted_14$b
              ]),
              createVNode(_component_modal_delete_confirm, {
                ref: "modal_delete_all",
                title: $data.title_delete,
                body: $data.body_delete,
                onDelete: $options.delete_all
              }, null, 8 /* PROPS */, ["title", "body", "onDelete"]),
              createVNode(_component_modal_autolayout_confirm, {
                ref: "modal_autolayout",
                title: $data.title_autolayout,
                body: $data.body_autolayout,
                onAutolayout: $options.reload_map
              }, null, 8 /* PROPS */, ["title", "body", "onAutolayout"]),
              createVNode(_component_network_map, {
                ref: "asset_map",
                empty_message: $data.no_services_message,
                event_listeners: $data.event_listeners,
                page_csrf: $props.page_csrf,
                url: $data.get_url,
                url_params: $props.url_params,
                map_id: $props.map_id
              }, null, 8 /* PROPS */, ["empty_message", "event_listeners", "page_csrf", "url", "url_params", "map_id"])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$9, [
            createBaseVNode("button", _hoisted_16$9, [
              _hoisted_17$8,
              createTextVNode(" " + toDisplayString($data.i18n("map_page.delete_services")), 1 /* TEXT */)
            ]),
            createBaseVNode("a", {
              href: $data.download_url,
              class: "btn btn-primary",
              role: "button",
              "aria-disabled": "true",
              download: "asset_map.json",
              target: "_blank"
            }, _hoisted_20$8, 8 /* PROPS */, _hoisted_18$8)
          ])
        ]),
        createVNode(_component_NoteList, { note_list: $data.notes }, null, 8 /* PROPS */, ["note_list"])
      ])
    ]))
  }

  script$14.render = render$4;
  script$14.__file = "http_src/vue/page-asset-map.vue";

  const _hoisted_1$X = { class: "form-group mb-3 row" };
  const _hoisted_2$Q = { class: "col-form-label col-sm-4" };
  const _hoisted_3$P = { class: "col-sm-7" };
  const _hoisted_4$M = /*#__PURE__*/createBaseVNode("div", { class: "invalid-feedback" }, null, -1 /* HOISTED */);
  const _hoisted_5$H = { class: "form-group mb-3 row" };
  const _hoisted_6$y = { class: "col-form-label col-sm-4 pt-2" };
  const _hoisted_7$v = { class: "form-switch col-sm-7 pt-2 ps-3" };
  const _hoisted_8$u = { class: "col-form-label" };


  var script$13 = {
    __name: 'modal-add-device-exclusion',
    props: {
      body: String,
      title: String,
      footer: String,
      list_notes: String,
  },
    emits: ['add'],
    setup(__props, { expose, emit }) {

  const input_mac_list = ref("");
  const input_trigger_alerts = ref("");

  const modal_id = ref(null);


  const showed = () => {};



  const show = () => {
      input_mac_list.value = "";
      modal_id.value.show();
  };

  const add_ = () => {
      emit('add', { mac_list: input_mac_list.value, trigger_alerts: input_trigger_alerts.value });
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[2] || (_cache[2] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$X, [
          createBaseVNode("label", _hoisted_2$Q, toDisplayString(__props.body), 1 /* TEXT */),
          createBaseVNode("div", _hoisted_3$P, [
            withDirectives(createBaseVNode("textarea", {
              name: "items-list",
              id: "itemslist-textarea",
              class: "w-100 form-control",
              rows: "6",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((input_mac_list).value = $event))
            }, null, 512 /* NEED_PATCH */), [
              [vModelText, input_mac_list.value]
            ]),
            createBaseVNode("small", null, toDisplayString(__props.list_notes), 1 /* TEXT */),
            _hoisted_4$M
          ])
        ]),
        createBaseVNode("div", _hoisted_5$H, [
          createBaseVNode("label", _hoisted_6$y, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert')), 1 /* TEXT */),
          createBaseVNode("div", _hoisted_7$v, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              class: "form-check-input ms-0",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((input_trigger_alerts).value = $event))
            }, null, 512 /* NEED_PATCH */), [
              [vModelCheckbox, input_trigger_alerts.value]
            ])
          ]),
          createBaseVNode("small", _hoisted_8$u, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert_descr')), 1 /* TEXT */)
        ])
      ]),
      footer: withCtx(() => [
        createTextVNode(toDisplayString(_i18n('host_details.notes')) + ": " + toDisplayString(__props.footer) + " ", 1 /* TEXT */),
        createBaseVNode("button", {
          type: "button",
          onClick: add_,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('add')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$13.__file = "http_src/vue/modal-add-device-exclusion.vue";

  const _hoisted_1$W = {
    key: 0,
    class: "form-group mb-3 row"
  };
  const _hoisted_2$P = { class: "col-form-label col-sm-4" };
  const _hoisted_3$O = { class: "col-sm-7" };
  const _hoisted_4$L = ["placeholder"];
  const _hoisted_5$G = { class: "form-group mb-3 row" };
  const _hoisted_6$x = { class: "col-form-label col-sm-4" };
  const _hoisted_7$u = { class: "col-sm-7" };
  const _hoisted_8$t = { class: "form-group mb-3 row" };
  const _hoisted_9$n = { class: "col-form-label col-sm-4 pt-2" };
  const _hoisted_10$k = { class: "form-switch col-sm-7 pt-2 ps-3" };
  const _hoisted_11$h = { class: "col-form-label" };



  var script$12 = {
    __name: 'modal-edit-device-exclusion',
    props: {
      title: String,
      title_edit_all: String,
  },
    emits: ['edit'],
    setup(__props, { expose, emit }) {

  const input_mac_address_name = ref("");
  const input_device_status = ref("");
  const input_trigger_alerts = ref("");

  const custom_name_placeholder = ref(i18n('if_stats_config.custom_name'));
  const modal_id = ref(null);


  const showed = () => { };




  const _i18n = (t) => i18n(t);
  const device_status_list = ref([
    {id: "allowed", value:"allowed", label:_i18n('edit_check.authorized') },
    {id: "denied", value:"denied", label:_i18n('edit_check.unauthorized') },
  ]);

  const edit_all = ref(false);

  const show = (row) => {
      if(row != null) {
        let tmp_device_status = null;
        device_status_list.value.forEach((item) => {
          if(item.id == row.status) {
            tmp_device_status = item;
          }
        });
        input_device_status.value = tmp_device_status;
        input_mac_address_name.value = row.mac_address.mac;
        input_trigger_alerts.value = row.trigger_alert || false;
      } else {
        input_device_status.value = device_status_list.value[0];
        edit_all.value = true;
      }
      
      modal_id.value.show();
  };

  const edit_ = () => {
      if(edit_all.value == false)
        emit('edit', { mac_alias: input_mac_address_name.value, mac_status: input_device_status.value.value, trigger_alerts: input_trigger_alerts.value });
      else 
        emit('edit', { mac_status: input_device_status.value.value, trigger_alerts: input_trigger_alerts.value, mac_alias: 'all', });

      close();
  };

  const close = () => {
    modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[3] || (_cache[3] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        (edit_all.value == false)
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
            ], 64 /* STABLE_FRAGMENT */))
          : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(__props.title_edit_all), 1 /* TEXT */)
            ], 64 /* STABLE_FRAGMENT */))
      ]),
      body: withCtx(() => [
        (edit_all.value == false)
          ? (openBlock(), createElementBlock("div", _hoisted_1$W, [
              createBaseVNode("label", _hoisted_2$P, toDisplayString(_i18n('edit_check.device_alias')), 1 /* TEXT */),
              createBaseVNode("div", _hoisted_3$O, [
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  name: "custom_name",
                  class: "form-control",
                  placeholder: custom_name_placeholder.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((input_mac_address_name).value = $event))
                }, null, 8 /* PROPS */, _hoisted_4$L), [
                  [vModelText, input_mac_address_name.value]
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_5$G, [
          createBaseVNode("label", _hoisted_6$x, toDisplayString(_i18n('edit_check.device_status')), 1 /* TEXT */),
          createBaseVNode("div", _hoisted_7$u, [
            createVNode(script$1I, {
              selected_option: input_device_status.value,
              "onUpdate:selected_option": _cache[1] || (_cache[1] = $event => ((input_device_status).value = $event)),
              options: device_status_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ]),
        createBaseVNode("div", _hoisted_8$t, [
          createBaseVNode("label", _hoisted_9$n, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert')), 1 /* TEXT */),
          createBaseVNode("div", _hoisted_10$k, [
            withDirectives(createBaseVNode("input", {
              type: "checkbox",
              class: "form-check-input ms-0",
              "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((input_trigger_alerts).value = $event))
            }, null, 512 /* NEED_PATCH */), [
              [vModelCheckbox, input_trigger_alerts.value]
            ])
          ]),
          createBaseVNode("small", _hoisted_11$h, toDisplayString(_i18n('edit_check.trigger_device_disconnected_alert_descr')), 1 /* TEXT */)
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: edit_,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('edit')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$12.__file = "http_src/vue/modal-edit-device-exclusion.vue";

  const _hoisted_1$V = { class: "row" };
  const _hoisted_2$O = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$N = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$K = { class: "card" };
  const _hoisted_5$F = { class: "card-body" };
  const _hoisted_6$w = {
    key: 0,
    class: "alert alert-info"
  };
  const _hoisted_7$t = { id: "table_devices_vue" };
  const _hoisted_8$s = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-plus" }, null, -1 /* HOISTED */);
  const _hoisted_9$m = [
    _hoisted_8$s
  ];
  const _hoisted_10$j = { class: "card-footer mt-3" };
  const _hoisted_11$g = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_12$g = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-edit" }, null, -1 /* HOISTED */);



  var script$11 = {
    __name: 'page-device-exclusions',
    props: {
      context: Object
  },
    setup(__props) {

  const props = __props;

  const table_device_exclusions = ref();
  const modal_delete_confirm = ref();
  const modal_delete_all = ref();
  const modal_add_device = ref();
  const modal_edit_device = ref();

  const table_id = ref('device_exclusions');

  const add_url             = `${http_prefix}/lua/pro/rest/v2/add/device/exclusion.lua`;
  const delete_url          = `${http_prefix}/lua/pro/rest/v2/delete/device/exclusion.lua`;
  const edit_url            = `${http_prefix}/lua/pro/rest/v2/edit/device/exclusion.lua`;
  const learning_status_url = `${http_prefix}/lua/pro/rest/v2/get/device/learning_status.lua`;
  const is_learning_status = ref(false);
  const _i18n = (t) => i18n(t);

  let title_delete= '';
  let body_delete= '';
  let title_delete_all= _i18n('edit_check.delete_all_device_exclusions');
  let body_delete_all=  _i18n('edit_check.delete_all_device_exclusions_message');
  let title_add= _i18n('edit_check.add_device_exclusion');
  let body_add= _i18n('edit_check.add_device_exclusion_message');
  let footer_add= _i18n('edit_check.add_device_exclusion_notes');
  let list_notes_add= _i18n('edit_check.add_device_exclusion_list_notes');
  let title_edit= _i18n('edit_check.edit_device_exclusion');
  let title_edit_all= _i18n('edit_check.edit_all_devices_status');
  let learning_message= _i18n('edit_check.learning');
  let row_to_delete= ref(null);
  let row_to_edit= ref(null);




  const rest_params = {
    csrf: props.context.csrf,
    ifid: props.context.ifid
  };

  const notes_list = [
    _i18n("edit_check.device_exclusion_page_notes.note_1")
  ];

  const sub_notes_list = [
    _i18n("edit_check.device_exclusion_page_notes.sub_note_1"),
    _i18n("edit_check.device_exclusion_page_notes.sub_note_2")
  ];

  /* ******************************************************************** */ 

  /* Function to handle all buttons */
  function on_table_custom_event(event) {
    
    let events_managed = {
      "click_button_edit_device": click_button_edit_device,
      "click_button_historical_flows": click_button_historical_flows,
      "click_button_delete": click_button_delete,
    };
    if (events_managed[event.event_id] == null) {
      return;
    }
    events_managed[event.event_id](event);
  }

  async function click_button_delete(event) {
    let body = `${i18n('edit_check.delete_device_exclusion')} ${event.row.mac_address.mac}`;
    row_to_delete.value = event.row;

    body_delete = body;

    title_delete = i18n('edit_check.device_exclusion');
    modal_delete_confirm.value.show(body_delete, title_delete);    
    
  }

  async function click_button_edit_device(event) {
    row_to_edit.value = event.row;
    modal_edit_device.value.show(row_to_edit.value);  
  }

  function click_button_historical_flows(event) {
    const rowData = event.row;
    const url = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${rowData.first_seen.timestamp}&epoch_end=${rowData.last_seen.timestamp}&mac=${rowData.mac_address.mac};eq&aggregated=false`;
    window.open(url, '_blank');
  }

  onMounted(async () => {

    await learning_status();

  });

  const csrf = props.crsf;

  /* Function to delete device */
  const delete_row = async function () {
    const row = row_to_delete.value;

    const url = NtopUtils.buildURL(delete_url, {
      device: row.mac_address.mac,
    });

    rest_params.device = {
      mac: row.mac_address.mac
    };
    await ntopng_utility.http_post_request(url, rest_params);
    refresh();

  };

  const delete_all_confirm = async function() {
    modal_delete_all.value.show();
  };

  const edit_all_devices_confirm = async function() {
    modal_edit_device.value.show();
  };

  /* Function to delete all devices */
  const delete_all = async function () {
    const url = NtopUtils.buildURL(delete_url, {
      device: 'all',
    });

    await ntopng_utility.http_post_request(url, rest_params);
    refresh();

  };

  const learning_status = async function() {
      
    const rsp = await ntopng_utility.http_request(learning_status_url);
    if(rsp.learning_done) {
      is_learning_status.value = false;
    } else {
      is_learning_status.value = true;
    }
  };

  const refresh = async function() {
    await learning_status();
    table_device_exclusions.value.refresh_table();
  };

  function add_device() {
    modal_add_device.value.show();
  }

  const add_device_rest = async function (set_params_in_url) {
    let params = set_params_in_url;
    params.mac_list = params.mac_list.replace(/(?:\t| )/g,'');
    params.mac_list = params.mac_list.replace(/(?:\r\n|\r|\n)/g, ',');

    const url = NtopUtils.buildURL(add_url, {
      ...params
    });

    await ntopng_utility.http_post_request(url, rest_params);
    refresh();
            
  };

  const edit_row = async function(params) {
    let row = row_to_edit.value;
    if(row != null)
      params.mac_alias = params.mac_alias.replace(/(?:\t| )/g,'');   
    if(row != null)
      params.mac = row.mac_address.mac;
    params.csrf = props.context.csrf;

    const url = NtopUtils.buildURL(edit_url, {
      ...params
    });

    await ntopng_utility.http_post_request(url, rest_params);

    refresh();
  };


  function columns_sorting(col, r0, r1) {
    if (col != null) {
      let r0_col = r0[col.data.data_field];
      let r1_col = r1[col.data.data_field];
      if(col.id == "last_ip") {
        if (r0_col != '') {
          r0_col = take_ip(r0_col);
          r0_col = NtopUtils.convertIPAddress(r0_col);
        } 
        if (r1_col != '') {
          r1_col = take_ip(r1_col);
          r1_col = NtopUtils.convertIPAddress(r1_col);
        }
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else if(col.id == "manufacturer" ) {
        if (r0_col === undefined) r0_col = '';
        if (r1_col === undefined) r1_col = '';
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else if(col.id == "mac_address") {
        r0_col = r0_col.mac;
        r1_col = r1_col.mac;
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      }else if(col.id == "first_seen") {
        r0_col = r0["first_seen"]["timestamp"] == 0 ? '' : r0["first_seen"]["data"];
        r1_col = r1["first_seen"]["timestamp"] == 0 ? '' : r1["first_seen"]["data"];
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else if(col.id == "last_seen") {
        r0_col = r0["last_seen"]["timestamp"] == 0 ? '' : r0["last_seen"]["data"];
        r1_col = r1["last_seen"]["timestamp"] == 0 ? '' : r1["last_seen"]["data"];
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else if (col.id == "status") {
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else if (col.id == "trigger_alert") {
        r0_col = format_bool(r0_col);
        r1_col = format_bool(r1_col);

        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      }
    }
    
  }

  function take_ip(r_col) {
    const ip = r_col.split('host=')[1].split("\'")[0];
    return ip;
  }

  function format_bool(r_col) {
    if (r_col) {
      return 'true';
    }

    if (!r_col) {
      return 'false';
    }

    if (r_col == 'true') {
      return r_col;
    }

    if (r_col == 'false') {
      return r_col;
    }
  }

  const map_table_def_columns = async (columns) => {
      
    let map_columns = {
      "mac_address": (data, row) => {
        let label = data.mac;
        let alias = data.alias;

        if ((data.symbolic_mac) && (data.symbolic_mac != label))
          label = data.symbolic_mac;

        if ((alias != null) && (alias != label))
          label = `${label} (${alias})`;

        if (data.url != null)
          label = `<a href='${data.url}' title='${data.mac}'>${label}</a>`;

        return label;
      },
      "first_seen": (first_seen, row) => {
        if (first_seen.timestamp == 0) {
          return '';
        } else {
          return first_seen.data;
        }
      }, 
      "last_seen": (last_seen, row) => {
        if (last_seen.timestamp == 0) {
          return '';
        } else {
          return last_seen.data;
        }
      },
      "status": (status, row) => {
        //<span class="badge bg-success" title="${label}">${label}</span>
        //<span class="badge bg-danger" title="${label}">${label}</span>
        //const label = _i18n(status);
        let label = "";
        if (status == "allowed") {
          label = _i18n("edit_check.authorized");
          return `<span class="badge bg-success" title="${label}">${label}</span>`
        } else {
          label = _i18n("edit_check.unauthorized");
          return `<span class="badge bg-danger" title="${label}">${label}</span>`
        }

      },
      "trigger_alert": (trigger_alert, row) => {
        let is_enabled = false;
        if (trigger_alert == "false") 
          is_enabled = false;
        else
          is_enabled = trigger_alert;
        return is_enabled ? `<i class="fas fa-check text-success"></i>` : `<i class="fas fa-times text-danger"></i>`;
      }
    };
    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];

      /*if (c.id == "actions") {
              
        c.button_def_array.forEach((b) => {
            
          b.f_map_class = (current_class, row) => { 
            current_class = current_class.filter((class_item) => class_item != "link-disabled");
            if((row.is_ok_last_scan == 4 || row.is_ok_last_scan == null || row.num_open_ports < 1) && visible_dict[b.id]) {
              current_class.push("link-disabled"); 
            }
            return current_class;
          }
        });
      }*/
    });
      // console.log(columns);
    return columns;
  };

  const get_extra_params_obj = () => {
      /*let params = get_url_params(active_page, per_page, columns_wrap, map_search, first_get_rows);
      set_params_in_url(params);*/
      let params = get_url_params();
      return params;
  };

  function get_url_params() {
      let actual_params = {
          ifid: ntopng_url_manager.get_url_entry("ifid") || props.context.ifid,
      };    

      return actual_params;
  }

  const map_config = (config) => {
      return config;
  };


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$V, [
      createBaseVNode("div", _hoisted_2$O, [
        _hoisted_3$N,
        createBaseVNode("div", _hoisted_4$K, [
          createBaseVNode("div", _hoisted_5$F, [
            (is_learning_status.value)
              ? (openBlock(), createElementBlock("div", _hoisted_6$w, toDisplayString(unref(learning_message)), 1 /* TEXT */))
              : createCommentVNode("v-if", true),
            createBaseVNode("div", _hoisted_7$t, [
              createVNode(script$1c, {
                ref_key: "modal_delete_confirm",
                ref: modal_delete_confirm,
                title: unref(title_delete),
                body: unref(body_delete),
                onDelete: delete_row
              }, null, 8 /* PROPS */, ["title", "body"]),
              createVNode(script$1c, {
                ref_key: "modal_delete_all",
                ref: modal_delete_all,
                title: unref(title_delete_all),
                body: unref(body_delete_all),
                onDelete: delete_all
              }, null, 8 /* PROPS */, ["title", "body"]),
              createVNode(script$13, {
                ref_key: "modal_add_device",
                ref: modal_add_device,
                title: unref(title_add),
                body: unref(body_add),
                footer: unref(footer_add),
                list_notes: unref(list_notes_add),
                onAdd: add_device_rest
              }, null, 8 /* PROPS */, ["title", "body", "footer", "list_notes"]),
              createVNode(script$12, {
                ref_key: "modal_edit_device",
                ref: modal_edit_device,
                title: unref(title_edit),
                title_edit_all: unref(title_edit_all),
                onEdit: edit_row
              }, null, 8 /* PROPS */, ["title", "title_edit_all"]),
              createVNode(script$1w, {
                ref_key: "table_device_exclusions",
                ref: table_device_exclusions,
                csrf: unref(csrf),
                table_id: table_id.value,
                f_map_columns: map_table_def_columns,
                get_extra_params_obj: get_extra_params_obj,
                f_map_config: map_config,
                f_sort_rows: columns_sorting,
                onCustom_event: on_table_custom_event
              }, {
                custom_header: withCtx(() => [
                  createBaseVNode("button", {
                    class: "btn btn-link",
                    type: "button",
                    ref: "add_device",
                    onClick: add_device
                  }, _hoisted_9$m, 512 /* NEED_PATCH */)
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["csrf", "table_id"])
            ])
          ]),
          createBaseVNode("div", _hoisted_10$j, [
            createBaseVNode("button", {
              type: "button",
              onClick: delete_all_confirm,
              class: "btn btn-danger me-1"
            }, [
              _hoisted_11$g,
              createTextVNode(" " + toDisplayString(_i18n("edit_check.delete_all_device_exclusions")), 1 /* TEXT */)
            ]),
            createBaseVNode("button", {
              type: "button",
              onClick: edit_all_devices_confirm,
              class: "btn btn-secondary"
            }, [
              _hoisted_12$g,
              createTextVNode(" " + toDisplayString(_i18n("edit_check.edit_all_devices_status")), 1 /* TEXT */)
            ])
          ])
        ]),
        createVNode(script$1u, {
          note_list: notes_list,
          add_sub_notes: "true",
          sub_note_list: sub_notes_list
        })
      ])
    ]))
  }
  }

  };

  script$11.__file = "http_src/vue/page-device-exclusions.vue";

  var script$10 = {
    components: {	  
      'datatable': script$1g,
    },
    props: {
      page_csrf: String,
      url_params: Object,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_datatable$2(this);
    },
    mounted() {},    
    data() {
      return {
        i18n: (t) => i18n(t),
        config_devices_standard: null,
        config_devices_centrality: null,
      };
    },
    methods: { 
      /* Method used to switch active table tab */
      reload_table: function() {
        let table = this.get_active_table();
        table.reload();
      },
      get_active_table: function() {
        return this.$refs[`table_fingerprint`];
      },
    },
  };  

  function start_datatable$2(DatatableVue) {
    const datatableButton = [];
    let columns = [];
    let default_sorting_columns = 3 /* Contacts column */;
    
    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        DatatableVue.reload_table();
      }
    });
    
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      columns_config: [],
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/fingerprint/data.lua`, url_params),
      enable_search: true,
    };

    /* Standard table configuration */  

    columns = [
      {
        columnName: i18n("client_fingerprint_type"), name: 'type', data: 'type', className: 'text-nowrap', render: (data, type) => {
          if (data == 'JA3')
            return `<a class="ntopng-external-link" href="https://github.com/salesforce/ja3">${data} <i class="fas fa-external-link-alt"></i></a>`;
          else
            return `<a class="ntopng-external-link" href="https://github.com/FoxIO-LLC/ja4">${data} <i class="fas fa-external-link-alt"></i></a>`;

        }, responsivePriority: 0, createdCell: DataTableRenders.applyCellStyle },
      { columnName: i18n("client_fingerprint"), name: 'hash', data: 'hash', className: 'text-nowrap', render: (data, type, rowData) => {
        if (rowData.type == 'JA3')
          return `<a class="ntopng-external-link" style="max-width:315px" href="https://sslbl.abuse.ch/ja3-fingerprints/${data}">${data} <i class="fas fa-external-link-alt"></i></a>`;
        else
          return data;
        }, responsivePriority: 0, createdCell: DataTableRenders.applyCellStyle },
      { columnName: i18n("status"), name: 'is_malicious', data: 'is_malicious', className: 'text-nowrap text-center', responsivePriority: 0, render: (data, type) => {
          return (data ? `<i class="fa-solid fa-face-frown text-danger" title="${i18n('malicious')}"></i>` : `<i class="fa-solid fa-face-smile text-success" title="${i18n('ok')}"></i>`);
        }
      },
      { columnName: i18n("app_name"), name: 'app_name', data: 'app_name', className: 'text-nowrap text-right', responsivePriority: 1 },
      { columnName: i18n("num_uses"), name: 'num_uses', data: 'num_uses', className: 'text-nowrap text-right', responsivePriority: 1, render: (data) => { return NtopUtils.formatValue(data); } },
    ];

    /* Extra table configuration */
    let table_config = {
      serverSide: false,
      order: [[ default_sorting_columns, 'desc' ]]
    };
    
    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
    configDevices.data_url = `${configDevices.data_url}`;
    configDevices.columns_config = columns;
    configDevices.table_config = ntopng_utility.clone(table_config);
    DatatableVue.config_devices_standard = configDevices;
  }

  const _hoisted_1$U = { class: "row" };
  const _hoisted_2$N = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$M = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$J = { class: "card" };
  const _hoisted_5$E = { class: "card-body" };
  const _hoisted_6$v = { id: "table_host_tls" };
  const _hoisted_7$s = { class: "card-footer" };

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_datatable = resolveComponent("datatable");

    return (openBlock(), createElementBlock("div", _hoisted_1$U, [
      createBaseVNode("div", _hoisted_2$N, [
        _hoisted_3$M,
        createBaseVNode("div", _hoisted_4$J, [
          createBaseVNode("div", _hoisted_5$E, [
            createBaseVNode("div", _hoisted_6$v, [
              createVNode(_component_datatable, {
                ref: "table_fingerprint",
                table_buttons: $data.config_devices_standard.table_buttons,
                columns_config: $data.config_devices_standard.columns_config,
                data_url: $data.config_devices_standard.data_url,
                enable_search: $data.config_devices_standard.enable_search,
                table_config: $data.config_devices_standard.table_config
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
            ])
          ]),
          createBaseVNode("div", _hoisted_7$s, [
            createBaseVNode("b", null, toDisplayString($data.i18n('fingerprint_note')), 1 /* TEXT */)
          ])
        ])
      ])
    ]))
  }

  script$10.render = render$3;
  script$10.__file = "http_src/vue/page-host-tls.vue";

  var script$$ = {
    components: {	  
      'datatable': script$1g,
    },
    props: {
      page_csrf: String,
      url_params: Object,
    },
    /**
     * First method called when the component is created.
     */
    created() {
      start_datatable$1(this);
    },
    mounted() {},    
    data() {
      return {
        i18n: (t) => i18n(t),
        config_devices_standard: null,
        config_devices_centrality: null,
      };
    },
    methods: { 
      /* Method used to switch active table tab */
      reload_table: function() {
        let table = this.get_active_table();
        table.reload();
      },
      get_active_table: function() {
        return this.$refs[`table_hassh`];
      },
    },
  };  

  function start_datatable$1(DatatableVue) {
    const datatableButton = [];
    let columns = [];
    let default_sorting_columns = 3 /* Contacts column */;
    
    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        DatatableVue.reload_table();
      }
    });
    
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      columns_config: [],
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/fingerprint/data.lua`, url_params),
      enable_search: true,
    };

    /* Standard table configuration */  

    columns = [
      { columnName: i18n("hassh_fingerprint"), name: 'ja3', data: 'ja3', className: 'text-nowrap', render: (data, type) => {
          return `<a class="ntopng-external-link" href="https://sslbl.abuse.ch/ja3-fingerprints/${data}">${data} <i class="fas fa-external-link-alt"></i></a>`;
        }, responsivePriority: 0, createdCell: DataTableRenders.applyCellStyle },
      { columnName: i18n("status"), name: 'is_malicious', data: 'is_malicious', className: 'text-nowrap text-center', responsivePriority: 0, render: (data, type) => {
          return (data ? `<i class="fa-solid fa-face-frown text-danger" title="${i18n('malicious')}"></i>` : `<i class="fa-solid fa-face-smile text-success" title="${i18n('ok')}"></i>`);
        }
      },
      { columnName: i18n("app_name"), name: 'app_name', data: 'app_name', className: 'text-nowrap text-right', responsivePriority: 1 },
      { columnName: i18n("num_uses"), name: 'num_uses', data: 'num_uses', className: 'text-nowrap text-right', responsivePriority: 1, render: (data) => { return NtopUtils.formatValue(data); } },
    ];

    /* Extra table configuration */
    let table_config = {
      serverSide: false,
      order: [[ default_sorting_columns, 'desc' ]]
    };
    
    let configDevices = ntopng_utility.clone(defaultDatatableConfig);
    configDevices.table_buttons = defaultDatatableConfig.table_buttons;
    configDevices.data_url = `${configDevices.data_url}`;
    configDevices.columns_config = columns;
    configDevices.table_config = ntopng_utility.clone(table_config);
    DatatableVue.config_devices_standard = configDevices;
  }

  const _hoisted_1$T = { class: "row" };
  const _hoisted_2$M = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$L = /*#__PURE__*/createBaseVNode("div", {
    class: "alert alert-danger d-none",
    id: "alert-row-buttons",
    role: "alert"
  }, null, -1 /* HOISTED */);
  const _hoisted_4$I = { class: "card" };
  const _hoisted_5$D = { class: "card-body" };
  const _hoisted_6$u = { id: "table_host_ssh" };

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_datatable = resolveComponent("datatable");

    return (openBlock(), createElementBlock("div", _hoisted_1$T, [
      createBaseVNode("div", _hoisted_2$M, [
        _hoisted_3$L,
        createBaseVNode("div", _hoisted_4$I, [
          createBaseVNode("div", _hoisted_5$D, [
            createBaseVNode("div", _hoisted_6$u, [
              createVNode(_component_datatable, {
                ref: "table_hassh",
                table_buttons: $data.config_devices_standard.table_buttons,
                columns_config: $data.config_devices_standard.columns_config,
                data_url: $data.config_devices_standard.data_url,
                enable_search: $data.config_devices_standard.enable_search,
                table_config: $data.config_devices_standard.table_config
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
            ])
          ])
        ])
      ])
    ]))
  }

  script$$.render = render$2;
  script$$.__file = "http_src/vue/page-host-ssh.vue";

  const change_map_event = "change_map_event";

    var script$_ = {
      components: {	  
        'page-periodicity-map': script$15,
        'page-periodicity-table': script$1a,
        'page-asset-map': script$14,
        'page-asset-table': script$1b,
        'page-service-map': script$16,
        'page-service-table': script$19,
        'page-navbar': script$1H,
      },
      props: {
        page_csrf: String,
        base_url_params: Object,
        ifid: Number,
        is_admin: Boolean,
        map_id: String,
        view: String,
        navbar_info: Object,
        service_acceptance: Array,
        service_map_filter_list: Object,
        service_table_filter_list: Array,
        periodicity_map_filter_list: Object,
        periodicity_table_filter_list: Array,
        asset_map_filter_list: Object,
        asset_table_filter_list: Array,
      },
      /**
       * First method called when the component is created.
       */
      created() {
        this.url_params = this.$props.base_url_params;
        this.active_tab = this.$props.map_id;
        this.page = this.url_params.page;
        this.updated_view = this.$props.view;

        if(asset_map_filter_list && asset_table_filter_list) {
          this.navbar_context.items_table.push({ active: false, class: "disabled ps-0 pe-0", label: '-' });
          this.navbar_context.items_table.push({ active: false, icon: "fas fa-lg fa-compass", class: "disabled pe-0", title: i18n('asset_map'), label: i18n('asset') + ": " });
          this.navbar_context.items_table.push({ active: false, label: i18n('map_format'), id: "asset_map", page: "graph" });
          this.navbar_context.items_table.push({ active: false, class: "disabled ps-0 pe-0", label: '/' });
          this.navbar_context.items_table.push({ active: false, label: i18n('table_format'), id: "asset_map", page: "table" });
        }

        this.navbar_context.items_table.forEach((i) => {
          (i.id == this.active_tab && i.page == this.page) ? i.active = true : i.active = false;
        });
      },
      mounted() {
        
        const format_navbar = this.format_navbar_title;
        format_navbar(this.$props.navbar_info);

        ntopng_events_manager.on_custom_event("page_navbar", ntopng_custom_events.CHANGE_PAGE_TITLE, (node) => {
          format_navbar({ selected_iface: this.$props.navbar_info.selected_iface, selected_host: node });
        });

        ntopng_events_manager.on_custom_event("change_service_table_tab", change_map_event, (tab) => {
          ntopng_url_manager$1.set_key_to_url('map', tab.id);
          ntopng_url_manager$1.set_key_to_url('page', tab.page);
          if(tab.page == 'table')
            this.destroy();
          
          this.active_tab = tab.id;
          this.page = tab.page;
          this.url_params.map = tab.id;
          this.url_params.page = tab.page;
          this.updated_view = ntopng_url_manager$1.get_url_entry('view');
          format_navbar();
       });
      },    
      data() {
        return {
          i18n: (t) => i18n(t),
          active_tab: null,
          page: null,
          url_params: {},
          updated_view: null,
          navbar_node: {},
          navbar_context: {
            main_title: {
              label: ' ' + i18n("maps"),
              icon: "fas fa-map",
            },
            secondary_title_list: [],
            items_table: [
              { active: false, icon: "fas fa-lg fa-concierge-bell", class: "disabled pe-0", title: i18n('service_map'), label: i18n('service') + ": " },
              { active: true, label: i18n('map_format'), id: "service_map", page: "graph" },
              { active: false, class: "disabled ps-0 pe-0", label: '/' },
              { active: false, label: i18n('table_format'), id: "service_map", page: "table" },
              { active: false, class: "disabled ps-0 pe-0", label: '-' },
              { active: false, icon: "fas fa-lg fa-clock", class: "disabled pe-0", title: i18n('periodicity_map'), label: i18n('periodicity') + ": " },
              { active: false, label: i18n('map_format'), id: "periodicity_map", page: "graph" },
              { active: false, class: "disabled ps-0 pe-0", label: '/' },
              { active: false, label: i18n('table_format'), id: "periodicity_map", page: "table" },
            ],
          },
        };
      },
      methods: { 
        destroy: function() {
          let current_tab = this.get_active_tab();
          current_tab.destroy();
        },
        format_navbar_title: function(data) {
          if(data) {
            this.navbar_node = data; /* Update navbar node */
          } else {
            data = this.navbar_node; /* Use the old navbar node */
          } 

          this.navbar_context.secondary_title_list = [
            { label: data.selected_iface.label, title: NtopUtils.shortenLabel(`${data.selected_iface.label}`, 16) }
          ];

          if(data.selected_host && data.selected_host.id != '') {
            const host_name = data.selected_host.label;
            const ip = NtopUtils.removeVlan(data.selected_host.id);
            this.navbar_context.secondary_title_list[0]['href'] = `${http_prefix}/lua/pro/enterprise/network_maps.lua?map=${this.active_tab}&page=${this.page}&ifid=${this.$props.ifid}`;
            this.navbar_context.secondary_title_list.push({
              label: `${NtopUtils.formatNameValue(host_name, ip)}`, // Adding the laptop icon
              title: `${data.selected_host.label}`,
              href: data.selected_host.is_active ? `${http_prefix}/lua/host_details.lua?host=${ip}` : null,
              icon: "fa-solid fa-laptop",
              target_blank: "true",
            });
          }  
        },
        get_active_tab: function() {
          return this.$refs[this.active_tab + "_" + this.page];
        },
        /* Method used to switch active table tab */
        click_item: function(item) {
          if(item.id != this.active_tab || item.page != this.page) {
            this.navbar_context.items_table.forEach((i) => i.active = false);
            item.active = true;
            ntopng_events_manager.emit_custom_event(change_map_event, item);
          }
        },
      },
    };

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_navbar = resolveComponent("page-navbar");
    const _component_page_service_map = resolveComponent("page-service-map");
    const _component_page_service_table = resolveComponent("page-service-table");
    const _component_page_periodicity_map = resolveComponent("page-periodicity-map");
    const _component_page_periodicity_table = resolveComponent("page-periodicity-table");
    const _component_page_asset_map = resolveComponent("page-asset-map");
    const _component_page_asset_table = resolveComponent("page-asset-table");

    return (openBlock(), createElementBlock(Fragment, null, [
      createVNode(_component_page_navbar, {
        id: "page_navbar",
        main_title: $data.navbar_context.main_title,
        secondary_title_list: $data.navbar_context.secondary_title_list,
        help_link: $data.navbar_context.help_link,
        items_table: $data.navbar_context.items_table,
        onClick_item: $options.click_item
      }, null, 8 /* PROPS */, ["main_title", "secondary_title_list", "help_link", "items_table", "onClick_item"]),
      ($data.active_tab == 'service_map' && $data.page == 'graph')
        ? (openBlock(), createBlock(_component_page_service_map, {
            key: 0,
            ref: "service_map_graph",
            page_csrf: $props.page_csrf,
            url_params: $data.url_params,
            ifid: $props.ifid,
            is_admin: $props.is_admin,
            map_id: $props.map_id,
            all_filter_list: $props.service_map_filter_list
          }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
        : createCommentVNode("v-if", true),
      ($data.active_tab == 'service_map' && $data.page == 'table')
        ? (openBlock(), createBlock(_component_page_service_table, {
            key: 1,
            ref: "service_map_table",
            page_csrf: $props.page_csrf,
            url_params: $data.url_params,
            view: $data.updated_view,
            table_filters: $props.service_table_filter_list,
            is_admin: $props.is_admin,
            service_acceptance: $props.service_acceptance
          }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters", "is_admin", "service_acceptance"]))
        : createCommentVNode("v-if", true),
      ($data.active_tab == 'periodicity_map' && $data.page == 'graph')
        ? (openBlock(), createBlock(_component_page_periodicity_map, {
            key: 2,
            ref: "periodicity_map_graph",
            page_csrf: $props.page_csrf,
            url_params: $data.url_params,
            ifid: $props.ifid,
            is_admin: $props.is_admin,
            map_id: $props.map_id,
            all_filter_list: $props.periodicity_map_filter_list
          }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
        : createCommentVNode("v-if", true),
      ($data.active_tab == 'periodicity_map' && $data.page == 'table')
        ? (openBlock(), createBlock(_component_page_periodicity_table, {
            key: 3,
            ref: "periodicity_map_table",
            page_csrf: $props.page_csrf,
            url_params: $data.url_params,
            view: $data.updated_view,
            table_filters: $props.periodicity_table_filter_list,
            is_admin: $props.is_admin
          }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters", "is_admin"]))
        : createCommentVNode("v-if", true),
      ($props.asset_map_filter_list && $props.asset_table_filter_list)
        ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
            ($data.active_tab == 'asset_map' && $data.page == 'graph')
              ? (openBlock(), createBlock(_component_page_asset_map, {
                  key: 0,
                  ref: "asset_map_graph",
                  page_csrf: $props.page_csrf,
                  url_params: $data.url_params,
                  ifid: $props.ifid,
                  is_admin: $props.is_admin,
                  map_id: $props.map_id,
                  all_filter_list: $props.asset_map_filter_list
                }, null, 8 /* PROPS */, ["page_csrf", "url_params", "ifid", "is_admin", "map_id", "all_filter_list"]))
              : createCommentVNode("v-if", true),
            ($data.active_tab == 'asset_map' && $data.page == 'table')
              ? (openBlock(), createBlock(_component_page_asset_table, {
                  key: 1,
                  ref: "asset_map_table",
                  page_csrf: $props.page_csrf,
                  url_params: $data.url_params,
                  view: $data.updated_view,
                  table_filters: $props.asset_table_filter_list
                }, null, 8 /* PROPS */, ["page_csrf", "url_params", "view", "table_filters"]))
              : createCommentVNode("v-if", true)
          ], 64 /* STABLE_FRAGMENT */))
        : createCommentVNode("v-if", true)
    ], 64 /* STABLE_FRAGMENT */))
  }

  script$_.render = render$1;
  script$_.__file = "http_src/vue/page-home-map.vue";

  const _hoisted_1$S = ["width", "height"];
  const _hoisted_2$L = /*#__PURE__*/createBaseVNode("defs", null, null, -1 /* HOISTED */);
  const _hoisted_3$K = /*#__PURE__*/createBaseVNode("g", {
    class: "nodes",
    style: {"stroke":"#000","strokeOpacity":"0.5"}
  }, null, -1 /* HOISTED */);
  const _hoisted_4$H = /*#__PURE__*/createBaseVNode("g", {
    class: "links",
    style: {"stroke":"#000","strokeOpacity":"0.3","fill":"none"}
  }, null, -1 /* HOISTED */);
  const _hoisted_5$C = /*#__PURE__*/createBaseVNode("g", { class: "texts" }, null, -1 /* HOISTED */);
  const _hoisted_6$t = [
    _hoisted_2$L,
    _hoisted_3$K,
    _hoisted_4$H,
    _hoisted_5$C
  ];


  var script$Z = {
    __name: 'page-sankey',
    props: {
      width: Number,
      height: Number,
  },
    setup(__props) {

  const props = __props;

  const d3 = d3v7;



  const sankey_chart_ref = ref(null);
  const sankey_size = ref({});

  onBeforeMount(async() => {});

  onMounted(async () => {    
      draw_sankey();
  });

  async function draw_sankey() {
      const colors = d3.scaleOrdinal(d3.schemeCategory10);
      let data = await get_sankey_data();
      const size = get_size();
      sankey_size.value = size;
      const { links, nodes } = calculate_sankey(data, size.width - 10, size.height - 5);
      
      d3.select(sankey_chart_ref.value)
  	.select("g.nodes")
  	.selectAll("rect")
  	.data(nodes)
  	.join(
              (enter) => {
  		const e = enter.append("rect");
  		
  		e.attr("x", (d) => d.x0).attr("y", (d) => d.y0);
  		
  		e.transition(d3.easeLinear)
  		    .delay(1000)
  		    .duration(500)
  		    .attr("height", (d) => d.y1 - d.y0)
  		    .attr("width", (d) => d.x1 - d.x0)
  		    .attr("dataIndex", (d) => d.index)
  		    .attr("fill", (d) => colors(d.index / nodes.length));
  		e.append("title").text((d) => `${d.name}\n${d.hours}`);
              },
              (update) =>
  		update
  		.transition(d3.easeLinear)
  		.delay(500)
  		.duration(500)
  		.attr("x", (d) => d.x0)
  		.attr("y", (d) => d.y0)
  		.attr("height", (d) => d.y1 - d.y0)
  		.attr("width", (d) => d.x1 - d.x0)
  		.attr("dataIndex", (d) => d.index)
  		.attr("fill", (d) => colors(d.index / nodes.length))
  		.select("title")
  		.text((d) => `${d.name}\n${d.hours}`),
              (exit) =>
  		exit.transition(d3.easeLinear).duration(500).style("opacity", 0).remove()
  	).on("dblclick", function(data) {
  	    //todo portare fuori
  	    // data = data.currentTarget.__data__
  	    // const sourceLink = data.sourceLinks;
  	    // const targetLink = data.targetLinks;
  	    // const link = (sourceLink && sourceLink[0]) ? sourceLink[0] : targetLink[0];
  	    
  	    // if(link) {
  	    //   /* Get the node link from the rest */
  	    //   if(link.source.id === data.id) {
  	    //     if(link.source_link && link.source_link !== '')
  	    //       window.open(link.source_link, '_blank');
  	    //   } else if(link.target.id === data.id) {
  	    //     if(link.target_link && link.target_link !== '')
  	    //       window.open(link.target_link, '_blank');
  	    //   } 
  	    // } 
  	});
      
      d3.select(sankey_chart_ref.value)
  	.select("g.texts")
  	.selectAll("text")
  	.data(nodes)
  	.join(
              (enter) => {
  		const e = enter.append("text");
  		
  		e.transition(d3.easeLinear)
  		    .delay(1000)
  		    .duration(500)
  		    .attr("x", (d) => (d.x0 < size.width / 2 ? d.x1 + 6 : d.x0 - 6))
  		    .attr("y", (d) => (d.y1 + d.y0) / 2)
  		    .attr("fill", (d) => d3.rgb(colors(d.index / nodes.length)).darker())
  		    .attr("alignment-baseline", "middle")
  		    .attr("text-anchor", (d) =>
  			  d.x0 < size.width / 2 ? "start" : "end"
  			 )
  		    .attr("font-size", 9)
  		    .text((d) => d.name);
              },
              (update) =>
  		update
  		.transition(d3.easeLinear)
  		.delay(500)
  		.duration(500)
  		.attr("x", (d) => (d.x0 < size.width / 2 ? d.x1 + 6 : d.x0 - 6))
  		.attr("y", (d) => (d.y1 + d.y0) / 2)
  		.attr("fill", (d) => d3.rgb(colors(d.index / nodes.length)).darker())
  		.attr("text-anchor", (d) =>
  		      d.x0 < size.width / 2 ? "start" : "end"
  		     )
  		.attr("font-size", 9)
  		.text((d) => d.name),
              (exit) =>
  		exit
  		.transition(d3.easeLinear)
              /* .delay(500) */
  		.duration(500)
  		.style("opacity", 0)
  		.remove()
  	);
      
      d3.select(sankey_chart_ref.value)
  	.select("defs")
  	.selectAll("linearGradient")
  	.data(links)
  	.join(
              (enter) => {
  		const lg = enter.append("linearGradient");
  		
  		lg.attr("id", (d) => `gradient-${d.index}`)
  		    .attr("gradientUnits", "userSpaceOnUse")
  		    .attr("x1", (d) => d.source.x1)
  		    .attr("x2", (d) => d.target.x0);
  		
  		lg.append("stop")
  		    .attr("offset", "0")
  		    .attr("stop-color", (d) => colors(d.source.index / nodes.length));
  		
  		lg.append("stop")
  		    .attr("offset", "100%")
  		    .attr("stop-color", (d) => colors(d.target.index / nodes.length));
              },
              (update) => {
  		update
  		    .attr("id", (d) => `gradient-${d.index}`)
  		    .attr("gradientUnits", "userSpaceOnUse")
  		    .attr("x1", (d) => d.source.x1)
  		    .attr("x2", (d) => d.target.x0);
  		update.selectAll("stop").remove();
  		update
  		    .append("stop")
  		    .attr("offset", "0")
  		    .attr("stop-color", (d) => colors(d.source.index / nodes.length));
  		
  		update
  		    .append("stop")
  		    .attr("offset", "100%")
  		    .attr("stop-color", (d) => colors(d.target.index / nodes.length));
              },
              (exit) => exit.remove()
  	);
      
      d3.select(sankey_chart_ref.value)
  	.select("g.links")
  	.selectAll("path")
  	.data(links)
  	.join(
              (enter) => {
  		const e = enter.append("path");
  		e.transition(d3.easeLinear)
  		    .delay(1000)
  		    .duration(500)
  		    .attr("d", d3.sankeyLinkHorizontal())
  		    .attr("stroke", (d) => `url(#gradient-${d.index}`)
  		    .attr("stroke-width", (d) => d.width);
  		e.append("title").text((d) => `${d.hours}`);
              },
              (update) =>
  		update
  		.transition(d3.easeLinear)
  		.delay(500)
  		.duration(500)
  		.attr("d", d3.sankeyLinkHorizontal())
  		.attr("stroke", (d) => `url(#gradient-${d.index}`)
  		.attr("stroke-width", (d) => d.width)
  		.select("title")
  		.text((d) => `${d.hours}`),
              (exit) =>
  		exit
  		.transition(d3.easeLinear)
              /* .delay(1000) */
  		.duration(500)
  		.style("opacity", 0)
  		.remove()
  	);
  }

  async function get_sankey_data() {
      const rsp = [
  	{
  	    "link_color": "#e377c2",
  	    "source_color": "#e377c2",
  	    "source_link": "/lua/host_details.lua?page=flows&host=192.168.1.7&vlan=0&application=IGMP",
  	    "target": "224.0.0.251",
  	    "source": "IGMP",
  	    "link": "IGMP",
  	    "target_link": "/lua/host_details.lua?host=224.0.0.251&vlan=0",
  	    "target_node": "224.0.0.251",
  	    "source_node": "192.168.1.7",
  	    "value": 60
  	},
  	{
  	    "link_color": "#e377c2",
  	    "source_link": "/lua/host_details.lua?host=192.168.1.7&vlan=0",
  	    "target": "IGMP",
  	    "source": "192.168.1.7",
  	    "link": "IGMP",
  	    "target_link": "/lua/host_details.lua?page=flows&host=192.168.1.7&vlan=0&application=IGMP",
  	    "target_node": "224.0.0.2",
  	    "target_color": "#e377c2",
  	    "source_node": "192.168.1.7",
  	    "value": 120
  	},
  	{
  	    "link_color": "#e377c2",
  	    "source_color": "#e377c2",
  	    "source_link": "/lua/host_details.lua?page=flows&host=192.168.1.7&vlan=0&application=IGMP",
  	    "target": "224.0.0.2",
  	    "source": "IGMP",
  	    "link": "IGMP",
  	    "target_link": "/lua/host_details.lua?host=224.0.0.2&vlan=0",
  	    "target_node": "224.0.0.2",
  	    "source_node": "192.168.1.7",
  	    "value": 60
  	},
  	{
  	    "link_color": "#bcbd22",
  	    "source_link": "/lua/host_details.lua?host=192.168.1.7&vlan=0",
  	    "target": "MDNS",
  	    "source": "192.168.1.7",
  	    "link": "MDNS",
  	    "target_link": "/lua/host_details.lua?page=flows&host=192.168.1.7&vlan=0&application=MDNS",
  	    "target_node": "224.0.0.251",
  	    "target_color": "#bcbd22",
  	    "source_node": "192.168.1.7",
  	    "value": 396
  	},
  	{
  	    "link_color": "#bcbd22",
  	    "source_color": "#bcbd22",
  	    "source_link": "/lua/host_details.lua?page=flows&host=192.168.1.7&vlan=0&application=MDNS",
  	    "target": "224.0.0.251",
  	    "source": "MDNS",
  	    "link": "MDNS",
  	    "target_link": "/lua/host_details.lua?host=224.0.0.251&vlan=0",
  	    "target_node": "224.0.0.251",
  	    "source_node": "192.168.1.7",
  	    "value": 396
  	}
      ];
      
  /*
      let data = {
  	// nodes: [
  	//     { index: 0, name: "Liikevaihto", value: 100, hours: "100%" },
  	//     { index: 1, name: "Kiinteät kulut", value: 75, hours: "85%" },
  	//     { index: 2, name: "Muuttuvat kulut", value: 10, hours: "3:00" },
  	//     { index: 3, name: "Palkkakulut", value: 69, hours: "1:20" },
  	//     { index: 4, name: "Muut kiinte", value: 6, hours: "1:40" },
  	//     { index: 5, name: "Kate", value: 15, hours: "1:40" }
  	// ],
  	nodes: [
  	    { index: 0, name: "Liikevaihto", hours: "100%" },
  	    { index: 1, name: "Kiinteät kulut", hours: "85%" },
  	    { index: 2, name: "Muuttuvat kulut", hours: "3:00" },
  	    { index: 3, name: "Palkkakulut", hours: "1:20" },
  	    { index: 4, name: "Muut kiinte", hours: "1:40" },
  	    { index: 5, name: "Kate", hours: "1:40" }
  	],
  	links: [
  	    { source: 0, target: 1, value: 75, hours: "+1:00" },
  	    { source: 0, target: 2, value: 10, hours: "+2:00" },
  	    { source: 1, target: 3, value: 69, hours: "+1:20" },
  	    { source: 1, target: 4, value: 6, hours: "+1:40" },
  	    { source: 0, target: 5, value: 15, hours: "+1:40" }
  	]
      };
  */
      data = wrap_graph_rsp(rsp);

      //debugger;
      return data;
  }

  function wrap_graph_rsp(rsp) {
      let nodes = [];
      let links = [];

      let nodes_added_dict = {};
      const f_add_node = (node_id, href, color) => {
  	if (nodes_added_dict[node_id] != null) { return; }
  	let index = nodes.length;
  	nodes_added_dict[node_id] = index;
  	let new_node = { index, name: node_id, href, color };
  	nodes.push(new_node);
      };
      const f_add_link = (source, target, value, label) => {
  	const source_index = nodes_added_dict[source];
  	const target_index = nodes_added_dict[target];
  	let new_link = { source: source_index, target: target_index, value, label };
  	links.push(new_link);
      };
      rsp.forEach((el) => {
  	f_add_node(el.source, el.source_link, el.source_color);
  	f_add_node(el.target, el.target_link, el.target_color);
  	f_add_link(el.source, el.target, el.value, el.link);
      });
      return { nodes, links };
  }

  function get_size() {
      let width = props.width;
      if (width == null) { width = window.innerWidth - 200; }
      let height = props.height;
      if (height == null) { height = window.innerHeight - 50; }

      return { width, height };
  }

  function calculate_sankey(data, width, height) {
      const sankeyimpl = d3.sankey()
  	  .nodeAlign(d3.sankeyCenter)
  	  .nodeWidth(10)
  	  .nodePadding(10)
  	  .extent([
  	      [0, 5],
  	      [width, height]
  	  ]);
      
      return sankeyimpl(data);
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", null, [
      (openBlock(), createElementBlock("svg", {
        ref_key: "sankey_chart_ref",
        ref: sankey_chart_ref,
        width: sankey_size.value.width,
        height: sankey_size.value.height,
        style: {"margin":"10px"}
      }, _hoisted_6$t, 8 /* PROPS */, _hoisted_1$S))
    ]))
  }
  }

  };

  var css_248z$b = "\n.node rect {\n  fill-opacity: 0.9;\n  shape-rendering: crispEdges;\n}\n.node text {\n  pointer-events: none;\n  text-shadow: 0 1px 0 #fff;\n}\n.link {\n  fill: none;\n  stroke: #000;\n  stroke-opacity: 0.2;\n}\n.link:hover {\n  stroke-opacity: 0.5;\n}\n";
  styleInject(css_248z$b);

  script$Z.__file = "http_src/vue/page-sankey.vue";

  const change_applications_tab_event = "change_applications_tab_event";

  var script$Y = {
    components: {	  
      'chart': script$1F,
      'datatable': script$1g,
      'modal-delete-confirm': script$1c,
      'tab-list': script$1d,
    },
    props: {
      page_csrf: String,
      url_params: Object,
      view: String,
      is_ch_enabled: Boolean,
      is_locale: String,
      ts_l7_enabled: Boolean,
      ts_cat_enabled: Boolean
    },
    /**
     * First method called when the component is created.
     */
    created() {
      this.applications_tab = ntopng_url_manager$1.get_url_entry("view") || this.$props.view;
      this.tab_list.forEach((i) => {
        this.applications_tab == i.id ? i.active = true : i.active = false;
      });
      start_datatable(this);
    },
    mounted() {
      ntopng_events_manager$1.on_custom_event("change_applications_tab_event", change_applications_tab_event, (tab) => {
  	    let table = this.get_active_table();
        ntopng_url_manager$1.set_key_to_url('view', tab.id);
        table.destroy_table();
        this.applications_tab = tab.id;
      });
    },    
    data() {
      return {
        i18n: (t) => i18n(t),
        applications_tab: null,
        config_devices_applications: null,
        config_devices_categories: null,
        chart_options: [
          {
            title: i18n('graphs.top_10_ndpi_protocols'),
            type: ntopChartApex.typeChart.DONUT,
            url: `${http_prefix}/lua/rest/v2/get/host/l7/proto_data.lua`,
            tab: `applications`,
            id: `top_applications`,
          },
          {
            title: i18n('graphs.top_breed'),
            type: ntopChartApex.typeChart.DONUT,
            url: `${http_prefix}/lua/rest/v2/get/host/l7/breed_data.lua`,
            tab: `applications`,
            id: `top_breed`,
          },
          {
            title: i18n('graphs.top_10_ndpi_categories'),
            type: ntopChartApex.typeChart.DONUT,
            url: `${http_prefix}/lua/rest/v2/get/host/l7/cat_data.lua`,
            tab: `categories`,
            id: `top_categories`,
          },
          {
            title: i18n('graphs.top_breed'),
            type: ntopChartApex.typeChart.DONUT,
            url: `${http_prefix}/lua/rest/v2/get/host/l7/breed_data.lua`,
            tab: `categories`,
            id: `top_breed`,
          },
        ],
        tab_list: [
          { 
            title: i18n('host_details.applications_tab'),
            active: (this.$props.view == 'applications'),
            id: 'applications'
          },
          { 
            title: i18n('host_details.categories_tab'),
            active: (this.$props.view == 'categories'),
            id: 'categories'
          },
        ]
      };
    },
    methods: {
      add_action_column: function(columns, name, value) {
        const host = `${this.$props.url_params.host}`;
        const vlan = `${this.$props.url_params.vlan}`;
        const ifid = `${this.$props.url_params.ifid}`;
        let handlerId = "page-stats-action-jump-historical";
        columns.push({ columnName: i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, handlerId, render: (data, type, service) => {
          const jump_to_historical = {
            handlerId,
            onClick: () => {
              let url = `${http_prefix}/lua/pro/db_search.lua?ifid=${ifid}&${name}=${service[value].id};eq&ip=${host};eq`;
              if(vlan != 0)
                url = `${url}&vlan_id=${vlan};eq`;
              window.open(url);
            }
          };
          return DataTableUtils.createActionButtons([{ class: 'dropdown-item', href: '#', title: i18n('db_explorer.historical_data'), handler: jump_to_historical }])
        }});
      },
      destroy: function() {
        let table = this.get_active_table();
        table.destroy_table();
      },
      /* Method used to switch active table tab */
      click_item: function(item) {
        this.tab_list.forEach((i) => i.active = false);
        item.active = true;
        ntopng_events_manager$1.emit_custom_event(change_applications_tab_event, item);
      }, 
      reload_table: function() {
        let table = this.get_active_table();
        NtopUtils.showOverlays();
        table.reload();
        NtopUtils.hideOverlays();
      },
      get_active_table: function() {
        return this.$refs[`table_host_${this.applications_tab}`];
      },
      get_f_get_custom_chart_options() {
        console.log("get_f_");
        return async (url) => {
          return charts_options_items.value[chart_index].chart_options;
        }
      }
    },
  };  

  function start_datatable(PageVue) {
    const datatableButton = [];

    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        PageVue.reload_table();
      }
    });
    
    let tmp_params = url_params;
    tmp_params['view'] = 'applications';
    
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l7/data.lua`, tmp_params),
      enable_search: true,
      table_config: { 
        serverSide: false, 
        order: [[ 6 /* percentage column */, 'desc' ]],
        columnDefs: [
          { type: "time-uni", targets: 1 },
          { type: "file-size", targets: 2 },
          { type: "file-size", targets: 3 },
          { type: "file-size", targets: 5 },
        ]
      }
    };
    
    /* Applications table configuration */  

    let columns = [
      { columnName: i18n("host_details.application"), targets: 0, width: '20', name: 'application', data: 'application', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
        if (PageVue.$props.is_locale == "1" && PageVue.$props.ts_l7_enabled === true) {
          return `<a href="${http_prefix}/lua/host_details.lua?host=${PageVue.$props.url_params.host}@${PageVue.$props.url_params.vlan}&page=historical&ifid=${PageVue.$props.url_params.ifid}&protocol=${data.label}&ts_schema=host:ndpi" target="_blank">${data.label}</a>`
        } else
          return `${data.label}`;
        } 
      },
      { columnName: i18n("host_details.duration"), targets: 1, width: '10', name: 'duration', data: 'duration', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
          return NtopUtils.secondsToTime(data);
        }  
      },
      { columnName: i18n("host_details.sent"), targets: 2, width: '10', name: 'sent', data: 'bytes_sent', className: 'text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }  
      },
      { columnName: i18n("host_details.rcvd"), targets: 3, width: '10', name: 'rcvd', data: 'bytes_rcvd',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }  
      },
      { columnName: i18n("host_details.breakdown"), targets: 4, width: '10', name: 'breakdown', data: 'breakdown', orderable: false, className: 'text-center text-nowrap', responsivePriority: 2, render: (data, type, row) => {
          const percentage_sent = (row.bytes_sent * 100) / row.tot_bytes;
          const percentage_rcvd = (row.bytes_rcvd * 100) / row.tot_bytes;
          return NtopUtils.createBreakdown(percentage_sent, percentage_rcvd, i18n('host_details.sent'), i18n('host_details.rcvd'));
        }  
      },
      { columnName: i18n("host_details.tot_bytes"), targets: 5, width: '20', name: 'tot_bytes', data: 'tot_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }   
      },
      { columnName: i18n("host_details.tot_percentage"), targets: 6, width: '20', name: 'percentage', data: 'percentage',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          const percentage = data.toFixed(1);
          return NtopUtils.createProgressBar(percentage);
        }  
      },
    ];

    if(is_ch_enabled)
      PageVue.add_action_column(columns, 'l7proto', 'application');
    
    let applicationsConfig = ntopng_utility.clone(defaultDatatableConfig);
    applicationsConfig.columns_config = columns;
    PageVue.config_devices_applications = applicationsConfig;


    /* Categories table configuration */

    tmp_params['view'] = 'categories';  
    defaultDatatableConfig.data_url = NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l7/data.lua`, tmp_params);


    columns = [
      { columnName: i18n("host_details.category"), targets: 0, name: 'category', data: 'category', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
        if (PageVue.$props.is_locale == "1" && PageVue.$props.ts_cat_enabled === true)
          return `<a href="${http_prefix}/lua/host_details.lua?host=${PageVue.$props.url_params.host}@${PageVue.$props.url_params.vlan}&ts_schema=host:ndpi_categories&page=historical&category=${data.label}" target="_blank">${data.label}</a>`
        else
          return `${data.label}`;
        } 
      },
      { columnName: i18n("host_details.applications"), targets: 0, name: 'applications', data: 'applications', orderable: false, className: 'text-nowrap', responsivePriority: 1, render: (data) => {
          if(PageVue.$props.is_locale == "1")
            return `${data.label || ''} <a href="${http_prefix}/${data.href}${data.category_id}">${data.more_protos || ''}</a>`
          else
            return `${data.label || ''}`;
        } 
      },
      { columnName: i18n("host_details.duration"), targets: 0, name: 'duration', data: 'duration', className: 'text-nowrap', responsivePriority: 1, render: (data) => {
          return NtopUtils.secondsToTime(data);
        }  
      },
      { columnName: i18n("host_details.tot_bytes"), targets: 0, name: 'tot_bytes', data: 'tot_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }  
      },
      { columnName: i18n("host_details.tot_percentage"), targets: 0, name: 'percentage', data: 'percentage', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          const percentage = data.toFixed(1);
          return NtopUtils.createProgressBar(percentage);
        }  
      },
    ];

    if(is_ch_enabled)
      PageVue.add_action_column(columns, 'l7cat', 'category');
    
    let categoriesConfig = ntopng_utility.clone(defaultDatatableConfig);
    categoriesConfig.columns_config = columns;
    categoriesConfig.table_config.order = [[ 4 /* percentage column */, 'desc' ]];
    categoriesConfig.table_config.columnDefs = [
      { type: "time-uni", targets: 2 },
      { type: "file-size", targets: 3 },
    ];
    
    PageVue.config_devices_categories = categoriesConfig;
  }

  const _hoisted_1$R = { class: "row" };
  const _hoisted_2$K = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$J = { class: "card" };
  const _hoisted_4$G = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$B = { class: "card-body" };
  const _hoisted_6$s = { id: "host_details_applications" };
  const _hoisted_7$r = {
    class: "row mb-4 mt-4",
    id: "host_details_applications"
  };
  const _hoisted_8$r = { class: "col-6" };
  const _hoisted_9$l = {
    key: 0,
    class: "widget-name"
  };

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_tab_list = resolveComponent("tab-list");
    const _component_chart = resolveComponent("chart");
    const _component_datatable = resolveComponent("datatable");

    return (openBlock(), createElementBlock("div", _hoisted_1$R, [
      createBaseVNode("div", _hoisted_2$K, [
        createBaseVNode("div", _hoisted_3$J, [
          _hoisted_4$G,
          createBaseVNode("div", _hoisted_5$B, [
            createBaseVNode("div", _hoisted_6$s, [
              createVNode(_component_tab_list, {
                ref: "host_details_applications_tab_list",
                id: "host_details_applications_tab_list",
                tab_list: $data.tab_list,
                onClick_item: $options.click_item
              }, null, 8 /* PROPS */, ["tab_list", "onClick_item"]),
              createBaseVNode("div", _hoisted_7$r, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.chart_options, (chart_option) => {
                  return (openBlock(), createElementBlock("div", _hoisted_8$r, [
                    (chart_option.tab == $data.applications_tab)
                      ? (openBlock(), createElementBlock("h3", _hoisted_9$l, toDisplayString(chart_option.title), 1 /* TEXT */))
                      : createCommentVNode("v-if", true),
                    (chart_option.tab == $data.applications_tab)
                      ? (openBlock(), createBlock(_component_chart, {
                          key: 1,
                          id: chart_option.id,
                          chart_type: chart_option.type,
                          base_url_request: chart_option.url,
                          register_on_status_change: false
                        }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"]))
                      : createCommentVNode("v-if", true)
                  ]))
                }), 256 /* UNKEYED_FRAGMENT */))
              ]),
              ($data.applications_tab == 'applications')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 0,
                    ref: "table_host_applications",
                    table_buttons: $data.config_devices_applications.table_buttons,
                    columns_config: $data.config_devices_applications.columns_config,
                    data_url: $data.config_devices_applications.data_url,
                    enable_search: $data.config_devices_applications.enable_search,
                    table_config: $data.config_devices_applications.table_config
                  }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
                : createCommentVNode("v-if", true),
              ($data.applications_tab == 'categories')
                ? (openBlock(), createBlock(_component_datatable, {
                    key: 1,
                    ref: "table_host_categories",
                    table_buttons: $data.config_devices_categories.table_buttons,
                    columns_config: $data.config_devices_categories.columns_config,
                    data_url: $data.config_devices_categories.data_url,
                    enable_search: $data.config_devices_categories.enable_search,
                    table_config: $data.config_devices_categories.table_config
                  }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
                : createCommentVNode("v-if", true)
            ])
          ])
        ])
      ])
    ]))
  }

  script$Y.render = render;
  script$Y.__file = "http_src/vue/page-host-details-applications.vue";

  const _hoisted_1$Q = { class: "row" };
  const _hoisted_2$J = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$I = { class: "card" };
  const _hoisted_4$F = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$A = { class: "card-body" };
  const _hoisted_6$r = { id: "host_details_traffic" };
  const _hoisted_7$q = {
    class: "row mb-4 mt-4",
    id: "host_details_traffic"
  };
  const _hoisted_8$q = { class: "col-4" };
  const _hoisted_9$k = { class: "widget-name" };


  var script$X = {
    __name: 'page-host-details-traffic',
    props: {
    page_csrf: String,
  },
    setup(__props) {

  const traffic_table = ref(null);
  ref([]);
  const config_traffic_table = ref({});

  const destroy = () => {
    traffic_table.value.destroy_table();
  };

  const reload_table = () => {
    traffic_table.value.reload();
  };
      
  onBeforeMount(async () => {
    start_datatable();
  });

  onUnmounted(async () => {
    destroy();
  });

  const chart_options = [
    {
      title: i18n('graphs.l4_proto'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/l4/proto_data.lua`,
      id: `traffic_protos`,
    },
    {
      title: i18n('graphs.contacted_hosts'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/l4/contacted_hosts_data.lua`,
      id: `contacted_hosts`,
    },
    {
      title: i18n('graphs.traffic'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/l4/traffic_data.lua`,
      id: `traffic`,
    },
  ];

  function start_datatable(PageVue) {
    const datatableButton = [];
    let url_params = {};
    
    url_params["host"] = ntopng_url_manager$1.get_url_entry("host");
    url_params["vlan"] = ntopng_url_manager$1.get_url_entry("vlan");
    url_params["ifid"] = ntopng_url_manager$1.get_url_entry("ifid");

    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        reload_table();
      }
    });
      
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/host/l4/data.lua`, url_params),
      enable_search: true,
      table_config: { 
        serverSide: false, 
        order: [[ 6 /* percentage column */, 'desc' ]],
        columnDefs: [
          { type: "time-uni", targets: 1 },
          { type: "file-size", targets: 2 },
          { type: "file-size", targets: 3 },
          { type: "file-size", targets: 5 },
        ]
      }
    };
    
    /* Applications table configuration */  

    let columns = [
      { columnName: i18n("protocol"), targets: 0, name: 'protocol', data: 'protocol', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("chart"), targets: 1, name: 'historical', data: 'historical', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("traffic_labels.bytes_sent"), targets: 2, name: 'sent', data: 'bytes_sent', className: 'text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }  
      },
      { columnName: i18n("traffic_labels.bytes_rcvd"), targets: 3, name: 'rcvd', data: 'bytes_rcvd',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }  
      },
      { columnName: i18n("traffic_labels.breakdown"), targets: 4, name: 'breakdown', data: 'breakdown', orderable: false, className: 'text-center text-nowrap', responsivePriority: 2, render: (data, type, row) => {
          const percentage_sent = (row.bytes_sent * 100) / row.total_bytes;
          const percentage_rcvd = (row.bytes_rcvd * 100) / row.total_bytes;
          return NtopUtils.createBreakdown(percentage_sent, percentage_rcvd, i18n('host_details.sent'), i18n('host_details.rcvd'));
        }  
      },
      { columnName: i18n("traffic_labels.total_bytes"), targets: 5, name: 'tot_bytes', data: 'total_bytes', className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          return NtopUtils.bytesToSize(data);
        }   
      },
      { columnName: i18n("traffic_labels.total_percentage"), targets: 6, width: '20%', name: 'percentage', data: 'total_percentage',  className: 'text-center text-nowrap', responsivePriority: 2, render: (data) => {
          const percentage = data.toFixed(1);
          return NtopUtils.createProgressBar(percentage);
        }  
      },
    ];

    let trafficConfig = ntopng_utility.clone(defaultDatatableConfig);
    trafficConfig.columns_config = columns;
    config_traffic_table.value = trafficConfig;
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$Q, [
      createBaseVNode("div", _hoisted_2$J, [
        createBaseVNode("div", _hoisted_3$I, [
          _hoisted_4$F,
          createBaseVNode("div", _hoisted_5$A, [
            createBaseVNode("div", _hoisted_6$r, [
              createBaseVNode("div", _hoisted_7$q, [
                (openBlock(), createElementBlock(Fragment, null, renderList(chart_options, (chart_option) => {
                  return createBaseVNode("div", _hoisted_8$q, [
                    createBaseVNode("h3", _hoisted_9$k, toDisplayString(chart_option.title), 1 /* TEXT */),
                    createVNode(script$1F, {
                      id: chart_option.id,
                      chart_type: chart_option.type,
                      base_url_request: chart_option.url,
                      register_on_status_change: false
                    }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
                  ])
                }), 64 /* STABLE_FRAGMENT */))
              ]),
              createVNode(script$1g, {
                ref_key: "traffic_table",
                ref: traffic_table,
                table_buttons: config_traffic_table.value.table_buttons,
                columns_config: config_traffic_table.value.columns_config,
                data_url: config_traffic_table.value.data_url,
                enable_search: config_traffic_table.value.enable_search,
                table_config: config_traffic_table.value.table_config
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$X.__file = "http_src/vue/page-host-details-traffic.vue";

  const _hoisted_1$P = { class: "row" };
  const _hoisted_2$I = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$H = { class: "card" };
  const _hoisted_4$E = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$z = { class: "card-body" };
  const _hoisted_6$q = { class: "row" };
  const _hoisted_7$p = { class: "col-6 mb-4 mt-4" };
  const _hoisted_8$p = { class: "widget-name" };


  var script$W = {
    __name: 'page-host-details-packets',
    props: {
    page_csrf: String,
    url_params: Object,
  },
    setup(__props) {
  const chart_options = [
    {
      title: i18n('graphs.packets_sent'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/packets/sent_data.lua`,
      id: `packets_sent`,
    },
    {
      title: i18n('graphs.packets_rcvd'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/packets/rcvd_data.lua`,
      id: `packets_rcvd`,
    },
    {
      title: i18n('graphs.tcp_flags'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/packets/tcp_flags_data.lua`,
      id: `tcp_flags`,
    },
    {
      title: i18n('graphs.arp_distribution'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/packets/arp_data.lua`,
      id: `arp_requests`,
    },
  ];

  function chart_done(data, tmp, tmp2) {
    NtopUtils$1.hideOverlays();
  }

  onMounted(() => {});


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$P, [
      createBaseVNode("div", _hoisted_2$I, [
        createBaseVNode("div", _hoisted_3$H, [
          _hoisted_4$E,
          createBaseVNode("div", _hoisted_5$z, [
            createBaseVNode("div", _hoisted_6$q, [
              (openBlock(), createElementBlock(Fragment, null, renderList(chart_options, (chart_option) => {
                return createBaseVNode("div", _hoisted_7$p, [
                  createBaseVNode("h3", _hoisted_8$p, toDisplayString(chart_option.title), 1 /* TEXT */),
                  createVNode(script$1F, {
                    id: chart_option.id,
                    chart_type: chart_option.type,
                    base_url_request: chart_option.url,
                    register_on_status_change: false,
                    onChart_reloaded: chart_done
                  }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
                ])
              }), 64 /* STABLE_FRAGMENT */))
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$W.__file = "http_src/vue/page-host-details-packets.vue";

  const _hoisted_1$O = {
    key: 0,
    class: "alert alert-info",
    id: "empty-message"
  };
  const _hoisted_2$H = ["width", "height"];
  const _hoisted_3$G = /*#__PURE__*/createBaseVNode("g", {
    class: "nodes",
    style: {"stroke":"#000","strokeOpacity":"0.5"}
  }, null, -1 /* HOISTED */);
  const _hoisted_4$D = /*#__PURE__*/createBaseVNode("g", {
    class: "links",
    style: {"stroke":"#000","strokeOpacity":"0.3","fill":"none"}
  }, null, -1 /* HOISTED */);
  const _hoisted_5$y = [
    _hoisted_3$G,
    _hoisted_4$D
  ];


  var script$V = {
    __name: 'sankey',
    props: {
    no_data_message: String,
    width: Number,
    height: Number,
    sankey_data: Object,
  },
    emits: ['node_click', 'update_width', 'update_height'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const d3 = d3v7;

  const node_width = 10;
  const no_data = ref(false);



  const sankey_chart_ref = ref(null);
  const sankey_size = ref({});

  onBeforeMount(async() => {});

  onMounted(async () => {
      set_sankey_data();
      attach_events();
  });

  watch(() => props.sankey_data, (cur_value, old_value) => {
      set_sankey_data(true);
  });

  function set_sankey_data(reset) {
      if (reset) {
  	$(".nodes", sankey_chart_ref.value).empty();
  	$(".links", sankey_chart_ref.value).empty();
      }
      if (props.sankey_data.nodes == null || props.sankey_data.links == null
  	|| props.sankey_data.length == 0 || props.sankey_data.links.length == 0) {
  	return;
      }
      draw_sankey();
  }

  function attach_events() {
      window.addEventListener('resize', () => set_sankey_data(true));
  }

  let sankey = null;
  let sankeyData = null;
  async function draw_sankey() {
      const colors = d3.scaleOrdinal(d3.schemeCategory10);
      let data = props.sankey_data;//await get_sankey_data();
      const size = get_size();
      sankey_size.value = size;
      sankey = create_sankey(size.width - 10, size.height - 5);
      sankeyData = sankey(data);
      const { links, nodes } = sankeyData;
      
      let d3_nodes = d3.select(sankey_chart_ref.value)
  	.select("g.nodes")
  	.selectAll("g")
  	.data(nodes)
  	.join((enter) => enter.append("g"))
  	.attr("transform", (d) => `translate(${d.x0}, ${d.y0})`);
      
      d3.zoom()
  	  .scaleExtent([1, 40])
  	  .on("zoom", zoomed);
      
      d3_nodes.append("rect")
      // .transition(d3.easeLinear)
      // .delay(1000)
      // .duration(500)
  	.attr("height", (d) => d.y1 - d.y0)
  	.attr("width", (d) => d.x1 - d.x0)
  	.attr("dataIndex", (d) => d.index)
  	.attr("fill", (d) => colors(d.index / nodes.length))
  	.attr("class", "sankey-node")
  	.attr("style", "cursor:move;");
      d3.selectAll("rect").append("title").text((d) => `${d?.label}`);
      
      // Relative to container/ node rect    
      d3_nodes.data(nodes)
  	.append("text")
      // .transition(d3.easeLinear)
      // .delay(1000)
      // .duration(500)
      	.attr('class', 'label')
      	.style('pointer-events', 'auto')
  	.attr("style", "cursor:pointer;")
      	.style('fill-opacity', function(d) { return 1; } )
      	.attr("fill", (d) => "#000")
      // .attr("fill", (d) => d3.rgb(colors(d.index / nodes.length)).darker())
  	.attr("x", (d) => (d.x0 < size.width / 2 ? 6 + (d.x1 - d.x0) : -6))
  	.attr("y", (d) => (d.y1 - d.y0) / 2)
      	.attr("alignment-baseline", "middle")
  	.attr("text-anchor", (d) =>
                d.x0 < size.width / 2 ? "start" : "end"
               )
      	.attr("font-size", 12)
      	.text((d) => d.label)
  	.on("click", function(event, data_obj){ emit('node_click', data_obj.data); });    
      d3_nodes
  	.call(d3.drag().subject(d => d).on("start", dragStart).on("drag", dragMove));
      
      const links_d3 = d3.select(sankey_chart_ref.value)
  	  .select("g.links")
  	  .selectAll("g")
  	  .data(links)
  	  .join((enter) => enter.append("g"));
      
      let lg_d3 = links_d3.append("linearGradient");
      lg_d3.attr("id", (d) => `gradient-${d.index}`)
      	.attr("gradientUnits", "userSpaceOnUse")
      	.attr("x1", (d) => d.source.x1)
      	.attr("x2", (d) => d.target.x0);
      
      lg_d3.append("stop")
      	.attr("offset", "0")
      	.attr("stop-color", (d) => colors(d.source.index / nodes.length));
      
      lg_d3.append("stop")
      	.attr("offset", "100%")
      	.attr("stop-color", (d) => colors(d.target.index / nodes.length));
      
      links_d3
  	.append("path")
      	.style('pointer-events', 'none')
  	.attr("class", "sankey-link")
  	.attr("d", d3.sankeyLinkHorizontal())
      // .attr("style", `stroke-width: ${d.width}px;`)
  	.attr("stroke-width", (d) => {
  	    return Math.max(1, d.width);
  	})
      // .transition(d3.easeLinear)
      // .delay(1000)
      // .duration(500) 
      	.attr("stroke", (d) => `url(#gradient-${d.index}`);
      // 	.attr("stroke", `black`)
      
      // 	.attr("stroke-width", (d) => Math.max(100, d.width));
          
      links_d3
      	.append("title")
      	.text((d) => `${d.label}`);
  }

  function dragStart(event, d) {
      d.__x = event.x;
      d.__y = event.y;
      d.__x0 = d.x0;
      d.__y0 = d.y0;
      d.__x1 = d.x1;
      d.__y1 = d.y1;
  } //dragStart

  function dragMove(event, d) {
      d3.select(this).attr("transform", function (d) {
  	const dx = event.x - d.__x;
  	const dy = event.y - d.__y;
  	const width = sankey_size.value.width;
  	const height = sankey_size.value.width;
  	d.x0 = d.__x0 + dx;
  	d.x1 = d.__x1 + dx;
  	d.y0 = d.__y0 + dy;
  	d.y1 = d.__y1 + dy;
  	
  	if (d.x0 < 0) {
              d.x0 = 0;
              d.x1 = node_width;
  	} // if
  	
  	if (d.x1 > width) {
              d.x0 = width - node_width;
              d.x1 = width;
  	} // if
  	
  	if (d.y0 < 0) {
              d.y0 = 0;
              d.y1 = d.__y1 - d.__y0;
  	} // if
  	
  	if (d.y1 > height) {
              d.y0 = height - (d.__y1 - d.__y0);
              d.y1 = height;
  	} // if
  	sankey.update(sankeyData);
  	d3.selectAll(".sankey-link").attr("d", d3.sankeyLinkHorizontal());
  	return `translate(${d.x0}, ${d.y0})`;
      });
  }

  function zoomed({transform}) {
      g.attr("transform", transform);
  }
  function get_size() {
      emit('update_width');
      let width = props.width;
      if (width == undefined) { width = $(sankey_chart_ref.value).parent().parent().width() - 10; }

      emit('update_height');
      let height = props.height;
      if (height == undefined) { height = $(sankey_chart_ref.value).parent().parent().height() - 80; }

      return { width, height };
  }

  function create_sankey(width, height) {
      const _sankey = d3.sankey()
  	  .nodeAlign(d3.sankeyCenter)
  	  .nodeWidth(10)
  	  .nodePadding(node_width)
  	  .extent([
  	      [0, 5],
  	      [width, height]
  	  ]);
      return _sankey;
  }

  /* Set to true, to show the 'No Data' message */
  function set_no_data_flag(set_no_data) {
    no_data.value = set_no_data;
  }

  const _i18n = (t) => i18n(t);
      
  expose({ draw_sankey, set_no_data_flag });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      (no_data.value)
        ? (openBlock(), createElementBlock("div", _hoisted_1$O, toDisplayString(__props.no_data_message || _i18n('flows_page.no_data')), 1 /* TEXT */))
        : createCommentVNode("v-if", true),
      createBaseVNode("div", null, [
        (openBlock(), createElementBlock("svg", {
          ref_key: "sankey_chart_ref",
          ref: sankey_chart_ref,
          width: sankey_size.value.width,
          height: sankey_size.value.height,
          style: {"margin":"10px"}
        }, _hoisted_5$y, 8 /* PROPS */, _hoisted_2$H))
      ])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  var css_248z$a = "\n/* .node rect { */\n/*   fill-opacity: 0.9; */\n/*   shape-rendering: crispEdges; */\n/* } */\n\n/* .node text { */\n/*   pointer-events: none; */\n/*   text-shadow: 0 1px 0 #fff; */\n/* } */\n\n/* path.link.link2 { */\n/*     all: initial; */\n/*     fill: unset; */\n/*     stroke: unset; */\n/*     stroke-opacity: unset; */\n/*     stroke-width: unset; */\n/* } */\n\n/* .link:hover { */\n/*   stroke-opacity: 0.5; */\n/* } */\n";
  styleInject(css_248z$a);

  script$V.__file = "http_src/vue/sankey.vue";

  const _hoisted_1$N = { class: "row" };
  const _hoisted_2$G = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$F = { class: "card card-shadow" };
  const _hoisted_4$C = { class: "card-body" };
  const _hoisted_5$x = { class: "d-flex align-items-center mb-2" };
  const _hoisted_6$p = { class: "d-flex no-wrap ms-auto" };
  const _hoisted_7$o = { class: "m-1" };
  const _hoisted_8$o = { style: {"min-width":"16rem"} };
  const _hoisted_9$j = { class: "my-auto me-1" };
  const _hoisted_10$i = /*#__PURE__*/createBaseVNode("label", { class: "my-auto me-1" }, null, -1 /* HOISTED */);
  const _hoisted_11$f = /*#__PURE__*/createBaseVNode("span", null, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_12$f = [
    _hoisted_11$f
  ];


  var script$U = {
    __name: 'page-host-details-flow-sankey',
    props: {
      is_local: Boolean
  },
    setup(__props) {

  const props = __props;



  const _i18n = (t) => i18n(t);
  const url = `${http_prefix}/lua/pro/rest/v2/get/host/flows/data.lua`;
  const sankey_chart = ref(null);
  const loading = ref(false);

  const sankey_format_list = [
      { filter_name: 'hosts_type', key: 3, id: 'local_origin_remote_target', title: _i18n('flows_page.local_cli_remote_srv'), label: _i18n('flows_page.local_cli_remote_srv'), filter_icon: false, countable: false },
      { filter_name: 'hosts_type', key: 4, id: 'remote_origin_local_target', title: _i18n('flows_page.local_srv_remote_cli'), label: _i18n('flows_page.local_srv_remote_cli'), filter_icon: false, countable: false },
      { filter_name: 'hosts_type', key: 5, id: 'all_hosts', title: _i18n('flows_page.all_flows'), label: _i18n('flows_page.all_flows'), filter_icon: false, countable: false },
  ];

  if (props.is_local) {
      sankey_format_list.unshift({ filter_name: 'hosts_type', key: 1, id: 'local_only', title: _i18n('flows_page.local_only'), label: _i18n('flows_page.local_only'), filter_icon: false, countable: false });
  } else {
      sankey_format_list.unshift({ filter_name: 'hosts_type', key: 2, id: 'remote_only', title: _i18n('flows_page.remote_only'), label: _i18n('flows_page.remote_only'), filter_icon: false, countable: false });
  }

  const active_hosts_type = ref(sankey_format_list[3]);

  const sankey_data = ref({});

  onBeforeMount(() => { });

  onMounted(() => {
      update_sankey();
  });

  function on_node_click(node) {
      if (node.is_link_node == true) { return; }
      let url_obj = {
          host: node.info.ip,
          vlan: node.info.vlan,
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(url_obj);
      const host_url = `${http_prefix}/lua/host_details.lua?${url_params}`;
      ntopng_url_manager$1.go_to_url(host_url);
      //host=' .. flow["cli.ip"] .. '&vlan=' .. flow["vlan"]
  }

  const update_sankey = function () {
      let entry = active_hosts_type.value;
      ntopng_url_manager$1.set_key_to_url(entry.filter_name, entry.id);
      set_sankey_data();
  };

  const reload = function () {
      update_sankey();
  };

  async function set_sankey_data() {
      loading.value = true;
      let data = await get_sankey_data();
      sankey_data.value = data;
      loading.value = false;
  }

  /*
  function add_fake_circular_link(graph) {
      const node_id_0 = "node_id_0", node_id_1 = "node_id_1";
      graph.nodes.push({ node_id: node_id_0, label: node_id_0 });
      graph.nodes.push({ node_id: node_id_1, label: node_id_1 });
      graph.links.push({ source_node_id: node_id_0, target_node_id: node_id_1, value: 10, label: `${node_id_0}_${node_id_1}` });
      graph.links.push({ source_node_id: node_id_1, target_node_id: node_id_0, value: 10, label: `${node_id_1}_${node_id_0}` });
  }
  */

  async function get_sankey_data() {
      const url_request = get_sankey_url();
      // let graph = await sankeyUtils.get_data();
      let graph = await ntopng_utility$1.http_request(url_request);
      // add_fake_circular_link(graph);
      graph = make_complete_graph(graph);
      let main_node_id = get_main_node_id();
      let sankey_data = get_sankey_data_from_rest_data(graph, main_node_id);
      (sankey_data.links.length > 0 && sankey_data.nodes.length > 0) ?
          sankey_chart.value.set_no_data_flag(false) :
          sankey_chart.value.set_no_data_flag(true);
      // sankey_data = make_dag_graph(sankey_data);
      return sankey_data;
  }

  function get_sankey_url() {
      let params = {
          host: ntopng_url_manager$1.get_url_entry("host"),
          vlan: ntopng_url_manager$1.get_url_entry("vlan"),
          ifid: ntopng_url_manager$1.get_url_entry("ifid"),
          hosts_type: ntopng_url_manager$1.get_url_entry("hosts_type"),
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params);
      let url_request = `${url}?${url_params}`;
      return url_request;
  }

  function get_main_node_id() {
      return ntopng_url_manager$1.get_url_entry("host");
  }

  function get_sankey_data_from_rest_data(graph, main_node_id) {
      if (graph.nodes.length == 0 && graph.links.length == 0) { return graph; }
      let node_dict = {};
      // create a node dict
      graph.nodes.forEach((node) => node_dict[node.node_id] = node);

      //get link direction 
      const f_get_link_direction = (link) => {
          if (link.source_node_id == main_node_id) {
              return -1;
          } else if (link.target_node_id == main_node_id) {
              return 1;
          }
          throw `Wrong direction link ${link.source_node_id} -> ${link.target_node_id}`;
      };

      // get node id with direction
      const f_get_node_direction_id = (node_id, direction) => {
          if (node_id == main_node_id) {
              return node_id;
          }
          return `${direction}_${node_id}`;
      };

      // create a new graph duplicating all nodes with different direction
      let graph2_node_dict = {};
      let graph2 = { nodes: [], links: [] };
      graph.links.forEach((link) => {
          let direction = f_get_link_direction(link);
          let new_link = {
              source_node_id: f_get_node_direction_id(link.source_node_id, direction),
              target_node_id: f_get_node_direction_id(link.target_node_id, direction),
              label: link.label,
              value: link.value,
              data: link,
          };
          let new_node;
          if (direction == -1) {
              let n = node_dict[link.target_node_id];
              new_node = { node_id: new_link.target_node_id, label: n.label, data: n };
          } else {
              let n = node_dict[link.source_node_id];
              new_node = { node_id: new_link.source_node_id, label: n.label, data: n };
          }
          graph2.links.push(new_link);
          if (graph2_node_dict[new_node.node_id] == null) {
              graph2_node_dict[new_node.node_id] = true;
              graph2.nodes.push(new_node);
          }
      });
      let main_node = node_dict[main_node_id];
      graph2.nodes.push({ node_id: main_node.node_id, label: main_node.label, data: main_node });

      // update node dict
      graph2.nodes.forEach((node) => node_dict[node.node_id] = node);

      // return the link node_id 
      const f_get_link_node_id = (link) => {
          let direction = f_get_link_direction(link);
          return `${direction}_${link.label}`;
          // return `${link.source_node_id}_${link.label}`; 
      };

      let link_to_nodes_dict = {}; // key: link node id, value: links
      // merge all links by link node_id
      graph2.links.forEach((link) => {
          let link_node_id = f_get_link_node_id(link);
          let link_to_nodes = link_to_nodes_dict[link_node_id];
          if (link_to_nodes == null) {
              link_to_nodes = {
                  id: link_node_id,
                  label: link.label,
                  data: { ...link, is_link_node: true },
                  node_links: [],
              };
              link_to_nodes_dict[link_node_id] = link_to_nodes;
          }
          link_to_nodes.node_links.push({
              source: node_dict[link.source_node_id],
              target: node_dict[link.target_node_id],
              value: get_link_value(link),
          });
      });

      // create nodes and links graph, creating a new node for each link
      let nodes = graph2.nodes.map((n) => n), links = [];
      for (let link_node_id in link_to_nodes_dict) {
          let link_to_nodes = link_to_nodes_dict[link_node_id];
          let link_node = {
              node_id: link_to_nodes.id,
              label: link_to_nodes.label,
              data: link_to_nodes.data,
          };
          nodes.push(link_node);
          link_to_nodes.node_links.forEach((link) => {
              links.push({
                  source_node_id: link.source.node_id,
                  target_node_id: link_node.node_id,
                  label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
                  value: link.value,
                  data: link,
              });
              links.push({
                  source_node_id: link_node.node_id,
                  target_node_id: link.target.node_id,
                  label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
                  value: link.value,
                  data: link,
              });
          });
      }

      let sankey_node_dict = {}; // key: node_id, value: sankey_node
      let sankey_nodes = [];
      nodes.map((n, index) => {
          let sankey_node = { index, node_id: n.node_id, label: n.label, data: n.data };
          sankey_node_dict[n.node_id] = sankey_node;
          sankey_nodes.push(sankey_node);
      });
      let sankey_links = links.map((l) => {
          let source = sankey_node_dict[l.source_node_id];
          let target = sankey_node_dict[l.target_node_id];
          return {
              source: source.index,
              target: target.index,
              source_node_id: source.index,
              target_node_id: target.index,
              value: l.value,
              label: l.label,
          };
      });
      return { nodes: sankey_nodes, links: sankey_links };
  }

  // remove all links with a not existing node
  function make_complete_graph(graph) {
      let f_log_link = (l) => console.error(`link (source: ${l.source_node_id}, target: ${l.target_node_id}) removed for not existing source/target node`);
      let links = get_links_with_existing_node(graph, f_log_link);
      return { nodes: graph.nodes, links };
  }

  function get_links_with_existing_node(graph, f_log) {
      let node_dict = {};
      graph.nodes.forEach((n) => node_dict[n.node_id] = true);
      let f_filter = (l) => node_dict[l.source_node_id] != null && node_dict[l.target_node_id] != null;
      let links = filter_log(graph.links, f_filter, f_log);
      return links;
  }

  // log elements deleted if f_log != null
  function filter_log(elements, f_filter, f_log) {
      return elements.filter((e) => {
          const take_element = f_filter(e);
          if (take_element == false && f_log != null) {
              f_log(e);
          }
          return take_element;
      });
  }

  function get_link_value(link) {
      return link.data?.info?.traffic;
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$N, [
      createBaseVNode("div", _hoisted_2$G, [
        createBaseVNode("div", _hoisted_3$F, [
          (loading.value)
            ? (openBlock(), createBlock(script$1z, { key: 0 }))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_4$C, [
            createBaseVNode("div", {
              class: normalizeClass(["align-items-center justify-content-end mb-3", [loading.value ? 'ntopng-gray-out' : '']]),
              style: {"height":"70vh"}
            }, [
              createBaseVNode("div", _hoisted_5$x, [
                createBaseVNode("div", _hoisted_6$p, [
                  createBaseVNode("div", _hoisted_7$o, [
                    createBaseVNode("div", _hoisted_8$o, [
                      createBaseVNode("label", _hoisted_9$j, toDisplayString(_i18n('hosts')) + ": ", 1 /* TEXT */),
                      createVNode(script$1I, {
                        selected_option:  active_hosts_type.value ,
                        "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (( active_hosts_type.value ) = $event)),
                        options:  sankey_format_list ,
                        onSelect_option:  update_sankey 
                      }, null, 8 /* PROPS */, ["selected_option", "options", "onSelect_option"])
                    ])
                  ]),
                  createBaseVNode("div", null, [
                    _hoisted_10$i,
                    createBaseVNode("div", null, [
                      createBaseVNode("button", {
                        class: "btn btn-link m-1",
                        tabindex: "0",
                        type: "button",
                        onClick: _cache[1] || (_cache[1] = (...args) => ( reload  &&  reload (...args)))
                      }, _hoisted_12$f)
                    ])
                  ])
                ])
              ]),
              createVNode(script$V, {
                ref_key: "sankey_chart",
                ref: sankey_chart,
                onNode_click:  on_node_click ,
                sankey_data: sankey_data.value
              }, null, 8 /* PROPS */, ["onNode_click", "sankey_data"])
            ], 2 /* CLASS */)
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$U.__file = "http_src/vue/page-host-details-flow-sankey.vue";

  /*
    (C) 2013-23 - ntop.org
   */

  /*
    Here a list of functions used to check, format data;
    e.g. functions that check if a string is null or empty
   */

  /* This function check if value is null, empty or 0 */
  const isEmptyOrNull = (value) => {
    return !!(value == null || value == "" || value == 0);
  };

  /* This function check if value is null, or an empty array */
  const isEmptyArrayOrNull = (value) => {
    return !!(value == null || value.length === 0);
  };

  /* ******************************************************************** */

  const dataUtils = function () {
    return {
      isEmptyOrNull,
      isEmptyArrayOrNull,
    };
  }();

  /*
    (C) 2013-23 - ntop.org
   */

  /* ******************************************************************** */ 

  function format_num_for_sort(num) {
    if(typeof num === "number") {
      /* Check if it's a number */
      return num;
    } else if(typeof num === "string") {
      if(num == "") {
        /* Safety check */
        return 0;
      }
      
      /* If it's a string convert it into a number */
      num = num.split(',').join("");
      num = parseInt(num);
    } else {
      /* In case both failed, convert num to 0 */
      num = 0;
    }

    return num;
  }

  // max number value for sort number with normalize option 
  // for cases: last scan and last duration column to handle empty values
  const MAX_NUMBER_VALUE = 99999999999;

  const normalize_number_value = function(lower_value, val, sort) {
    if (val == lower_value) {
      if (sort == 1) {
        val = MAX_NUMBER_VALUE;
      }
    }    
    return val; 
  };
  /* ******************************************************************** */ 

  /* Sort by Name */
  const sortByName = function(val_1, val_2, sort) {
    if (sort == 1) {
      return val_1?.localeCompare(val_2);
    }
    return val_2?.localeCompare(val_1);
  };

  /* ******************************************************************** */ 

  /* Sort by IP Addresses */
  const sortByIP = function(val_1, val_2, sort) {
    val_1 = NtopUtils.convertIPAddress(val_1);
    val_2 = NtopUtils.convertIPAddress(val_2);
    if (sort == 1) {
      return val_1.localeCompare(val_2);
    }
    return val_2.localeCompare(val_1);
  };

  /* ******************************************************************** */ 

  /* Sort by Number */
  const sortByNumber = function(val_1, val_2, sort) {
    /* It's an array */
    val_1 = format_num_for_sort(val_1);
    val_2 = format_num_for_sort(val_2);

    if (sort == 1) {
      return val_1 - val_2;
    }
    return val_2 - val_1; 
  };

  /* ******************************************************************** */ 

  /* Sort by Number after values normalization */
  const sortByNumberWithNormalizationValue = function(val_1, val_2, sort, lower_value) {
    val_1 = normalize_number_value(lower_value, val_1, sort);
    val_2 = normalize_number_value(lower_value, val_2, sort);

    return sortByNumber(val_1,val_2,sort);
  };

  /* ******************************************************************** */ 

  const sortingFunctions = function () {
    return {
      sortByIP,
      sortByName,
      sortByNumber,
      sortByNumberWithNormalizationValue,
    };
  }();

  const _hoisted_1$M = {
    key: 0,
    class: "alert alert-info alert-dismissable"
  };
  const _hoisted_2$F = /*#__PURE__*/createBaseVNode("span", { class: "text-info me-1" }, null, -1 /* HOISTED */);
  const _hoisted_3$E = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_4$B = { class: "col-form-label col-sm-2" };
  const _hoisted_5$w = { class: "col-sm-10" };
  const _hoisted_6$o = {
    class: "btn-group btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_7$n = {
    key: 1,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_8$n = { class: "col-form-label col-sm-2" };
  const _hoisted_9$i = { class: "col-sm-10" };
  const _hoisted_10$h = ["placeholder"];
  const _hoisted_11$e = {
    key: 2,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_12$e = { class: "col-form-label col-sm-2" };
  const _hoisted_13$a = { class: "col-sm-10" };
  const _hoisted_14$a = {
    key: 3,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_15$8 = { class: "col-form-label col-sm-2" };
  const _hoisted_16$8 = { class: "col-sm-10" };
  const _hoisted_17$7 = {
    key: 4,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_18$7 = { class: "col-form-label col-sm-2" };
  const _hoisted_19$7 = { class: "col-10" };
  const _hoisted_20$7 = {
    key: 5,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_21$6 = { class: "col-form-label col-sm-2" };
  const _hoisted_22$6 = { class: "col-10" };
  const _hoisted_23$6 = { class: "col-form-label col-sm-2" };
  const _hoisted_24$6 = { class: "col-10" };
  const _hoisted_25$5 = {
    key: 6,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_26$5 = { class: "col-form-label col-sm-2" };
  const _hoisted_27$5 = { class: "col-10" };
  const _hoisted_28$3 = {
    key: 7,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_29$3 = { class: "col-form-label col-sm-2" };
  const _hoisted_30$2 = { class: "col-10" };
  const _hoisted_31$2 = {
    key: 8,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_32$2 = { class: "col-form-label col-sm-2" };
  const _hoisted_33$2 = {
    key: 0,
    class: "col-10"
  };
  const _hoisted_34$2 = {
    key: 1,
    class: "col-10"
  };
  const _hoisted_35$2 = {
    key: 2,
    class: "col-10"
  };
  const _hoisted_36$2 = {
    key: 3,
    class: "col-10"
  };
  const _hoisted_37$2 = {
    key: 4,
    class: "col-10"
  };
  const _hoisted_38$2 = {
    key: 5,
    class: "col-10"
  };
  const _hoisted_39$2 = {
    key: 6,
    class: "col-10"
  };
  const _hoisted_40$2 = {
    key: 9,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_41$2 = { class: "col-form-label col-sm-2" };
  const _hoisted_42$2 = { class: "col-10" };
  const _hoisted_43$2 = {
    class: "form-group ms-2 me-2 mt-3 row",
    style: {"margin-top":"3px"}
  };
  const _hoisted_44$2 = { class: "col-form-label col-sm-2" };
  const _hoisted_45$2 = { class: "col-sm-3" };
  const _hoisted_46$2 = {
    class: "btn-group float-end btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_47$2 = ["value", "id"];
  const _hoisted_48$2 = ["id", "for"];
  const _hoisted_49$2 = ["value", "id"];
  const _hoisted_50$1 = ["id", "for"];
  const _hoisted_51$1 = ["value", "id"];
  const _hoisted_52$1 = ["id", "for"];
  const _hoisted_53$1 = {
    class: "col-sm-2 btn-group float-end btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_54$1 = ["value", "id"];
  const _hoisted_55$1 = ["id", "for"];
  const _hoisted_56$1 = {
    key: 10,
    class: "message alert alert-warning mt-3"
  };
  const _hoisted_57$1 = ["disabled"];
  const _hoisted_58$1 = ["disabled"];


  var script$T = {
    __name: 'modal-add-host-rules',
    props: {
    metric_list: Array,
    ifid_list: Array,
    flow_exporter_devices: Array,
    interface_metric_list: Array,
    flow_device_metric_list: Array,
    frequency_list: Array,
    has_vlans: Boolean,
    has_profiles: Boolean,
    init_func: Function,
    page_csrf: String,
  },
    emits: ['add', 'edit'],
    setup(__props, { expose, emit }) {

  const props = __props;

  ref("");
  ref("");


  let has_host_pools = ref(false);
  let has_cidr = ref(false);
  const modal_id = ref(null);

  let title = i18n('if_stats_config.add_host_rules_title');
  const host_placeholder = i18n('if_stats_config.host_placeholder');

  const metrics_ready = ref(false);
  const _i18n = (t) => i18n(t);
  const metric_list = ref([]);
  const init_func = ref(null);
  const delete_row = ref(null);
  const ifid_list = ref([]);
  const flow_exporter_devices = ref([]);
  const flow_exporter_device_ifid_list = ref([]);
  const interface_metric_list = ref([]);
  const host_pool_metric_list = ref([]);
  const flow_device_metric_list = ref([]);
  const frequency_list = ref([]);
  const threshold_measure = ref(null);
  const threshold_sign = ref(null);
  const selected_metric = ref({});
  const selected_frequency = ref({});
  const selected_ifid = ref({});
  const selected_exporter_device = ref({});
  const selected_exporter_device_ifid = ref({});
  const selected_interface_metric = ref({});
  const selected_host_pool_metric = ref({});
  const selected_flow_device_metric = ref({});
  const disable_add = ref(true);
  const metric_type = ref({});
  const visible = ref(true);
  const rule_type = ref("hosts");
  const flow_device_timeseries_available = ref(false);
  const is_edit_page = ref(false);
  const page_csrf_ = ref(null);
  const row_to_edit_id = ref(null);
  const invalid_add = ref(false);
  const host_pool_list = ref(null);
  const network_list = ref(null);
  const selected_host_pool = ref({});
  const selected_network = ref({});
  const selected_network_metric = ref({});
  const network_metric_list = ref(null);
  const vlan_list = ref([]);
  const selected_vlan = ref({});
  const vlan_metric_list = ref(null);
  const selected_vlan_metric = ref({});
  const profiles_list = ref([]);
  const selected_profile = ref({});
  const profiles_metric_list = ref(null);
  const selected_profile_metric = ref({});

  let active_metric_type_list = ref([]);


  const note_list = [
    _i18n('if_stats_config.note_1'),
    _i18n('if_stats_config.note_2'),
    _i18n('if_stats_config.note_3'),
    _i18n('if_stats_config.note_4'),
  ];

  const sub_notes_list = [
    _i18n('if_stats_config.note_5')
  ];

  const metric_type_list = ref([
    { title: _i18n('volume'), label: _i18n('volume'), id: 'volume', active: true },
    { title: _i18n('throughput'), label: _i18n('throughput'), id: 'throughput', active: false },
    { title: _i18n('percentage'), label: _i18n('percentage'), id: 'percentage', active: false },
  ]);

  /* Currently disabled the percentage */
  const exporter_metric_type_list = ref([
    { title: _i18n('volume'), label: _i18n('volume'), id: 'volume', active: true },
    { title: _i18n('throughput'), label: _i18n('throughput'), id: 'throughput', active: false },
    { title: _i18n('percentage'), label: _i18n('percentage'), id: 'percentage', active: false },
  ]);

  const pool_metric_type_list = ref([
    { title: _i18n('volume'), label: _i18n('volume'), id: 'volume', active: true, measure_unit: 'bps' },
    { title: _i18n('throughput'), label: _i18n('throughput'), id: 'throughput', active: false, measure_unit: 'bps' },
    { title: _i18n('percentage'), label: _i18n('percentage'), id: 'percentage', active: false, measure_unit: 'number' },
    { title: _i18n('value'), label: _i18n('value'), id: 'value', active: false, measure_unit: 'number' }
  ]);

  const exporter_usage_type_list = ref([
    { title: _i18n('percentage'), label: _i18n('percentage'), id: 'absolute_percentage', active: false, measure_unit: 'number' },
  ]);

  const volume_threshold_list = ref([
    { title: _i18n('kb'), label: _i18n('kb'), id: 'kb', value: 1024, active: false },
    { title: _i18n('mb'), label: _i18n('mb'), id: 'mb', value: 1048576, active: false },
    { title: _i18n('gb'), label: _i18n('gb'), id: 'gb', value: 1073741824, active: true, default_active: true },
  ]);

  const throughput_threshold_list = ref([
    { title: _i18n('kbps'), label: _i18n('kbps'), id: 'kbps', value: 1000, active: false },
    { title: _i18n('mbps'), label: _i18n('mbps'), id: 'mbps', value: 1000000, active: false },
    { title: _i18n('gbps'), label: _i18n('gbps'), id: 'gbps', value: 1000000000, active: true, default_active: true },
  ]);

  const sign_threshold_list = ref([
    { title: "+", label: ">", id: 'plus', value: 1, active: false },
    { title: "-", label: "<", id: 'minus', value: -1, active: true, default_active: true },
  ]);

  const percentage_threshold_list = [
    { title: "+", label: "%", id: 'plus', value: 1, active: true },
  ];

  const host = ref(null);
  const threshold = ref(null);

  const showed = () => { };



  ({
    csrf: props.page_csrf
  });

  function reset_radio_selection(radio_array) {

    radio_array.forEach((item) => item.active = item.default_active == true);
  }

  /**
   * 
   * Reset fields in modal form 
   */
  const reset_modal_form = async function () {
    invalid_add.value = false;
    host.value = "";
    rule_type.value = "Host";
    selected_ifid.value = ifid_list.value[0];
    selected_metric.value = metric_list.value[0];
    selected_interface_metric.value = interface_metric_list.value[0];
    selected_flow_device_metric.value = flow_device_metric_list.value[0];

    is_edit_page.value = false;
    title = i18n('if_stats_config.add_host_rules_title');
    selected_frequency.value = frequency_list.value[0];
    metric_type.value = metric_type_list.value[0];
    selected_exporter_device.value = flow_exporter_devices.value[1];
    if (selected_exporter_device.value != null) {
      update_exporter_interfaces();
    }

    // reset metric_type_list
    metric_type_list.value.forEach((t) => t.active = false);
    metric_type_list.value[0].active = true;

    if (host_pool_list.value != null)
      selected_host_pool.value = host_pool_list.value[0];

    selected_host_pool_metric.value = host_pool_metric_list.value[0];

    if (network_list.value != null)
      selected_network.value = network_list.value[0];
    if (network_metric_list.value != null)
      selected_network_metric.value = network_metric_list.value[0];


    reset_radio_selection(volume_threshold_list.value);
    reset_radio_selection(throughput_threshold_list.value);
    reset_radio_selection(sign_threshold_list.value);

    rule_type.value = "Host";

    disable_add.value = true;

    threshold.value.value = 1;

    row_to_edit_id.value = null;

    active_metric_type_list.value = metric_type_list.value;

    if (rule_type == 'Host' || rule_type == 'interface') {
      metric_type.vale = metric_type_list.value[0];
    } else {
      metric_type.value = active_metric_type_list.value[0];
    }

    if (props.has_vlans) {
      selected_vlan.value = vlan_list.value[0];
      selected_vlan_metric.value = vlan_metric_list.value[0];
    }

  };

  const set_rule_type = (type) => {
    rule_type.value = type;

    active_metric_type_list.value = metric_type_list.value;

    if (type == "host_pool" || type == "CIDR") {
      change_metric_type_hp();

      if (type == "host_pool") {
        metric_type.value = active_metric_type_list.value[1];
      } else {
        metric_type.value = active_metric_type_list.value[0];
      }

      visible.value = true;

    } else {
      metric_type.value = metric_type_list.value[0];

      if (type == "Host") {
        change_threshold();
      } else if (type == "interface") {
        change_interface_threshold();
      } else if (type == "vlan") {
        change_vlan_threshold();
      } else {
        visible.value = true;
      }
      
    }
  };


  const change_metric_type_exporter = () => {
    let tmp_metric_type_list = [];
    if ((selected_flow_device_metric.value.id == "flowdev_port:usage")) {
      exporter_usage_type_list.value.forEach((item) => {
        if (item.measure_unit == 'number') {
          tmp_metric_type_list.push(item);
        }
      });
      active_metric_type_list.value = tmp_metric_type_list;
    } else {
      exporter_metric_type_list.value.forEach((item) => {
        if (item.id != 'value') {
          tmp_metric_type_list.push(item);
        }
      });
      active_metric_type_list.value = tmp_metric_type_list;
    }
    metric_type.value = active_metric_type_list.value[0];
  };


  const change_metric_type_hp = (set_active_one) => {
    let tmp_metric_type_list = [];
    if ((rule_type.value == "host_pool" && selected_host_pool_metric.value.measure_unit != "bps") || (rule_type.value == "CIDR" && selected_network_metric.value.measure_unit != "bps")) {

      pool_metric_type_list.value.forEach((item) => {
        if (item.measure_unit == 'number') {
          tmp_metric_type_list.push(item);
        }
      });

      active_metric_type_list.value = tmp_metric_type_list;

    } else {

      pool_metric_type_list.value.forEach((item) => {
        if (item.id != 'value') {
          tmp_metric_type_list.push(item);
        }
      });
      active_metric_type_list.value = tmp_metric_type_list;

    }
    if (set_active_one == null || set_active_one == false) {
      metric_type.value = active_metric_type_list.value[0];
    }

  };


  /**
   * 
   * Set row to edit 
   */
  const set_row_to_edit = (row) => {

    if (row != null) {
      title = _i18n('if_stats_config.edit_host_rules_title');
      is_edit_page.value = true;

      row_to_edit_id.value = row.row_id;

      disable_add.value = false;

      // set threshold sign
      sign_threshold_list.value.forEach((t) => {
        t.active = (t.value == row.threshold_sign);
      });

      // set metric_type
      metric_type_list.value.forEach((t) => {
        if (t.id == row.metric_type) {
          t.active = true;
          metric_type.value = t;
        } else {
          t.active = false;
        }
      });

      active_metric_type_list.value = metric_type_list.value;

      // set threshold
      if (row.metric_type == 'volume')
        volume_threshold_list.value.forEach((t) => {
          if ((row.threshold % t.value) == 0) {
            let row_threshold_value = row.threshold / t.value;
            if (row_threshold_value < 1024) {
              t.active = true;
              threshold.value.value = row_threshold_value == 0 ? 1 : row_threshold_value;
            } else {
              t.active = false;
            }
          } else {
            t.active = false;
          }
        });
      else
        if (row.metric_type == 'throughput') {
          //row.threshold = row.threshold * 8;
          throughput_threshold_list.value.forEach((t) => {
            if ((row.threshold % t.value) == 0) {
              let row_threshold_value = row.threshold / t.value;
              if (row_threshold_value < 1000) {
                t.active = true;
                threshold.value.value = row_threshold_value == 0 ? 1 : row_threshold_value;
              } else {
                t.active = false;
              }
            } else {
              t.active = false;
            }
          });
        } else if (row.metric_type == 'percentage') {

          //percentage case
          threshold.value.value = row.threshold;
        } else if (row.metric_type == 'value' || row.metric_type == 'absolute_percentage') {
          threshold.value.value = row.threshold * (row.threshold_sign);
        }

      // set rule_type
      rule_type.value = row.rule_type;

      if (rule_type.value == 'interface') {

        // set ifid
        ifid_list.value.forEach((t) => {
          if (t.id == row.target)
            selected_ifid.value = t;
        });

        // set metric
        if (row.extra_metric != null) {
          interface_metric_list.value.forEach((t) => {
            if (t.id == row.metric && t.extra_metric == row.extra_metric) {
              selected_interface_metric.value = t;
            }
          });

        } else {
          interface_metric_list.value.forEach((t) => {
            if (t.id == row.metric) {
              selected_interface_metric.value = t;
            }
          });
        }
      } else if (rule_type.value == 'exporter') {
        flow_exporter_devices.value.forEach((item) => {
          if (item.id == row.target)
            selected_exporter_device.value = item;
        });
        flow_exporter_device_ifid_list.value.forEach((item) => {
          if (item.id == row.flow_exp_ifid)
            selected_exporter_device_ifid.value = item;
        });
      } else if (rule_type.value == 'Host') {

        //set host
        host.value = row.target;

        //set metric
        if (row.extra_metric != null) {

          metric_list.value.forEach((t) => {
            if (row.metric.contains(t.id) && t.extra_metric == row.extra_metric)
              selected_metric.value = t;
          });
        } else {
          metric_list.value.forEach((t) => {
            if (t.id == row.metric)
              selected_metric.value = t;
          });
        }
      } else if (rule_type.value == 'CIDR') {
        network_list.value.forEach((item) => {
          if (item.id == row.target) {
            selected_network.value = item;
          }
        });

        network_metric_list.value.forEach((item) => {
          if (item.label == row.metric_label) {
            selected_network_metric.value = item;
          }
        });

        change_metric_type_hp(true);

        active_metric_type_list.value.forEach((item) => {
          if (item.id == row.metric_type) {
            metric_type.value = item;
          }
        });


      } else if (rule_type.value == 'host_pool') {
        host_pool_list.value.forEach((item) => {
          if (item.id == row.target) {
            selected_host_pool.value = item;
          }
        });

        host_pool_metric_list.value.forEach((item) => {
          if (item.label == row.metric_label) {
            selected_host_pool_metric.value = item;
          }
        });
        change_metric_type_hp();

        active_metric_type_list.value.forEach((item) => {
          if (item.id == row.metric_type) {
            metric_type.value = item;
          }
        });

      } else if (rule_type.value == 'vlan') {
        selected_vlan.value = vlan_list.value.find((item) => item.id == row.target);
        
        vlan_metric_list.value.forEach((item) => {
          if(item.schema == row.metric) {
            selected_vlan_metric.value = item;
          }
        });

      } else if (rule_type.value == 'profiles') {
        selected_profile.value = profiles_list.value.find((item) => item.id == row.target);
        
        selected_profile_metric.value = profiles_metric_list.value.find((item) => 
          item.schema == row.metric
        );
      }
    }
  };

  const show = (row) => {
    if (row != null) {
      set_row_to_edit(row);
    } else {
      reset_modal_form();
    }


    modal_id.value.show();
  };

  const change_threshold = () => {
    (selected_metric.value.show_volume == true) ? visible.value = true : visible.value = false;
  };

  const change_interface_threshold = () => {
    (selected_interface_metric.value.show_volume == true) ? visible.value = true : visible.value = false;
  };

  const change_vlan_threshold = () => {
    (selected_vlan_metric.value.show_volume == true) ? visible.value = true : visible.value = false;
  };

  const check_empty_host = () => {
    let regex = new RegExp(regexValidation.get_data_pattern('ip'));
    disable_add.value = !(regex.test(host.value) || host.value === '*');
  };

  const set_active_sign_radio = (selected_radio) => {
    const id = selected_radio.target.id;
    sign_threshold_list.value.forEach((measure) => {
      (measure.id === id) ? measure.active = true : measure.active = false;
    });

  };

  /**
   * 
   * Set the metric type
   */
  const set_active_radio = (selected_radio) => {
    const id = selected_radio.target.id;

    if (metric_type.value.id == 'throughput') {
      throughput_threshold_list.value.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    } else if (metric_type.value.id == 'volume') {
      volume_threshold_list.value.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    } else if (metric_type.value.id == 'percentage') {
      percentage_threshold_list.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    }

  };


  /**
   * Function to add rule to rules list
   */
  const add_ = (is_edit) => {
    let tmp_host = '';
    if (rule_type.value != 'interface')
      tmp_host = host.value;

    const tmp_frequency = selected_frequency.value.id;
    let tmp_metric = selected_metric.value.id;
    let tmp_metric_label = selected_metric.value.label;
   
    const tmp_rule_type = rule_type.value;

    let tmp_metric_type = metric_type.value.id;
    let tmp_extra_metric; 
    let basic_value;
    let basic_sign_value;
    let tmp_threshold;
    let tmp_sign_value;

    let tmp_edit_row_id = (is_edit) ? row_to_edit_id.value : null;

    if (visible.value === false) {
      tmp_metric_type = '';
      tmp_extra_metric = '';
      tmp_threshold = threshold.value.value;
    }


    if (tmp_metric_type == 'throughput') {
      sign_threshold_list.value.forEach((measure) => { if (measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      throughput_threshold_list.value.forEach((measure) => { if (measure.active) basic_value = measure.value; });
      tmp_threshold = basic_value * parseInt(threshold.value.value);
      /* The throughput is in bit, the volume in Bytes!! */
    } else if (tmp_metric_type == 'volume') {
      sign_threshold_list.value.forEach((measure) => { if (measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      volume_threshold_list.value.forEach((measure) => { if (measure.active) basic_value = measure.value; });
      tmp_threshold = basic_value * parseInt(threshold.value.value);
    } else if (tmp_metric_type == 'percentage') {
      sign_threshold_list.value.forEach((measure) => { if (measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      tmp_threshold = parseInt(threshold.value.value);
    } else if (tmp_metric_type == 'value' || tmp_metric_type == 'absolute_percentage') {
      sign_threshold_list.value.forEach((measure) => { if (measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      tmp_threshold = tmp_sign_value * parseInt(threshold.value.value);
    }
    let emit_name = 'add';

    if (is_edit == true)
      emit_name = 'edit';


    if (rule_type.value == 'Host') {

      tmp_extra_metric = (selected_metric.value.extra_metric) ? selected_metric.value.extra_metric : null;

      emit(emit_name, {
        host: tmp_host,
        frequency: tmp_frequency,
        metric: tmp_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id

      });
    } else if (rule_type.value == 'interface') {
      tmp_extra_metric = ((selected_interface_metric.value.extra_metric) ? selected_interface_metric.value.extra_metric : null);
      tmp_metric = selected_interface_metric.value.id;
      tmp_metric_label = selected_interface_metric.value.label;
      const tmp_interface_metric = selected_interface_metric.value.id;
      const tmp_interface = selected_ifid.value.id;
      emit(emit_name, {
        frequency: tmp_frequency,
        metric: tmp_interface_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        interface: tmp_interface,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id

      });
    } else if (rule_type.value == "exporter") {
      let flow_device_ifindex = selected_exporter_device_ifid.value.id;
      selected_exporter_device_ifid.value.label;
      const flow_device_ip = selected_exporter_device.value.id;
      if (flow_device_ip == '*') 
        flow_device_ifindex = '*';
      const ifid = selected_exporter_device.value.ifid;
      let metric_exp;

      if (!selected_flow_device_metric.value.id) {
        metric_exp = flow_device_metric_list.value.find((item) => item.id === null);
        /* In case no metric id is found, it means it's the traffic one */
        if (flow_device_ifindex != null && flow_device_ifindex != '*') {
          metric_exp = selected_flow_device_metric.value;
          metric_exp.id = "flowdev_port:traffic";
        }
        else {
          metric_exp = selected_flow_device_metric.value;
          metric_exp.id = "flowdev:traffic";
        }
      } else {
        metric_exp = flow_device_metric_list.value.find((item) => item.id == selected_flow_device_metric.value.id);
      }


      let metric_exp_label = metric_exp.label;

      emit(emit_name, {
        host: flow_device_ip,
        frequency: tmp_frequency,
        metric: metric_exp.id,
        metric_label: metric_exp_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        rule_type: tmp_rule_type,
        interface: flow_device_ifindex,
        rule_ifid: ifid,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id
        
      });
    } else if (rule_type.value == "CIDR") {

      tmp_metric = selected_network_metric.value.schema;
      tmp_metric_label = selected_network_metric.value.label;
      tmp_host = selected_network.value.id;
      const network_id = selected_network.value.network_id;
      emit(emit_name, {
        host: tmp_host,
        frequency: tmp_frequency,
        metric: tmp_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id,
        network: network_id

      });
    } else if (rule_type.value == "host_pool") {

      tmp_metric = selected_host_pool_metric.value.schema;
      tmp_metric_label = selected_host_pool_metric.value.label;
      const tmp_host_pool_id = selected_host_pool.value.id;
      const tmp_host_pool_label = selected_host_pool.value.label;

      emit(emit_name, {
        host_pool_id: tmp_host_pool_id,
        host_pool_label: tmp_host_pool_label,
        frequency: tmp_frequency,
        metric: tmp_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id

      });

    } else if (rule_type.value == "vlan") {

      tmp_metric = selected_vlan_metric.value.schema;
      tmp_metric_label = selected_vlan_metric.value.label;
      const tmp_vlan_id = selected_vlan.value.id;
      const tmp_vlan_label = selected_vlan.value.label;

      emit(emit_name, {
        vlan_id: tmp_vlan_id,
        vlan_label: tmp_vlan_label,
        frequency: tmp_frequency,
        metric: tmp_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id

      });
    } else if (rule_type.value == "profiles") {

      tmp_metric = selected_profile_metric.value.schema;
      tmp_metric_label = selected_profile_metric.value.label;
      const tmp_profile = selected_profile.value.id;

      emit(emit_name, {
        profile: tmp_profile,
        frequency: tmp_frequency,
        metric: tmp_metric,
        metric_label: tmp_metric_label,
        threshold: tmp_threshold,
        metric_type: tmp_metric_type,
        extra_metric: tmp_extra_metric,
        rule_type: tmp_rule_type,
        rule_threshold_sign: tmp_sign_value,
        rule_id: tmp_edit_row_id
      });
    }

  };


  const edit_ = () => {
    add_(true);
  };

  const close = () => {
    is_edit_page.value = false;
    invalid_add.value = false;
    modal_id.value.close();
  };

  const invalidAdd = () => {
    invalid_add.value = true;
  };

  const compare_labels = function (a,b) {
    let x = a.label.toLowerCase();
    let y = b.label.toLowerCase();

    if (x < y) { return -1; }
    if (x > y) { return 1; }
    return 0;
  };

  /**
   * 
   * Function to format ifid list
   */
  const format_ifid_list = function (data) {
    let _ifid_list = [];
    data.forEach((ifid) => {
      let item = { id: ifid.ifid, label: ifid.name };
      _ifid_list.push(item);
    });
    _ifid_list.sort((a, b) => compare_labels(a,b));
    return _ifid_list
  };

  const metricsLoaded = async (_metric_list, _ifid_list, _interface_metric_list, _flow_exporter_devices, _flow_exporter_devices_metric_list, 
                               page_csrf, _init_func, _delete_row, _host_pool_list, _network_list, _host_pool_metric_list, _network_metric_list, 
                               _vlan_list, _vlan_metric_list, _profiles_list, _profiles_metric_list) => {
    metrics_ready.value = true;
    metric_list.value = _metric_list;
    interface_metric_list.value = _interface_metric_list;
    ifid_list.value = format_ifid_list(_ifid_list);

    frequency_list.value = props.frequency_list;
    selected_frequency.value = frequency_list.value[0];
    selected_metric.value = metric_list.value[0];
    selected_ifid.value = ifid_list.value[0];
    page_csrf_.value = page_csrf;
    if (_init_func) {
      init_func.value = _init_func;
    }

    if (_delete_row) {
      delete_row.value = _delete_row;
    }

    flow_exporter_devices.value = format_flow_exporter_device_list(_flow_exporter_devices);

    if (!dataUtils.isEmptyArrayOrNull(_host_pool_list)) {
      has_host_pools.value = true;
    }
    host_pool_list.value = _host_pool_list;
    host_pool_metric_list.value = _host_pool_metric_list;

    if (!dataUtils.isEmptyArrayOrNull(_network_list)) {
      has_cidr.value = true;
    }
    network_list.value = _network_list;
    network_metric_list.value = _network_metric_list;
    flow_device_metric_list.value = _flow_exporter_devices_metric_list;

    selected_exporter_device.value = flow_exporter_devices.value[1];
    if (selected_exporter_device.value != null) {
      update_exporter_interfaces();
    }
    if (props.has_vlans) {
      vlan_list.value = format_vlan_list(_vlan_list);
      selected_vlan.value = vlan_list.value[0];
      vlan_metric_list.value = _vlan_metric_list;
      selected_vlan_metric.value = vlan_metric_list.value[1];
    }
    if (props.has_profiles) {
      profiles_list.value = format_profile_list(_profiles_list);
      selected_profile.value = profiles_list.value[0];
      profiles_metric_list.value = _profiles_metric_list;
      selected_profile_metric.value = profiles_metric_list.value[0];
    }
  };

  /* *************************************************** */

  /* This function updates the exporter interfaces list, 
   * by requesting to the back end the list of interfaces for the selected exporter 
   */
  async function update_exporter_interfaces() {
    let interfaces_list = [];
    if (selected_exporter_device.value.id == '*') {
      return;
    }
    const url_device_exporter_details =
      NtopUtils$1.buildURL(`${http_prefix}/lua/pro/rest/v2/get/flowdevice/stats.lua?ip=${selected_exporter_device.value.id}&ifid=${selected_exporter_device.value.ifid}`);

    await $.get(url_device_exporter_details, function (response, status) {
      interfaces_list = response.rsp;
    });

    const exporter_interfaces = [
      { id: "*", value: "*", label: "*", timeseries_available: interfaces_list[0]?.timeseries_available }
    ];

    interfaces_list.forEach((rsp) => {
      exporter_interfaces.push({ id: rsp.id, label: rsp.name, timeseries_available: rsp.timeseries_available });
    });
    flow_exporter_device_ifid_list.value = exporter_interfaces;
    selected_exporter_device_ifid.value = flow_exporter_device_ifid_list.value[1];
    flow_device_timeseries_available.value = flow_exporter_device_ifid_list.value[0]?.timeseries_available;
  }

  /* *************************************************** */


  /**
   * Function to format flow exporter device list 
   */
  const format_flow_exporter_device_list = function (data) {
    const _f_exp_dev_list = [
      { id: "*", value: "*", label: "*" }
    ];

    data.forEach((dev) => {
      const ip = dev.probe_ip;
      _f_exp_dev_list.push({
        id: ip,
        label: ip,
        value: ip,
        ifid: dev.ifid
      });
    });

    _f_exp_dev_list.sort((a, b) => sortingFunctions.sortByIP(
      a.label,
      b.label,
      1 /* by default asc */
    ));
    return _f_exp_dev_list;
  };

  /**
   * Function to format vlan list 
   */
  const format_vlan_list = function(data) {
    const f_vlan_list = [];
    data.forEach((vlan) => {
      if (vlan.key != 0) {
        let vlan_label = vlan.key;
        let tag_splitted = vlan.column_vlan.split(">");
        let graphs_splitterd = tag_splitted[1].split("[");
        if (graphs_splitterd.length > 1) {
          vlan_label = tag_splitted[1].split("<")[0];
        }
        f_vlan_list.push({
          id: vlan.key,
          label: vlan_label,
          value: vlan.key,
        });
      }
      
    });

    f_vlan_list.sort((a, b) => sortingFunctions.sortByName(
      a.label,
      b.label,
      1 /* by default asc */
    ));
    return f_vlan_list;
  };

  /**
   * Function to format profile list 
   */
  const format_profile_list = function(data) {
    const f_profile_list = [];
    data.forEach((profile) => {
      if (profile.column_profile != "") {
        f_profile_list.push({
          id: profile.column_profile,
          label: profile.column_profile,
          value: profile.column_profile,
        });
      }
      
    });

    f_profile_list.sort((a, b) => sortingFunctions.sortByName(
      a.id,
      b.id,
      1 /* by default asc */
    ));
    return f_profile_list;
  };

  /* *************************************************** */

  /* This function is automatically called whenever a different exporter is selected
   * in order to update the interfaces select dropdown
   */
  const change_exporter_interfaces = function () {
    update_exporter_interfaces();
  };

  /* *************************************************** */

  onBeforeMount(() => {
    metric_type_list.value.forEach((t) => {
      if (t.active) {
        metric_type.value = t;
      }

    });
    invalid_add.value = false;
  });

  expose({ show, close, metricsLoaded, invalidAdd });



  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[28] || (_cache[28] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        (invalid_add.value)
          ? (openBlock(), createElementBlock("div", _hoisted_1$M, [
              _hoisted_2$F,
              createBaseVNode("span", null, toDisplayString(_i18n('rule_already_present')), 1 /* TEXT */)
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Target information, here an IP is put "),
        createBaseVNode("div", _hoisted_3$E, [
          createBaseVNode("label", _hoisted_4$B, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.add_rules_type")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_5$w, [
            createBaseVNode("div", _hoisted_6$o, [
              createBaseVNode("label", {
                class: normalizeClass(["btn", [rule_type.value == 'Host' ? 'btn-primary active' : 'btn-secondary']])
              }, [
                createBaseVNode("input", {
                  class: "btn-check",
                  type: "radio",
                  name: "rule_type",
                  value: "hosts",
                  onClick: _cache[0] || (_cache[0] = $event => (set_rule_type('Host')))
                }),
                createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_host")), 1 /* TEXT */)
              ], 2 /* CLASS */),
              createBaseVNode("label", {
                class: normalizeClass(["btn", [rule_type.value == 'interface' ? 'btn-primary active' : 'btn-secondary']])
              }, [
                createBaseVNode("input", {
                  onClick: _cache[1] || (_cache[1] = $event => (set_rule_type('interface'))),
                  class: "btn-check",
                  type: "radio",
                  name: "rule_type",
                  value: "interface"
                }),
                createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_interface")), 1 /* TEXT */)
              ], 2 /* CLASS */),
              (flow_device_timeseries_available.value == true)
                ? (openBlock(), createElementBlock("label", {
                    key: 0,
                    class: normalizeClass(["btn", [rule_type.value == 'exporter' ? 'btn-primary active' : 'btn-secondary']])
                  }, [
                    createBaseVNode("input", {
                      onClick: _cache[2] || (_cache[2] = $event => (set_rule_type('exporter'))),
                      class: "btn-check",
                      type: "radio",
                      name: "rule_type",
                      value: "exporter"
                    }),
                    createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_flow_exporter")), 1 /* TEXT */)
                  ], 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (unref(has_host_pools) == true)
                ? (openBlock(), createElementBlock("label", {
                    key: 1,
                    class: normalizeClass(["btn", [rule_type.value == 'host_pool' ? 'btn-primary active' : 'btn-secondary']])
                  }, [
                    createBaseVNode("input", {
                      onClick: _cache[3] || (_cache[3] = $event => (set_rule_type('host_pool'))),
                      class: "btn-check",
                      type: "radio",
                      name: "rule_type",
                      value: "host_pool"
                    }),
                    createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_host_pool")), 1 /* TEXT */)
                  ], 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (unref(has_cidr) == true)
                ? (openBlock(), createElementBlock("label", {
                    key: 2,
                    class: normalizeClass(["btn", [rule_type.value == 'CIDR' ? 'btn-primary active' : 'btn-secondary']])
                  }, [
                    createBaseVNode("input", {
                      onClick: _cache[4] || (_cache[4] = $event => (set_rule_type('CIDR'))),
                      class: "btn-check",
                      type: "radio",
                      name: "rule_type",
                      value: "CIDR"
                    }),
                    createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_cidr")), 1 /* TEXT */)
                  ], 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (props.has_vlans == true)
                ? (openBlock(), createElementBlock("label", {
                    key: 3,
                    class: normalizeClass(["btn", [rule_type.value == 'vlan' ? 'btn-primary active' : 'btn-secondary']])
                  }, [
                    createBaseVNode("input", {
                      onClick: _cache[5] || (_cache[5] = $event => (set_rule_type('vlan'))),
                      class: "btn-check",
                      type: "radio",
                      name: "rule_type",
                      value: "vlan"
                    }),
                    createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_vlans")), 1 /* TEXT */)
                  ], 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (props.has_profiles == true)
                ? (openBlock(), createElementBlock("label", {
                    key: 4,
                    class: normalizeClass(["btn", [rule_type.value == 'profiles' ? 'btn-primary active' : 'btn-secondary']])
                  }, [
                    createBaseVNode("input", {
                      onClick: _cache[6] || (_cache[6] = $event => (set_rule_type('profiles'))),
                      class: "btn-check",
                      type: "radio",
                      name: "rule_type",
                      value: "profiles"
                    }),
                    createTextVNode(" " + toDisplayString(_i18n("if_stats_config.add_rules_type_profiles")), 1 /* TEXT */)
                  ], 2 /* CLASS */))
                : createCommentVNode("v-if", true)
            ])
          ])
        ]),
        (rule_type.value == 'Host')
          ? (openBlock(), createElementBlock("div", _hoisted_7$n, [
              createBaseVNode("label", _hoisted_8$n, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_9$i, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => ((host).value = $event)),
                  onInput: check_empty_host,
                  class: "form-control",
                  type: "text",
                  placeholder: unref(host_placeholder),
                  required: ""
                }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_10$h), [
                  [vModelText, host.value]
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (rule_type.value == 'CIDR')
          ? (openBlock(), createElementBlock("div", _hoisted_11$e, [
              createBaseVNode("label", _hoisted_12$e, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_13$a, [
                createVNode(script$1I, {
                  selected_option: selected_network.value,
                  "onUpdate:selected_option": _cache[8] || (_cache[8] = $event => ((selected_network).value = $event)),
                  options: network_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (rule_type.value == 'host_pool')
          ? (openBlock(), createElementBlock("div", _hoisted_14$a, [
              createBaseVNode("label", _hoisted_15$8, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_16$8, [
                createVNode(script$1I, {
                  selected_option: selected_host_pool.value,
                  "onUpdate:selected_option": _cache[9] || (_cache[9] = $event => ((selected_host_pool).value = $event)),
                  options: host_pool_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (rule_type.value == 'interface')
          ? (openBlock(), createElementBlock("div", _hoisted_17$7, [
              createBaseVNode("label", _hoisted_18$7, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target_interface")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_19$7, [
                createVNode(script$1I, {
                  selected_option: selected_ifid.value,
                  "onUpdate:selected_option": _cache[10] || (_cache[10] = $event => ((selected_ifid).value = $event)),
                  options: ifid_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (rule_type.value == 'exporter' && flow_device_timeseries_available.value == true)
          ? (openBlock(), createElementBlock("div", _hoisted_20$7, [
              createBaseVNode("label", _hoisted_21$6, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target_exporter_device")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_22$6, [
                createVNode(script$1I, {
                  selected_option: selected_exporter_device.value,
                  "onUpdate:selected_option": _cache[11] || (_cache[11] = $event => ((selected_exporter_device).value = $event)),
                  options: flow_exporter_devices.value,
                  onSelect_option: change_exporter_interfaces
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ]),
              (selected_exporter_device.value.id != '*')
                ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("label", _hoisted_23$6, [
                      createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target_exporter_device_ifid")), 1 /* TEXT */)
                    ]),
                    createBaseVNode("div", _hoisted_24$6, [
                      createVNode(script$1I, {
                        selected_option: selected_exporter_device_ifid.value,
                        "onUpdate:selected_option": _cache[12] || (_cache[12] = $event => ((selected_exporter_device_ifid).value = $event)),
                        options: flow_exporter_device_ifid_list.value
                      }, null, 8 /* PROPS */, ["selected_option", "options"])
                    ])
                  ], 64 /* STABLE_FRAGMENT */))
                : createCommentVNode("v-if", true)
            ]))
          : createCommentVNode("v-if", true),
        (rule_type.value == 'vlan')
          ? (openBlock(), createElementBlock("div", _hoisted_25$5, [
              createBaseVNode("label", _hoisted_26$5, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target_vlan")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_27$5, [
                createVNode(script$1I, {
                  selected_option: selected_vlan.value,
                  "onUpdate:selected_option": _cache[13] || (_cache[13] = $event => ((selected_vlan).value = $event)),
                  options: vlan_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Traffic Profiles "),
        (rule_type.value == 'profiles')
          ? (openBlock(), createElementBlock("div", _hoisted_28$3, [
              createBaseVNode("label", _hoisted_29$3, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.target_profile")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_30$2, [
                createVNode(script$1I, {
                  selected_option: selected_profile.value,
                  "onUpdate:selected_option": _cache[14] || (_cache[14] = $event => ((selected_profile).value = $event)),
                  options: profiles_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Metric information, here a metric is selected (e.g. DNS traffic) "),
        (metrics_ready.value)
          ? (openBlock(), createElementBlock("div", _hoisted_31$2, [
              createBaseVNode("label", _hoisted_32$2, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.metric")), 1 /* TEXT */)
              ]),
              (rule_type.value == 'Host')
                ? (openBlock(), createElementBlock("div", _hoisted_33$2, [
                    createVNode(script$1I, {
                      selected_option: selected_metric.value,
                      "onUpdate:selected_option": _cache[15] || (_cache[15] = $event => ((selected_metric).value = $event)),
                      onSelect_option: _cache[16] || (_cache[16] = $event => (change_threshold())),
                      options: metric_list.value
                    }, null, 8 /* PROPS */, ["selected_option", "options"])
                  ]))
                : (rule_type.value == 'interface')
                  ? (openBlock(), createElementBlock("div", _hoisted_34$2, [
                      createVNode(script$1I, {
                        selected_option: selected_interface_metric.value,
                        "onUpdate:selected_option": _cache[17] || (_cache[17] = $event => ((selected_interface_metric).value = $event)),
                        onSelect_option: _cache[18] || (_cache[18] = $event => (change_interface_threshold())),
                        options: interface_metric_list.value
                      }, null, 8 /* PROPS */, ["selected_option", "options"])
                    ]))
                  : (rule_type.value == 'exporter')
                    ? (openBlock(), createElementBlock("div", _hoisted_35$2, [
                        createVNode(script$1I, {
                          selected_option: selected_flow_device_metric.value,
                          "onUpdate:selected_option": _cache[19] || (_cache[19] = $event => ((selected_flow_device_metric).value = $event)),
                          onSelect_option: change_metric_type_exporter,
                          options: flow_device_metric_list.value
                        }, null, 8 /* PROPS */, ["selected_option", "options"])
                      ]))
                    : (rule_type.value == 'host_pool')
                      ? (openBlock(), createElementBlock("div", _hoisted_36$2, [
                          createVNode(script$1I, {
                            selected_option: selected_host_pool_metric.value,
                            "onUpdate:selected_option": _cache[20] || (_cache[20] = $event => ((selected_host_pool_metric).value = $event)),
                            onSelect_option: _cache[21] || (_cache[21] = $event => (change_metric_type_hp())),
                            options: host_pool_metric_list.value
                          }, null, 8 /* PROPS */, ["selected_option", "options"])
                        ]))
                      : (rule_type.value == 'CIDR')
                        ? (openBlock(), createElementBlock("div", _hoisted_37$2, [
                            createVNode(script$1I, {
                              selected_option: selected_network_metric.value,
                              "onUpdate:selected_option": _cache[22] || (_cache[22] = $event => ((selected_network_metric).value = $event)),
                              onSelect_option: _cache[23] || (_cache[23] = $event => (change_metric_type_hp())),
                              options: network_metric_list.value
                            }, null, 8 /* PROPS */, ["selected_option", "options"])
                          ]))
                        : (rule_type.value == 'vlan')
                          ? (openBlock(), createElementBlock("div", _hoisted_38$2, [
                              createVNode(script$1I, {
                                selected_option: selected_vlan_metric.value,
                                "onUpdate:selected_option": _cache[24] || (_cache[24] = $event => ((selected_vlan_metric).value = $event)),
                                options: vlan_metric_list.value,
                                onSelect_option: change_vlan_threshold
                              }, null, 8 /* PROPS */, ["selected_option", "options"])
                            ]))
                          : (rule_type.value == 'profiles')
                            ? (openBlock(), createElementBlock("div", _hoisted_39$2, [
                                createVNode(script$1I, {
                                  selected_option: selected_profile_metric.value,
                                  "onUpdate:selected_option": _cache[25] || (_cache[25] = $event => ((selected_profile_metric).value = $event)),
                                  options: profiles_metric_list.value
                                }, null, 8 /* PROPS */, ["selected_option", "options"])
                              ]))
                            : createCommentVNode("v-if", true)
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Frequency information, a frequency of 1 day, 5 minute or 1 hour for example "),
        (metrics_ready.value)
          ? (openBlock(), createElementBlock("div", _hoisted_40$2, [
              createBaseVNode("label", _hoisted_41$2, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.frequency")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_42$2, [
                createVNode(script$1I, {
                  selected_option: selected_frequency.value,
                  "onUpdate:selected_option": _cache[26] || (_cache[26] = $event => ((selected_frequency).value = $event)),
                  options: frequency_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Threshold information, maximum amount of bytes "),
        createBaseVNode("div", _hoisted_43$2, [
          createBaseVNode("label", _hoisted_44$2, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.threshold")), 1 /* TEXT */)
          ]),
          (visible.value)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_45$2, [
                  createVNode(script$1I, {
                    selected_option: metric_type.value,
                    "onUpdate:selected_option": _cache[27] || (_cache[27] = $event => ((metric_type).value = $event)),
                    options: unref(active_metric_type_list)
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["col-3", [metric_type.value.id == 'throughput' ? 'p-0' : '']])
                }, [
                  createBaseVNode("div", _hoisted_46$2, [
                    (metric_type.value.id == 'throughput')
                      ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(throughput_threshold_list.value, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_47$2),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [measure.active ? 'btn-primary active' : 'btn-secondary']]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_48$2)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 256 /* UNKEYED_FRAGMENT */))
                      : createCommentVNode("v-if", true),
                    (metric_type.value.id == 'percentage')
                      ? (openBlock(), createElementBlock(Fragment, { key: 1 }, renderList(percentage_threshold_list, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_49$2),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [measure.active ? 'btn-primary active' : 'btn-secondary']]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_50$1)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 64 /* STABLE_FRAGMENT */))
                      : createCommentVNode("v-if", true),
                    (metric_type.value.id == 'volume')
                      ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(volume_threshold_list.value, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_51$1),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [measure.active ? 'btn-primary active' : 'btn-secondary']]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_52$1)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 256 /* UNKEYED_FRAGMENT */))
                      : createCommentVNode("v-if", true)
                  ])
                ], 2 /* CLASS */),
                createBaseVNode("div", _hoisted_53$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(sign_threshold_list.value, (measure) => {
                    return (openBlock(), createElementBlock(Fragment, null, [
                      createBaseVNode("input", {
                        value: measure.value,
                        id: measure.id,
                        type: "radio",
                        class: "btn-check",
                        autocomplete: "off",
                        ref_for: true,
                        ref_key: "threshold_sign",
                        ref: threshold_sign,
                        name: "threshold_sign"
                      }, null, 8 /* PROPS */, _hoisted_54$1),
                      createBaseVNode("label", {
                        class: normalizeClass(["btn", [measure.active ? 'btn-primary active' : 'btn-secondary']]),
                        id: measure.id,
                        onClick: set_active_sign_radio,
                        for: measure.id
                      }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_55$1)
                    ], 64 /* STABLE_FRAGMENT */))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ])
              ], 64 /* STABLE_FRAGMENT */))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass([visible.value ? 'col-sm-2' : 'col-sm-8'])
          }, [
            (metric_type.value.id == 'percentage')
              ? (openBlock(), createElementBlock("input", {
                  key: 0,
                  value: "1",
                  ref_key: "threshold",
                  ref: threshold,
                  type: "number",
                  name: "threshold",
                  class: "form-control",
                  max: "100",
                  min: "1",
                  required: ""
                }, null, 512 /* NEED_PATCH */))
              : (openBlock(), createElementBlock("input", {
                  key: 1,
                  value: "1",
                  ref_key: "threshold",
                  ref: threshold,
                  type: "number",
                  name: "threshold",
                  class: "form-control",
                  max: "1023",
                  min: "1",
                  required: ""
                }, null, 512 /* NEED_PATCH */))
          ], 2 /* CLASS */)
        ]),
        (metric_type.value.id == 'percentage')
          ? (openBlock(), createElementBlock("div", _hoisted_56$1, toDisplayString(_i18n("show_alerts.host_rules_percentage")), 1 /* TEXT */))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        createVNode(script$1u, {
          note_list: note_list,
          add_sub_notes: true,
          sub_note_list: sub_notes_list
        }),
        (is_edit_page.value == false)
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: add_,
              class: "btn btn-primary",
              disabled: disable_add.value && rule_type.value == 'Host'
            }, toDisplayString(_i18n('add')), 9 /* TEXT, PROPS */, _hoisted_57$1))
          : (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              onClick: edit_,
              class: "btn btn-primary",
              disabled: disable_add.value && rule_type.value == 'Host'
            }, toDisplayString(_i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_58$1))
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$T.__file = "http_src/vue/modal-add-host-rules.vue";

  const _hoisted_1$L = { class: "row" };
  const _hoisted_2$E = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$D = { class: "card" };
  const _hoisted_4$A = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$v = { class: "card-body" };
  const _hoisted_6$n = { class: "mb-4" };
  const _hoisted_7$m = { id: "host_rules" };
  const _hoisted_8$m = { class: "card-footer" };


  var script$S = {
    __name: 'page-host-rules',
    props: {
    page_csrf: String,
    has_vlans: Boolean,
    has_profiles: Boolean,
    ifid: String,
  },
    setup(__props) {

  const props = __props;



  const table_host_rules = ref(null);
  const modal_delete_confirm = ref(null);
  const modal_add_host_rule = ref(null);
  const _i18n = (t) => i18n(t);
  const row_to_delete = ref({});
  const row_to_edit = ref({});
  const invalid_add = ref(false);


  const metric_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=host`;
  const metric_ifname_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=interface`;

  const metric_host_pool_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=host_pool`;
  const metric_network_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=CIDR`;
  const metric_vlan_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=vlan`;
  const metric_profiles_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=profiles`;

  const metric_flow_exp_device_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_metric.lua?rule_type=exporter`;
  const flow_devices_url = `${http_prefix}/lua/pro/rest/v2/get/flowdevices/stats.lua`;
`${http_prefix}/lua/pro/enterprise/flowdevice_details.lua`;
  const host_pool_url = `${http_prefix}/lua/rest/v2/get/host/pool/pools.lua`;
  const network_list_url = `${http_prefix}/lua/rest/v2/get/network/networks.lua`;
  const ifid_url = `${http_prefix}/lua/rest/v2/get/ntopng/interfaces.lua`;
  const vlans_url = `${http_prefix}/lua/get_vlans_data.lua`;
  const profiles_url = `${http_prefix}/lua/get_traffic_profiles.lua`;
  const data_url = `${http_prefix}/lua/pro/rest/v2/get/interface/host_rules/host_rules_data.lua`;
  const add_rule_url = `${http_prefix}/lua/pro/rest/v2/add/interface/host_rules/add_host_rule.lua`;
  const remove_rule_url = `${http_prefix}/lua/pro/rest/v2/delete/interface/host_rules/delete_host_rule.lua`;

  const note_list = [
    _i18n('if_stats_config.generic_notes_1'),
    _i18n('if_stats_config.generic_notes_2'),
    _i18n('if_stats_config.generic_notes_3'),
  ];

  const rest_params = {
    ifid: props.ifid,
    csrf: props.page_csrf,
    gui: true // Some API requires this to return html content for backward compatibility
  };

  let host_rules_table_config = {};
  let title_delete = _i18n('if_stats_config.delete_host_rules_title');
  _i18n('if_stats_config.edit_local_network_rules');
  let body_delete = _i18n('if_stats_config.delete_host_rules_description');
  let metric_list = [];
  let interface_metric_list = [];
  let host_pool_metric_list = [];
  let ifid_list = [];
  let flow_exporter_list = [];
  let flow_exporter_metric_list = [];
  let host_pool_list = [];
  let network_list = [];
  let network_metric_list = [];
  let vlan_list = [];
  let vlan_metric_list = [];
  let profiles_list = [];
  let profiles_metric_list = [];


  const frequency_list = [
    { title: i18n('show_alerts.5_min'), label: i18n('show_alerts.5_min'), id: '5min', value: '5min' },
    { title: i18n('show_alerts.hourly'), label: i18n('show_alerts.hourly'), id: 'hour', value: 'hour' },
    { title: i18n('show_alerts.daily'), label: i18n('show_alerts.daily'), id: 'day', value: 'day' }
  ];

  const show_delete_dialog = function (row) {
    row_to_delete.value = row;
    modal_delete_confirm.value.show();
  };

  const load_selected_field = function (row) {
    row_to_edit.value = row;

    row_to_delete.value = row;

    modal_add_host_rule.value.show(row);

  };

  async function edit(params) {
    //await delete_row();

    await add_host_rule(params);
  }
  const init_edit = function () {
    const row = row_to_edit.value;
    row_to_edit.value = null;
    return row;
  };

  const destroy_table = function () {
    table_host_rules.value.destroy_table();
  };

  const reload_table = function () {
    table_host_rules.value.reload();
  };

  const delete_row = async function () {
    const row = row_to_delete.value;
    const url = NtopUtils$1.buildURL(remove_rule_url, {
      ...rest_params,
      ...{
        rule_id: row.id,
        rule_type: row.rule_type
      }
    });

    await $.post(url, function (rsp, status) {
      reload_table();
    });
  };

  const add_host_rule = async function (params) {

    params.csrf = props.page_csrf;
    params.ifid = props.ifid;
    const rsp = await ntopng_utility.http_post_request(add_rule_url, params);

    invalid_add.value = rsp.rsp;

    if (invalid_add.value == false) {
      modal_add_host_rule.value.close();
      reload_table();
    } else {
      modal_add_host_rule.value.invalidAdd();
    }

  };


  const add_action_column = function (rowData) {
    let delete_handler = {
      handlerId: "delete_host",
      onClick: () => {
        show_delete_dialog(rowData);
      },
    };

    let edit_handler = {
      handlerId: "edit_rule",
      onClick: () => {
        load_selected_field(rowData);
      },
    };

    return DataTableUtils.createActionButtons([
      { class: `pointer`, handler: edit_handler, icon: 'fa-edit', title: i18n('edit') },
      { class: `pointer`, handler: delete_handler, icon: 'fa-trash', title: i18n('delete') },
    ]);
  };

  const format_metric = function (data, rowData) {
    let metric_label = data;

    if (rowData.metric_label) {
      metric_label = rowData.metric_label;
    } else {
      if (rowData.rule_type != 'interface') {
        metric_list.forEach((metric) => {
          if (metric.id == data) {
            if (rowData.extra_metric) {
              if (rowData.extra_metric == metric.extra_metric)
                metric_label = metric.label;
            } else {
              metric_label = metric.label;
            }
          }
        });
      } else {
        interface_metric_list.forEach((metric) => {
          if (metric.id == data) {
            if (rowData.extra_metric) {
              if (rowData.extra_metric == metric.extra_metric)
                metric_label = metric.label;
            } else {
              metric_label = metric.label;
            }
          }
        });
      }
    }

    return metric_label
  };

  const format_frequency = function (data) {
    let frequency_title = '';
    frequency_list.forEach((frequency) => {
      if (data == frequency.id)
        frequency_title = frequency.title;
    });

    return frequency_title
  };

  const format_threshold = function (data, rowData) {
    let formatted_data = parseInt(data);
    let threshold_sign = "> ";

    if ((rowData.threshold_sign) && (rowData.threshold_sign == '-1'))
      threshold_sign = "< ";

    if ((rowData.metric_type) && (rowData.metric_type == 'throughput')) {
      formatted_data = threshold_sign + NtopUtils$1.bitsToSize(data);
    } else if ((rowData.metric_type) && (rowData.metric_type == 'volume')) {
      formatted_data = threshold_sign + NtopUtils$1.bytesToSize(data);
    } else if ((rowData.metric_type) && (rowData.metric_type.contains('percentage'))) {
      if (data < 0) {
        data = data * (-1);
      }
      formatted_data = threshold_sign + NtopUtils$1.fpercent(data);
    } else if ((rowData.metric_type) && (rowData.metric_type == 'value')) {
      if (data < 0) {
        data = data * (-1);
      }
      formatted_data = threshold_sign + data;
    }

    return formatted_data
  };

  const format_last_measurement = function (data, rowData) {
    let formatted_data = parseInt(data);
    if (rowData.target == "*") {
      return "";
    }

    if (data == null) {
      return "";
    }
    if ((rowData.metric_type) && (rowData.metric_type == 'throughput')) {
      formatted_data = NtopUtils$1.bitsToSize(data);
    } else if ((rowData.metric_type) && (rowData.metric_type == 'volume')) {
      formatted_data = NtopUtils$1.bytesToSize(data);
    } else if ((rowData.metric_type) && (rowData.metric_type.includes('percentage'))) {
      const sign_data = data < 0 ? -1 : 1;
      const absolute_value = NtopUtils$1.fpercent(data * sign_data);
      formatted_data = sign_data == -1 ? `<label title='${i18n("percentage_decrease")}'> (-) ${absolute_value} </label>` : `<label title='${i18n("percentage_increase")}'>${absolute_value}</label>`;
    }

    return formatted_data
  };

  const format_rule_type = function (data, rowData) {
    let formatted_data = '';
    if ((rowData.rule_type) && (rowData.rule_type == 'interface')) {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("interface") + " <i class='fas fa-ethernet'></i></span>";
    } else if ((rowData.rule_type) && (rowData.rule_type == 'Host')) {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("about.host_checks_directory") + " <i class='fas fa-laptop'></i></span>";
    } else if ((rowData.rule_type) && rowData.rule_type == 'host_pool') {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("alert_entities.host_pool") + " <i class='fas fa-laptop'></i></span>";

    } else if ((rowData.rule_type) && rowData.rule_type == 'CIDR') {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("network") + " <i class='fas fa-laptop'></i></span>";

    } else if ((rowData.rule_type) && (rowData.rule_type == 'exporter') && rowData.metric == "flowdev:traffic") {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("flow_exporter_device") + " <i class='fas fa-laptop'></i></span>";

    } else if ((rowData.rule_type) && (rowData.rule_type == 'exporter') && rowData.metric.includes("flowdev_port")) {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("interface_flow_exporter_device") + " <i class='fas fa-ethernet'></i></span>";
    } else if ((rowData.rule_type) && rowData.rule_type == 'vlan') {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("vlan") + " <i class='fas fa-ethernet'></i></span>";
    } else if ((rowData.rule_type) && rowData.rule_type == 'profiles') {
      formatted_data = "<span class='badge bg-secondary'>" + _i18n("if_stats_config.target_profile") + " <i class='fas fa-ethernet'></i></span>";
    }

    return formatted_data;
  };

  const format_target = function (data, rowData) {
    let formatted_data = '';
    if ((rowData.rule_type) && (rowData.rule_type == 'interface')) {
      formatted_data = rowData.selected_iface;
    } else if (rowData.rule_type && (rowData.rule_type == 'Host' || rowData.rule_type == 'CIDR')) {
      formatted_data = rowData.target;
    } else if (rowData.rule_type == 'host_pool') {
      formatted_data = rowData.host_pool_label;
    } else if (rowData.rule_type == 'vlan') {
      formatted_data = rowData.vlan_label;
    } else if (rowData.rule_type == 'profiles') {
      formatted_data = rowData.target;
    } else if (rowData.rule_type && rowData.rule_type == 'exporter' && rowData.metric == "flowdev:traffic") {
      formatted_data = rowData.target;
    } else {
      let interface_label = rowData.flow_exp_ifid_name != "" && rowData.flow_exp_ifid_name != null  ? rowData.flow_exp_ifid_name : rowData.flow_exp_ifid;
      formatted_data = rowData.target + " " + _i18n("on_interface") + ": " + interface_label;
    }
    return formatted_data;
  };

  const get_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_url, rest_params);

    await $.get(url, function (rsp, status) {
      metric_list = rsp.rsp;
    });
  };


  const get_host_pool_list = async function () {
    const url = NtopUtils$1.buildURL(host_pool_url, rest_params);
    let tmp_host_pool_list;
    await $.get(url, function (rsp, status) {
      tmp_host_pool_list = rsp.rsp;
    });

    tmp_host_pool_list.sort((a, b) => (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0));
    host_pool_list = tmp_host_pool_list;
  };

  const get_network_list = async function () {
    const url = NtopUtils$1.buildURL(network_list_url, rest_params);

    let tmp_network_list;
    await $.get(url, function (rsp, status) {
      tmp_network_list = rsp.rsp;
    });

    tmp_network_list.sort((a, b) => (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0));
    network_list = tmp_network_list;

  };

  const get_interface_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_ifname_url, rest_params);

    await $.get(url, function (rsp, status) {
      interface_metric_list = rsp.rsp;
    });

  };

  const get_host_pool_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_host_pool_url, rest_params);

    let tmp_host_pool_metric_list;
    await $.get(url, function (rsp, status) {
      tmp_host_pool_metric_list = rsp.rsp;
    });

    tmp_host_pool_metric_list.sort((a, b) => (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0));
    host_pool_metric_list = tmp_host_pool_metric_list;
  };


  const get_network_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_network_url, rest_params);

    let tmp_network_metric_list;
    await $.get(url, function (rsp, status) {
      tmp_network_metric_list = rsp.rsp;
    });

    tmp_network_metric_list.sort((a, b) => (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0));
    network_metric_list = tmp_network_metric_list;

  };

  const get_vlan_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_vlan_url, rest_params);

    let tmp_vlan_metric_list;
    await $.get(url, function (rsp, status) {
      tmp_vlan_metric_list = rsp.rsp;
    });

    tmp_vlan_metric_list.sort((a, b) => (a.label > b.label) ? 1 : ((b.label > a.label) ? -1 : 0));
    vlan_metric_list = tmp_vlan_metric_list;

  };

  const get_profiles_metric_list = async function() {
    const url = NtopUtils$1.buildURL(metric_profiles_url, rest_params);

    let tmp_profiles_metric_list;
    await $.get(url, function (rsp, status) {
      tmp_profiles_metric_list = rsp.rsp;
    });

    profiles_metric_list = tmp_profiles_metric_list;
  };

  const get_flow_exporter_devices_metric_list = async function () {
    const url = NtopUtils$1.buildURL(metric_flow_exp_device_url, {
      ...rest_params
    });

    await $.get(url, function (rsp, status) {
      flow_exporter_metric_list = rsp.rsp;
    });

  };

  const get_flow_exporter_devices_list = async function () {
    const url = NtopUtils$1.buildURL(flow_devices_url, {
      ...rest_params
    });

    await $.get(url, function (rsp, status) {
      flow_exporter_list = rsp.rsp;
    });

  };

  const get_ifid_list = async function () {
    const url = NtopUtils$1.buildURL(ifid_url, rest_params);

    await $.get(url, function (rsp, status) {
      ifid_list = rsp.rsp;
    });
  };

  const get_vlans = async function () {
    const url = NtopUtils$1.buildURL(vlans_url, rest_params);

    await $.get(url, function (rsp, status) {
      vlan_list = JSON.parse(rsp).data;
    });
  };

  const get_profiles = async function () {
    const url = NtopUtils$1.buildURL(profiles_url, rest_params);

    await $.get(url, function (rsp, status) {
      profiles_list = rsp.data;
    });
  };

  const start_datatable = function () {
    const datatableButton = [];

    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function () {
        reload_table();
      }
    }, {
      text: '<i class="fas fa-plus"></i>',
      className: 'btn-link',
      action: function () {
        modal_add_host_rule.value.show();
      }
    });

    const columns = [
      { columnName: _i18n("actions"), width: '5%', targets:0 , name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) } },
      { columnName: _i18n("id"), visible: false, targets: 1, name: 'id', data: 'id', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: _i18n("if_stats_config.target"), targets: 2, width: '20', name: 'target', data: 'target', className: 'text-nowrap', responsivePriority: 1, render: function (data, _, rowData) { return format_target(data, rowData) } },
      { columnName: _i18n("if_stats_config.rule_type"), targets: 3, width: '20', name: 'rule_type', data: 'rule_type', className: 'text-center', responsivePriority: 1, render: function (data, _, rowData) { return format_rule_type(data, rowData) } },
      { columnName: _i18n("if_stats_config.metric"), targets: 4, width: '10', name: 'metric', data: 'metric', className: 'text-center', responsivePriority: 1, render: function (data, _, rowData) { return format_metric(data, rowData) } },
      { columnName: _i18n("if_stats_config.frequency"), targets: 5, width: '10', name: 'frequency', data: 'frequency', className: 'text-center', responsivePriority: 1, render: function (data) { return format_frequency(data) } },
      { columnName: _i18n("if_stats_config.last_measurement"), targets:6 , width: '10', name: 'last_measurement', data: 'last_measurement', className: 'text-center', responsivePriority: 1, render: function (data, _, rowData) { return format_last_measurement(data, rowData) } },
      { columnName: _i18n("if_stats_config.threshold"), targets: 7, width: '10', name: 'threshold', data: 'threshold', className: 'text-end', responsivePriority: 1, render: function (data, _, rowData) { return format_threshold(data, rowData) } },
      { columnName: _i18n("metric_type"), visible: false, targets: 8, name: 'metric_type', data: 'metric_type', className: 'text-nowrap', responsivePriority: 1 },
    ];

    const hostRulesTableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils$1.buildURL(data_url, rest_params),
      enable_search: true,
      columns_config: columns,
      table_config: {
        scrollX: false,
        serverSide: false,
        order: [[1 /* target */, 'desc']],
        columnDefs: columns
      }
    };

    host_rules_table_config = hostRulesTableConfig;
  };

  onBeforeMount(async () => {
    start_datatable();
    await get_metric_list();
    await get_ifid_list();
    await get_interface_metric_list();
    await get_flow_exporter_devices_metric_list();
    await get_flow_exporter_devices_list();
    await get_host_pool_list();
    await get_host_pool_metric_list();
    await get_network_list();
    await get_network_metric_list();
    if (props.has_vlans) {
      await get_vlans();
      await get_vlan_metric_list();
    }
    if (props.has_profiles) {
      await get_profiles();
      await get_profiles_metric_list();
    }
    modal_add_host_rule.value.metricsLoaded(metric_list, ifid_list, interface_metric_list, flow_exporter_list, flow_exporter_metric_list, props.page_csrf, null, null, host_pool_list, network_list, host_pool_metric_list, network_metric_list, vlan_list, vlan_metric_list, profiles_list, profiles_metric_list);
  });

  onUnmounted(() => {
    destroy_table();
  });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$L, [
      createBaseVNode("div", _hoisted_2$E, [
        createBaseVNode("div", _hoisted_3$D, [
          _hoisted_4$A,
          createBaseVNode("div", _hoisted_5$v, [
            createBaseVNode("div", _hoisted_6$n, [
              createBaseVNode("h4", null, toDisplayString(_i18n('if_stats_config.traffic_rules')), 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_7$m, [
              createVNode(script$1c, {
                ref_key: "modal_delete_confirm",
                ref: modal_delete_confirm,
                title: unref(title_delete),
                body: unref(body_delete),
                onDelete: delete_row
              }, null, 8 /* PROPS */, ["title", "body"]),
              createVNode(script$T, {
                ref_key: "modal_add_host_rule",
                ref: modal_add_host_rule,
                metric_list: unref(metric_list),
                interface_metric_list: unref(interface_metric_list),
                frequency_list: frequency_list,
                init_func: init_edit,
                has_vlans: props.has_vlans,
                has_profiles: props.has_profiles,
                onAdd: add_host_rule,
                onEdit: edit
              }, null, 8 /* PROPS */, ["metric_list", "interface_metric_list", "has_vlans", "has_profiles"]),
              createVNode(script$1g, {
                ref_key: "table_host_rules",
                ref: table_host_rules,
                table_buttons: unref(host_rules_table_config).table_buttons,
                columns_config: unref(host_rules_table_config).columns_config,
                data_url: unref(host_rules_table_config).data_url,
                enable_search: unref(host_rules_table_config).enable_search,
                table_config: unref(host_rules_table_config).table_config
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
            ])
          ]),
          createBaseVNode("div", _hoisted_8$m, [
            createVNode(script$1u, { note_list: note_list })
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$S.__file = "http_src/vue/page-host-rules.vue";

  const _hoisted_1$K = { class: "row" };
  const _hoisted_2$D = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$C = { class: "card" };
  const _hoisted_4$z = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$u = { class: "card-body" };
  const _hoisted_6$m = { id: "host_details_ports" };
  const _hoisted_7$l = {
    class: "row mb-4 mt-4",
    id: "host_details_ports"
  };
  const _hoisted_8$l = { class: "col-6" };


  var script$R = {
    __name: 'page-host-details-ports',
    props: {
    page_csrf: String,
  },
    setup(__props) {

  ref(null);
  ref([]);
  ref({});

  const _i18n = (t) => i18n(t);

  function print_stats_column(col) {
    return col.label;
  }

  function print_stats_row(col, row) {
    // debugger;
    let label = row.label;
    return label;
  }

  const destroy = () => {
    traffic_table.value.destroy_table();
  };
      
  onBeforeMount(async () => {
    await start_datatable();
  });

  onMounted(async () => {
    NtopUtils$1.hideOverlays();
  });

  onUnmounted(async () => {
    destroy();
  });

  [
    {
      title: i18n('graphs.cli_ports'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/port/cli_port_data.lua`,
      id: `cli_port_flows`,
    },
    {
      title: i18n('graphs.srv_ports'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/port/srv_port_data.lua`,
      id: `srv_port_flows`,
    },
  ];

  const table_options = [
    {
      url: `${http_prefix}/lua/rest/v2/get/host/port/table_port_data.lua`,
      id: `cli_port_flows`,
      extra_params: {
        mode: 'local',
        protocol: 'tcp'
      },
      columns: [
        { id: "active_server_tcp_ports", label: _i18n("ports_page.active_server_tcp_ports") },
        { id: "port_application", label: _i18n("port") },
      ],
      stats_rows: [],
    },
    {
      url: `${http_prefix}/lua/rest/v2/get/host/port/table_port_data.lua`,
      id: `cli_port_flows`,
      extra_params: {
        mode: 'local',
        protocol: 'udp'
      },
      columns: [
        { id: "active_server_udp_ports", label: _i18n("ports_page.active_server_udp_ports") },
        { id: "port_application", label: _i18n("port") },
      ],
      stats_rows: [],
    },
    {
      url: `${http_prefix}/lua/rest/v2/get/host/port/table_port_data.lua`,
      id: `srv_port_flows`,
      extra_params: {
        mode: 'remote',
        protocol: 'tcp'
      },
      columns: [
        { id: "client_contacted_server_tcp_ports", label: _i18n("ports_page.client_contacted_server_tcp_ports") },
        { id: "port_application", label: _i18n("port") },
      ],
      stats_rows: [],
    },
    {
      url: `${http_prefix}/lua/rest/v2/get/host/port/table_port_data.lua`,
      id: `srv_port_flows`,
      extra_params: {
        mode: 'remote',
        protocol: 'udp'
      },
      columns: [
        { id: "client_contacted_server_udp_ports", label: _i18n("ports_page.client_contacted_server_udp_ports") },
        { id: "port_application", label: _i18n("port") },
      ],
      stats_rows: [],
    },
  ];

  async function start_datatable() {
    let url_params = {};
    
    url_params["host"] = ntopng_url_manager$1.get_url_entry("host");
    url_params["vlan"] = ntopng_url_manager$1.get_url_entry("vlan");
    url_params["ifid"] = ntopng_url_manager$1.get_url_entry("ifid");
      
    table_options.forEach((table) => {
      let tmp_params = {
        ...table.extra_params,
        ...url_params,
      };

      $.get(NtopUtils$1.buildURL(table.url, tmp_params), async function(data, status){
        // debugger;
        let rows = [];
        data.rsp.forEach((data) => {
          const port = data.port_info.port;
          const proto = data.port_info.l7_proto;
          rows.push({ label: `${port} (${proto})` });
        });
        table.stats_rows = rows;
      });
    });
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$K, [
      createBaseVNode("div", _hoisted_2$D, [
        createBaseVNode("div", _hoisted_3$C, [
          _hoisted_4$z,
          createBaseVNode("div", _hoisted_5$u, [
            createBaseVNode("div", _hoisted_6$m, [
              createBaseVNode("div", _hoisted_7$l, [
                (openBlock(), createElementBlock(Fragment, null, renderList(table_options, (table_option) => {
                  return createBaseVNode("div", _hoisted_8$l, [
                    createVNode(script$1f, {
                      id: table_option.id,
                      columns: table_option.columns,
                      rows: table_option.stats_rows,
                      print_html_column: (col) => print_stats_column(col),
                      print_html_row: (col, row) => print_stats_row(col, row)
                    }, null, 8 /* PROPS */, ["id", "columns", "rows", "print_html_column", "print_html_row"])
                  ])
                }), 64 /* STABLE_FRAGMENT */))
              ])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$R.__file = "http_src/vue/page-host-details-ports.vue";

  const _hoisted_1$J = { class: "row" };
  const _hoisted_2$C = { class: "col-12" };
  const _hoisted_3$B = { class: "card" };
  const _hoisted_4$y = { class: "card-body" };
  const _hoisted_5$t = {
    class: "align-items-center justify-content-end mb-3",
    style: {"height":"70vh"}
  };
  const _hoisted_6$l = { class: "d-flex ms-auto flex-row-reverse" };
  const _hoisted_7$k = /*#__PURE__*/createBaseVNode("label", { class: "my-auto me-1" }, null, -1 /* HOISTED */);
  const _hoisted_8$k = /*#__PURE__*/createBaseVNode("span", null, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_9$h = [
    _hoisted_8$k
  ];
  const _hoisted_10$g = {
    key: 0,
    class: "m-1"
  };
  const _hoisted_11$d = { style: {"min-width":"14rem"} };
  const _hoisted_12$d = { class: "my-auto me-1" };


  var script$Q = {
    __name: 'page-alert-analysis',
    props: {
    ifid: String,
    page_csrf: String,
    charts_options: Array,
    available_filters: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);


  const loading = ref(false);
  const chart_type = ntopChartApex.typeChart.BUBBLE;
  const rest_url = `${http_prefix}/lua/pro/rest/v2/charts/alert/analysis.lua`;
  const widget_name = 'alerts-map';
  const active_filter_list = {};
  const bubble_chart = ref(null);

  const format_request = function() {
    let params_string = '';
    const params = {
      bubble_mode: ntopng_url_manager$1.get_url_entry('bubble_mode'),
      timeframe: ntopng_url_manager$1.get_url_entry('timeframe'),
      vlan: ntopng_url_manager$1.get_url_entry('vlan'),
      ifid: ntopng_url_manager$1.get_url_entry('ifid'),
    };

    for (const [key, value] of Object.entries(params)) {
      params_string = `${params_string}&${key}=${value}`;
    }

    /* Return a custom string, containing custom options */
    return params_string
  };

  const reload = function() {
    loading.value = true;
    bubble_chart.value.update_chart(`${rest_url}?${format_request()}`);
    loading.value = false;
  };

  const format_options = function(mode_id) {
    let options = {};

    props.charts_options.forEach((option_list) => {
      if(option_list.mode_id == mode_id)
        options = option_list;
    });

    /* Add the correct event functions */
    if(options && options.chart && options.chart.ntop_events) {
      options.chart.events = options.chart.events || {};
      for(const [event, fun] of Object.entries(options.chart.ntop_events)) {
        if(fun == undefined) 
          continue

        options.chart.events[event] = NtopUtils$1[fun] || NtopUtils$1.fnone;
      }
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.xaxis && options.xaxis.labels && options.xaxis.labels.ntop_utils_formatter) {
      options.xaxis.labels.formatter = NtopUtils$1[options.xaxis.labels.ntop_utils_formatter] || NtopUtils$1.fnone;
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.yaxis && options.yaxis.labels && options.yaxis.labels.ntop_utils_formatter) {
      options.yaxis.labels.formatter = NtopUtils$1[options.yaxis.labels.ntop_utils_formatter] || NtopUtils$1.fnone;
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.tooltip && options.tooltip.ntop_utils_formatter)
      options.tooltip.custom = NtopUtils$1[options.tooltip.ntop_utils_formatter];

    return options
  };

  const get_f_get_custom_chart_options = function() {
    
    /* Return the list of formatted options of the chart */
    return async (url) => {
      let options = format_options(Number(active_filter_list['bubble_mode'].id));
      const data = await ntopng_utility.http_request(url);
      options.series = data.series || {};
      return options
    }
  };

  const click_item = function(item) {
    loading.value = true;
    ntopng_url_manager$1.set_key_to_url(item.filter_name, item.id);
    bubble_chart.value.update_chart(`${rest_url}?${format_request()}`);
    loading.value = false;
  };

  onBeforeMount(() => {
    /* Before mounting the various widgets, update the url to the correct one, by adding ifid, ecc. */
    const timeframe = ntopng_url_manager$1.get_url_entry('timeframe');
    const vlan = ntopng_url_manager$1.get_url_entry('vlan');
    const bubble_mode = ntopng_url_manager$1.get_url_entry('bubble_mode');
    
    if(!bubble_mode) ntopng_url_manager$1.set_key_to_url('bubble_mode', 0); /* First Entry */
    if(!timeframe) ntopng_url_manager$1.set_key_to_url('timeframe', 300); /* Default 5 min */
    if(!vlan) ntopng_url_manager$1.set_key_to_url('vlan', ''); /* Default no vlan */
    
    ntopng_url_manager$1.set_key_to_url('ifid', props.ifid); /* Current interface */

    for(const [name, filters] of Object.entries(props.available_filters)) {
      filters.forEach((filter) => {
        filter.filter_name = name;
        if(filter.currently_active)
          active_filter_list[name] = filter;
      });
    }
  });

  onMounted(() => {
    loading.value = false;
  });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$J, [
      createBaseVNode("div", _hoisted_2$C, [
        createBaseVNode("div", _hoisted_3$B, [
          createBaseVNode("div", _hoisted_4$y, [
            createBaseVNode("div", _hoisted_5$t, [
              createBaseVNode("div", _hoisted_6$l, [
                createBaseVNode("div", null, [
                  _hoisted_7$k,
                  createBaseVNode("div", null, [
                    createBaseVNode("button", {
                      class: "btn btn-link m-1",
                      tabindex: "0",
                      type: "button",
                      onClick: reload
                    }, _hoisted_9$h)
                  ])
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.available_filters, (value, key, index) => {
                  return (openBlock(), createElementBlock(Fragment, null, [
                    (value.length > 0)
                      ? (openBlock(), createElementBlock("div", _hoisted_10$g, [
                          createBaseVNode("div", _hoisted_11$d, [
                            createBaseVNode("label", _hoisted_12$d, toDisplayString(_i18n('bubble_map.' + key)) + ": ", 1 /* TEXT */),
                            createVNode(script$1I, {
                              selected_option: active_filter_list[key],
                              "onUpdate:selected_option": $event => ((active_filter_list[key]) = $event),
                              options: value,
                              onSelect_option: click_item
                            }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options"])
                          ])
                        ]))
                      : createCommentVNode("v-if", true)
                  ], 64 /* STABLE_FRAGMENT */))
                }), 256 /* UNKEYED_FRAGMENT */))
              ]),
              (loading.value)
                ? (openBlock(), createBlock(script$1z, { key: 0 }))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                id: widget_name,
                style: {"height":"90%"},
                class: normalizeClass([ loading.value ? 'ntopng-gray-out' : '' ])
              }, [
                createVNode(script$1F, {
                  ref_key: "bubble_chart",
                  ref: bubble_chart,
                  id: widget_name,
                  chart_type: unref(chart_type),
                  base_url_request: rest_url,
                  get_params_url_request: format_request,
                  get_custom_chart_options: get_f_get_custom_chart_options(),
                  register_on_status_change: false
                }, null, 8 /* PROPS */, ["chart_type", "get_custom_chart_options"])
              ], 2 /* CLASS */)
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$Q.__file = "http_src/vue/page-alert-analysis.vue";

  const _hoisted_1$I = { class: "row" };
  const _hoisted_2$B = { class: "col-12" };
  const _hoisted_3$A = { class: "card" };
  const _hoisted_4$x = { class: "card-body" };
  const _hoisted_5$s = {
    class: "align-items-center justify-content-end mb-3",
    style: {"height":"70vh"}
  };
  const _hoisted_6$k = { class: "d-flex ms-auto flex-row-reverse" };
  const _hoisted_7$j = /*#__PURE__*/createBaseVNode("label", { class: "my-auto me-1" }, null, -1 /* HOISTED */);
  const _hoisted_8$j = { class: "m-1" };
  const _hoisted_9$g = {
    key: 0,
    style: {"min-width":"18rem"}
  };
  const _hoisted_10$f = { class: "my-auto me-1" };


  var script$P = {
    __name: 'page-host-map',
    props: {
    ifid: String,
    page_csrf: String,
    charts_options: Array,
    available_filters: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const chart_type = ntopChartApex.typeChart.BUBBLE;
  const rest_url = `${http_prefix}/lua/rest/v2/charts/host/map.lua`;
  const widget_name = 'alerts-map';
  const active_filter_list = {};
  const bubble_chart = ref(null);

  const format_request = function() {
    let params_string = '';
    const params = {
      bubble_mode: ntopng_url_manager$1.get_url_entry('bubble_mode'),
      ifid: ntopng_url_manager$1.get_url_entry('ifid'),
    };

    for (const [key, value] of Object.entries(params)) {
      params_string = `${params_string}&${key}=${value}`;
    }

    /* Return a custom string, containing custom options */
    return params_string
  };

  const format_options = function(mode_id) {
    let options = {};

    props.charts_options.forEach((option_list) => {
      if(option_list.mode_id == mode_id)
        options = option_list;
    });

    /* Add the corract event functions */
    if(options && options.chart && options.chart.ntop_events) {
      options.chart.events = options.chart.events || {};
      for(const [event, fun] of Object.entries(options.chart.ntop_events)) {
        if(fun == undefined) 
          continue

        options.chart.events[event] = NtopUtils$1[fun] || NtopUtils$1.fnone;
      }
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.xaxis && options.xaxis.labels && options.xaxis.labels.ntop_utils_formatter) {
      options.xaxis.labels.formatter = NtopUtils$1[options.xaxis.labels.ntop_utils_formatter] || NtopUtils$1.fnone;
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.yaxis && options.yaxis.labels && options.yaxis.labels.ntop_utils_formatter) {
      options.yaxis.labels.formatter = NtopUtils$1[options.yaxis.labels.ntop_utils_formatter] || NtopUtils$1.fnone;
    }

    /* Add the correct formatting function, given from the backend */
    if(options && options.tooltip && options.tooltip.ntop_utils_formatter)
      options.tooltip.custom = NtopUtils$1[options.tooltip.ntop_utils_formatter];

    return options
  };

  const get_f_get_custom_chart_options = function() {
    
    /* Return the list of formatted options of the chart */
    return async (url) => {
      let options = format_options(Number(active_filter_list['bubble_mode'].id));
      const data = await ntopng_utility.http_request(url);
      options.series = data.series || {};
      return options
    }
  };

  const click_item = function(item) {
    ntopng_url_manager$1.set_key_to_url(item.filter_name, item.id);
    bubble_chart.value.update_chart(`${rest_url}?${format_request()}`);
  };

  onBeforeMount(() => {
    /* Before mounting the various widgets, update the url to the correct one, by adding ifid, ecc. */
    const bubble_mode = ntopng_url_manager$1.get_url_entry('bubble_mode');
    
    if(!bubble_mode) ntopng_url_manager$1.set_key_to_url('bubble_mode', 0); /* First Entry */
    
    ntopng_url_manager$1.set_key_to_url('ifid', props.ifid); /* Current interface */

    for(const [name, filters] of Object.entries(props.available_filters)) {
      filters.forEach((filter) => {
        filter.filter_name = name;
        if(filter.currently_active)
          active_filter_list[name] = filter;
      });
    }
  });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$I, [
      createBaseVNode("div", _hoisted_2$B, [
        createBaseVNode("div", _hoisted_3$A, [
          createBaseVNode("div", _hoisted_4$x, [
            createBaseVNode("div", _hoisted_5$s, [
              createBaseVNode("div", _hoisted_6$k, [
                _hoisted_7$j,
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.available_filters, (value, key, index) => {
                  return (openBlock(), createElementBlock("div", _hoisted_8$j, [
                    (value.length > 0)
                      ? (openBlock(), createElementBlock("div", _hoisted_9$g, [
                          createBaseVNode("label", _hoisted_10$f, toDisplayString(_i18n('bubble_map.' + key)) + ": ", 1 /* TEXT */),
                          createVNode(script$1I, {
                            selected_option: active_filter_list[key],
                            "onUpdate:selected_option": $event => ((active_filter_list[key]) = $event),
                            options: value,
                            onSelect_option: click_item
                          }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options"])
                        ]))
                      : createCommentVNode("v-if", true)
                  ]))
                }), 256 /* UNKEYED_FRAGMENT */))
              ]),
              createBaseVNode("div", {
                id: widget_name,
                style: {"height":"90%"}
              }, [
                createVNode(script$1F, {
                  ref_key: "bubble_chart",
                  ref: bubble_chart,
                  id: widget_name,
                  chart_type: unref(chart_type),
                  base_url_request: rest_url,
                  get_params_url_request: format_request,
                  get_custom_chart_options: get_f_get_custom_chart_options(),
                  register_on_status_change: false
                }, null, 8 /* PROPS */, ["chart_type", "get_custom_chart_options"])
              ])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$P.__file = "http_src/vue/page-host-map.vue";

  const _hoisted_1$H = { class: "row" };
  const _hoisted_2$A = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$z = { class: "card card-shadow" };
  const _hoisted_4$w = { class: "card-body" };
  const _hoisted_5$r = { class: "d-flex align-items-center flex-row-reverse mb-2" };
  const _hoisted_6$j = /*#__PURE__*/createBaseVNode("label", { class: "my-auto me-1" }, null, -1 /* HOISTED */);
  const _hoisted_7$i = /*#__PURE__*/createBaseVNode("span", null, [
    /*#__PURE__*/createBaseVNode("i", { class: "fas fa-sync" })
  ], -1 /* HOISTED */);
  const _hoisted_8$i = [
    _hoisted_7$i
  ];
  const _hoisted_9$f = {
    key: 0,
    class: "m-1"
  };
  const _hoisted_10$e = { style: {"min-width":"14rem"} };
  const _hoisted_11$c = { class: "my-auto me-1" };
  const _hoisted_12$c = ["title"];
  const _hoisted_13$9 = /*#__PURE__*/createBaseVNode("button", {
    type: "button",
    class: "btn btn-link",
    disabled: ""
  }, [
    /*#__PURE__*/createBaseVNode("i", { class: "text-danger fa-solid fa-triangle-exclamation" })
  ], -1 /* HOISTED */);
  const _hoisted_14$9 = [
    _hoisted_13$9
  ];


  var script$O = {
    __name: 'page-vlan-ports-sankey',
    props: {
    ifid: Number,
    available_filters: Object,
  },
    setup(__props) {

  const props = __props;

  const active_filter_list = {};


  const _i18n = (t) => i18n(t);
  const max_entries_reached = ref(false);
  const max_entry_title = _i18n('ports_analysis.max_entries');
  const no_data_message = _i18n('ports_analysis.no_data');
  const sankey_chart = ref(null);
  const body_div = ref(null);
  const width = ref(null);
  const height = ref(null);
  const sankey_data = ref({});
  const live_rest = `${http_prefix}/lua/pro/rest/v2/get/vlan/live_ports.lua`;
  const historical_rest = `${http_prefix}/lua/pro/rest/v2/get/vlan/historical_ports.lua`;
  const loading = ref(false);

  onBeforeMount(() => {
    /* Before mounting the various widgets, update the url to the correct one, by adding ifid, ecc. */
    const timeframe = ntopng_url_manager$1.get_url_entry('timeframe');
    const vlan = ntopng_url_manager$1.get_url_entry('vlan');
    ntopng_url_manager$1.get_url_entry('l4proto');
    
    if(!timeframe) ntopng_url_manager$1.set_key_to_url('timeframe', 'none'); /* Default live */
    if(!vlan) ntopng_url_manager$1.set_key_to_url('vlan', 'none'); /* Default all VLANs */
    if(!vlan) ntopng_url_manager$1.set_key_to_url('l4proto', 'none'); /* Default no protocol */
    
    ntopng_url_manager$1.set_key_to_url('ifid', props.ifid); /* Current interface */

    for(const [name, filters] of Object.entries(props.available_filters)) {
      filters.forEach((filter) => {
        filter.filter_name = name;
        if(filter.currently_active)
          active_filter_list[name] = filter;
      });
    }
  });

  onMounted(() => {
    update_height();
    update_width();
    update_sankey();
  });

  function on_node_click(node) {
    if (node.is_link_node == true) { return; }
    if (node.link) { ntopng_url_manager$1.go_to_url(node.link); }
  }

  const reload = function() {
    update_sankey();
  };

  const click_item = function(item) {
    ntopng_url_manager$1.set_key_to_url(item.filter_name, item.id);
    update_sankey();
  };

  const update_sankey = function() {
    set_sankey_data();
  };

  function check_max_entries(data) {
    max_entries_reached.value = data.max_entries_reached;
  }

  async function set_sankey_data() {
    loading.value = true;
    let data = await get_sankey_data();    
    sankey_data.value = data;
    loading.value = false;
  }

  async function get_sankey_data() {
    const url_request = get_sankey_url();
    let graph = await ntopng_utility$1.http_request(url_request);
    check_max_entries(graph);
    graph = make_complete_graph(graph);
    const sankey_data = get_sankey_data_from_rest_data(graph);
    /* In case no data is returned, show the No Data message */
    (sankey_data.links.length > 0 && sankey_data.nodes.length > 0) ? 
      sankey_chart.value.set_no_data_flag(false) : 
      sankey_chart.value.set_no_data_flag(true);
    
    
    return sankey_data;
  }

  function get_sankey_url() {
    let vlan = ntopng_url_manager$1.get_url_entry("vlan");
    let timeframe = ntopng_url_manager$1.get_url_entry("timeframe");
    let l4proto = ntopng_url_manager$1.get_url_entry("l4proto");
    if(vlan == 'none') { vlan = ''; }
    if(timeframe == 'none') { timeframe = ''; }
    if(l4proto == 'none') { l4proto = ''; }
    
    let url_request = '';
    let params = {
      ifid: ntopng_url_manager$1.get_url_entry("ifid"),
      vlan: vlan,
      timeframe: timeframe,
      l4proto: l4proto
    };
    let url_params = ntopng_url_manager$1.obj_to_url_params(params);

    if(timeframe == '') { url_request = `${live_rest}?${url_params}`; }
    else { url_request = `${historical_rest}?${url_params}`; }

    return url_request;
  }

  function get_sankey_data_from_rest_data(res) {
      let node_dict = {}, link_to_nodes_dict = {};
      // create a node dict
      res.nodes.forEach((node) => node_dict[node.node_id] = node);
      
      let f_get_link_node_id = (link) => {
  	return `${link.source_node_id}_${link.label}`; 
      };
      // merge all links by label
      res.links.forEach((link) => {
  	let link_node_id = f_get_link_node_id(link);
  	let link_to_nodes = link_to_nodes_dict[link_node_id];
  	if (link_to_nodes == null) {
  	    link_to_nodes = {
  		id: link_node_id,
  		label: link.label,
      link: link.optional_info.link,
  		node_links: [],		
  	    };
  	    link_to_nodes_dict[link_node_id] = link_to_nodes;
  	}
  	link_to_nodes.node_links.push({
  	    source: node_dict[link.source_node_id],
  	    target: node_dict[link.target_node_id],
  	    value: link.value,
  	});	
      });
      
      // create nodes and links
      let nodes = res.nodes.map((n) => n), links = [];
      for (let link_node_id in link_to_nodes_dict) {
  	let link_to_nodes = link_to_nodes_dict[link_node_id];
  	let link_node = {
  	    node_id: link_to_nodes.id,
  	    label: link_to_nodes.label,
        link: link_to_nodes.link,
  	};
  	nodes.push(link_node);
  	link_to_nodes.node_links.forEach((link) => {
  	    links.push({
  		source_node_id: link.source.node_id,
  		target_node_id: link_node.node_id,
  		label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
  		value: link.value,
  	    });
  	    links.push({
  		source_node_id: link_node.node_id,
  		target_node_id: link.target.node_id,
  		label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
  		value: link.value,
  	    });
  	});
      }
      let sankey_nodes = nodes.map((n, index) => {
  	return { index, label: n.label, data: n };
      });
      let sankey_node_dict = {};    
      sankey_nodes.forEach((sn, index) => sankey_node_dict[sn.data.node_id] = sn);
      let sankey_links = links.map((l) => {
  	let source_index = sankey_node_dict[l.source_node_id].index;
  	let target_index = sankey_node_dict[l.target_node_id].index;
  	return {
  	    source: source_index,
  	    target: target_index,
  	    value: l.value,
  	    label: l.label,
  	};
      });
      return { nodes: sankey_nodes, links: sankey_links };
  }

  // remove all links with a not existing node
  function make_complete_graph(graph) {
      let f_log_link = (l) => console.error(`link (source: ${l.source_node_id}, target: ${l.target_node_id}) removed for not existing source/target node`);    
      let links = get_links_with_existing_node(graph, f_log_link);
      return { nodes: graph.nodes, links };
  }

  function get_links_with_existing_node(graph, f_log) {
      let node_dict = {};
      graph.nodes.forEach((n) => node_dict[n.node_id] = true);
      let f_filter = (l) => node_dict[l.source_node_id] != null && node_dict[l.target_node_id] != null;    
      let links = filter_log(graph.links, f_filter, f_log);
      return links;
  }

  // log elements deleted if f_log != null
  function filter_log(elements, f_filter, f_log) {
      return elements.filter((e) => {
  	const take_element = f_filter(e);
  	if (take_element == false && f_log != null) {
  	    f_log(e);
  	}
  	return take_element;
      });
  }

  function update_height() {
    height.value = $(body_div.value).height() - 100;
  }

  function update_width() {
    width.value = $(body_div.value).width() - 10;
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$H, [
      createBaseVNode("div", _hoisted_2$A, [
        createBaseVNode("div", _hoisted_3$z, [
          (loading.value)
            ? (openBlock(), createBlock(script$1z, { key: 0 }))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_4$w, [
            createBaseVNode("div", {
              class: normalizeClass(["align-items-center justify-content-end mb-2", [loading.value ? 'ntopng-gray-out' : '']]),
              style: {"height":"70vh"},
              ref_key: "body_div",
              ref: body_div
            }, [
              createBaseVNode("div", _hoisted_5$r, [
                createBaseVNode("div", null, [
                  _hoisted_6$j,
                  createBaseVNode("div", null, [
                    createBaseVNode("button", {
                      class: "btn btn-link m-1",
                      tabindex: "0",
                      type: "button",
                      onClick: reload
                    }, _hoisted_8$i)
                  ])
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.available_filters, (value, key, index) => {
                  return (openBlock(), createElementBlock(Fragment, null, [
                    (value.length > 0)
                      ? (openBlock(), createElementBlock("div", _hoisted_9$f, [
                          createBaseVNode("div", _hoisted_10$e, [
                            createBaseVNode("label", _hoisted_11$c, toDisplayString(_i18n('ports_analysis.' + key)) + ": ", 1 /* TEXT */),
                            createVNode(script$1I, {
                              selected_option: active_filter_list[key],
                              "onUpdate:selected_option": $event => ((active_filter_list[key]) = $event),
                              options: value,
                              onSelect_option: click_item
                            }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options"])
                          ])
                        ]))
                      : createCommentVNode("v-if", true)
                  ], 64 /* STABLE_FRAGMENT */))
                }), 256 /* UNKEYED_FRAGMENT */)),
                (max_entries_reached.value == true)
                  ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: "mt-auto m-1",
                      title: unref(max_entry_title),
                      style: {"cursor":"help"}
                    }, _hoisted_14$9, 8 /* PROPS */, _hoisted_12$c))
                  : createCommentVNode("v-if", true)
              ]),
              createVNode(script$V, {
                ref_key: "sankey_chart",
                ref: sankey_chart,
                width: width.value,
                height: height.value,
                no_data_message: unref(no_data_message),
                sankey_data: sankey_data.value,
                onUpdate_width: update_width,
                onUpdate_height: update_height,
                onNode_click: on_node_click
              }, null, 8 /* PROPS */, ["width", "height", "no_data_message", "sankey_data"])
            ], 2 /* CLASS */)
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$O.__file = "http_src/vue/page-vlan-ports-sankey.vue";

  const _hoisted_1$G = { class: "row" };
  const _hoisted_2$z = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$y = { class: "card card-shadow" };
  const _hoisted_4$v = { class: "card-body" };
  const _hoisted_5$q = { class: "d-flex align-items-center mb-2" };
  const _hoisted_6$i = {
    class: "d-flex no-wrap",
    style: {"text-align":"left","margin-right":"1rem","min-width":"25rem"}
  };
  const _hoisted_7$h = { class: "my-auto me-1" };
  const _hoisted_8$h = { class: "dropdown me-3 d-inline-block" };
  const _hoisted_9$e = { class: "no-wrap d-flex align-items-center filters-label" };
  const _hoisted_10$d = { class: "d-flex justify-content-center align-items-center" };


  var script$N = {
    __name: 'page-aggregated-live-flows',
    props: {
      context: Object
  },
    setup(__props) {

  const props = __props;



  const csrf = ref(props.context.csrf);
  const _i18n = (t) => i18n(t);

  const criteria_list_def = [
      { label: _i18n("application_proto"), value: 1, param: "application_protocol", table_id: "aggregated_app_proto", enterprise_m: false, search_enabled: true },
      { label: _i18n("client"), value: 2, param: "client", table_id: "aggregated_client", enterprise_m: false, search_enabled: false },
      { label: _i18n("client_server"), value: 4, param: "client_server", table_id: "aggregated_client_server", enterprise_m: true, search_enabled: false },
      { label: _i18n("client_server_application_proto"), value: 5, param: "app_client_server", table_id: "aggregated_app_client_server", enterprise_m: true, search_enabled: true },
      { label: _i18n("client_server_srv_port"), value: 7, param: "client_server_srv_port", table_id: "aggregated_client_server_srv_port", enterprise_m: false, search_enabled: false },
      { label: _i18n("client_server_srv_port_app_proto"), value: 8, param: "client_server_srv_port_app_proto", table_id: "aggregated_client_server_srv_port_app_proto", enterprise_m: false, search_enabled: false },
      { label: _i18n("info"), value: 6, param: "info", table_id: "aggregated_info", enterprise_m: true, search_enabled: true },
      { label: _i18n("server"), value: 3, param: "server", table_id: "aggregated_server", enterprise_m: false, search_enabled: false },
  ];

  const loading = ref(false);
  const table_aggregated_live_flows = ref();
  const filter_table_array = ref([]);
  ref([]);
  const filters = ref([]);

  const table_config_id = ref('aggregated_live_flows');
  const table_id = computed$1(() => {
      if (selected_criteria.value?.value == null) { return table_config_id.value; }
      let id = `${table_config_id.value}_${selected_criteria.value.value}`;
      return id;
  });
  const selected_criteria = ref(criteria_list_def[0]);

  const criteria_list = function () {
      if (props.context.is_ntop_enterprise_m) {
          return ref(criteria_list_def);
      }
      else {
          let critera_list_def_com = [];
          criteria_list_def.forEach((c) => {
              if (!c.enterprise_m)
                  critera_list_def_com.push(c);
          });
          return ref(critera_list_def_com);
      }
  }();

  onBeforeMount(async () => {
      init_selected_criteria();
      load_table_filters_array();
  });

  function init_selected_criteria() {
      let aggregation_criteria = ntopng_url_manager$1.get_url_entry("aggregation_criteria");
      if (aggregation_criteria == null || aggregation_criteria == "") {
          return;
      }
      selected_criteria.value = criteria_list_def.find((c) => c.param == aggregation_criteria);
  }

  async function update_criteria() {
      ntopng_url_manager$1.set_key_to_url("aggregation_criteria", selected_criteria.value.param);
  }
  const get_extra_params_obj = () => {
      /*let params = get_url_params(active_page, per_page, columns_wrap, map_search, first_get_rows);
        set_params_in_url(params);*/
      let params = get_url_params();
      return params;
  };

  /* ************************************** */

  function reset_filters() {
      filter_table_array.value.forEach((el, index) => {
          /* Getting the currently selected filter */
          ntopng_url_manager$1.set_key_to_url(el.id, ``);
      });
      load_table_filters_array();
      table_aggregated_live_flows.value.refresh_table();
  }

  /* ************************************** */

  function set_filters_list(res) {
      if (!res) {
          filter_table_array.value = filters.value.filter((t) => {
              if (t.show_with_key) {
                  const key = ntopng_url_manager$1.get_url_entry(t.show_with_key);
                  if (key !== t.show_with_value) {
                      return false
                  }
              }
              return true
          });
      } else {
          filters.value = res.map((t) => {
              const key_in_url = ntopng_url_manager$1.get_url_entry(t.name);
              if (key_in_url === null) {
                  ntopng_url_manager$1.set_key_to_url(t.name, ``);
              }
              return {
                  id: t.name,
                  label: t.label,
                  title: t.tooltip,
                  options: t.value,
                  show_with_key: t.show_with_key,
                  show_with_value: t.show_with_value,
              };
          });
          set_filters_list();
          return;
      }
      set_filter_array_label();
  }

  /* ************************************** */

  function set_filter_array_label() {
      filter_table_array.value.forEach((el, index) => {
          /* Setting the basic label */
          if (el.basic_label == null) {
              el.basic_label = el.label;
          }

          /* Getting the currently selected filter */
          const url_entry = ntopng_url_manager$1.get_url_entry(el.id);
          el.options.forEach((option) => {
              if (option.value.toString() === url_entry) {
                  el.current_option = option;
              }
          });
      });
  }

  /* ************************************** */

  function add_table_filter(opt, opt2) {
      ntopng_url_manager$1.set_key_to_url(opt.key, `${opt.value}`);
      if (opt2) {
          ntopng_url_manager$1.set_key_to_url(opt2.key, `${opt2.value}`);
      }
      table_aggregated_live_flows.value.refresh_table();
      load_table_filters_array();
  }

  /* ************************************** */

  async function load_table_filters_array() {
      loading.value = true;
      let extra_params = get_extra_params_obj();
      let url_params = ntopng_url_manager$1.obj_to_url_params(extra_params);
      const url = `${http_prefix}/lua/rest/v2/get/flow/aggregated_live_flows_filters.lua?${url_params}`;
      const res = await ntopng_utility$1.http_request(url);
      set_filters_list(res);
      loading.value = false;
  }

  /* ************************************** */

  function get_url_params() {
      let actual_params = {
          ifid: ntopng_url_manager$1.get_url_entry("ifid") || props.context.ifid,
          vlan_id: ntopng_url_manager$1.get_url_entry("vlan_id")  /* No filter by default */,
          deviceIP: ntopng_url_manager$1.get_url_entry("deviceIP"),
          inIfIdx: ntopng_url_manager$1.get_url_entry("inIfIdx"),
          outIfIdx: ntopng_url_manager$1.get_url_entry("outIfIdx"),
          aggregation_criteria: ntopng_url_manager$1.get_url_entry("aggregation_criteria") || selected_criteria.value.param,
          host: ntopng_url_manager$1.get_url_entry("host") || props.context.host,
      };

      return actual_params;
  }


  const map_config = (config) => {
      config.enable_search = selected_criteria.value.search_enabled == true;
      return config;
  };

  /// methods to get columns config
  const map_table_def_columns = async (columns) => {
      columns = [];
      columns.push(
          {
              sortable: false, title_i18n: 'flows_page.live_flows', name: 'flows_icon', data_field: 'live_flows', class: ['text-center'], responsivePriority: 1, render_func: (data_field, rowData) => {
                  return format_flows_icon(data_field, rowData)
              }
          });

      if (selected_criteria.value.value == 1) {

          // application protocol case
          columns.push(
              {
                  title_i18n: "application_proto", sortable: true, name: 'application', data_field: 'application', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_application_proto_guessed(data_field, rowData)
                      //return `${data_field.label_with_icons}`
                  }
              },
              /*{
                  title_i18n: "application_proto_guessed",sortable: false, name: 'application', data_field: 'is_not_guessed', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_application_proto_guessed(data_field, rowData)
                  }
              }*/
          );
      }
      else if (selected_criteria.value.value == 2) {
          // client case
          columns.push(
              {
                  title_i18n: "client", sortable: true, name: 'client', data_field: 'client', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {

                      return format_client_name(data_field)
                  }
              });
      }
      else if (selected_criteria.value.value == 3) {
          // server case
          columns.push(
              {
                  title_i18n: "last_server", sortable: true, name: 'server', data_field: 'server', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_server_name(data_field, rowData)
                  }
              });
      }
      else if (selected_criteria.value.value == 7) {
          columns.push(
              {
                  title_i18n: "client", sortable: true, name: 'client', data_field: 'client', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_client_name(data_field)
                  }
              }, {
              title_i18n: "last_server", sortable: true, name: 'server', data_field: 'server', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                  return format_server_name(data_field, rowData);
              }
          });
      } else if (selected_criteria.value.value == 8) {
          columns.push(

              {
                  title_i18n: "client", sortable: true, name: 'client', data_field: 'client', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_client_name(data_field)
                  }
              }, {
              title_i18n: "last_server", sortable: true, name: 'server', data_field: 'server', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                  return format_server_name(data_field, rowData);
              }
          },
              {
                  title_i18n: "application_proto", sortable: true, name: 'application', data_field: 'application', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_application_proto_guessed(data_field, rowData);
                      //return `${data_field.label_with_icons}`
                  }
              }
          );
      }
      else if (props.context.is_ntop_enterprise_m) {
          if (selected_criteria.value.value == 4 || selected_criteria.value.value == 7) {
              columns.push(
                  {
                      title_i18n: "client", sortable: true, name: 'client', data_field: 'client', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                          return format_client_name(data_field)
                      }
                  }, {
                  title_i18n: "last_server", sortable: true, name: 'server', data_field: 'server', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                      return format_server_name(data_field, rowData);
                  }
              });
          } else if (selected_criteria.value.value == 5) {
              columns.push(
                  {
                      title_i18n: "client", sortable: true, name: 'client', data_field: 'client', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                          return format_client_name(data_field);
                      }
                  },
                  {
                      title_i18n: "last_server", sortable: true, name: 'server', data_field: 'server', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                          return format_server_name(data_field, rowData);
                      }
                  },
                  {
                      title_i18n: "application_proto", sortable: true, name: 'application', data_field: 'application', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field, rowData) => {
                          return format_application_proto_guessed(data_field, rowData);
                          //return `${data_field.label_with_icons}`
                      }
                  });
          } else if (selected_criteria.value.value == 6) {
              columns.push(
                  {
                      title_i18n: "info", sortable: true, name: 'info', data_field: 'info', class: ['text-nowrap'], responsivePriority: 1, render_func: (data_field) => {

                          return `${data_field.label}`
                      }
                  });
          }
      }

      if (props.context.vlans.length > 2) {
          columns.push({
              title_i18n: "vlan", sortable: true, name: 'vlan_id', data_field: 'vlan_id', class: ['text-nowrap ', 'text-center'], responsivePriority: 1, render_func: (data_field) => {
                  if (data_field.id === 0 || data_field.id == undefined) {
                      const label = i18n('no_vlan');
                      return `<a href="${http_prefix}/lua/flows_stats.lua?vlan=0">${label}</a>`
                  }
                  else {
                      return `<a href="${http_prefix}/lua/flows_stats.lua?vlan=${data_field.id}">${data_field.label}</a>`
                  }
              }
          });
      }
      columns.push({
          title_i18n: "flows", sortable: true, name: 'flows', data_field: 'flows', class: ['text-nowrap ', 'text-center'], responsivePriority: 1
      }, {
          title_i18n: "total_score", sortable: true, name: 'score', data_field: 'tot_score', class: ['text-center'], responsivePriority: 1
      });

      if (selected_criteria.value.value != 2 && selected_criteria.value.value != 4 && selected_criteria.value.value != 7)
          columns.push({ title_i18n: "clients", sortable: true, name: 'num_clients', data_field: 'num_clients', class: ['text-nowrap ', 'text-center'], responsivePriority: 1 });

      if (selected_criteria.value.value != 3 && selected_criteria.value.value != 4 && selected_criteria.value.value != 7)
          columns.push({ title_i18n: "servers", sortable: true, name: 'num_servers', data_field: 'num_servers', class: ['text-nowrap ', 'text-center'], responsivePriority: 1 });

      columns.push({
          title_i18n: "breakdown", sortable: false, name: 'breakdown', data_field: 'breakdown', class: ['text-nowrap', 'text-center'], responsivePriority: 1, render_func: (data_field) => {
              return NtopUtils$1.createBreakdown(data_field.percentage_bytes_sent, data_field.percentage_bytes_rcvd, i18n('sent'), i18n('rcvd'));
          }
      }, {
          title_i18n: "traffic_sent", sortable: true, name: 'bytes_sent', data_field: 'bytes_sent', class: ['text-nowrap', 'text-end'], responsivePriority: 1, render_func: (data_field) => {
              return NtopUtils$1.bytesToSize(data_field);
          }
      }, {
          title_i18n: "traffic_rcvd", sortable: true, name: 'bytes_rcvd', data_field: 'bytes_rcvd', class: ['text-nowrap', 'text-end'], responsivePriority: 1, render_func: (data_field) => {
              return NtopUtils$1.bytesToSize(data_field);
          }
      }, {
          title_i18n: "total_traffic", sortable: true, name: 'tot_traffic', data_field: 'tot_traffic', class: ['text-nowrap', 'text-end'], responsivePriority: 1, render_func: (data_field) => {
              return NtopUtils$1.bytesToSize(data_field);
          }
      });
      return columns;
  };

  const format_client_name = function (data, rowData) {
      let alert_label = '';
      if (data.is_alerted) {
          alert_label = `<i class='fas fa-exclamation-triangle' style='color: #B94A48;'></i>`;
      }

      if (!data.in_memory) {
          return `${data.label} ${alert_label} ${data.extra_labels}`;
      } else {
          return `<a href="${http_prefix}/lua/flows_stats.lua?client=${data.ip}&vlan=${data.vlan_id}">${data.label}</a> ${alert_label} ${data.extra_labels} <a href="${http_prefix}/lua/host_details.lua?host=${data.ip}&vlan=${data.vlan_id}" data-bs-toggle='tooltip' title=''><i class='fas fa-laptop'></i></a>`;
      }
  };

  const format_server_name = function (data, rowData) {
      let alert_label = '';
      if (data.is_alerted) {
          alert_label = `<i class='fas fa-exclamation-triangle' style='color: #B94A48;'></i>`;
      }

      if (!data.in_memory) {
          if ((selected_criteria.value.value == 7 || selected_criteria.value.value == 8) && rowData.srv_port != null) {
              return `${data.label} ${alert_label} ${data.extra_labels}:${rowData.srv_port.label}`;
          } else {
              return `${data.label} ${alert_label} ${data.extra_labels}`;
          }

      } else {
          if ((selected_criteria.value.value == 7 || selected_criteria.value.value == 8) && rowData.srv_port != null) {
              return `<a href="${http_prefix}/lua/flows_stats.lua?server=${data.ip}&vlan=${data.vlan_id}">${data.label}</a> ${alert_label} ${data.extra_labels} <a href="${http_prefix}/lua/host_details.lua?host=${data.ip}&vlan=${data.vlan_id}" data-bs-toggle='tooltip' title=''><i class='fas fa-laptop'></i></a>:<a href="${http_prefix}/lua/flows_stats.lua?port=${rowData.srv_port.id}&vlan=${data.vlan_id}">${rowData.srv_port.label}</a>`;
          } else {
              return `<a href="${http_prefix}/lua/flows_stats.lua?server=${data.ip}&vlan=${data.vlan_id}">${data.label}</a> ${alert_label} ${data.extra_labels} <a href="${http_prefix}/lua/host_details.lua?host=${data.ip}&vlan=${data.vlan_id}" data-bs-toggle='tooltip' title=''><i class='fas fa-laptop'></i></a>`;

          }
      }
  };

  const format_flows_icon = function (data, rowData) {
      let url = ``;
      let add_host = false;
      const exporter = ntopng_url_manager$1.get_url_entry("deviceIP");
      const in_interface = ntopng_url_manager$1.get_url_entry("inIfIdx");
      const out_interface = ntopng_url_manager$1.get_url_entry("outIfIdx");
      
      if (props.context.host != null && props.context.host != "")
          add_host = true;
      if (selected_criteria.value.value == 1) {
          url = `${http_prefix}/lua/flows_stats.lua?application=${rowData.application.id}`;
          if (add_host) url = url + `&host=` + props.context.host;
      }
      else if (selected_criteria.value.value == 2)
          url = `${http_prefix}/lua/flows_stats.lua?client=${rowData.client.ip}&vlan=${rowData.client.vlan_id}`;
      else if (selected_criteria.value.value == 3)
          url = `${http_prefix}/lua/flows_stats.lua?server=${rowData.server.ip}&vlan=${rowData.server.vlan_id}`;
      else if (selected_criteria.value.value == 4)
          url = `${http_prefix}/lua/flows_stats.lua?client=${rowData.client.ip}&server=${rowData.server.ip}&vlan=${rowData.vlan_id.id}`;
      else if (selected_criteria.value.value == 5)
          url = `${http_prefix}/lua/flows_stats.lua?application=${rowData.application.id}&client=${rowData.client.ip}&server=${rowData.server.ip}&vlan=${rowData.vlan_id.id}`;
      else if (selected_criteria.value.value == 6) {
          url = `${http_prefix}/lua/flows_stats.lua?flow_info=${rowData.info.id}`;
          if (add_host) url = url + `&host=` + props.context.host;
      }
      else if (selected_criteria.value.value == 7) {
          url = `${http_prefix}/lua/flows_stats.lua?client=${rowData.client.ip}&server=${rowData.server.ip}&vlan=${rowData.vlan_id.id}&srv_port=${rowData.srv_port.id}`;
      }
      else if (selected_criteria.value.value == 8) {
          url = `${http_prefix}/lua/flows_stats.lua?application=${rowData.application.id}&client=${rowData.client.ip}&server=${rowData.server.ip}&vlan=${rowData.vlan_id.id}&srv_port=${rowData.srv_port.id}`;
      }

      if (!(exporter === "")) {
          url = `${url}&deviceIP=${exporter}`;
      }
      if (!(in_interface === "")) {
          url = `${url}&inIfIdx=${in_interface}`;
      }
      if (!(out_interface === "")) {
          url = `${url}&outIfIdx=${out_interface}`;
      }

      return `<a href=${url} class="btn btn-sm btn-info" ><i class= 'fas fa-stream'></i></a>`
  };

  const format_application_proto_guessed = function (data, rowData) {
      if (rowData.confidence == 0)
          return `${data.label_with_icons} <span class=\"badge bg-warning\" title=\" ` + rowData.confidence_name + `\">` + rowData.confidence_name + ` </span>`
      else if (rowData.confidence)
          return `${data.label_with_icons} <span class=\"badge bg-success\" title=\"` + rowData.confidence_name + ` \"> ` + rowData.confidence_name + `</span>`


  };


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$G, [
      createBaseVNode("div", _hoisted_2$z, [
        createBaseVNode("div", _hoisted_3$y, [
          createBaseVNode("div", _hoisted_4$v, [
            createBaseVNode("div", _hoisted_5$q, [
              createBaseVNode("div", _hoisted_6$i, [
                createBaseVNode("label", _hoisted_7$h, toDisplayString(_i18n('criteria_filter')) + ": ", 1 /* TEXT */),
                createVNode(script$1I, {
                  selected_option: selected_criteria.value,
                  "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_criteria).value = $event)),
                  options: unref(criteria_list),
                  onSelect_option: update_criteria
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]),
            createBaseVNode("div", null, [
              createVNode(script$1w, {
                ref_key: "table_aggregated_live_flows",
                ref: table_aggregated_live_flows,
                csrf: csrf.value,
                table_id: unref(table_id),
                table_config_id: table_config_id.value,
                f_map_columns: map_table_def_columns,
                get_extra_params_obj: get_extra_params_obj,
                f_map_config: map_config
              }, {
                custom_header: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (item) => {
                    return (openBlock(), createElementBlock("div", _hoisted_8$h, [
                      createBaseVNode("span", _hoisted_9$e, [
                        createBaseVNode("b", null, toDisplayString(item["basic_label"]), 1 /* TEXT */)
                      ]),
                      createVNode(script$1I, {
                        selected_option: item['current_option'],
                        "onUpdate:selected_option": $event => ((item['current_option']) = $event),
                        theme: "bootstrap-5",
                        dropdown_size: "small",
                        disabled: loading.value,
                        options: item['options'],
                        onSelect_option: add_table_filter
                      }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "disabled", "options"])
                    ]))
                  }), 256 /* UNKEYED_FRAGMENT */)),
                  createBaseVNode("div", _hoisted_10$d, [
                    createBaseVNode("div", {
                      class: "btn btn-sm btn-primary mt-2 me-3",
                      type: "button",
                      onClick: reset_filters
                    }, toDisplayString(_i18n('reset')), 1 /* TEXT */),
                    createVNode(script$1v, {
                      show: loading.value,
                      size: "1rem",
                      class: "me-1"
                    }, null, 8 /* PROPS */, ["show"])
                  ])
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["csrf", "table_id", "table_config_id"])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$N.__file = "http_src/vue/page-aggregated-live-flows.vue";

  const _hoisted_1$F = { id: "aggregated_live_flows" };


  var script$M = {
    __name: 'page-test-table',
    props: {
      url: String,
      ifid: Number,
      columns_config: Array
  },
    setup(__props) {

  const props = __props;



  const table_config = ref({});
  const table_test = ref(null);

  onBeforeMount(() => {
      set_datatable_config();
  });

  function set_datatable_config() {
      const datatableButton = [];
      
      let params = { 
  	ifid: ntopng_url_manager.get_url_entry("ifid") || props.ifid,	
      };
      let url_params = ntopng_url_manager.obj_to_url_params(params);
      
      datatableButton.push({
  	text: '<i class="fas fa-sync"></i>',
  	className: 'btn-link',
  	action: function (e, dt, node, config) {
              table_test.value.reload();
  	}
      });
      
      let defaultDatatableConfig = {
  	table_buttons: datatableButton,
  	data_url: `${props.url}?${url_params}`,
  	enable_search: true,
      };
      
      defaultDatatableConfig.columns_config = props.columns_config;
      table_config.value = defaultDatatableConfig;
  }
      

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$F, [
      createVNode(script$1g, {
        ref_key: "table_test",
        ref: table_test,
        table_buttons: table_config.value.table_buttons,
        columns_config: table_config.value.columns_config,
        data_url: table_config.value.data_url,
        filter_buttons: table_config.value.table_filters,
        enable_search: table_config.value.enable_search,
        table_config: table_config.value.table_config
      }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "filter_buttons", "enable_search", "table_config"])
    ]))
  }
  }

  };

  script$M.__file = "http_src/vue/page-test-table.vue";

  const _hoisted_1$E = { class: "container-fluid" };
  const _hoisted_2$y = { class: "row form-group mb-3" };
  const _hoisted_3$x = { class: "col col-md-12" };
  const _hoisted_4$u = { class: "form-label" };
  const _hoisted_5$p = { class: "row form-group mb-3" };
  const _hoisted_6$h = { class: "col col-md-6" };
  const _hoisted_7$g = { class: "form-label" };
  const _hoisted_8$g = { class: "col col-md-6" };
  const _hoisted_9$d = { class: "form-label" };
  const _hoisted_10$c = { key: 0 };
  const _hoisted_11$b = { key: 1 };
  const _hoisted_12$b = ["pattern"];
  const _hoisted_13$8 = { class: "row form-group mb-3" };
  const _hoisted_14$8 = { class: "col col-md-6" };
  const _hoisted_15$7 = { class: "form-label" };
  const _hoisted_16$7 = { class: "col col-md-6" };
  const _hoisted_17$6 = { class: "form-label" };
  const _hoisted_18$6 = { key: 0 };
  const _hoisted_19$6 = { key: 1 };
  const _hoisted_20$6 = ["pattern"];
  const _hoisted_21$5 = { class: "row form-group mb-3" };
  const _hoisted_22$5 = { class: "col col-md-12" };
  const _hoisted_23$5 = { class: "form-label" };
  const _hoisted_24$5 = { class: "row form-group mb-3" };
  const _hoisted_25$4 = { class: "col col-md-12" };
  const _hoisted_26$4 = { class: "form-label" };
  const _hoisted_27$4 = ["disabled"];


  var script$L = {
    __name: 'modal-nedge-add-rule-config',
    props: {
  },
    emits: ['edit', 'add'],
    setup(__props, { expose, emit }) {

  const _i18n = (t) => i18n(t);

  const modal_id = ref(null);


  const showed = () => {};



  const title = ref("");

  const type_array = [
      { label: _i18n("nedge.page_rules_config.modal_rule_config.ip"), value: "ip", default: true },
      { label: _i18n("nedge.page_rules_config.modal_rule_config.cidr"), value: "cidr" },
      { label: _i18n("interface"), value: "interface" },
  ];

  let default_direction_value = "source_to_dest";
  const directions = [
      { label: _i18n("nedge.page_rules_config.bidirectional"), value: "bidirectional", bidirectional: true, },
      { label: _i18n("nedge.page_rules_config.source_to_dest"), value: "source_to_dest", bidirectional: false, },
  ];
  const selected_direction = ref({});

  let default_action_value = "accept";
  const actions = [
      { label: _i18n("nedge.page_rules_config.accept"), value: "accept" },
      { label: _i18n("nedge.page_rules_config.deny"), value: "deny" },
  ];
  const selected_action = ref({});

  const rule_id = ref(0);
  const new_rule_id = ref(0);

  const selected_source_type = ref({});
  const source_regex = ref("");
  const source = ref("");

  const selected_dest_type = ref({});
  const dest_regex = ref("");
  const dest = ref("");

  const interface_list_url = `${http_prefix}/lua/rest/v2/get/nedge/interfaces.lua`;
  let interface_list;
  const interface_array = ref([]);

  const selected_source_interface = ref({});
  const selected_dest_interface = ref({});

  const button_text = ref("");

  const is_valid_source = computed$1(() => {
      return is_valid(selected_source_type.value, source.value, source_regex.value);
  });

  const is_valid_dest = computed$1(() => {
      return is_valid(selected_dest_type.value, dest.value, dest_regex.value);
  });

  const show = (row, default_action) => {
      init(row, default_action);
      modal_id.value.show();
  };

  const is_open_in_add = ref(true);

  function init(row, default_action) {
      is_open_in_add.value = row == null;
      if (default_action != null) {
  	default_action_value = default_action.value;
      }
      // check if we need open in edit
      if (is_open_in_add.value == false) {
  	title.value = _i18n("nedge.page_rules_config.modal_rule_config.title_edit");
  	button_text.value = _i18n("edit");
  	selected_source_type.value = type_array.find((s) => s.value == row.source.type);
  	selected_dest_type.value = type_array.find((s) => s.value == row.destination.type);
  	selected_direction.value = directions.find((d) => d.bidirectional == row.bidirectional);
  	selected_action.value = actions.find((a) => a.value == row.action);
  	rule_id.value = row.rule_id;
          new_rule_id.value = row.rule_id;
      } else {
  	title.value = _i18n("nedge.page_rules_config.modal_rule_config.title_add");
  	button_text.value = _i18n("add");
  	let default_type = type_array.find((s) => s.default == true);
  	selected_source_type.value = default_type;
  	selected_dest_type.value = default_type;
  	selected_direction.value = directions.find((d) => d.value == default_direction_value);
  	selected_action.value = actions.find((a) => a.value != default_action_value);
      }
      change_source_type(row);
      change_dest_type(row);
  }

  async function change_source_type(row) {
      let value = null;
      if (row != null) {
  	value = row.source.value;
      }
      if (selected_source_type.value.value == "interface") {
  	await set_interface_array();
  	if (value != null) {
  	    selected_source_interface.value = interface_array.value.find((i) => i.value == value);
  	} else {
  	    selected_source_interface.value = interface_array.value[0];
  	}
      } else {
  	if (row != null) {
  	    source.value = row.source.value;
  	} else {
  	    source.value = "";
  	}
  	set_regex(source_regex, selected_source_type.value.value);
      }    
  }

  async function change_dest_type(row) {
      let value = null;
      if (row != null) {
  	value = row.destination.value;
      }
      if (selected_dest_type.value.value == "interface") {
  	await set_interface_array();
  	if (value != null) {
  	    selected_dest_interface.value = interface_array.value.find((i) => i.value == value);
  	} else {
  	    selected_dest_interface.value = interface_array.value[0];
  	}
      } else {
  	if (row != null) {
  	    dest.value = row.destination.value;
  	} else {
  	    dest.value = "";
  	}
  	set_regex(dest_regex, selected_dest_type.value.value);
      }
  }

  function is_valid(selected_type, text, rg_text) {
      if (selected_type.value == "interface") {
  	return true;
      }
      let regex = new RegExp(rg_text);
      return regex.test(text);
  }

  let is_set_interface_array = false;
  async function set_interface_array() {
      if (is_set_interface_array == true) { return; }
  	if (interface_list == null) {
  	    interface_list = ntopng_utility$1.http_request(interface_list_url);
  	}
  	let res_interface_list = await interface_list;
  	interface_array.value = res_interface_list.filter((i) => i.role == "lan").map((i) => {
  	    return {
  		label: i.label,
  		value: i.ifname,
  	    };
  	});
      is_set_interface_array = true;
  }

  function set_regex(rg, type) {
      rg.value = regexValidation.get_data_pattern(type);
  }

  const apply = () => {
      let src_type = selected_source_type.value.value;    
      let src_value = source.value;
      if (src_type == "interface") {
  	src_value = selected_source_interface.value.value;
      }
      let dst_type = selected_dest_type.value.value;    
      let dst_value = dest.value;
      if (dst_type == "interface") {
  	dst_value = selected_dest_interface.value.value;
      }
      let policy = selected_action.value.value;
      let bidirectional = selected_direction.value.value == "bidirectional";
      let obj = {
  	src_type,
  	src_value,
  	dst_type,
  	dst_value,
  	policy,
  	bidirectional,
      };
      let event = "add";
      if (is_open_in_add.value == false) {
  	obj.rule_id = rule_id.value;
  	obj.new_rule_id = new_rule_id.value;
  	event = "edit";
      }
      
      emit(event, obj);
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[12] || (_cache[12] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$E, [
          createCommentVNode(" Rule ID "),
          withDirectives(createBaseVNode("div", _hoisted_2$y, [
            createBaseVNode("div", _hoisted_3$x, [
              createBaseVNode("label", _hoisted_4$u, toDisplayString(_i18n("nedge.page_rules_config.rule_id")), 1 /* TEXT */),
              withDirectives(createBaseVNode("input", {
                type: "text",
                class: "form-control",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((new_rule_id).value = $event))
              }, null, 512 /* NEED_PATCH */), [
                [vModelText, new_rule_id.value]
              ]),
              withDirectives(createBaseVNode("input", {
                type: "hidden",
                class: "form-control",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((rule_id).value = $event))
              }, null, 512 /* NEED_PATCH */), [
                [vModelText, rule_id.value]
              ])
            ])
          ], 512 /* NEED_PATCH */), [
            [vShow, !is_open_in_add.value]
          ]),
          createCommentVNode(" Source "),
          createBaseVNode("div", _hoisted_5$p, [
            createBaseVNode("div", _hoisted_6$h, [
              createBaseVNode("label", _hoisted_7$g, toDisplayString(_i18n("nedge.page_rules_config.modal_rule_config.source_type")), 1 /* TEXT */),
              createVNode(script$1I, {
                selected_option: selected_source_type.value,
                "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_source_type).value = $event)),
                onSelect_option: _cache[3] || (_cache[3] = $event => (change_source_type())),
                options: type_array
              }, null, 8 /* PROPS */, ["selected_option"])
            ]),
            createBaseVNode("div", _hoisted_8$g, [
              createBaseVNode("label", _hoisted_9$d, toDisplayString(_i18n("nedge.page_rules_config.source")), 1 /* TEXT */),
              (selected_source_type.value.value == 'interface')
                ? (openBlock(), createElementBlock("div", _hoisted_10$c, [
                    createVNode(script$1I, {
                      selected_option: selected_source_interface.value,
                      "onUpdate:selected_option": _cache[4] || (_cache[4] = $event => ((selected_source_interface).value = $event)),
                      options: interface_array.value
                    }, null, 8 /* PROPS */, ["selected_option", "options"])
                  ]))
                : (openBlock(), createElementBlock("div", _hoisted_11$b, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      pattern: source_regex.value,
                      "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((source).value = $event))
                    }, null, 8 /* PROPS */, _hoisted_12$b), [
                      [vModelText, source.value]
                    ])
                  ]))
            ])
          ]),
          createCommentVNode(" Dest "),
          createBaseVNode("div", _hoisted_13$8, [
            createBaseVNode("div", _hoisted_14$8, [
              createBaseVNode("label", _hoisted_15$7, toDisplayString(_i18n("nedge.page_rules_config.modal_rule_config.dest_type")), 1 /* TEXT */),
              createVNode(script$1I, {
                selected_option: selected_dest_type.value,
                "onUpdate:selected_option": _cache[6] || (_cache[6] = $event => ((selected_dest_type).value = $event)),
                onSelect_option: _cache[7] || (_cache[7] = $event => (change_dest_type())),
                options: type_array
              }, null, 8 /* PROPS */, ["selected_option"])
            ]),
            createBaseVNode("div", _hoisted_16$7, [
              createBaseVNode("label", _hoisted_17$6, toDisplayString(_i18n("nedge.page_rules_config.dest")), 1 /* TEXT */),
              (selected_dest_type.value.value == 'interface')
                ? (openBlock(), createElementBlock("div", _hoisted_18$6, [
                    createVNode(script$1I, {
                      selected_option: selected_dest_interface.value,
                      "onUpdate:selected_option": _cache[8] || (_cache[8] = $event => ((selected_dest_interface).value = $event)),
                      options: interface_array.value
                    }, null, 8 /* PROPS */, ["selected_option", "options"])
                  ]))
                : (openBlock(), createElementBlock("div", _hoisted_19$6, [
                    withDirectives(createBaseVNode("input", {
                      type: "text",
                      class: "form-control",
                      pattern: dest_regex.value,
                      "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => ((dest).value = $event))
                    }, null, 8 /* PROPS */, _hoisted_20$6), [
                      [vModelText, dest.value]
                    ])
                  ]))
            ])
          ]),
          createCommentVNode(" Direction "),
          createBaseVNode("div", _hoisted_21$5, [
            createBaseVNode("div", _hoisted_22$5, [
              createBaseVNode("label", _hoisted_23$5, toDisplayString(_i18n("nedge.page_rules_config.direction")), 1 /* TEXT */),
              createVNode(script$1I, {
                selected_option: selected_direction.value,
                "onUpdate:selected_option": _cache[10] || (_cache[10] = $event => ((selected_direction).value = $event)),
                options: directions
              }, null, 8 /* PROPS */, ["selected_option"])
            ])
          ]),
          createCommentVNode(" Action "),
          createBaseVNode("div", _hoisted_24$5, [
            createBaseVNode("div", _hoisted_25$4, [
              createBaseVNode("label", _hoisted_26$4, toDisplayString(_i18n("nedge.page_rules_config.action")), 1 /* TEXT */),
              createVNode(script$1I, {
                selected_option: selected_action.value,
                "onUpdate:selected_option": _cache[11] || (_cache[11] = $event => ((selected_action).value = $event)),
                options: actions
              }, null, 8 /* PROPS */, ["selected_option"])
            ])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          disabled: !unref(is_valid_source) || !unref(is_valid_dest),
          onClick: apply,
          class: "btn btn-primary"
        }, toDisplayString(button_text.value), 9 /* TEXT, PROPS */, _hoisted_27$4)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$9 = "\ninput[data-v-50692d68]:invalid {\n  border-color: #ff0000;\n}\n";
  styleInject(css_248z$9);

  script$L.__scopeId = "data-v-50692d68";
  script$L.__file = "http_src/vue/modal-nedge-add-rule-config.vue";

  const _hoisted_1$D = { class: "container-fluid" };
  const _hoisted_2$x = { class: "row form-group mb-3" };
  const _hoisted_3$w = { class: "col col-md-12" };
  const _hoisted_4$t = { class: "form-label" };


  var script$K = {
    __name: 'modal-nedge-change-default-policy',
    emits: ['apply'],
    setup(__props, { expose, emit }) {



  const modal_id = ref(null);

  const _i18n = (t) => i18n(t);

  const title = _i18n("nedge.page_rules_config.modal_change_default_policy.title");
  const actions = [
      { label: _i18n("nedge.page_rules_config.accept"), value: "accept" },
      { label: _i18n("nedge.page_rules_config.deny"), value: "deny" },
  ];
  const selected_action = ref({});

  const showed = () => {
  };

  const show = (policy) => {
      selected_action.value = actions.find((a) => a.value == policy.value);
      modal_id.value.show();
  };

  const close = () => {
      modal_id.value.close();
  };

  function apply() {
      emit('apply', selected_action.value.value);
      close();
  }

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[1] || (_cache[1] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$D, [
          createCommentVNode(" Default Policy "),
          createBaseVNode("div", _hoisted_2$x, [
            createBaseVNode("div", _hoisted_3$w, [
              createBaseVNode("label", _hoisted_4$t, toDisplayString(_i18n("nedge.page_rules_config.default policy")), 1 /* TEXT */),
              createVNode(script$1I, {
                selected_option: selected_action.value,
                "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_action).value = $event)),
                options: actions
              }, null, 8 /* PROPS */, ["selected_option"])
            ])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: apply,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('apply')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$K.__file = "http_src/vue/modal-nedge-change-default-policy.vue";

  const _hoisted_1$C = { class: "mb-2" };
  const _hoisted_2$w = /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */);
  const _hoisted_3$v = { class: "d-inline-block" };
  const _hoisted_4$s = {
    key: 0,
    style: {"color":"green"}
  };
  const _hoisted_5$o = {
    key: 1,
    style: {"color":"red"}
  };
  const _hoisted_6$g = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-cog" }, null, -1 /* HOISTED */);
  const _hoisted_7$f = [
    _hoisted_6$g
  ];
  const _hoisted_8$f = { id: "aggregated_live_flows" };


  var script$J = {
    __name: 'page-nedge-rules-config',
    props: {
      url: String,
      ifid: Number,
      csrf: String,
      columns_config: Array
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const timeout_delete = 1 * 500;



  const table_config = ref({});
  const table_rules = ref(null);
  const modal_add_rule_config = ref(null);
  const modal_change_default_policy = ref(null);
  const default_policy = ref({});

  onBeforeMount(async () => {
      set_datatable_config();
      load_default_policy();
  });

  function edit_rule(rule) {    
      const edit_url = `${http_prefix}/lua/rest/v2/edit/nedge/policy/rule.lua`;
      set_rule(rule, edit_url);
  }

  function add_rule(rule) {
      const add_url = `${http_prefix}/lua/rest/v2/add/nedge/policy/rule.lua`;
      set_rule(rule, add_url);
  }

  async function load_default_policy(policy) {
      if (policy == null) {
  	const get_policy_url = `${http_prefix}/lua/rest/v2/get/nedge/policy/default.lua`;
  	let policy_res = await ntopng_utility$1.http_request(get_policy_url);
  	policy = policy_res.default_policy;
      }
      if (policy == "accept") {
  	default_policy.value = {
  	    value: policy,
  	    label: _i18n("nedge.page_rules_config.accept"),
  	};
      } else {
  	default_policy.value = {
  	    value: policy,
  	    label: _i18n("nedge.page_rules_config.deny"),
  	};    
      }
  }

  async function set_default_policy(policy) {
      const set_policy_url = `${http_prefix}/lua/rest/v2/set/nedge/policy/default.lua`;
      let headers = {
          'Content-Type': 'application/json'
      };
      let body = JSON.stringify({ default_policy: policy, csrf: props.csrf});
      await ntopng_utility$1.http_request(set_policy_url, { method: "post", headers, body});
      load_default_policy(policy);
      refresh_table();    
  }

  function set_rule(rule, url) {
      let headers = {
          'Content-Type': 'application/json'
      };
      let body = JSON.stringify({ ...rule, csrf: props.csrf});
      
      ntopng_utility$1.http_request(url, { method: "post", headers, body});
      refresh_table();    
  }

  function show_modal_change_policy() {    
      modal_change_default_policy.value.show(default_policy.value);
  }

  function set_datatable_config() {
      const datatableButton = [];
      
      let params = { 
  	ifid: ntopng_url_manager$1.get_url_entry("ifid") || props.ifid,	
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params);
      
      datatableButton.push({
  	text: '<i class="fas fa-sync"></i>',
  	className: 'btn-link',
  	action: function (e, dt, node, config) {
  	    refresh_table();
              // table_rules.value.reload();
  	}
      }, {
  	text: '<i class="fas fa-plus"></i>',
  	className: 'btn-link',
  	action: function () {
  	    modal_add_rule_config.value.show(null, default_policy.value);
  	}
      });
      
      let defaultDatatableConfig = {
  	table_buttons: datatableButton,
  	data_url: `${props.url}?${url_params}`,
  	enable_search: false,
      };
      
      let columns = [
  	{ 
  	    columnName: _i18n("nedge.page_rules_config.rule_id"), targets: 0, name: 'rule_id', data: 'rule_id', className: 'text-nowrap text-center', responsivePriority: 1
  	}, { 
  	    columnName: _i18n("nedge.page_rules_config.source"), targets: 0, name: 'source', data: 'source', className: 'text-nowrap text-center', responsivePriority: 1, render: function(value, type, rowData) {
  		if (value.label != null && value.label != "") {
  		    return value.label;
  		} 
  		return value.value;
  	    }
  	}, { 
  	    columnName: _i18n("nedge.page_rules_config.dest"), targets: 0, name: 'dest', data: 'destination', className: 'text-nowrap text-center', responsivePriority: 1, render: function(value, type, rowData) {
  		if (value.label != null && value.label != "") {
  		    return value.label;
  		} 
  		return value.value;
  	    }
  	}, { 
  	    columnName: _i18n("nedge.page_rules_config.direction"), targets: 0, name: 'bidirectional', data: 'bidirectional', className: 'text-nowrap text-center', responsivePriority: 1, render: function(value, type, rowData) {
  		if (value == true) {
  		    return _i18n("nedge.page_rules_config.bidirectional");
  		} 
  		return _i18n("nedge.page_rules_config.source_to_dest");
  	    }
  	}, { 
  	    columnName: _i18n("nedge.page_rules_config.action"), targets: 0, name: 'action', data: 'action', className: 'text-nowrap text-center', responsivePriority: 1, render: function(value, type, rowData) {
  		let color = "red";
  		let name = _i18n(`nedge.page_rules_config.deny`);
  		if (value == "accept") {
  		    color = "green";
  		    name =  _i18n(`nedge.page_rules_config.accept`);
  		}
  		return `<span style="color:${color};">${name}</span>`;
  	    }
  	}
      ];
      let wrap_columns_config = columns.map((c) => c);
      // let wrap_columns_config = props.columns_config.map((c) => c);
      wrap_columns_config.push({ columnName: _i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) } });
      
      defaultDatatableConfig.columns_config = wrap_columns_config;
      table_config.value = defaultDatatableConfig;
  }

  const add_action_column = function (rowData) {
      let delete_handler = {
  	handlerId: "delete_host",	  
  	onClick: () => {
  	    delete_rule(rowData);
  	},
      };
      
      let edit_handler = {
  	handlerId: "edit_rule",
  	onClick: () => {
  	    modal_add_rule_config.value.show(rowData);
  	},
      };
      
      return DataTableUtils.createActionButtons([
  	{ class: `btn-secondary`, handler: edit_handler, handlerId: "edit_rule", icon: 'fa-edit', title: i18n('edit') },
  	{ class: `btn-danger`, handler: delete_handler, handlerId: "delete_rule", icon: 'fa-trash', title: i18n('delete') },
      ]);
  };

  async function delete_rule(rule) {
      const add_url = `${http_prefix}/lua/rest/v2/delete/nedge/policy/rule.lua`;
      let headers = {
          'Content-Type': 'application/json'
      };
      let body = JSON.stringify({ rule_id: rule.rule_id, csrf: props.csrf});
      
      ntopng_utility$1.http_request(add_url, { method: "post", headers, body});
      refresh_table();    
  }

  function refresh_table() {
      setTimeout(() => {
  	ntopng_url_manager$1.reload_url();
   	// table_rules.value.reload();
      }, timeout_delete);
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$C, [
        createBaseVNode("h2", null, toDisplayString(_i18n("nedge.rules_config_title")), 1 /* TEXT */),
        _hoisted_2$w,
        createBaseVNode("h5", _hoisted_3$v, [
          createTextVNode(toDisplayString(_i18n("nedge.page_rules_config.default policy")) + " ", 1 /* TEXT */),
          (default_policy.value?.value == 'accept')
            ? (openBlock(), createElementBlock("span", _hoisted_4$s, toDisplayString(default_policy.value?.label), 1 /* TEXT */))
            : createCommentVNode("v-if", true),
          (default_policy.value?.value == 'deny')
            ? (openBlock(), createElementBlock("span", _hoisted_5$o, toDisplayString(default_policy.value?.label), 1 /* TEXT */))
            : createCommentVNode("v-if", true),
          createBaseVNode("small", null, [
            createBaseVNode("a", {
              href: "javascript:void(0)",
              style: {"margin-left":"0.5rem"},
              onClick: show_modal_change_policy
            }, _hoisted_7$f)
          ])
        ])
      ]),
      createBaseVNode("div", _hoisted_8$f, [
        createVNode(script$1g, {
          ref_key: "table_rules",
          ref: table_rules,
          table_buttons: table_config.value.table_buttons,
          columns_config: table_config.value.columns_config,
          data_url: table_config.value.data_url,
          filter_buttons: table_config.value.table_filters,
          enable_search: table_config.value.enable_search,
          table_config: table_config.value.table_config
        }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "filter_buttons", "enable_search", "table_config"])
      ]),
      createVNode(script$L, {
        ref_key: "modal_add_rule_config",
        ref: modal_add_rule_config,
        onAdd: add_rule,
        onEdit: edit_rule
      }, null, 512 /* NEED_PATCH */),
      createVNode(script$K, {
        ref_key: "modal_change_default_policy",
        ref: modal_change_default_policy,
        onApply: set_default_policy
      }, null, 512 /* NEED_PATCH */)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$J.__file = "http_src/vue/page-nedge-rules-config.vue";

  const _hoisted_1$B = {
    key: 0,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_2$v = { class: "col-form-label col-sm-4" };
  const _hoisted_3$u = { class: "col-8" };
  const _hoisted_4$r = {
    key: 1,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_5$n = { class: "col-form-label col-sm-4" };
  const _hoisted_6$f = { class: "col-8" };
  const _hoisted_7$e = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_8$e = { class: "col-form-label col-sm-4" };
  const _hoisted_9$c = { class: "col-8" };
  const _hoisted_10$b = ["placeholder"];
  const _hoisted_11$a = ["disabled"];
  const _hoisted_12$a = ["disabled"];


  var script$I = {
    __name: 'modal-add-application',
    props: {
    page_csrf: String,
    ifid: String,
  },
    emits: ['add'],
    setup(__props, { expose, emit }) {

  const modal_id = ref(null);

  const is_edit_page = ref(false);
  const _i18n = (t) => i18n(t);
  const disable_add = ref(true);
  let title = ref(i18n('add_application'));
  const comment = ref(i18n('details.custom_rules_placeholder'));
  const selected_category = ref({});
  const category_list = ref([]);
  const custom_rules = ref('');
  const application_name = ref('');
  const application_id = ref(null);

  ref({});

  const note_list = [
    _i18n("custom_categories.each_host_separate_line"),
    _i18n("custom_categories.allowed_rules"),
    _i18n("custom_categories.ip_address"),
    _i18n("custom_categories.ip_address_port"),
    _i18n("custom_categories.port"),
    _i18n("custom_categories.port_range"),
    _i18n("custom_categories.host_domain")
  ];

  const showed = () => { };



  function reset_modal_form() {
    application_name.value = '';
    selected_category.value = category_list.value[0];
    custom_rules.value = '';
  }

  const check_validation = () => {
    if (check_application_name() == true && check_custom_rules() == true)
      disable_add.value = false;
    else
      disable_add.value = true;
  };

  const check_application_name = () => {
    return (/^[A-Za-z0-9_-]*$/.test(application_name.value));
  };

  const check_custom_rules = () => {
    let check = true;

    let rules = custom_rules.value.split("\n");
    rules.forEach((rule) => {
      check = check && (/* tcp:1100 */(/^((tcp|udp):(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3}))$/.test(rule)) ||
                        /* tcp:1000-1002*/(/^((tcp|udp):(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3})-(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3}))$/.test(rule)) ||
  //                      (/^((?!.* ).*)$/.test(rule)) ||
                        /* ip:1.1.1.1 */(/^(ip):(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(rule)) ||
                        /* ip:1.1.1.1:1010 */(/^(ip):(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):(6553[0-5]|655[0-2][0-9]\d|65[0-4](\d){2}|6[0-4](\d){3}|[1-5](\d){4}|[1-9](\d){0,3})$/.test(rule)) ||
                        /* host:google */(/^((host):[a-zA-Z0-9]+)$/.test(rule)) ||
                        /* host:google.com */(/(host):[a-zA-Z0-9].[a-zA-Z]/g.test(rule)) ||
                        /* Empty string */rule === '');
    });

    return check
  };

  const populate_modal_form = (row) => {
    let edit_row_category = null;
    category_list.value.forEach((item) => {
      if(item.id == row.category_id) {
        edit_row_category = item;
      }
    });

    selected_category.value = edit_row_category;
    custom_rules.value = row.custom_rules?.replace(',', '\n');
  };

  const show = (row) => {
    reset_modal_form();
    is_edit_page.value = false;
    title.value = i18n('add_application');

    if (row != null) {
      application_id.value = row.application_id;
      application_name.value = row.application;
      is_edit_page.value = true;
      title.value = `${i18n('edit_application')}: ${application_name.value}`;
      populate_modal_form(row);
    }
    modal_id.value.show();
    check_validation();
  };

  const add_ = () => {
    emit('add', {
      l7_proto_id: application_id.value,
      protocol_alias: application_name.value,
      category: selected_category.value.id,
      custom_rules: custom_rules.value,
      is_edit_page: is_edit_page.value,
    });

    close();
  };

  const close = () => {
    modal_id.value.close();
  };

  const format_category_list = (list) => {
    let formatted_list = [];
    list.forEach((item) => {
      formatted_list.push({
        id: item.cat_id,
        label: item.name,
        app_list: item.app_list

      });
    });

    // sort formatted categories;
    formatted_list = formatted_list.sort((a, b) => {
  		    if (a == null || a.label == null) { return -1; }
  		    if (b == null || b.label == null) { return 1; }
  		    return a.label.toString().localeCompare(b.label.toString());
    });

    return formatted_list;
  };

  const loadCategoryList = (list) => {
    category_list.value = format_category_list(list);
  };

  onBeforeMount(() => { });

  expose({ show, close, loadCategoryList });



  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[4] || (_cache[4] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        withDirectives(createBaseVNode("input", {
          class: "form-control",
          type: "text",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((application_id).value = $event)),
          spellcheck: "false",
          hidden: ""
        }, null, 512 /* NEED_PATCH */), [
          [vModelText, application_id.value]
        ]),
        (is_edit_page.value == false)
          ? (openBlock(), createElementBlock("div", _hoisted_1$B, [
              createBaseVNode("label", _hoisted_2$v, [
                createBaseVNode("b", null, toDisplayString(_i18n("app_name")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_3$u, [
                withDirectives(createBaseVNode("input", {
                  class: "form-control",
                  type: "text",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((application_name).value = $event)),
                  onInput: check_validation,
                  spellcheck: "false"
                }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                  [vModelText, application_name.value]
                ])
              ])
            ]))
          : (openBlock(), createElementBlock("div", _hoisted_4$r, [
              createBaseVNode("label", _hoisted_5$n, [
                createBaseVNode("b", null, toDisplayString(_i18n("category")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_6$f, [
                createVNode(script$1I, {
                  selected_option: selected_category.value,
                  "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_category).value = $event)),
                  options: category_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ])),
        createBaseVNode("div", _hoisted_7$e, [
          createBaseVNode("label", _hoisted_8$e, [
            createBaseVNode("b", null, toDisplayString(_i18n("category_custom_rule")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_9$c, [
            withDirectives(createBaseVNode("textarea", {
              class: "form-control",
              onInput: check_validation,
              placeholder: comment.value,
              rows: "6",
              "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((custom_rules).value = $event)),
              spellcheck: "false"
            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_10$b), [
              [vModelText, custom_rules.value]
            ])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createVNode(script$1u, { note_list: note_list }),
        (is_edit_page.value == false)
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: add_,
              class: "btn btn-primary",
              disabled: disable_add.value
            }, toDisplayString(_i18n('add')), 9 /* TEXT, PROPS */, _hoisted_11$a))
          : (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              onClick: add_,
              class: "btn btn-primary",
              disabled: disable_add.value
            }, toDisplayString(_i18n('apply')), 9 /* TEXT, PROPS */, _hoisted_12$a))
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$I.__file = "http_src/vue/modal-add-application.vue";

  var script$H = {
    __name: 'modal-delete-application',
    emits: ['remove'],
    setup(__props, { expose, emit }) {

  const modal_id = ref(null);

  const _i18n = (t) => i18n(t);
  const application_name = ref(null);

  let title = ref(i18n('custom_categories.delete_app'));
  const body = i18n('custom_categories.delete_app_confirm');

  const show = (row) => {
    if(row != null) {
      application_name.value = row.application;
      title.value = `${i18n('custom_categories.delete_app')}: ${application_name.value}`;
    }
    modal_id.value.show();
  };

  const _remove = () => {
    emit('remove', { 
      protocol_alias: application_name.value,
    });
      
    close();
  };

  const close = () => {
    modal_id.value.close();
  };

  expose({ show, close });



  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(unref(body)), 1 /* TEXT */)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: _remove,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('delete')), 1 /* TEXT */)
      ]),
      default: withCtx(() => [
        withDirectives(createBaseVNode("input", {
          class: "form-control",
          type: "text",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((application_name).value = $event)),
          spellcheck: "false",
          hidden: ""
        }, null, 512 /* NEED_PATCH */), [
          [vModelText, application_name.value]
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$H.__file = "http_src/vue/modal-delete-application.vue";

  const _hoisted_1$A = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);


  var script$G = {
    __name: 'page-edit-applications',
    props: {
    page_csrf: String,
    ifid: String,
    has_protos_file: Boolean,
  },
    setup(__props) {

  const props = __props;

  const applications_table = ref(null);
  const modal_delete_application = ref(null);
  const modal_add_application = ref(null);
  const config_applications_table = ref({});
  const category_list = ref([]);
  const update_message = ref(null);
  const hidden = ref(true);
  let message = '';

  const category_list_url = `${http_prefix}/lua/rest/v2/get/l7/category/consts.lua`;
  const add_application_url = `${http_prefix}/lua/rest/v2/edit/application/application.lua`;
  const delete_application_url = `${http_prefix}/lua/rest/v2/delete/application/application.lua`;

  const _i18n = (t) => i18n(t);


  const _remove = async (params) => {  
    const url_params = {
      csrf: props.page_csrf,
      ifid: props.ifid
    };

    const url = NtopUtils.buildURL(delete_application_url, {
      ...url_params,
      ...params
    });

    await $.get(url, function(rsp, status){
      show_message(i18n('custom_categories.succesfully_removed'));
    });

    reload_table();
  };

  const open_delete_modal = (row) => {
    modal_delete_application.value.show(row);
  };

  const _add = async (params) => {
    const is_edit_page = params.is_edit_page;
    params.is_edit_page = null;

    const url_params = {
      csrf: props.page_csrf,
      ifid: props.ifid
    };

    const url = NtopUtils.buildURL(add_application_url, {
      ...url_params,
      ...params
    });
    
    await $.get(url, function(rsp, status){
      if(status == 'success') {
        if(is_edit_page)
          show_message(i18n('custom_categories.succesfully_edited'));
        else
          show_message(i18n('custom_categories.succesfully_added'));
      }
    });

    reload_table();
  };

  const open_add_modal = (row) => {
    modal_add_application.value.show(row);
  };

  const show_message = (_message) => {
    message = _message;
    hidden.value = false;
    setTimeout(() => {
      hidden.value = true;
      reload_table();
    }, 4000);
  };

  const destroy = () => {
    applications_table.value.destroy_table();
  };

  const reload_table = () => {
    applications_table.value.reload();
  };

  const load_categories = async () => {
    await $.get(category_list_url, function(rsp, status){
      category_list.value = rsp.rsp;
    });
    modal_add_application.value.loadCategoryList(category_list.value);
  };

  const search = (filter_app) => {
    applications_table.value.search_value(filter_app);
  };
      
  onBeforeMount(async () => {
    start_datatable();
  });

  onMounted(async () => {
    await load_categories();
    const filter_app = ntopng_url_manager.get_url_entry("application");
    if(filter_app) {
      search(filter_app);
    }
  });

  onUnmounted(async () => {
    destroy();
  });


  const add_action_column = function (rowData) {
    let edit_handler = {
      handlerId: "edit_rule",
      onClick: () => {
        open_add_modal(rowData);
      },
    };

    const actions = [
      { class: `pointer`, handler: edit_handler, icon: 'fa-edit', title: i18n('edit') },
    ];

    if(rowData.is_custom) {
      let delete_handler = {
        handlerId: "delete_rule",
        onClick: () => {
          open_delete_modal(rowData);
        },
      };
    
      actions.push(    
        { class: `pointer`, handler: delete_handler, icon: 'fa-trash', title: i18n('delete') },
      );
    }
    return DataTableUtils.createActionButtons(actions);
  };

  function start_datatable() {
    const datatableButton = [];

    if(props.has_protos_file) {
      datatableButton.push({
        text: '<i class="fas fa-plus"></i>',
        className: 'btn-link',
        action: function () {
          open_add_modal();
        }
      });
    }

    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function () {
        reload_table();
      }
    });
      
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils.buildURL(`${http_prefix}/lua/rest/v2/get/ntopng/applications.lua`, { ifid: props.ifid }),
      enable_search: true,
      table_config: { 
        serverSide: false, 
        order: [[ 0 /* application column */, 'asc' ]],
      }
    };
    
    /* Applications table configuration */  

    let columns = [
      { columnName: i18n("application"), name: 'application', data: 'application', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("category"), name: 'category', data: 'category', className: 'text-nowrap', responsivePriority: 1, render: function (data, type, rowData) { return data } },
      { columnName: i18n("custom_categories.custom_hosts"), name: 'custom_rules', data: 'custom_rules', className: 'text-nowrap', responsivePriority: 2 },
      { visible: false, name: 'application_hosts', data: 'application_hosts' },
      { visible: false, name: 'application_id', data: 'application_id' },
      { visible: false, name: 'category_id', data: 'category_id' },
      { columnName: _i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) } }
    ];

    let trafficConfig = ntopng_utility.clone(defaultDatatableConfig);
    trafficConfig.columns_config = columns;
    config_applications_table.value = trafficConfig;
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      _hoisted_1$A,
      withDirectives(createBaseVNode("div", {
        ref_key: "update_message",
        ref: update_message,
        class: "alert alert-info"
      }, toDisplayString(unref(message)), 513 /* TEXT, NEED_PATCH */), [
        [vShow, !hidden.value]
      ]),
      createVNode(script$I, {
        ref_key: "modal_add_application",
        ref: modal_add_application,
        category_list: category_list.value,
        page_csrf: __props.page_csrf,
        ifid: __props.ifid,
        onAdd: _add
      }, null, 8 /* PROPS */, ["category_list", "page_csrf", "ifid"]),
      createVNode(script$H, {
        ref_key: "modal_delete_application",
        ref: modal_delete_application,
        onRemove: _remove
      }, null, 512 /* NEED_PATCH */),
      createVNode(script$1g, {
        ref_key: "applications_table",
        ref: applications_table,
        table_buttons: config_applications_table.value.table_buttons,
        columns_config: config_applications_table.value.columns_config,
        data_url: config_applications_table.value.data_url,
        enable_search: config_applications_table.value.enable_search,
        table_config: config_applications_table.value.table_config
      }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$G.__file = "http_src/vue/page-edit-applications.vue";

  const _hoisted_1$z = { class: "row" };
  const _hoisted_2$u = { class: "col-12" };
  const _hoisted_3$t = { class: "card card-shadow" };
  const _hoisted_4$q = { class: "card-body" };
  const _hoisted_5$m = {
    key: 0,
    class: "alert alert-danger",
    role: "alert",
    id: "error-alert"
  };
  const _hoisted_6$e = {
    key: 2,
    class: "alert alert-info alert-dismissable"
  };
  const _hoisted_7$d = /*#__PURE__*/createBaseVNode("span", { class: "spinner-border spinner-border-sm text-info" }, null, -1 /* HOISTED */);
  const _hoisted_8$d = ["innerHTML"];
  const _hoisted_9$b = ["innerHTML"];


  var script$F = {
    __name: 'page-network-discovery',
    props: {
    ifid: String,
  },
    setup(__props) {

  const props = __props;

  const error = ref(false);
  const error_message = i18n("map_page.fetch_error");
  const discovery_requested = ref(false);
  const network_discovery_table = ref(null);
  const config_network_discovery = ref({});
  const progress_message = ref(null);
  const last_network_discovery = ref('');
  const discovery_requested_message = i18n('discover.network_discovery_not_enabled');
  const loading = ref(false);


  const ghost_message = i18n("discover.ghost_icon_descr");
  const too_many_devices_message = i18n("discover.too_many_devices_descr");
  const ghost_message_added = ref(false);

  let timeout_id;

  const note_list = [
    i18n("discover.discovery_running"),
    i18n("discover.protocols_note")
  ];

  const discovery_url = `${http_prefix}/lua/get_discover_progress.lua`;
  const network_discovery_data = `${http_prefix}/lua/rest/v2/get/network/discovery/discover.lua`;
  const run_network_discovery = `${http_prefix}/lua/rest/v2/get/network/discovery/run_discovery.lua`;

  /*  This function add notes to the pages, like adding notes 
   *  to note_list or last network discovery note 
   */
  const add_notes = (rsp) => {
    if(rsp.ghost_found == true
        && ghost_message_added.value == false) {
      note_list.unshift(ghost_message);
      ghost_message_added.value = true;
    }
    if(rsp.too_many_devices_message == true
        && too_many_devices_message.value == false) {
      note_list.unshift(too_many_devices_message);
      too_many_devices_message.value = true;
    }
    if(rsp.ghost_found == false
        && ghost_message_added.value == false) {
      note_list.shift();
      ghost_message_added.value = false;
    }
    if(rsp.too_many_devices_message == false
        && too_many_devices_message.value == true) {
      note_list.shift();
      too_many_devices_message.value = false;
    }

    last_network_discovery.value = rsp.last_network_discovery;
  };

  /*  This function handle the discovery, asking the backend if  
   *  a new discovery was requested or not and in case updates the notes
   *  and the various messages
   */
  const checkDiscovery = async function() {
    loading.value = false;
    await $.get(NtopUtils.buildURL(discovery_url, { ifid: props.ifid }), function(rsp, status){
      if(rsp.rsp.discovery_requested == true) {
        discovery_requested.value = true;
        if(rsp.rsp.progress != "") {
          progress_message.value = rsp.rsp.progress;
        }
      } else {
        discovery_requested.value = false;
        progress_message.value = '';
        clearInterval(timeout_id);
      }
      add_notes(rsp.rsp);
    });
  };

  const destroy = () => {
    network_discovery_table.value.destroy_table();
  };

  const reload_table = () => {
    network_discovery_table.value.reload();
  };

  onMounted(() => {
    timeout_id = setInterval(checkDiscovery, 3000);
  }),
      
  onBeforeMount(async () => {
    start_datatable();
  });

  onUnmounted(async () => {
    destroy();
  });

  /*  Initialize the datatable, adding the action buttons (next to the search),
   *  the various columns, names and data and the configuration of the datatable
   */
  function start_datatable() {
    const datatableButton = [{
        text: '<i class="fas fa-sync"></i>',
        className: 'btn-link',
        action: function () {
          reload_table();
        }
      }, {
        text: i18n("discover.start_discovery") + ' <i class="fa-solid fa-play"></i>',
        action: function() {
          loading.value = false;
          $.get(NtopUtils.buildURL(run_network_discovery, { ifid: props.ifid }), function(_) {});
          /* Set the descovery requested to true */
          timeout_id = setInterval(checkDiscovery, 1000);
        }
      }
    ];
      
    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils.buildURL(network_discovery_data, { ifid: props.ifid }),
      enable_search: true,
      table_config: { 
        serverSide: false, 
        order: [[ 0 /* application column */, 'asc' ]],
      }
    };
    
    /* Applications table configuration */  

    let columns = [
      { columnName: i18n("ip_address"), name: 'ip', data: 'ip', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: i18n("name"), name: 'name', data: 'name', className: 'text-nowrap text-center', responsivePriority: 1 },
      { columnName: i18n("mac_stats.manufacturer"), name: 'manufacturer', data: 'manufacturer', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("mac_address"), name: 'mac_address', data: 'mac_address', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("os"), name: 'os', data: 'os', className: 'text-nowrap text-center', responsivePriority: 2 },
      { columnName: i18n("info"), name: 'info', data: 'info', className: 'text-nowrap', responsivePriority: 2 },
      { columnName: i18n("device"), name: 'device', data: 'device', className: 'text-nowrap', responsivePriority: 2 },
    ];

    let trafficConfig = ntopng_utility.clone(defaultDatatableConfig);
    trafficConfig.columns_config = columns;
    config_network_discovery.value = trafficConfig;
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$z, [
      createBaseVNode("div", _hoisted_2$u, [
        createBaseVNode("div", _hoisted_3$t, [
          (loading.value)
            ? (openBlock(), createBlock(script$1z, { key: 0 }))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_4$q, [
            (error.value)
              ? (openBlock(), createElementBlock("div", _hoisted_5$m, toDisplayString(unref(error_message)), 1 /* TEXT */))
              : createCommentVNode("v-if", true),
            (!discovery_requested.value)
              ? (openBlock(), createBlock(script$1g, {
                  key: 1,
                  ref_key: "network_discovery_table",
                  ref: network_discovery_table,
                  table_buttons: config_network_discovery.value.table_buttons,
                  columns_config: config_network_discovery.value.columns_config,
                  data_url: config_network_discovery.value.data_url,
                  enable_search: config_network_discovery.value.enable_search,
                  table_config: config_network_discovery.value.table_config
                }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"]))
              : (openBlock(), createElementBlock("div", _hoisted_6$e, [
                  _hoisted_7$d,
                  createTextVNode(" " + toDisplayString(unref(discovery_requested_message)) + " ", 1 /* TEXT */),
                  createBaseVNode("span", { innerHTML: progress_message.value }, null, 8 /* PROPS */, _hoisted_8$d)
                ])),
            createVNode(script$1u, { note_list: note_list }),
            createCommentVNode(" Adding Extra Message "),
            createBaseVNode("div", {
              class: "p-1",
              innerHTML: last_network_discovery.value
            }, null, 8 /* PROPS */, _hoisted_9$b)
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$F.__file = "http_src/vue/page-network-discovery.vue";

  const _hoisted_1$y = { class: "row" };
  const _hoisted_2$t = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$s = { class: "card card-shadow" };
  const _hoisted_4$p = { class: "card-body" };
  const _hoisted_5$l = /*#__PURE__*/createBaseVNode("div", { class: "d-flex align-items-center" }, null, -1 /* HOISTED */);


  var script$E = {
    __name: 'page-manage-configurations-backup',
    props: {
    date_format: String,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const table_manage_configurations_backup = ref(null);
  const url = `${http_prefix}/lua/rest/v2/get/system/configurations/list_available_backups.lua`;
  const table_config = ref({});
  const loading = ref(false);




  const format_flows_icon = function (data, rowData) {
    const ms_data = data * 1000;
    let date_format = "HH:MM:SS";
    if (props.date_format == "little_endian") {
      date_format = "DD/MM/YYYY " + date_format;
    } else if (props.date_format == "middle_endian") {
      date_format = "MM/DD/YYYY " + date_format;
    } else {
      date_format = "YYYY/MM/DD " + date_format;
    }
    return ntopng_utility.from_utc_to_server_date_format(ms_data, date_format);
  };


  const reload_table = () => {
    loading.value = true;
    table_manage_configurations_backup.value.reload();
    loading.value = false;
  };

  onBeforeMount(async () => {
    await set_datatable_config();
  });

  const trigger_download = function (row) {
    window.open(`${http_prefix}/lua/rest/v2/get/system/configurations/download_backup.lua?epoch=${row.epoch}&download=true`);
  };

  const add_action_column = function (rowData) {

    let download_backup_handler = {
      handlerId: "download_backup_handler",
      onClick: () => {
        trigger_download(rowData);
      },
    };

    return DataTableUtils.createActionButtons([
      { class: `pointer`, handler: download_backup_handler, icon: 'fas fa-download fa-lg', title: i18n('download') },
    ]);
  };

  async function set_datatable_config() {
    const datatableButton = [];

    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function (e, dt, node, config) {
        reload_table();
      }
    });


    let defaultDatatableConfig = {
      table_buttons: datatableButton,
      data_url: `${url}`,
      enable_search: true,
      id: "manage_configurations_backup",
      table_config: {
        serverSide: true,
        responsive: false,
        scrollX: true,
        columnDefs: [
          { type: "file-size", targets: 0 },
        ]
      }
    };

    let columns = [];

    columns.push(
      {
        columnName: _i18n("backup_date"), orderable: true, targets: 0, name: 'epoch', data: 'epoch', className: 'text-left', responsivePriority: 1, render: (data, _, rowData) => {
          return format_flows_icon(data)
        }
      }, {
      columnName: _i18n("actions"), orderable: false, width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) }
    }
      ,
    );



    defaultDatatableConfig.columns_config = columns;
    table_config.value = defaultDatatableConfig;
  }


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$y, [
      createBaseVNode("div", _hoisted_2$t, [
        createBaseVNode("div", _hoisted_3$s, [
          createBaseVNode("div", _hoisted_4$p, [
            (loading.value)
              ? (openBlock(), createBlock(script$1z, { key: 0 }))
              : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              id: "manage_configurations_backup",
              class: normalizeClass([ loading.value ? 'ntopng-gray-out' : '' ])
            }, [
              (openBlock(), createBlock(script$1g, {
                ref_key: "table_manage_configurations_backup",
                ref: table_manage_configurations_backup,
                id: table_config.value.id,
                key: table_config.value.data_url,
                table_buttons: table_config.value.table_buttons,
                columns_config: table_config.value.columns_config,
                data_url: table_config.value.data_url,
                table_config: table_config.value.table_config
              }, {
                menu: withCtx(() => [
                  _hoisted_5$l
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["id", "table_buttons", "columns_config", "data_url", "table_config"]))
            ], 2 /* CLASS */)
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$E.__file = "http_src/vue/page-manage-configurations-backup.vue";

  const _hoisted_1$x = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$s = { class: "col-form-label col-sm-2" };
  const _hoisted_3$r = { class: "col-10" };
  const _hoisted_4$o = {
    key: 0,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_5$k = { class: "col-form-label col-sm-2" };
  const _hoisted_6$d = { class: "col-10" };
  const _hoisted_7$c = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_8$c = { class: "col-form-label col-sm-2" };
  const _hoisted_9$a = { class: "col-10" };
  const _hoisted_10$a = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_11$9 = { class: "col-form-label col-sm-2" };
  const _hoisted_12$9 = { class: "col-10" };
  const _hoisted_13$7 = {
    class: "form-group ms-2 me-2 mt-3 row",
    style: {"margin-top":"3px"}
  };
  const _hoisted_14$7 = { class: "col-form-label col-sm-2" };
  const _hoisted_15$6 = { class: "col-sm-3" };
  const _hoisted_16$6 = {
    class: "btn-group float-end btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_17$5 = ["value", "id"];
  const _hoisted_18$5 = ["id", "for"];
  const _hoisted_19$5 = ["value", "id"];
  const _hoisted_20$5 = ["id", "for"];
  const _hoisted_21$4 = ["value", "id"];
  const _hoisted_22$4 = ["id", "for"];
  const _hoisted_23$4 = {
    key: 0,
    class: "col-sm-2 btn-group float-end btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_24$4 = ["value", "id"];
  const _hoisted_25$3 = ["id", "for"];
  const _hoisted_26$3 = {
    key: 1,
    class: "col-sm-2 btn-group float-end btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_27$3 = ["value", "id"];
  const _hoisted_28$2 = ["id", "for"];
  const _hoisted_29$2 = {
    key: 1,
    class: "message alert alert-warning mt-3"
  };


  var script$D = {
    __name: 'modal-add-snmp-device-rules',
    props: {
    ifid_list: Array,
    snmp_devices_list: Array,
    snmp_metric_list: Array,
    frequency_list: Array,
    init_func: Function,
    page_csrf: String,
  },
    emits: ['add','edit'],
    setup(__props, { expose, emit }) {

  const props = __props;

  ref("");
  ref("");

  const modal_id = ref(null);

  const _i18n = (t) => i18n(t);
  ref(null);
  ref(null);
  const snmp_metric_list = ref([]);
  const snmp_devices_list = ref([]);
  let snmp_interfaces_list = ref([]);
  let enable_interfaces = ref(true);
  const snmp_interfaces_url = `${http_prefix}/lua/pro/rest/v2/get/snmp/device/available_interfaces.lua`;

  const frequency_list = ref([]);
  const threshold_measure = ref(null);
  const threshold_sign = ref(null);
  const selected_metric = ref({});
  const selected_snmp_device = ref({});
  const selected_snmp_interface = ref({});

  const selected_snmp_device_metric = ref({});
  const selected_frequency = ref({});
  const disable_add = ref(true);
  const metric_type = ref({});
  const visible = ref(true);
  const rule_type = ref("snmp");
  const is_edit_page = ref(false);
  const page_csrf_ = ref(null);
  let metric_type_active_list = ref([]);

  let title =  _i18n('if_stats_config.add_host_rules_title');


  const note_list = [
    _i18n('if_stats_config.note_snmp_device_rules.note_1'),
    _i18n('if_stats_config.note_snmp_device_rules.note_2'),
    _i18n('if_stats_config.note_snmp_device_rules.note_3'),
    _i18n('if_stats_config.note_3'),
    _i18n('if_stats_config.note_4')
  ];

  const sub_notes_list = [
    _i18n('if_stats_config.note_5')
  ];

  const metric_type_list = ref([
    { title: _i18n('volume'), label: _i18n('volume'), id: 'volume', active: true },
    { title: _i18n('throughput'), label: _i18n('throughput'), id: 'throughput', active: false },
    { title: _i18n('percentage'), label: _i18n('percentage'), id: 'percentage', active: false },
    { title: _i18n('packets'), label: _i18n('packets'), id: 'packets', active: false }
  ]);

  const volume_threshold_list = ref([
    { title: _i18n('kb'), label: _i18n('kb'), id: 'kb', value: 1024, active: false },
    { title: _i18n('mb'), label: _i18n('mb'), id: 'mb', value: 1048576, active: false },
    { title: _i18n('gb'), label: _i18n('gb'), id: 'gb', value: 1073741824, active: true, default_active: true},
  ]);

  const throughput_threshold_list = ref([
    { title: _i18n('kbps'), label: _i18n('kbps'), id: 'kbps', value: 1000, active: false },
    { title: _i18n('mbps'), label: _i18n('mbps'), id: 'mbps', value: 1000000, active: false },
    { title: _i18n('gbps'), label: _i18n('gbps'), id: 'gbps', value: 1000000000, active: true, default_active: true},
  ]);

  const sign_threshold_list = ref([
    { title: "+", label: ">", id: 'plus', value: 1, active: false, absolute_value: true },
    { title: "-", label: "<", id: 'minus', value: -1, active: true, default_active: true },
  ]);

  const sign_absolute_value = ref([
    { title: "+", label: ">", id: 'plus', value: 1, active: true, absolute_value: true },
  ]);

  const percentage_threshold_list = [
    { title: "+", label: "%", id: 'plus', value: 1, active: true },
  ];


  const host = ref(null);
  const threshold = ref(null);

  const showed = () => {};



  const rest_params = {
    csrf: props.page_csrf
  };

  function reset_radio_selection(radio_array) {

    radio_array.forEach((item) => item.active = item.default_active == true );
  }

  /**
   * 
   * Reset fields in modal form 
   */
  const reset_modal_form = async function() {

    host.value = "";
    selected_metric.value = snmp_metric_list.value[0];
    selected_snmp_device.value = null;
    selected_snmp_device.value = snmp_devices_list.value[0];
    change_interfaces();

    selected_snmp_device_metric.value = snmp_metric_list.value[0];
    change_active_threshold();
    
    selected_frequency.value = frequency_list.value[0];
    metric_type.value = metric_type_list.value[0];

    // reset metric_type_list
    metric_type_list.value.forEach((t) => t.active = false);
    metric_type_list.value[0].active = true;
    
    reset_radio_selection(volume_threshold_list.value);
    reset_radio_selection(throughput_threshold_list.value);
    reset_radio_selection(sign_threshold_list.value);

    rule_type.value = "snmp";

    disable_add.value = true;
    enable_interfaces.value = false;

    threshold.value.value = 1;
    is_edit_page.value = false;
    title = _i18n('if_stats_config.add_host_rules_title');

  };




  /**
   * 
   * Set row to edit 
   */
  const set_row_to_edit = (row) => {
    if(row != null) {
      is_edit_page.value = true;
      title = _i18n('if_stats_config.edit_host_rules_title');

      disable_add.value = false;

      snmp_devices_list.value.forEach((item) => {
        if(item.label_to_insert == row.device)
          selected_snmp_device.value = item;
      } );

      // set threshold sign
      sign_threshold_list.value.forEach((t) => {
        t.active = (t.value == row.threshold_sign);
      });

      snmp_metric_list.value.forEach((t) => {
        if(t.id == row.metric)
          selected_snmp_device_metric.value = t;
      });

      // set threshold
      if(row.metric_type == 'volume')
        volume_threshold_list.value.forEach((t) => {
          if ( (row.threshold % t.value) == 0 ) {
            let row_threshold_value = row.threshold / t.value;
            if( row_threshold_value < 1024) {
              t.active = true;
              threshold.value.value = row_threshold_value == 0 ? 1 : row_threshold_value;
            } else {
              t.active = false;
            }
          } else {
            t.active = false;
          }
        });
      else if(row.metric_type == 'throughput') {
        row.threshold = row.threshold * 8;
        throughput_threshold_list.value.forEach((t) => {
            if ( (row.threshold % t.value) == 0 ) {
              let row_threshold_value = row.threshold / t.value;
              if( row_threshold_value < 1000) {
                t.active = true;
                threshold.value.value = row_threshold_value == 0 ? 1 : row_threshold_value;
              } else {
                t.active = false;
              }
            } else {
              t.active = false;
            }
        });
      } else {

        //percentage case
        threshold.value.value = row.threshold * row.threshold_sign;

      }
      change_active_threshold();
      metric_type_active_list.value.forEach((item) => {
        if(item.id == row.metric_type) {
          metric_type.value = item;
          item.active = true;
        } else 
          item.active = false;
      });

      // set rule_type
      rule_type.value = row.rule_type;
      snmp_devices_list.value.forEach((t) => {
        if(t.label == row.device)
          selected_snmp_device.value = t;
      });

      frequency_list.value.forEach((item) => {
        if(item.id == row.frequency)
          selected_frequency.value = item;
      });

      change_interfaces(row.device_port);
    
    }
  };

  const show = (row) => {
    if(row != null) {
      set_row_to_edit(row);
    } else {
      reset_modal_form();
    }
    modal_id.value.show();
  };


  const set_active_sign_radio = (selected_radio) => {
    const id = selected_radio.target.id;
    sign_threshold_list.value.forEach((measure) => {
      (measure.id === id) ? measure.active = true : measure.active = false;
    });

  };

  /**
   * 
   * Set the metric type
   */
  const set_active_radio = (selected_radio) => {
    const id = selected_radio.target.id;

    if(metric_type.value.id == 'throughput') {
      throughput_threshold_list.value.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    } else if (metric_type.value.id == 'volume') {
      volume_threshold_list.value.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    } else if (metric_type.value.id == 'percentage'){
      percentage_threshold_list.forEach((measure) => {
        (measure.id === id) ? measure.active = true : measure.active = false;
      });
    } else if (metric_type.value.id == 'packets'); 
    
  };


  async function change_interfaces(interface_id) {
    const url = NtopUtils$1.buildURL(snmp_interfaces_url+"?host="+selected_snmp_device.value.label_to_insert, rest_params);
    let interfaces_list = [];
    await $.get(url, function(rsp, status){
      interfaces_list = rsp.rsp;
    });
    let result_interfaces = [];

    interfaces_list.forEach(iface => {
      if(iface.name != null && iface.name != "" && iface.name != iface.id)
        result_interfaces.push({label: iface.name + " ("+iface.id+")", id: iface.id, name: iface.name });
      else
        result_interfaces.push({label: iface.id, id: iface.id,  name: iface.id});
    });
    result_interfaces.push({label: "*", id:"*", name:"*"});
    result_interfaces.sort(function(a,b) {return (a.label.toLowerCase() > b.label.toLowerCase() ? 1 : (a.label.toLowerCase() < b.label.toLowerCase()) ? -1 : 0);});

    if (interface_id != null)
      result_interfaces.forEach((t) => {
        if(t.id == interface_id)
          selected_snmp_interface.value = t;
      });
    snmp_interfaces_list.value = result_interfaces;
    // debugger;
    if(selected_snmp_device.value.label_to_insert == "all")
      enable_interfaces.value = false;
    else
      enable_interfaces.value = true;

  }

  function change_active_threshold() {
    let list_metrics_active = [];
    if(selected_snmp_device_metric.value.id == 'packets'  || selected_snmp_device_metric.value.id == 'usage') {
      metric_type_list.value.forEach((t) => {
        if(t.id != 'percentage')
          t.active = false;
        else {
          t.active = true;
          list_metrics_active.push(t);
          metric_type.value = t;
        }
      });
    } else if (selected_snmp_device_metric.value.id == 'errors' ) {
      metric_type_list.value.forEach((t) => {
        if(t.id != 'packets')
          t.active = false;
        else {
          t.active = true;
          list_metrics_active.push(t);
          metric_type.value = t;
        }
      });

    } else {
      metric_type_list.value.forEach((t) => {
        if(t.id == 'packets')
          t.active = false;
        else {
          list_metrics_active.push(t);
        }
      });
    }


    metric_type_active_list.value = list_metrics_active;
  }



  /**
   * Function to add rule to rules list
   */
  const add_ = (is_edit) => {
    rule_type.value = 'snmp';
    host.value;

    const tmp_frequency = selected_frequency.value.id;
    const tmp_metric = selected_snmp_device_metric.value.id;
    const tmp_metric_label = selected_snmp_device_metric.value.label;
    const tmp_device = selected_snmp_device.value.label_to_insert;
    const tmp_device_label = selected_snmp_device.value.label;
    const tmp_device_ifid = selected_snmp_interface.value == null || Object.entries(selected_snmp_interface.value).length === 0 ? "*": selected_snmp_interface.value.id;
    const tmp_device_ifid_label = selected_snmp_interface.value == null || Object.entries(selected_snmp_interface.value).length === 0 ? "*":selected_snmp_interface.value.label;
    // debugger;
    // console.log(threshold)
    let tmp_metric_type = metric_type.value.id;
    let basic_value;
    let measure_unit_label;
    let basic_sign_value;
    let tmp_threshold;
    let tmp_sign_value;

    if(visible.value === false) {
      tmp_metric_type = '';
      tmp_extra_metric = '';
      tmp_threshold = threshold.value.value;
    }
    if(tmp_metric_type == 'throughput') {

      sign_threshold_list.value.forEach((measure) => { if(measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      throughput_threshold_list.value.forEach((measure) => { if(measure.active) { basic_value = measure.value; measure_unit_label = measure.label; }});
      tmp_threshold = basic_value * parseInt(threshold.value.value) / 8;
      /* The throughput is in bit, the volume in Bytes!! */
    } else if(tmp_metric_type == 'volume') {
      sign_threshold_list.value.forEach((measure) => { if(measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      volume_threshold_list.value.forEach((measure) => { if(measure.active) {basic_value = measure.value; measure_unit_label = measure.label;} });
      tmp_threshold = basic_value * parseInt(threshold.value.value);
    } else if(tmp_metric_type == 'percentage') {
      sign_threshold_list.value.forEach((measure) => { if(measure.active) basic_sign_value = measure.value; });
      tmp_sign_value = parseInt(basic_sign_value);
      tmp_threshold = tmp_sign_value * parseInt(threshold.value.value);
      measure_unit_label = "%";
    } else {
      tmp_sign_value = 1;
      tmp_threshold = parseInt(threshold.value.value);
    }
    let emit_name = 'add';

    if(is_edit == true) 
      emit_name = 'edit';

    emit(emit_name, { 
      frequency: tmp_frequency, 
      metric: tmp_metric,
      metric_label: tmp_metric_label,
      threshold: tmp_threshold,
      metric_type: tmp_metric_type,
      snmp_device: tmp_device,
      snmp_device_label: tmp_device_label,
      snmp_device_port: tmp_device_ifid,
      snmp_device_port_label: tmp_device_ifid_label,
      rule_threshold_sign: tmp_sign_value,
      snmp_threshold_value: threshold.value.value,
      snmp_threshold_unit: measure_unit_label,
      snmp_metric_type_label: metric_type.value.title
    });
    
      

    close();
  };


  const edit_ = () => {
    add_(true);
  };

  const close = () => {
    modal_id.value.close();
  };

  const format_snmp_devices_list = function(_snmp_devices_list) {
    let devices_list = [];
    _snmp_devices_list.data.forEach(item => {
      if(item.column_name != null && item.column_name != "" && item.column_name != "all")
        devices_list.push({label : item.column_name + " ("+item.column_key+")" , label_to_insert: item.column_key});
      else {
        if (item.column_name == "all")
          devices_list.push({label : item.column_key, label_to_insert: item.column_name});
        else
          devices_list.push({label : item.column_key, label_to_insert: item.column_key});
      }

    });

    devices_list.sort(function(a, b) {return (a.label.toLowerCase() > b.label.toLowerCase() ? 1 : (a.label.toLowerCase() < b.label.toLowerCase()) ? -1 : 0);});
    return devices_list;
  };

  const metricsLoaded =(_snmp_devices_list, _snmp_metric_list, page_csrf) => {

    snmp_devices_list.value = format_snmp_devices_list(_snmp_devices_list);
    snmp_metric_list.value = _snmp_metric_list;
    frequency_list.value = props.frequency_list;
    selected_frequency.value = frequency_list.value[0];
    selected_metric.value = snmp_metric_list.value[0];
    page_csrf_.value = page_csrf;
    
    
  };


  onBeforeMount(() => {
    metric_type_list.value.forEach((t) => {
      if(t.active) {
        metric_type.value = t;
      }

    });
  });

  expose({ show, close, metricsLoaded });



  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[7] || (_cache[7] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(unref(title)), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createCommentVNode(" Target information, here an IP is put "),
        createBaseVNode("div", _hoisted_1$x, [
          createBaseVNode("label", _hoisted_2$s, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.snmp_device")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$r, [
            createVNode(script$1I, {
              selected_option: selected_snmp_device.value,
              "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_snmp_device).value = $event)),
              onSelect_option: _cache[1] || (_cache[1] = $event => (change_interfaces())),
              options: snmp_devices_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ]),
        (unref(enable_interfaces) == true)
          ? (openBlock(), createElementBlock("div", _hoisted_4$o, [
              createBaseVNode("label", _hoisted_5$k, [
                createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.snmp_interface")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_6$d, [
                createVNode(script$1I, {
                  selected_option: selected_snmp_interface.value,
                  "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_snmp_interface).value = $event)),
                  options: unref(snmp_interfaces_list)
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_7$c, [
          createBaseVNode("label", _hoisted_8$c, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.metric")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_9$a, [
            createVNode(script$1I, {
              selected_option: selected_snmp_device_metric.value,
              "onUpdate:selected_option": _cache[3] || (_cache[3] = $event => ((selected_snmp_device_metric).value = $event)),
              onSelect_option: _cache[4] || (_cache[4] = $event => (change_active_threshold())),
              options: snmp_metric_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ]),
        createCommentVNode(" Frequency information, a frequency of 1 day, 5 minute or 1 hour for example "),
        createBaseVNode("div", _hoisted_10$a, [
          createBaseVNode("label", _hoisted_11$9, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.frequency")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_12$9, [
            createVNode(script$1I, {
              selected_option: selected_frequency.value,
              "onUpdate:selected_option": _cache[5] || (_cache[5] = $event => ((selected_frequency).value = $event)),
              options: frequency_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ]),
        createCommentVNode(" Threshold information, maximum amount of bytes "),
        createBaseVNode("div", _hoisted_13$7, [
          createBaseVNode("label", _hoisted_14$7, [
            createBaseVNode("b", null, toDisplayString(_i18n("if_stats_config.threshold")), 1 /* TEXT */)
          ]),
          (visible.value)
            ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createBaseVNode("div", _hoisted_15$6, [
                  createVNode(script$1I, {
                    selected_option: metric_type.value,
                    "onUpdate:selected_option": _cache[6] || (_cache[6] = $event => ((metric_type).value = $event)),
                    options: unref(metric_type_active_list)
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ]),
                createBaseVNode("div", {
                  class: normalizeClass(["col-3", [ metric_type.value.id == 'throughput' ? 'p-0' : '']])
                }, [
                  createBaseVNode("div", _hoisted_16$6, [
                    (metric_type.value.id == 'throughput' && metric_type.value.id != 'packets')
                      ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(throughput_threshold_list.value, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_17$5),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [ measure.active ? 'btn-primary active' : 'btn-secondary' ]]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_18$5)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 256 /* UNKEYED_FRAGMENT */))
                      : createCommentVNode("v-if", true),
                    (metric_type.value.id == 'percentage' && metric_type.value.id != 'packets')
                      ? (openBlock(), createElementBlock(Fragment, { key: 1 }, renderList(percentage_threshold_list, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_19$5),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [ measure.active ? 'btn-primary active' : 'btn-secondary' ]]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_20$5)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 64 /* STABLE_FRAGMENT */))
                      : createCommentVNode("v-if", true),
                    (metric_type.value.id == 'volume' && metric_type.value.id != 'packets')
                      ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(volume_threshold_list.value, (measure) => {
                          return (openBlock(), createElementBlock(Fragment, null, [
                            createBaseVNode("input", {
                              value: measure.value,
                              id: measure.id,
                              type: "radio",
                              class: "btn-check",
                              autocomplete: "off",
                              ref_for: true,
                              ref_key: "threshold_measure",
                              ref: threshold_measure,
                              name: "threshold_measure"
                            }, null, 8 /* PROPS */, _hoisted_21$4),
                            createBaseVNode("label", {
                              class: normalizeClass(["btn", [ measure.active ? 'btn-primary active' : 'btn-secondary' ]]),
                              id: measure.id,
                              onClick: set_active_radio,
                              for: measure.id
                            }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_22$4)
                          ], 64 /* STABLE_FRAGMENT */))
                        }), 256 /* UNKEYED_FRAGMENT */))
                      : createCommentVNode("v-if", true)
                  ])
                ], 2 /* CLASS */),
                (metric_type.value.id != 'packets')
                  ? (openBlock(), createElementBlock("div", _hoisted_23$4, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(sign_threshold_list.value, (measure) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          createBaseVNode("input", {
                            value: measure.value,
                            id: measure.id,
                            type: "radio",
                            class: "btn-check",
                            autocomplete: "off",
                            ref_for: true,
                            ref_key: "threshold_sign",
                            ref: threshold_sign,
                            name: "threshold_sign"
                          }, null, 8 /* PROPS */, _hoisted_24$4),
                          createBaseVNode("label", {
                            class: normalizeClass(["btn", [ measure.active ? 'btn-primary active' : 'btn-secondary' ]]),
                            id: measure.id,
                            onClick: set_active_sign_radio,
                            for: measure.id
                          }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_25$3)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ]))
                  : (openBlock(), createElementBlock("div", _hoisted_26$3, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(sign_absolute_value.value, (measure) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          createBaseVNode("input", {
                            value: measure.value,
                            id: measure.id,
                            type: "radio",
                            class: "btn-check",
                            autocomplete: "off",
                            ref_for: true,
                            ref_key: "threshold_sign",
                            ref: threshold_sign,
                            name: "threshold_sign"
                          }, null, 8 /* PROPS */, _hoisted_27$3),
                          createBaseVNode("label", {
                            class: normalizeClass(["btn", [ measure.absolute_value ? 'btn-primary active' : 'btn-secondary' ]]),
                            id: measure.id,
                            for: measure.id
                          }, toDisplayString(measure.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_28$2)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ]))
              ], 64 /* STABLE_FRAGMENT */))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass([visible.value ? 'col-sm-2' : 'col-sm-8'])
          }, [
            (metric_type.value.id == 'percentage')
              ? (openBlock(), createElementBlock("input", {
                  key: 0,
                  value: "1",
                  ref_key: "threshold",
                  ref: threshold,
                  type: "number",
                  name: "threshold",
                  class: "form-control",
                  max: "100",
                  min: "1",
                  required: ""
                }, null, 512 /* NEED_PATCH */))
              : (openBlock(), createElementBlock("input", {
                  key: 1,
                  value: "1",
                  ref_key: "threshold",
                  ref: threshold,
                  type: "number",
                  name: "threshold",
                  class: "form-control",
                  max: "1023",
                  min: "1",
                  required: ""
                }, null, 512 /* NEED_PATCH */))
          ], 2 /* CLASS */)
        ]),
        (selected_snmp_device_metric.value.id != 'usage' && metric_type.value.id == 'percentage')
          ? (openBlock(), createElementBlock("div", _hoisted_29$2, toDisplayString(_i18n("show_alerts.host_rules_percentage")), 1 /* TEXT */))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        createVNode(script$1u, {
          note_list: note_list,
          add_sub_notes: true,
          sub_note_list: sub_notes_list
        }),
        (is_edit_page.value == false)
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: add_,
              class: "btn btn-primary"
            }, toDisplayString(_i18n('add')), 1 /* TEXT */))
          : (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              onClick: edit_,
              class: "btn btn-primary"
            }, toDisplayString(_i18n('apply')), 1 /* TEXT */))
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$D.__file = "http_src/vue/modal-add-snmp-device-rules.vue";

  const _hoisted_1$w = { class: "row" };
  const _hoisted_2$r = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$q = { class: "card" };
  const _hoisted_4$n = /*#__PURE__*/createBaseVNode("div", { class: "overlay justify-content-center align-items-center position-absolute h-100 w-100" }, [
    /*#__PURE__*/createBaseVNode("div", { class: "text-center" }, [
      /*#__PURE__*/createBaseVNode("div", {
        class: "spinner-border text-primary mt-5",
        role: "status"
      }, [
        /*#__PURE__*/createBaseVNode("span", { class: "sr-only position-absolute" }, "Loading...")
      ])
    ])
  ], -1 /* HOISTED */);
  const _hoisted_5$j = { class: "card-body" };
  const _hoisted_6$c = { class: "mb-4" };
  const _hoisted_7$b = { id: "host_rules" };
  const _hoisted_8$b = { class: "card-footer" };


  var script$C = {
    __name: 'page-snmp-device-rules',
    props: {
    page_csrf: String,
    ifid: String,
  },
    setup(__props) {

  const props = __props;



  const table_host_rules = ref(null);
  const modal_delete_confirm = ref(null);
  const modal_add_snmp_device_rule = ref(null);
  const _i18n = (t) => i18n(t);
  const row_to_delete = ref({});
  const row_to_edit = ref({});


  const snmp_metric_url = `${http_prefix}/lua/pro/rest/v2/get/snmp/metric/rule_metrics.lua`;
  const snmp_devices_url = `${http_prefix}/lua/pro/enterprise/get_snmp_devices_list.lua`;

  const data_url = `${http_prefix}/lua/pro/rest/v2/get/snmp/device/rules.lua`;
  const add_rule_url = `${http_prefix}/lua/pro/rest/v2/add/snmp/device/rule.lua`;
  const remove_rule_url = `${http_prefix}/lua/pro/rest/v2/delete/snmp/device/rule.lua`;

  const note_list = [
    _i18n('if_stats_config.generic_notes_1'),
    _i18n('if_stats_config.generic_notes_2'),
    _i18n('if_stats_config.generic_notes_3'),
  ];

  const rest_params = {
    ifid: props.ifid,
    csrf: props.page_csrf
  };

  let host_rules_table_config = {};
  let title_delete = _i18n('if_stats_config.delete_host_rules_title');
  _i18n('if_stats_config.edit_local_network_rules');
  let body_delete = _i18n('if_stats_config.delete_host_rules_description');
  let snmp_metric_list = [];
  let snmp_devices_list = [];


  const frequency_list = [
    { title: i18n('show_alerts.5_min'), label: i18n('show_alerts.5_min'), id: '5min' },
    { title: i18n('show_alerts.hourly'), label: i18n('show_alerts.hourly'), id: 'hour' },
    { title: i18n('show_alerts.daily'), label: i18n('show_alerts.daily'), id: 'day' }
  ];

  const show_delete_dialog = function(row) {
    row_to_delete.value = row;
    modal_delete_confirm.value.show();
  };

  const load_selected_field = function(row) {
    row_to_edit.value = row;
    
    row_to_delete.value = row;

    modal_add_snmp_device_rule.value.show(row);

  };

  async function edit(params) {
    await delete_row();

    await add_host_rule(params);
  }

  const init_edit = function() {
    const row = row_to_edit.value;
    row_to_edit.value = null;
    return row;
  };

  const destroy_table = function() {
    table_host_rules.value.destroy_table();
  };

  const reload_table = function() {
    table_host_rules.value.reload();
  };

  const delete_row = async function() {
    const row = row_to_delete.value;
    const url = NtopUtils$1.buildURL(remove_rule_url, {
      ...rest_params,
      ...{
        rule_id: row.id,
        rule_type: row.rule_type
      }
    });
    
    await $.post(url, function(rsp, status){
      reload_table();
    });
  };

  const add_host_rule = async function(params) {
    const url = NtopUtils$1.buildURL(add_rule_url, {
      ...rest_params,
      ...params
    });
    
    await $.post(url, function(rsp, status){
      reload_table();
    });
  };


  const add_action_column = function (rowData) {
    let delete_handler = {
  	  handlerId: "delete_host",	  
  	  onClick: () => {
        show_delete_dialog(rowData);
  	  },
  	};

    let edit_handler = {
      handlerId: "edit_rule",
      onClick: () => {
        load_selected_field(rowData);
      },
    };
    
    return DataTableUtils.createActionButtons([
      { class: `pointer`, handler: edit_handler, icon: 'fa-edit', title: i18n('edit') },
  	  { class: `pointer`, handler: delete_handler, icon: 'fa-trash', title: i18n('delete') },
  	]);
  };

  const format_metric = function(data, rowData) {
    let metric_label = data;  
    if (rowData.metric_label && rowData.metric_label != data && rowData.metric_label != "") {
      metric_label = rowData.metric_label;
    } 
    
    
    return metric_label
  };

  const format_frequency = function(data) {
    let frequency_title = '';
    frequency_list.forEach((frequency) => {
      if(data == frequency.id)
        frequency_title = frequency.title;
    });

    return frequency_title
  };

  const format_threshold = function(data, rowData) {
    let formatted_data = parseInt(data);
    let threshold_sign = "> ";

    if((rowData.threshold_sign) && (rowData.threshold_sign == '-1'))
      threshold_sign = "< ";

    if((rowData.metric_type) && (rowData.metric_type == 'throughput')) {
      formatted_data = threshold_sign + NtopUtils$1.bitsToSize_no_comma(data * 8);
    } else if((rowData.metric_type) && (rowData.metric_type == 'volume')) {
      formatted_data = threshold_sign + NtopUtils$1.bytesToSize(data);
    } else if((rowData.metric_type) && (rowData.metric_type == 'percentage')){
      if (data < 0) {
        data = data * (-1);
      }
      formatted_data = threshold_sign + NtopUtils$1.fpercent(data);
    } else {
      formatted_data = threshold_sign + data;
    }

    return formatted_data
  };


  const format_target = function(data, rowData) {
    return rowData.device_label;
  };

  const format_interface = function(data, rowData) {
    return rowData.device_port_label;
  };

  const get_snmp_metric_list = async function() {
    const url = NtopUtils$1.buildURL(snmp_metric_url, rest_params);
    
    await $.get(url, function(rsp, status){
      snmp_metric_list = rsp.rsp;
    });
  };


  const get_snmp_devices_list = async function() {
    rest_params.verbose = true;
    const url = NtopUtils$1.buildURL(snmp_devices_url, rest_params);
    await $.get(url, function(rsp, status){
      snmp_devices_list = rsp.rsp;
    });
    snmp_devices_list.data.push({column_key: "*",column_name: "all" });
  };

  const start_datatable = function() {
    const datatableButton = [];

    /* Manage the buttons close to the search box */
    datatableButton.push({
      text: '<i class="fas fa-sync"></i>',
      className: 'btn-link',
      action: function () {
        reload_table();
      }
    }, {
      text: '<i class="fas fa-plus"></i>',
      className: 'btn-link',
      action: function () {
        modal_add_snmp_device_rule.value.show();
      }
    });
    
    const columns = [
      { columnName: _i18n("actions"), targets: 0, width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) } },

      { columnName: _i18n("id"), visible: false, targets:1, name: 'id', data: 'id', className: 'text-nowrap', responsivePriority: 1 },
      { columnName: _i18n("if_stats_config.snmp_device"), targets: 2, width: '20', name: 'device', data: 'device', className: 'text-nowrap', responsivePriority: 1, render: function(data, _, rowData) {return format_target(data, rowData) } },
      { columnName: _i18n("if_stats_config.snmp_interface"), targets: 3, width: '20', name: 'interface', data: 'interface', className: 'text-center', responsivePriority: 1, render: function(data, _, rowData) {return format_interface(data, rowData) } },
      { columnName: _i18n("if_stats_config.metric"), targets: 4, width: '10', name: 'metric', data: 'metric', className: 'text-center', responsivePriority: 1, render: function(data, _, rowData) { return format_metric(data, rowData) } },
      { columnName: _i18n("if_stats_config.frequency"), targets: 5, width: '10', name: 'frequency', data: 'frequency', className: 'text-center', responsivePriority: 1, render: function(data) { return format_frequency(data) } },
      { columnName: _i18n("if_stats_config.threshold"), targets: 6, width: '10', name: 'threshold', data: 'threshold', className: 'text-end', responsivePriority: 1, render: function(data, _, rowData) { return format_threshold(data, rowData) } },
      { columnName: _i18n("metric_type"), visible: false, targets: 7, name: 'metric_type', data: 'metric_type', className: 'text-nowrap', responsivePriority: 1 },
    ];

    const hostRulesTableConfig = {
      table_buttons: datatableButton,
      data_url: NtopUtils$1.buildURL(data_url, rest_params),
      enable_search: true,
      columns_config: columns,
      table_config: { 
        scrollX: false,
        serverSide: false, 
        order: [[ 1 /* target */, 'desc' ]],
        columnDefs: columns
      }
    };
    host_rules_table_config = hostRulesTableConfig;
  };

  onBeforeMount(async () => {
    start_datatable();
    await get_snmp_metric_list();
    await get_snmp_devices_list();
    modal_add_snmp_device_rule.value.metricsLoaded(snmp_devices_list, snmp_metric_list, props.page_csrf);
  });

  onUnmounted(() => {
    destroy_table();
  });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$w, [
      createBaseVNode("div", _hoisted_2$r, [
        createBaseVNode("div", _hoisted_3$q, [
          _hoisted_4$n,
          createBaseVNode("div", _hoisted_5$j, [
            createBaseVNode("div", _hoisted_6$c, [
              createBaseVNode("h4", null, toDisplayString(_i18n('if_stats_config.snmp_rules')), 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_7$b, [
              createVNode(script$1c, {
                ref_key: "modal_delete_confirm",
                ref: modal_delete_confirm,
                title: unref(title_delete),
                body: unref(body_delete),
                onDelete: delete_row
              }, null, 8 /* PROPS */, ["title", "body"]),
              createVNode(script$D, {
                ref_key: "modal_add_snmp_device_rule",
                ref: modal_add_snmp_device_rule,
                frequency_list: frequency_list,
                init_func: init_edit,
                onAdd: add_host_rule,
                onEdit: edit
              }, null, 512 /* NEED_PATCH */),
              createVNode(script$1g, {
                ref_key: "table_host_rules",
                ref: table_host_rules,
                table_buttons: unref(host_rules_table_config).table_buttons,
                columns_config: unref(host_rules_table_config).columns_config,
                data_url: unref(host_rules_table_config).data_url,
                enable_search: unref(host_rules_table_config).enable_search,
                table_config: unref(host_rules_table_config).table_config
              }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "enable_search", "table_config"])
            ])
          ]),
          createBaseVNode("div", _hoisted_8$b, [
            createVNode(script$1u, { note_list: note_list })
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$C.__file = "http_src/vue/page-snmp-device-rules.vue";

  //import NtopUtils from "../utilities/ntop-utils";


  var script$B = {
    __name: 'page-snmp-devices-interfaces-similarity',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const notes = [_i18n("snmp.snmp_similarity_note"), _i18n("snmp.snmp_similarity_time_note")];



  const table_id = "snmp_similarity_data";

  onMounted(async () => {
      table_utils.build_table(http_prefix, table_id);
  });


  console.log(props.context);

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createTextVNode(" Ciao Mondo "),
      createVNode(script$1u, { note_list: notes })
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$B.__file = "http_src/vue/page-snmp-devices-interfaces-similarity.vue";

  const _hoisted_1$v = { class: "row" };
  const _hoisted_2$q = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$p = { class: "card card-shadow" };
  const _hoisted_4$m = { class: "card-body" };
  const _hoisted_5$i = { class: "d-flex mb-3" };
  const _hoisted_6$b = { class: "d-flex align-items-center ml-2 mb-2" };
  const _hoisted_7$a = {
    class: "d-flex no-wrap",
    style: {"text-align":"left","margin-right":"1rem","min-width":"25rem"}
  };
  const _hoisted_8$a = { class: "my-auto me-1" };
  const _hoisted_9$9 = { class: "d-flex align-items-center mb-2" };
  const _hoisted_10$9 = {
    class: "d-flex no-wrap",
    style: {"text-align":"left","margin-right":"1rem","min-width":"25rem"}
  };
  const _hoisted_11$8 = { class: "my-auto me-1" };
  const _hoisted_12$8 = { class: "d-flex align-items-center mb-2" };
  const _hoisted_13$6 = {
    class: "d-flex no-wrap",
    style: {"text-align":"left","margin-right":"1rem","min-width":"25rem"}
  };
  const _hoisted_14$6 = { class: "my-auto me-1" };
  const _hoisted_15$5 = ["title"];
  const _hoisted_16$5 = ["onClick", "title"];

  var script$A = {
    __name: 'page-hosts-ports-analysis',
    props: {
      is_ntop_enterprise_m: Boolean,
      csrf: String,
      vlans: Array,
      ifid: Number,
      aggregation_criteria: String,
      page: Number,
      sort: String,
      order: String,
      start: Number,
      length: Number,
      host: String,
  },
    setup(__props) {

  const props = __props;

  const filter_table_array = ref([]);
  const filter_table_dropdown_array = ref([]);


  ref({
      csrf: props.csrf,
      ifid: props.ifid
  });
  const _i18n = (t) => i18n(t);

  /* L4 Protocol List */
  const criteria_list_def = [
      { label: _i18n("tcp"), value: 6, param: "tcp", table_id: "tcp_ports_analysis", enterprise_m: false },
      { label: _i18n("udp"), value: 17, param: "udp", table_id: "udp_ports_analysis", enterprise_m: false },
  ];


  /* Consts */
  const selected_criteria = ref(criteria_list_def[0]);
  const table_id = ref('server_ports_analysis');
  const selected_port = ref({});
  const selected_application = ref({});
  const table_server_ports_analysis = ref();

  let port_list = ref([]);
  let application_list = ref([]);

  const criteria_list = function () {
      if (props.is_ntop_enterprise_m) {
          return ref(criteria_list_def);
      }
      else {
          let critera_list_def_com = [];
          criteria_list_def.forEach((c) => {
              if (!c.enterprise_m)
                  critera_list_def_com.push(c);
          });
          return ref(critera_list_def_com);
      }
  }();

  onMounted(async () => {
      let port = ntopng_url_manager$1.get_url_entry('port');
      let l4_proto = ntopng_url_manager$1.get_url_entry('protocol');
      const l7_proto = ntopng_url_manager$1.get_url_entry('application');  
      ntopng_url_manager$1.set_key_to_url('ifid', props.ifid); /* Current interface */


      if (port != null && port.localeCompare("") != 0 &&
          l4_proto != null && l4_proto.localeCompare("") != 0 &&
          l7_proto != null && l7_proto.localeCompare("") != 0) {
          
          port = Number(port);
          l4_proto = Number(l4_proto);
          selected_criteria.value = criteria_list_def.find((proto) => (proto.value == l4_proto));
          

          await update_dropdown_menus(false, l7_proto, port);

      } else {
          selected_criteria.value = criteria_list_def[0];
          await update_dropdown_menus(false);

      }

      load_table_filters_overview();
      table_server_ports_analysis.value.refresh_table();


  });


  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager$1.get_url_object();
      return extra_params;
  };

  /* Function to update L4 Protocol */
  async function update_criteria() {
      await update_dropdown_menus(false);
      table_server_ports_analysis.value.refresh_table();

  }
  /* Function to update Application */
  async function update_port_list() {
      await update_dropdown_menus(true);
      table_server_ports_analysis.value.refresh_table();
  }

  /* Function to update port */
  function update_port() {
      set_port_in_url();
      table_server_ports_analysis.value.refresh_table();
  }

  function set_port_in_url() {
      ntopng_url_manager$1.set_key_to_url("port", selected_port.value.id);
  }


  /* Function to load filters (Just VLANs) */
  async function load_table_filters_array(action, filter) {
      let extra_params = get_extra_params_obj();
      let url_params = ntopng_url_manager$1.obj_to_url_params(extra_params);
      const url = `${http_prefix}/lua/pro/rest/v2/get/host/hosts_details_by_port_filters.lua?action=${action}&${url_params}`;
      let res = await ntopng_utility$1.http_request(url);
      return res.map((t) => {
          return {
              id: t.action || t.name,
              label: t.label,
              title: t.tooltip,
              data_loaded: action != 'overview',
              options: t.value,
              hidden: (t.value.length == 1)
          };
      });
  }

  const get_open_filter_table_dropdown = (filter, filter_index) => {
      return (_) => {
          load_table_filters(filter, filter_index);
      };
  };

  async function load_table_filters(filter, filter_index) {
      filter.show_spinner = true;
      await nextTick();
      if (filter.data_loaded == false) {
          let new_filter_array = await load_table_filters_array(filter.id);
          filter.options = new_filter_array.find((t) => t.id == filter.id).options;
          await nextTick();
          let dropdown = filter_table_dropdown_array.value[filter_index];
          dropdown.load_menu();
      }
      filter.show_spinner = false;
  }

  async function load_table_filters_overview(action) {
      filter_table_array.value = await load_table_filters_array("overview");
      set_filter_array_label();
  }

  /* Function to handle actions entries */
  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_flows": click_button_flows,
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  function click_button_flows(event) {
      live_flows(event.row.ip);
  }

  const live_flows = function (data) {

      let params = {
          l4proto: selected_criteria.value.value,
          server: data,
          port: selected_port.value.id,
          vlan: ntopng_url_manager$1.get_url_entry('vlan_id')
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params);
      const url = `${http_prefix}/lua/flows_stats.lua?${url_params}`;
      ntopng_url_manager$1.go_to_url(`${url}`);
  };

  function set_filter_array_label() {
      filter_table_array.value.forEach((el, index) => {
          if (el.basic_label == null) {
              el.basic_label = el.label;
          }

          const url_entry = ntopng_url_manager$1.get_url_entry(el.id);
          if (url_entry != null) {
              el.options.forEach((option) => {
                  if (option.value.toString() === url_entry) {
                      el.label = `${el.basic_label}: ${option.label || option.value}`;
                  }
              });
          }
      });
  }

  function add_table_filter(opt, event) {
      event.stopPropagation();
      ntopng_url_manager$1.set_key_to_url(opt.key, `${opt.value}`);
      set_filter_array_label();
      table_server_ports_analysis.value.refresh_table();
  }

  /* Function to update dropdown menus */
  async function update_dropdown_menus(is_application_selected, app, port) {
      ntopng_url_manager$1.set_key_to_url("protocol", selected_criteria.value.value);
      const vlan_id = ntopng_url_manager$1.get_url_entry("vlan_id") || "";
      const url = `${http_prefix}/lua/pro/rest/v2/get/host/server_ports.lua?protocol=${selected_criteria.value.value}&ifid=${props.ifid}&vlan_id=${vlan_id}`;
      let res = await ntopng_utility$1.http_request(url, null, null, true);
      let ports = [];
      application_list.value = [];
      port_list.value = [];

      res.rsp.forEach((item) => {
          let name = item.l7_proto_name;
          ports.push({ label: `${item.srv_port}/${name} (${item.n_hosts})`, id: item.srv_port, application: name, application_id: item.proto_id,num_hosts: item.n_hosts, vlan_id:item.vlan_id });
      });

      ports.forEach((port) => {
          let proto_id = port.application_id;
          if (! application_list.value.find(item => item.id == proto_id)) {
              application_list.value.push({ label: port.application, id: port.application_id, value: proto_id });
          }
      });

      application_list.value.sort((a, b) => {
          let x = a.label.toLowerCase();
          let y = b.label.toLowerCase();

          if (x < y) { return -1; }
          if (x > y) { return 1; }
          return 0;
      });

      if (!is_application_selected) {
        // by default select first l7_proto
        selected_application.value =  (app == null) ? 
                                      application_list.value[0] :
                                      application_list.value.find((item) => (item.id == app));
      }
      ntopng_url_manager$1.set_key_to_url("application", selected_application.value.id);
      ports.forEach((item) => {
          if (item.application == selected_application.value.label)
              port_list.value.push({ label: item.id + " (" + item.num_hosts + ")", id: item.id, value: item.id, vlan_id: item.vlan_id, n_hosts: item.num_hosts });
      });

      port_list.value.sort((a, b) => {
          let x = a.id;
          let y = b.id;

          if (x < y) { return -1; }
          if (x > y) { return 1; }
          return 0;
      });

      if (port != null) {
          selected_port.value = port_list.value.find((item) => (item.id == port));
      } else {
          selected_port.value = port_list.value[0];
      }

      set_port_in_url();
  }

  /* Function to format data */
  const map_table_def_columns = async (columns) => {
      let map_columns = {
          "ip": (ip, row) => {
              if (ip !== undefined) {
                  return format_ip(ip, row);
              }
          },
          "name": (name, row) => {
              if (name !== undefined) {
                  return format_host_name(name, row);
              }
          },
          "mac": (mac, row) => {
              if (mac !== undefined) {
                  return format_mac(mac);
              }
          },
          "tot_traffic": (tot_traffic, row) => {
              if (tot_traffic !== undefined) {
                  return NtopUtils$1.bytesToSize(tot_traffic);
              }
          }
      };

      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
      });
      // console.log(columns);
      return columns;
  };

  /* Function to format IP label */
  const format_ip = function (data, rowData) {
      if (data != null) {
          if (rowData.vlan_id != 0)
              return `<a href="${http_prefix}/lua/flows_stats.lua?server=${data}&vlan=${rowData.vlan_id}&port=${selected_port.value.id}">${data}@${rowData.vlan_id}</a>`;
          else
              return `<a href="${http_prefix}/lua/flows_stats.lua?server=${data}&port=${selected_port.value.id}">${data}</a>`;
      }
      return data;

  };

  /* Function to format MAC Address label */
  const format_mac = function (data, rowData) {
      if (data != null)
          return `<a href="${http_prefix}/lua/mac_details.lua?host=${data}">${data}</a>`;
      return data;
  };

  /* Function to format Host Name label */
  const format_host_name = function (data, rowData) {
      if (data != null) {
          if (rowData.vlan_id != 0)
              return `<a href="${http_prefix}/lua/host_details.lua?host=${rowData.ip}&vlan=${rowData.vlan_id}">${data}</a>`
          else
              return `<a href="${http_prefix}/lua/host_details.lua?host=${rowData.ip}">${data}</a>`
      }
      return data;
  };


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$v, [
      createBaseVNode("div", _hoisted_2$q, [
        createBaseVNode("div", _hoisted_3$p, [
          createBaseVNode("div", _hoisted_4$m, [
            createBaseVNode("div", _hoisted_5$i, [
              createBaseVNode("div", _hoisted_6$b, [
                createBaseVNode("div", _hoisted_7$a, [
                  createBaseVNode("label", _hoisted_8$a, toDisplayString(_i18n('protocol')) + ": ", 1 /* TEXT */),
                  createVNode(script$1I, {
                    selected_option: selected_criteria.value,
                    "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_criteria).value = $event)),
                    options: unref(criteria_list),
                    onSelect_option: update_criteria
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_9$9, [
                createBaseVNode("div", _hoisted_10$9, [
                  createBaseVNode("label", _hoisted_11$8, toDisplayString(_i18n('application')) + ": ", 1 /* TEXT */),
                  createVNode(script$1I, {
                    selected_option: selected_application.value,
                    "onUpdate:selected_option": _cache[1] || (_cache[1] = $event => ((selected_application).value = $event)),
                    options: unref(application_list),
                    onSelect_option: update_port_list
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ])
              ]),
              createBaseVNode("div", _hoisted_12$8, [
                createBaseVNode("div", _hoisted_13$6, [
                  createBaseVNode("label", _hoisted_14$6, toDisplayString(_i18n('db_search.tags.srv_port')) + ": ", 1 /* TEXT */),
                  createVNode(script$1I, {
                    selected_option: selected_port.value,
                    "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((selected_port).value = $event)),
                    options: unref(port_list),
                    onSelect_option: update_port
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ])
              ])
            ]),
            createBaseVNode("div", null, [
              createVNode(script$1w, {
                ref_key: "table_server_ports_analysis",
                ref: table_server_ports_analysis,
                csrf: __props.csrf,
                table_id: table_id.value,
                f_map_columns: map_table_def_columns,
                get_extra_params_obj: get_extra_params_obj,
                onCustom_event: on_table_custom_event
              }, {
                custom_header: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (t, t_index) => {
                    return (openBlock(), createBlock(script$1J, {
                      f_on_open: get_open_filter_table_dropdown(t, t_index),
                      ref_for: true,
                      ref: el => { filter_table_dropdown_array.value[t_index] = el; },
                      hidden: t.hidden
                    }, {
                      title: withCtx(() => [
                        createVNode(script$1v, {
                          show: t.show_spinner,
                          size: "1rem",
                          class: "me-1"
                        }, null, 8 /* PROPS */, ["show"]),
                        createBaseVNode("a", {
                          class: "ntopng-truncate",
                          title: t.title
                        }, toDisplayString(t.label), 9 /* TEXT, PROPS */, _hoisted_15$5)
                      ]),
                      menu: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (opt) => {
                          return (openBlock(), createElementBlock("a", {
                            style: {"cursor":"pointer","display":"block"},
                            onClick: $event => (add_table_filter(opt, $event)),
                            class: "ntopng-truncate tag-filter",
                            title: opt.value
                          }, [
                            (opt.count == null)
                              ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                  createTextVNode(toDisplayString(opt.label), 1 /* TEXT */)
                                ], 64 /* STABLE_FRAGMENT */))
                              : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                  createTextVNode(toDisplayString(opt.label + " (" + opt.count + ")"), 1 /* TEXT */)
                                ], 64 /* STABLE_FRAGMENT */))
                          ], 8 /* PROPS */, _hoisted_16$5))
                        }), 256 /* UNKEYED_FRAGMENT */))
                      ]),
                      _: 2 /* DYNAMIC */
                    }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["f_on_open", "hidden"]))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["csrf", "table_id"])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$A.__file = "http_src/vue/page-hosts-ports-analysis.vue";

  const _hoisted_1$u = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$p = { class: "col-form-label col-sm-3" };
  const _hoisted_3$o = { class: "col-7" };
  const _hoisted_4$l = { key: 0 };
  const _hoisted_5$h = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_6$a = { class: "col-form-label col-sm-3" };
  const _hoisted_7$9 = { class: "col-7" };
  const _hoisted_8$9 = ["placeholder"];
  const _hoisted_9$8 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_10$8 = { class: "col-form-label col-sm-3" };
  const _hoisted_11$7 = { class: "col-7" };
  const _hoisted_12$7 = ["disabled"];


  var script$z = {
    __name: 'modal-nedge-add-repeater-config',
    props: {},
    emits: ['edit', 'add'],
    setup(__props, { expose, emit }) {

  const _i18n = (t) => i18n(t);
  const host_placeholder = i18n('if_stats_config.multicast_ip_placeholder');
  const modal_id = ref(null);
  const selected_interfaces = ref([]);
  const ip = ref(null);
  const repeater_type = ref({value: "mdns", label: "MDNS" });

  const interfaces_search = ref(null);

  const showed = () => {};



  const disable_add = ref(true);
  const invalid_iface_number = ref(true);
  const not_valid_ip = ref(true);

  const check_empty_host = () => {
    let regex = new RegExp(regexValidation.get_data_pattern('ip'));
    not_valid_ip.value = !(regex.test(ip.value) || ip.value === '*');
  	disable_add.value = update_disable_add();
  };


  const update_disable_add = () => {
  	if (repeater_type.value.value == 'custom') {
  		return (invalid_iface_number.value || not_valid_ip.value);
  	} else {
  		return (invalid_iface_number.value);
  	}
  };

  const title = ref("");

  const repeater_type_array = [
      { label: _i18n("nedge.page_repeater_config.modal_repeater_config.mdns"), value: "mdns", default: true },
      { label: _i18n("nedge.page_repeater_config.modal_repeater_config.custom"), value: "custom" },
  ];

  const repeater_id = ref(0);

  const selected_repeater_type = ref({});


  const interface_list_url = `${http_prefix}/lua/rest/v2/get/nedge/interfaces.lua`;
  let interface_list;
  const interface_array = ref([]);


  const button_text = ref("");

  const all_criteria = (item) => {
  	invalid_iface_number.value = item.length < 2;
  	disable_add.value = update_disable_add();
  };

  const update_interfaces_selected = (items) => {
  	selected_interfaces.value = items;
  };

  const remove_interfaces_selected = (item_to_delete) => {
  	selected_interfaces.value = selected_interfaces.value.filter((item) => item.label != item_to_delete.label);
  };

  const reset_modal = () => {
  	selected_repeater_type.value = {};
  	ip.value = "";
  	selected_interfaces.value = [];
  	not_valid_ip.value = true;
  	invalid_iface_number.value = true;
  };

  const show = (row ) => {
  	reset_modal();
      init(row);
      modal_id.value.show();
  };

  const is_open_in_add = ref(true);

  function init(row) {
      is_open_in_add.value = row == null;

      // check if we need open in edit
      if (is_open_in_add.value == false) {
  			not_valid_ip.value = false;
  			invalid_iface_number.value = false;
  			disable_add.value = false;
  			title.value = _i18n("nedge.page_rules_config.modal_rule_config.title_edit");
  			button_text.value = _i18n("edit");
  			repeater_id.value = row.repeater_id;
  			selected_repeater_type.value = repeater_type_array.find((s) => (s.value == row.type));
  			if (selected_repeater_type.value.value == 'custom') {
  				ip.value = row.ip;
  			}
  			change_repeater_type();

      } else {
  			title.value = _i18n("nedge.page_rules_config.modal_rule_config.title_add");
  			button_text.value = _i18n("add");
  			repeater_type_array.find((s) => s.default == true);
      }
  		
  		if (is_open_in_add.value == false) {
  			const row_interfaces = row.interfaces.split(",");
  			let tmp_selected_interfaces = [];
  			row_interfaces.forEach((row_iface) => {
  				if (row_iface != '' && row_iface != null) {
  					tmp_selected_interfaces.push(interface_array.value.find((iface) => iface.value == row_iface));
  				}
  			});

  			selected_interfaces.value = tmp_selected_interfaces;
  		}
  }

  async function change_repeater_type(type) {
  		repeater_type.value = selected_repeater_type.value;
      if (repeater_type.value.value == "custom") {
  			await set_interface_array();
  		}
  }



  let is_set_interface_array = false;
  async function set_interface_array() {
      if (is_set_interface_array == true) { return; }
  	if (interface_list == null) {
  	    interface_list = ntopng_utility$1.http_request(interface_list_url);
  	}
  	let res_interface_list = await interface_list;
  	interface_array.value = res_interface_list.filter(i => i.role == "lan").map((i) => {
  			return {
  		label: i.label,
  		value: i.ifname,
  			};
  	});
      is_set_interface_array = true;
  }


  const apply = () => {
      let repeater_t = repeater_type.value.value;
      let obj = {
  			repeater_type: repeater_t,
      };
  		if (repeater_type.value.value == "custom") {
  			let ip_t = ip.value;
  			obj = {
  				repeater_type: repeater_t,
  				ip: ip_t,
      	};
  		}
      let event = "add";
      if (is_open_in_add.value == false) {
  	obj.repeater_id = repeater_id.value;
  	event = "edit";
      }

  	let interfaces = [];
  	let details = [];
  	
  	selected_interfaces.value.forEach((i) => {
  		interfaces.push(i.value);
  		
  		if(i.value != i.label && !i.label.includes(i.value)) {
  			details.push(i.label+" ("+i.value+")");
  		} else {
  			details.push(i.label);
  		}
  	});

  	const tmp_interfaces = interfaces.join(",");
  	const tmp_details = details.join(",");

  	obj.interfaces = tmp_interfaces;
  	obj.interface_details = tmp_details;
      emit(event, obj);
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(async () => {
  	await set_interface_array();

  });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[4] || (_cache[4] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createCommentVNode(" Repeater Type "),
        createBaseVNode("div", _hoisted_1$u, [
          createBaseVNode("label", _hoisted_2$p, [
            createBaseVNode("b", null, toDisplayString(_i18n("nedge.page_repeater_config.modal_repeater_config.repeater_type")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$o, [
            createVNode(script$1I, {
              selected_option: selected_repeater_type.value,
              "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_repeater_type).value = $event)),
              onSelect_option: _cache[1] || (_cache[1] = $event => (change_repeater_type())),
              options: repeater_type_array
            }, null, 8 /* PROPS */, ["selected_option"])
          ])
        ]),
        createCommentVNode(" IP "),
        (selected_repeater_type.value.value == 'custom')
          ? (openBlock(), createElementBlock("div", _hoisted_4$l, [
              createBaseVNode("div", _hoisted_5$h, [
                createBaseVNode("label", _hoisted_6$a, [
                  createBaseVNode("b", null, toDisplayString(_i18n("nedge.page_repeater_config.ip")), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_7$9, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((ip).value = $event)),
                    onFocusout: check_empty_host,
                    class: "form-control col-7",
                    type: "text",
                    placeholder: unref(host_placeholder),
                    required: ""
                  }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_8$9), [
                    [vModelText, ip.value]
                  ])
                ])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_9$8, [
          createBaseVNode("label", _hoisted_10$8, [
            createBaseVNode("b", null, toDisplayString(_i18n("nedge.page_repeater_config.interfaces")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_11$7, [
            createVNode(script$1I, {
              ref_key: "interfaces_search",
              ref: interfaces_search,
              selected_options: selected_interfaces.value,
              "onUpdate:selected_options": _cache[3] || (_cache[3] = $event => ((selected_interfaces).value = $event)),
              options: interface_array.value,
              multiple: true,
              onSelect_option: update_interfaces_selected,
              onUnselect_option: remove_interfaces_selected,
              onChange_selected_options: all_criteria
            }, null, 8 /* PROPS */, ["selected_options", "options"])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          disabled: disable_add.value,
          onClick: apply,
          class: "btn btn-primary"
        }, toDisplayString(button_text.value), 9 /* TEXT, PROPS */, _hoisted_12$7)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$8 = "\ninput[data-v-5b3dc248]:invalid {\n  border-color: #ff0000;\n}\n";
  styleInject(css_248z$8);

  script$z.__scopeId = "data-v-5b3dc248";
  script$z.__file = "http_src/vue/modal-nedge-add-repeater-config.vue";

  const _hoisted_1$t = { class: "mb-2" };
  const _hoisted_2$o = /*#__PURE__*/createBaseVNode("br", null, null, -1 /* HOISTED */);
  const _hoisted_3$n = { id: "aggregated_live_flows" };


  var script$y = {
    __name: 'page-nedge-repeaters-config',
    props: {
      url: String,
      ifid: Number,
      csrf: String,
      columns_config: Array
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const timeout_delete = 1 * 500;



  const table_config = ref({});
  const table_rules = ref(null);
  const modal_add_repeater_config = ref(null);

  onBeforeMount(async () => {
      set_datatable_config();
  });

  function edit_repeater(repeater) {    
      const edit_url = `${http_prefix}/lua/rest/v2/edit/nedge/forwarder.lua`;
      set_rule(repeater, edit_url);
  }

  function add_repeater(repeater) {
      const add_url = `${http_prefix}/lua/rest/v2/add/nedge/forwarder.lua`;
      set_rule(repeater, add_url);
  }


  function set_rule(rule, url) {
      let headers = {
          'Content-Type': 'application/json'
      };
      let body = JSON.stringify({ ...rule, csrf: props.csrf});
      
      ntopng_utility$1.http_request(url, { method: "post", headers, body});
      refresh_table();    
  }



  const format_interfaces = function(data, rowData) { 
      return data.split(",").join(", ");
  };
  function set_datatable_config() {
      const datatableButton = [];
      
      let params = { 
  	ifid: ntopng_url_manager$1.get_url_entry("ifid") || props.ifid,	
      };
      let url_params = ntopng_url_manager$1.obj_to_url_params(params);
      
      datatableButton.push({
  	text: '<i class="fas fa-sync"></i>',
  	className: 'btn-link',
  	action: function (e, dt, node, config) {
  	    refresh_table();
              // table_rules.value.reload();
  	}
      }, {
  	text: '<i class="fas fa-plus"></i>',
  	className: 'btn-link',
  	action: function () {
  	    modal_add_repeater_config.value.show(null);
  	}
      });
      
      let defaultDatatableConfig = {
  	table_buttons: datatableButton,
  	data_url: `${props.url}?${url_params}`,
  	enable_search: false,
      };
      
      let columns = [
  	 { 
  	    columnName: _i18n("nedge.page_repeater_config.type"), targets: 0, name: 'type', data: 'type', className: 'text-nowrap text-left', responsivePriority: 1, render: function (data, _, rowData)  {
              if (data == "custom") {
                  return _i18n("nedge.page_repeater_config.modal_repeater_config.custom");
              } else {
                  return _i18n("nedge.page_repeater_config.modal_repeater_config.mdns");
              }
          }
  	},
       { 
  	    columnName: _i18n("nedge.page_repeater_config.ip"), targets: 0, name: 'ip', data: 'ip', className: 'text-nowrap text-left', responsivePriority: 1
  	},
       { 
  	    columnName: _i18n("nedge.page_repeater_config.port"), targets: 0, name: 'port', data: 'port', className: 'text-nowrap text-left', responsivePriority: 1
  	},
      {
  	    columnName: _i18n("nedge.page_repeater_config.interfaces"), targets: 0, name: 'interfaces', data: 'details', className: 'text-nowrap text-left', responsivePriority: 1, render: function (data,_,rowData)  {
  		    return format_interfaces(data)}
  	},
      ];
      let wrap_columns_config = columns.map((c) => c);
      // let wrap_columns_config = props.columns_config.map((c) => c);
      wrap_columns_config.push({ columnName: _i18n("actions"), width: '5%', name: 'actions', className: 'text-center', orderable: false, responsivePriority: 0, render: function (_, type, rowData) { return add_action_column(rowData) } });
      
      defaultDatatableConfig.columns_config = wrap_columns_config;
      table_config.value = defaultDatatableConfig;
  }

  const add_action_column = function (rowData) {
      let delete_handler = {
  	handlerId: "delete_host",	  
  	onClick: () => {
  	    delete_rule(rowData);
  	},
      };
      
      let edit_handler = {
  	handlerId: "edit_rule",
  	onClick: () => {
  	    modal_add_repeater_config.value.show(rowData);
  	},
      };
      
      return DataTableUtils.createActionButtons([
  	{ class: `pointer`, handler: edit_handler, handlerId: "edit_rule", icon: 'fa-edit', title: i18n('edit') },
  	{ class: `pointer`, handler: delete_handler, handlerId: "delete_rule", icon: 'fa-trash', title: i18n('delete') },
      ]);
  };

  function delete_rule(repeater) {
      const add_url = `${http_prefix}/lua/rest/v2/delete/nedge/forwarder.lua`;
      let headers = {
          'Content-Type': 'application/json'
      };
      let body = JSON.stringify({ repeater_id: repeater.repeater_id, csrf: props.csrf});
      
      ntopng_utility$1.http_request(add_url, { method: "post", headers, body});
      refresh_table();    
  }

  function refresh_table() {
      setTimeout(() => {
  	ntopng_url_manager$1.reload_url();
   	// table_rules.value.reload();
      }, timeout_delete);
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$t, [
        createBaseVNode("h2", null, toDisplayString(_i18n("nedge.repeaters_config_title")), 1 /* TEXT */),
        _hoisted_2$o
      ]),
      createBaseVNode("div", _hoisted_3$n, [
        createVNode(script$1g, {
          ref_key: "table_rules",
          ref: table_rules,
          table_buttons: table_config.value.table_buttons,
          columns_config: table_config.value.columns_config,
          data_url: table_config.value.data_url,
          filter_buttons: table_config.value.table_filters,
          enable_search: table_config.value.enable_search,
          table_config: table_config.value.table_config
        }, null, 8 /* PROPS */, ["table_buttons", "columns_config", "data_url", "filter_buttons", "enable_search", "table_config"])
      ]),
      createVNode(script$z, {
        ref_key: "modal_add_repeater_config",
        ref: modal_add_repeater_config,
        onAdd: add_repeater,
        onEdit: edit_repeater
      }, null, 512 /* NEED_PATCH */)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$y.__file = "http_src/vue/page-nedge-repeaters-config.vue";

  const _hoisted_1$s = {
    key: 0,
    class: "text-left"
  };


  var script$x = {
    __name: 'modal-delete-inactive-host',
    props: {
    context: Object,
  },
    emits: ["delete_host"],
    setup(__props, { expose, emit }) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const modal_id = ref(null);
  const message = ref('');
  const return_message = ref('');
  const show_return_msg = ref(false);
  const err = ref(false);


  const row_id = ref({});



  onMounted(() => {});

  async function delete_host() {
    const url = `${http_prefix}/lua/rest/v2/delete/host/inactive_host.lua`;
    const params = {
      csrf: props.context.csrf,
      ifid: props.context.ifid,
      serial_key: row_id.value,
    };

    let headers = {
      'Content-Type': 'application/json'
    };
    const res = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) }); 
    if(res) {
      err.value = false;
      show_return_msg.value = true;
      let num_hosts_msg = '';
      if(res.deleted_hosts > 1) {
        num_hosts_msg = '. Number hosts deleted: ' + res.deleted_hosts;
      }
      return_message.value = i18n('succ_del_inactive_hosts') + num_hosts_msg;
      emit("delete_host");
      close();
    } else {
      err.value = true;
      show_return_msg.value = true;
      return_message.value = i18n('err_del_inactive_hosts');
    }
  }


  const show = (_row_id, _message) => {
    row_id.value = _row_id;
    message.value = _message;
    modal_id.value.show();
  };

  const close = () => {
    setTimeout(() => {
      modal_id.value.close();
    }, 3000 /* 3 seconds */);
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("delete_inactive_host_title")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(message.value) + " ", 1 /* TEXT */),
        (show_return_msg.value)
          ? (openBlock(), createElementBlock("div", _hoisted_1$s, [
              createBaseVNode("p", {
                class: normalizeClass(["text-sm-start fs-6 fw-medium pt-3 m-0", (err.value) ? 'text-danger' : 'text-success'])
              }, [
                createBaseVNode("small", null, toDisplayString(return_message.value), 1 /* TEXT */)
              ], 2 /* CLASS */)
            ]))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: delete_host,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("delete")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$x.__file = "http_src/vue/modal-delete-inactive-host.vue";

  const _hoisted_1$r = {
    class: "mt-3",
    style: {"max-width":"8rem"}
  };
  const _hoisted_2$n = {
    key: 0,
    class: "text-left"
  };


  var script$w = {
    __name: 'modal-delete-inactive-host-epoch',
    props: {
    context: Object,
  },
    emits: ["delete_host"],
    setup(__props, { expose, emit }) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  ref('csv');
  const selected_epoch = ref();
  const return_message = ref('');
  const show_return_msg = ref(false);
  const err = ref(false);
  const epoch_list = [
    { label: _i18n("show_alerts.presets.5_min"), value: 300 },
    { label: _i18n("show_alerts.presets.30_min"), value: 1800 },
    { label: _i18n("show_alerts.presets.hour"), value: 3600 },
    { label: _i18n("show_alerts.presets.2_hours"), value: 7200 },
    { label: _i18n("show_alerts.presets.6_hours"), value: 21600 },
    { label: _i18n("show_alerts.presets.12_hours"), value: 43200 },
    { label: _i18n("show_alerts.presets.day"), value: 86400 },
    { label: _i18n("show_alerts.presets.week"), value: 604800 },
  ];


  const modal_id = ref();



  onMounted(() => { 
    selected_epoch.value = epoch_list[0];
  });

  function update_option(selected_value) {
    selected_epoch.value = selected_value;
  }

  async function delete_host() {
    const url = `${http_prefix}/lua/rest/v2/delete/host/inactive_host.lua`;
    const params = {
      csrf: props.context.csrf,
      ifid: props.context.ifid,
      serial_key: selected_epoch.value.value,
    };

    let headers = {
      'Content-Type': 'application/json'
    };
    const res = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
    if(res) {
      err.value = false;
      show_return_msg.value = true;
      let num_hosts_msg = '';
      if(res.deleted_hosts > 1) {
        num_hosts_msg = '. Number hosts deleted: ' + res.deleted_hosts;
      }
      return_message.value = i18n('succ_del_inactive_hosts') + num_hosts_msg;
      emit("delete_host");
      close();
    } else {
      err.value = true;
      show_return_msg.value = true;
      return_message.value = i18n('err_del_inactive_hosts');
    }
  }

  const show = () => {
    modal_id.value.show();
  };

  const close = () => {
    setTimeout(() => {
      modal_id.value.close();
    }, 3000 /* 3 seconds */);
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("delete")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("delete_since")) + " ", 1 /* TEXT */),
        createBaseVNode("div", _hoisted_1$r, [
          createVNode(script$1I, {
            selected_option: selected_epoch.value,
            "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_epoch).value = $event)),
            options: epoch_list,
            onSelect_option: update_option
          }, null, 8 /* PROPS */, ["selected_option"])
        ]),
        (show_return_msg.value)
          ? (openBlock(), createElementBlock("div", _hoisted_2$n, [
              createBaseVNode("p", {
                class: normalizeClass(["text-sm-start fs-6 fw-medium pt-3 m-0", (err.value) ? 'text-danger' : 'text-success'])
              }, [
                createBaseVNode("small", null, toDisplayString(return_message.value), 1 /* TEXT */)
              ], 2 /* CLASS */)
            ]))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: delete_host,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("delete")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$w.__file = "http_src/vue/modal-delete-inactive-host-epoch.vue";

  const _hoisted_1$q = {
    class: "mt-3",
    style: {"max-width":"8rem"}
  };


  var script$v = {
    __name: 'modal-download-inactive-host',
    props: {
    context: Object,
  },
    emits: ["download"],
    setup(__props, { expose, emit }) {

  const _i18n = (t) => i18n(t);
  ref('csv');
  const selected_format = ref();
  const format_list = [
    { label: _i18n("csv"), value: "csv", param: "csv" },
    { label: _i18n("json"), value: "json", param: "json" },
  ];


  const modal_id = ref();



  onMounted(() => { 
    selected_format.value = format_list[0];
  });

  function update_option(selected_value) {
    selected_format.value = selected_value;
  }

  async function download() {
    let params = ntopng_url_manager.get_url_object(window.location.search);
    params.download = true;
    params.format = selected_format.value.value;
    const url = `${http_prefix}/lua/rest/v2/get/host/inactive_list.lua?` + ntopng_url_manager.obj_to_url_params(params);
    ntopng_utility$1.download_URI(url, "inactive_hosts." + selected_format.value.value);
    emit("download");
    close();
  }

  const show = () => {
    modal_id.value.show();
  };

  const close = () => {
    modal_id.value.close();
  };

  expose({ show, close });


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("download")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("download_format")) + " ", 1 /* TEXT */),
        createBaseVNode("div", _hoisted_1$q, [
          createVNode(script$1I, {
            selected_option: selected_format.value,
            "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_format).value = $event)),
            options: format_list,
            onSelect_option: update_option
          }, null, 8 /* PROPS */, ["selected_option"])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: download,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("download")), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$v.__file = "http_src/vue/modal-download-inactive-host.vue";

  const _hoisted_1$p = { class: "row" };
  const _hoisted_2$m = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$m = { class: "card card-shadow" };
  const _hoisted_4$k = { class: "card-body" };
  const _hoisted_5$g = {
    key: "1",
    class: "row mb-4 mt-4",
    id: "host_details_traffic"
  };
  const _hoisted_6$9 = { class: "col-4" };
  const _hoisted_7$8 = { class: "widget-name" };
  const _hoisted_8$8 = ["title"];
  const _hoisted_9$7 = ["onClick", "title"];
  const _hoisted_10$7 = { class: "card-footer mt-3" };
  const _hoisted_11$6 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_12$6 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_13$5 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-download" }, null, -1 /* HOISTED */);
  const _hoisted_14$5 = [
    _hoisted_13$5
  ];


  var script$u = {
    __name: 'page-inactive-hosts',
    props: {
    ifid: Number,
    csrf: String,
    show_historical: Boolean,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const table_id = ref('inactive_hosts');
  ref(_i18n('local_hosts_only'));
  const filter_table_array = ref([]);
  const filter_table_dropdown_array = ref([]);
  const table_inactive_hosts = ref();
  const modal_download = ref();
  const modal_delete = ref();
  const modal_delete_older = ref();
  const chart_1 = ref();
  const chart_2 = ref();
  const chart_3 = ref();
  const show_charts = ref(false);
  const inactive_hosts_tab_list = ref();
  ref();
  const change_applications_tab_event = "change_applications_tab_event";

  const context = ref({
    csrf: props.csrf,
    ifid: props.ifid
  });
  const chart_options = [
    {
      ref: chart_1,
      title: i18n('active_inactive'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/inactive/active_inactive.lua`,
      id: `active_inactive_distro`,
    },
    {
      ref: chart_2,
      title: i18n('inactivity_period'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/inactive/inactivity_period.lua`,
      id: `inactivity_period`,
    },
    {
      ref: chart_3,
      title: i18n('manufacturer'),
      type: ntopChartApex.typeChart.DONUT,
      url: `${http_prefix}/lua/rest/v2/get/host/inactive/inactive_manufacturer.lua`,
      id: `inactive_manufacturer`,
    },
  ];

  const tab_list = ref([
    {
      title: i18n('table_view'),
      active: (show_charts.value == false),
      id: "table"
    },
    {
      title: i18n('chart_view'),
      active: (show_charts.value == true),
      id: "chart"
    },
  ]);

  /* ************************************** */

  onMounted(async () => {
    ntopng_events_manager.on_custom_event("change_applications_tab_event", change_applications_tab_event, (tab) => {
      ntopng_url_manager$1.set_key_to_url('view', tab.id);
    });
    load_table_filters_overview();
  });

  /* ************************************** */

  const get_open_filter_table_dropdown = (filter, filter_index) => {
    return (_) => {
      load_table_filters(filter, filter_index);
    };
  };

  /* ************************************** */

  async function load_table_filters_overview(action) {
    filter_table_array.value = await load_table_filters_array("overview");
    set_filter_array_label();
  }

  /* ************************************** */

  function set_filter_array_label() {
    filter_table_array.value.forEach((el, index) => {
      if (el.basic_label == null) {
        el.basic_label = el.label;
      }

      const url_entry = ntopng_url_manager$1.get_url_entry(el.id);
      if (url_entry != null) {
        el.options.forEach((option) => {
          if (option.value.toString() === url_entry) {
            el.label = `${el.basic_label}: ${option.label || option.value}`;
          }
        });
      } else {
        el.label = `${el.basic_label}: ${el.options[0].label || el.options[0].value}`;
      }
    });
  }

  /* ************************************** */

  async function load_table_filters(filter, filter_index) {
    filter.show_spinner = true;
    await nextTick();
    if (filter.data_loaded == false) {
      let new_filter_array = await load_table_filters_array(filter.id);
      filter.options = new_filter_array.find((t) => t.id == filter.id).options;
      await nextTick();
      let dropdown = filter_table_dropdown_array.value[filter_index];
      dropdown.load_menu();
    }
    filter.show_spinner = false;
  }

  /* ************************************** */

  async function load_table_filters_array(action) {
    const params = ntopng_url_manager$1.get_url_params();
    const url = `${http_prefix}/lua/rest/v2/get/host/inactive_filters.lua?action=${action}&${params}`;
    let res = await ntopng_utility.http_request(url);
    return res.map((t) => {
      return {
        id: t.action || t.name,
        label: t.label,
        title: t.tooltip,
        data_loaded: action != 'overview',
        options: t.value,
        hidden: (t.value.length == 1)
      };
    });
  }

  /* ************************************** */

  function add_table_filter(opt, event, filter, filter_index) {
    event.stopPropagation();
    ntopng_url_manager$1.set_key_to_url(opt.key, `${opt.value}`);
    set_filter_array_label();
    table_inactive_hosts.value.refresh_table();
    if (show_charts.value == true) {
      chart_options.forEach((el) => {
        el.ref.value[0].update_chart();
      });
    }
    load_table_filters(filter, filter_index);
  }

  /* ************************************** */

  function refresh_table() {
    table_inactive_hosts.value.refresh_table();
  }

  /* ************************************** */

  function change_show_charts(item) {
    show_charts.value = !show_charts.value;
    tab_list.value.forEach((i) => {
      i.active = false;
      if(i.id == "table" && show_charts.value == false)
        i.active = true;
      else if(i.id == "chart" && show_charts.value == true)
        i.active = true;
    });
    ntopng_events_manager.emit_custom_event(change_applications_tab_event, item);
  }

  /* ************************************** */

  const get_extra_params_obj = () => {
    let extra_params = ntopng_url_manager$1.get_url_object();
    return extra_params;
  };

  /* ************************************** */

  function on_table_custom_event(event) {
    let events_managed = {
      "click_button_historical_flows": click_button_historical_flows,
      "click_button_delete": click_button_delete,
    };
    if (events_managed[event.event_id] == null) {
      return;
    }
    events_managed[event.event_id](event);
  }

  /* ************************************** */

  function click_button_delete(event) {
    const row = event.row.serial_key;
    modal_delete.value.show(row, i18n('delete_inactive_host', { host: event.row.host.ip_address.value }));
  }

  /* ************************************** */

  function delete_all_entries() {
    modal_delete.value.show('all', i18n('delete_all_inactive_hosts'));
  }

  /* ************************************** */

  function delete_entries_since() {
    modal_delete_older.value.show();
  }

  /* ************************************** */

  function download() {
    modal_download.value.show();
  }

  /* ************************************** */

  function click_button_historical_flows(event) {
    const row = event.row;
    let vlan = '';
    if(row.vlan != 0)
      vlan = `@${row.vlan}`;
    window.location.href = `${http_prefix}/lua/pro/db_search.lua?epoch_begin=${row.epoch_begin - 100}&epoch_end=${row.epoch_end + 100}&ip=${row.ip_address.value || row.ip_address}${vlan};eq&mac=${row.mac_address.value || row.mac_address};eq`;
  }

  /* ************************************** */

  const map_table_def_columns = (columns) => {
    let map_columns = {
      "mac_address": (mac, row) => {
        let result = mac;
        if (mac != null &&
          mac.url != null &&
          mac.name != null &&
          mac.value != null) {
          result = `<a href='${http_prefix}${mac.url}' title='${mac.value}'>${mac.name}</a>`;
        }

        return result;
      },
      "network": (network, row) => {
        let result = network;
        if (network.url != null &&
          network.name != null &&
          network.value != null) {
          result = `<a href='${http_prefix}${network.url}' title='${network.value}'>${network.name}</a>`;
        }

        return result;
      },
      "host": (host, row) => {
        let result = '';
        const ip_address = host.ip_address;
        result = `<a href='${http_prefix}${ip_address.url}' title='${ip_address.value}'>${ip_address.name}</a>`;

        if (host.vlan != null && host.vlan.name != "") {
          const vlan = host.vlan;
          if (vlan.url != null) {
            result = `${result}@<a href='${http_prefix}${vlan.url || '#'}' title='${vlan.value}'>${vlan.name}</a>`;
          } else {
            result = `${result}@${vlan.name}`;
          }
        }
        return `${result} ${host.device_type}`;
      },
    };

    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];
      if (c.id == "actions") {
        const visible_dict = {
          historical_data: props.show_historical,
        };
        c.button_def_array.forEach((b) => {
          if (!visible_dict[b.id]) {
            b.class.push("disabled");
          }
        });
      }
    });

    return columns;
  };

  /* ************************************** */


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$p, [
        createBaseVNode("div", _hoisted_2$m, [
          createBaseVNode("div", _hoisted_3$m, [
            createBaseVNode("div", _hoisted_4$k, [
              createVNode(script$1d, {
                ref_key: "inactive_hosts_tab_list",
                ref: inactive_hosts_tab_list,
                id: "inactive_hosts_tab_list",
                tab_list: tab_list.value,
                onClick_item: change_show_charts
              }, null, 8 /* PROPS */, ["tab_list"]),
              createCommentVNode("\n          <div class=\"card card-shadow\">\n            <div class=\"card-body p-1\">\n              <transition name=\"component-fade\" mode=\"out-in\">\n                <div key=\"1\" v-if=\"show_charts == true\" class=\"row mb-4 mt-4\" id=\"host_details_traffic\">\n                  \n                </div>\n              </transition>\n            </div>\n          </div>\n          <div class=\"text-center\" style=\"cursor: pointer;\" @click=\"change_show_charts\">\n            <i v-if=\"show_charts == false\" class=\"fa-solid fa-angles-down\"></i>\n            <i v-else class=\"fa-solid fa-angles-up\"></i>\n          </div>\n          "),
              createBaseVNode("div", null, [
                (show_charts.value == true)
                  ? (openBlock(), createElementBlock("div", _hoisted_5$g, [
                      (show_charts.value == true)
                        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, renderList(chart_options, (chart_option) => {
                            return createBaseVNode("div", _hoisted_6$9, [
                              createBaseVNode("h3", _hoisted_7$8, toDisplayString(chart_option.title), 1 /* TEXT */),
                              createVNode(script$1F, {
                                ref_for: true,
                                ref: chart_option.ref,
                                id: chart_option.id,
                                chart_type: chart_option.type,
                                base_url_request: chart_option.url,
                                register_on_status_change: true
                              }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
                            ])
                          }), 64 /* STABLE_FRAGMENT */))
                        : createCommentVNode("v-if", true)
                    ]))
                  : (openBlock(), createBlock(script$1w, {
                      key: 1,
                      ref_key: "table_inactive_hosts",
                      ref: table_inactive_hosts,
                      table_id: table_id.value,
                      csrf: __props.csrf,
                      f_map_columns: map_table_def_columns,
                      get_extra_params_obj: get_extra_params_obj,
                      onCustom_event: on_table_custom_event
                    }, {
                      custom_header: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (t, t_index) => {
                          return (openBlock(), createBlock(script$1J, {
                            f_on_open: get_open_filter_table_dropdown(t, t_index),
                            ref_for: true,
                            ref: el => { filter_table_dropdown_array.value[t_index] = el; },
                            hidden: t.hidden
                          }, {
                            title: withCtx(() => [
                              createVNode(script$1v, {
                                show: t.show_spinner,
                                size: "1rem",
                                class: "me-1"
                              }, null, 8 /* PROPS */, ["show"]),
                              createBaseVNode("a", {
                                class: "ntopng-truncate",
                                title: t.title
                              }, toDisplayString(t.label), 9 /* TEXT, PROPS */, _hoisted_8$8)
                            ]),
                            menu: withCtx(() => [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (opt) => {
                                return (openBlock(), createElementBlock("a", {
                                  style: {"cursor":"pointer","display":"block"},
                                  onClick: $event => (add_table_filter(opt, $event, t, t_index)),
                                  class: "ntopng-truncate tag-filter",
                                  title: opt.value
                                }, [
                                  (opt.count == null)
                                    ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                        createTextVNode(toDisplayString(opt.label), 1 /* TEXT */)
                                      ], 64 /* STABLE_FRAGMENT */))
                                    : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                        createTextVNode(toDisplayString(opt.label + " (" + opt.count + ")"), 1 /* TEXT */)
                                      ], 64 /* STABLE_FRAGMENT */))
                                ], 8 /* PROPS */, _hoisted_9$7))
                              }), 256 /* UNKEYED_FRAGMENT */))
                            ]),
                            _: 2 /* DYNAMIC */
                          }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["f_on_open", "hidden"]))
                        }), 256 /* UNKEYED_FRAGMENT */)),
                        createCommentVNode(" Dropdown filters ")
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["table_id", "csrf"]))
              ]),
              createBaseVNode("div", _hoisted_10$7, [
                createBaseVNode("button", {
                  type: "button",
                  ref: "delete_all",
                  onClick: delete_all_entries,
                  class: "btn btn-danger me-1"
                }, [
                  _hoisted_11$6,
                  createTextVNode(" " + toDisplayString(_i18n("delete_all_entries")), 1 /* TEXT */)
                ], 512 /* NEED_PATCH */),
                createBaseVNode("button", {
                  type: "button",
                  ref: "delete_older",
                  onClick: delete_entries_since,
                  class: "btn btn-danger me-1"
                }, [
                  _hoisted_12$6,
                  createTextVNode(" " + toDisplayString(_i18n("delete_older")), 1 /* TEXT */)
                ], 512 /* NEED_PATCH */),
                createBaseVNode("button", {
                  type: "button",
                  ref: "download",
                  onClick: download,
                  class: "btn btn-primary me-1"
                }, _hoisted_14$5, 512 /* NEED_PATCH */)
              ])
            ])
          ])
        ])
      ]),
      createVNode(script$x, {
        ref_key: "modal_delete",
        ref: modal_delete,
        context: context.value,
        onDelete_host: refresh_table
      }, null, 8 /* PROPS */, ["context"]),
      createVNode(script$w, {
        ref_key: "modal_delete_older",
        ref: modal_delete_older,
        context: context.value,
        onDelete_host: refresh_table
      }, null, 8 /* PROPS */, ["context"]),
      createVNode(script$v, {
        ref_key: "modal_download",
        ref: modal_download,
        context: context.value
      }, null, 8 /* PROPS */, ["context"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$u.__file = "http_src/vue/page-inactive-hosts.vue";

  const _hoisted_1$o = { class: "row" };
  const _hoisted_2$l = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$l = { class: "mt-4 card card-shadow" };
  const _hoisted_4$j = { class: "card-body" };


  var script$t = {
    __name: 'page-inactive-host-details',
    props: {
    ifid: Number,
    csrf: String,
  },
    setup(__props) {

  const _i18n = (t) => i18n(t);

  const url = "/lua/rest/v2/get/host/inactive_host.lua";
  const table_id = ref('inactive_host_details');


  const stats_rows = ref([]);

  const print_html_title = function (name) {
    return (name || "");
  };

  const print_stats_row = function (value) {
    let label = value.name || '';
    if (value.url && value.url != '')
      label = `<a href="${http_prefix}${value.url}">${label}</>`;

    return label;
  };

  onMounted(async () => {
    const extra_params = ntopng_url_manager.get_url_object();
    const url_params = ntopng_url_manager.obj_to_url_params(extra_params);
    const host_stats = await ntopng_utility.http_request(`${http_prefix}${url}?${url_params}`);
    stats_rows.value = host_stats.host_info;
    $('#navbar_title').html("<i class='fas fa-laptop'></i> " + _i18n('host_details.host') + ": " + host_stats.host_name);
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$o, [
      createBaseVNode("div", _hoisted_2$l, [
        createBaseVNode("div", _hoisted_3$l, [
          createBaseVNode("div", _hoisted_4$j, [
            createVNode(script$1f, {
              horizontal: true,
              id: table_id.value,
              rows: stats_rows.value,
              print_html_title: print_html_title,
              print_html_row: print_stats_row
            }, null, 8 /* PROPS */, ["id", "rows"])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$t.__file = "http_src/vue/page-inactive-host-details.vue";

  const _hoisted_1$n = { class: "table table-bordered table-striped" };


  var script$s = {
    __name: 'page-flowdevice-config',
    props: {
    ifid: Number,
    csrf: String,
    flowdev_ip: String,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const custom_name = ref(null);
  const prev_name = ref('');
  const disabled = ref(true);

  const get_flowdev_alias_url = `${http_prefix}/lua/pro/rest/v2/get/flowdevice/alias.lua?flowdev_ip=${props.flowdev_ip}&ifid=${props.ifid}`;
  const update_flowdev_alias_url = `${http_prefix}/lua/pro/rest/v2/set/flowdevice/alias.lua`;

  onMounted(async () => {
    getFlowDevAlias();
  });

  async function getFlowDevAlias() {
    const rsp = await ntopng_utility.http_request(`${get_flowdev_alias_url}`, { method: 'get' });
    custom_name.value.value = rsp || props.flowdev_ip;
    prev_name.value = custom_name.value.value;
  }

  const updateFlowDevAlias = async function() {
    const params = {
      csrf: props.csrf,
      flowdev_ip: props.flowdev_ip,
      alias: custom_name.value.value,
      ifid: props.ifid
    };
    let headers = {
      'Content-Type': 'application/json'
    };
    await ntopng_utility.http_request(update_flowdev_alias_url, { method: 'post', headers, body: JSON.stringify(params) });
    getFlowDevAlias();
    disabled.value = true;
  };

  const checkDisabled = function() {
    if (prev_name.value == custom_name.value.value) {
      disabled.value = true;
    } else {
      disabled.value = false;
    }
  };

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("table", _hoisted_1$n, [
        createBaseVNode("tr", null, [
          createBaseVNode("th", null, toDisplayString(_i18n("flowdev_alias")), 1 /* TEXT */),
          createBaseVNode("td", null, [
            createBaseVNode("input", {
              type: "text",
              ref_key: "custom_name",
              ref: custom_name,
              class: "form-control",
              onInput: checkDisabled
            }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */)
          ])
        ])
      ]),
      createBaseVNode("button", {
        class: normalizeClass(["btn btn-primary", [disabled.value ? 'disabled' : '']]),
        onClick: updateFlowDevAlias,
        id: "save"
      }, toDisplayString(_i18n("save_settings")), 3 /* TEXT, CLASS */)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$s.__file = "http_src/vue/page-flowdevice-config.vue";

  const _hoisted_1$m = { class: "table table-striped table-bordered col-sm-12" };
  const _hoisted_2$k = { class: "col-3" };
  const _hoisted_3$k = { class: "col-9" };
  const _hoisted_4$i = { class: "d-flex ps-0" };
  const _hoisted_5$f = { class: "col-3" };
  const _hoisted_6$8 = { class: "col-9" };
  const _hoisted_7$7 = { class: "d-flex ps-0" };
  const _hoisted_8$7 = { class: "d-flex align-items-center me-2" };
  const _hoisted_9$6 = { class: "col-3" };
  const _hoisted_10$6 = { class: "col-9" };
  const _hoisted_11$5 = { class: "d-flex ps-0" };
  const _hoisted_12$5 = { class: "d-flex align-items-center me-2" };


  var script$r = {
    __name: 'page-flowdevice-interface-config',
    props: {
    ifid: String,
    csrf: String,
    device_ip: String,
    port_index: String,
  },
    setup(__props) {

  const props = __props;

  const BIT_VALUE = 1000000000;
  const _i18n = (t) => i18n(t);
  const custom_name = ref(null);
  const prev_name = ref('');
  const uplink_speed = ref(null);
  const prev_uplink_speed = ref('');
  const downlink_speed = ref(null);
  const prev_downlink_speed = ref('');
  const disabled = ref(true);


  const get_interface_config_url = `${http_prefix}/lua/pro/rest/v2/get/flowdevice/interface/config.lua?device_ip=${props.device_ip}&port_index=${props.port_index}&ifid=${props.ifid}`;
  const update_interface_config_url = `${http_prefix}/lua/pro/rest/v2/set/flowdevice/interface/config.lua`;

  onMounted(async () => {
    getFlowDeviceInterfaceConfig();
  });

  async function getFlowDeviceInterfaceConfig() {
    const rsp = await ntopng_utility.http_request(`${get_interface_config_url}`, { method: 'get' });
    custom_name.value.value = rsp.alias;
    prev_name.value = custom_name.value.value;
    uplink_speed.value.value = rsp.uplink_speed / BIT_VALUE;
    prev_uplink_speed.value = uplink_speed.value.value;
    downlink_speed.value.value = rsp.downlink_speed / BIT_VALUE;
    prev_downlink_speed.value = downlink_speed.value.value;
  }

  const updateInterfaceConfig = async function () {
    const params = {
      ifid: props.ifid,
      csrf: props.csrf,
      device_ip: props.device_ip,
      port_index: props.port_index,
      alias: custom_name.value.value,
      uplink_speed: Number(uplink_speed.value.value) * BIT_VALUE,
      downlink_speed: Number(downlink_speed.value.value) * BIT_VALUE,
    };
    let headers = {
      'Content-Type': 'application/json'
    };
    await ntopng_utility.http_request(update_interface_config_url, { method: 'post', headers, body: JSON.stringify(params) });
    getFlowDeviceInterfaceConfig();
    disabled.value = true;
  };

  const checkDisabled = function () {
    if (prev_name.value == custom_name.value.value
      && prev_uplink_speed.value == uplink_speed.value.value
      && prev_downlink_speed.value == downlink_speed.value.value) {
      disabled.value = true;
    } else {
      disabled.value = false;
    }
  };

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("table", _hoisted_1$m, [
        createBaseVNode("tbody", null, [
          createBaseVNode("tr", null, [
            createBaseVNode("th", _hoisted_2$k, toDisplayString(_i18n("interface_alias")), 1 /* TEXT */),
            createBaseVNode("td", _hoisted_3$k, [
              createBaseVNode("div", _hoisted_4$i, [
                createBaseVNode("input", {
                  type: "text",
                  ref_key: "custom_name",
                  ref: custom_name,
                  class: "form-control",
                  style: {"width":"16rem"},
                  onInput: checkDisabled
                }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */)
              ])
            ])
          ]),
          createBaseVNode("tr", null, [
            createBaseVNode("th", _hoisted_5$f, toDisplayString(_i18n("interface_uplink_speed")), 1 /* TEXT */),
            createBaseVNode("td", _hoisted_6$8, [
              createBaseVNode("div", _hoisted_7$7, [
                createBaseVNode("label", _hoisted_8$7, toDisplayString(_i18n("gbit")), 1 /* TEXT */),
                createBaseVNode("input", {
                  ref_key: "uplink_speed",
                  ref: uplink_speed,
                  class: "form-control text-end",
                  type: "number",
                  min: "0",
                  step: "0.01",
                  style: {"width":"8rem"},
                  onInput: checkDisabled
                }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */)
              ])
            ])
          ]),
          createBaseVNode("tr", null, [
            createBaseVNode("th", _hoisted_9$6, toDisplayString(_i18n("interface_downlink_speed")), 1 /* TEXT */),
            createBaseVNode("td", _hoisted_10$6, [
              createBaseVNode("div", _hoisted_11$5, [
                createBaseVNode("label", _hoisted_12$5, toDisplayString(_i18n("gbit")), 1 /* TEXT */),
                createBaseVNode("input", {
                  ref_key: "downlink_speed",
                  ref: downlink_speed,
                  class: "form-control text-end",
                  type: "number",
                  min: "0",
                  step: "0.001",
                  style: {"width":"8rem"},
                  onInput: checkDisabled
                }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */)
              ])
            ])
          ])
        ])
      ]),
      createBaseVNode("button", {
        class: normalizeClass(["btn btn-primary d-flex ms-auto", [disabled.value ? 'disabled' : '']]),
        onClick: updateInterfaceConfig,
        id: "save"
      }, toDisplayString(_i18n("save_settings")), 3 /* TEXT, CLASS */)
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$r.__file = "http_src/vue/page-flowdevice-interface-config.vue";

  var script$q = {
    __name: 'modal-delete-scan-confirm',
    props: {
      body: String,
      title: String,
  },
    emits: ['delete','delete_all'],
    setup(__props, { expose, emit }) {

  const modal_id = ref(null);


  const showed = () => {};


  const body = ref('');
  const title = ref('');
  const delete_type = ref('');
  const show_note_list = ref(true);
  const note_list = [
    i18n('note_scan_host')
  ];

  const show = (type, value) => {
    show_note_list.value = false;
    delete_type.value = type;

      if(type == "delete_all") {
        title.value = i18n("delete_all_entries");
        body.value = value;
      } else if(type == "delete_single_row") {
        title.value = i18n("delete_vs_host_title");
        body.value = value;
      } else if(type == "scan_all_rows") {
        title.value = i18n("scan_all_hosts_title");
        body.value = value;
      } else if(type == "scan_row") {
        show_note_list.value = true;
        title.value = i18n("scan_host_title");
        body.value = value;
      } else if (type == "delete_single_report") {
        title.value = i18n("hosts_stats.page_scan_hosts.reports_page.delete_title");
        body.value = i18n("hosts_stats.page_scan_hosts.reports_page.delete_description");
      }
      
      modal_id.value.show();
  };

  const delete_ = () => {
      if (delete_type.value == "delete_all") {
        emit('delete_all');
      } else if ( delete_type.value == "delete_single_row" || delete_type.value == "delete_single_report") {
        emit('delete');
      } else if (delete_type.value == "scan_all_rows") {
        emit('scan_all_rows');
      } else if (delete_type.value == "scan_row") {
        emit('scan_row');
      }
      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[0] || (_cache[0] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createTextVNode(toDisplayString(body.value) + " ", 1 /* TEXT */),
        (show_note_list.value)
          ? (openBlock(), createBlock(script$1u, {
              key: 0,
              note_list: note_list
            }))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        (delete_type.value == 'delete_all' || delete_type.value == 'delete_single_row' || delete_type.value == 'delete_single_report')
          ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: delete_,
              class: "btn btn-danger"
            }, toDisplayString(_i18n('delete')), 1 /* TEXT */))
          : (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              onClick: delete_,
              class: "btn btn-primary"
            }, toDisplayString(_i18n('hosts_stats.page_scan_hosts.schedule_scan')), 1 /* TEXT */))
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$q.__file = "http_src/vue/modal-delete-scan-confirm.vue";

  const _hoisted_1$l = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$j = { class: "col-form-label col-sm-4" };
  const _hoisted_3$j = { class: "col-8" };


  var script$p = {
    __name: 'modal-update-periodicity-scan',
    props: {
          title: String,
      },
    emits: ['update',],
    setup(__props, { expose, emit }) {

  const modal_id = ref(null);



  const automatic_scan_frequencies_list = ref([
    { id: "disabled", label:i18n('hosts_stats.page_scan_hosts.disabled')},
    { id: "1day", label:i18n('hosts_stats.page_scan_hosts.every_night')},
    { id: "1week", label:i18n('hosts_stats.page_scan_hosts.every_week')},
  ]);

  let selected_scan_frequency = ref(automatic_scan_frequencies_list.value[0]);
      
  const showed = () => {};

  //  const title = ref(i18n("hosts_stats.page_scan_hosts.delete_host_title"))

  const show = (row) => {
    modal_id.value.show();
  };

  const update_ = () => {
      emit('update', {scan_frequency: selected_scan_frequency.value.id});

      close();
  };

  const close = () => {
      modal_id.value.close();
  };


  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[1] || (_cache[1] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$l, [
          createBaseVNode("label", _hoisted_2$j, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.automatic_scan")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$j, [
            createVNode(script$1I, {
              selected_option: unref(selected_scan_frequency),
              "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => (isRef(selected_scan_frequency) ? (selected_scan_frequency).value = $event : selected_scan_frequency = $event)),
              options: automatic_scan_frequencies_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: update_,
          class: "btn btn-secondary me-4"
        }, toDisplayString(_i18n('hosts_stats.page_scan_hosts.update_all')), 1 /* TEXT */)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$p.__file = "http_src/vue/modal-update-periodicity-scan.vue";

  const _hoisted_1$k = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$i = { class: "col-form-label col-sm-2" };
  const _hoisted_3$i = { class: "col-sm-4 pe-0" };
  const _hoisted_4$h = ["disabled", "placeholder"];
  const _hoisted_5$e = /*#__PURE__*/createBaseVNode("div", { class: "col-1 ps-5 pe-0 mt-1" }, [
    /*#__PURE__*/createBaseVNode("span", null, "/")
  ], -1 /* HOISTED */);
  const _hoisted_6$7 = { class: "col-2 ps-0" };
  const _hoisted_7$6 = ["disabled", "placeholder"];
  const _hoisted_8$6 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_9$5 = { class: "col-form-label col-sm-2" };
  const _hoisted_10$5 = { class: "col-sm-10" };
  const _hoisted_11$4 = ["placeholder"];
  const _hoisted_12$4 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_13$4 = { class: "col-form-label col-sm-2" };
  const _hoisted_14$4 = { class: "col-10" };
  const _hoisted_15$4 = {
    key: 0,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_16$4 = { class: "col-form-label col-sm-2" };
  const _hoisted_17$4 = { class: "col-10" };
  const _hoisted_18$4 = {
    key: 1,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_19$4 = { class: "col-form-label col-sm-2" };
  const _hoisted_20$4 = { class: "col-10" };
  const _hoisted_21$3 = { class: "mt-4" };
  const _hoisted_22$3 = {
    key: 0,
    class: "me-auto text-danger d-inline"
  };
  const _hoisted_23$3 = ["disabled"];
  const _hoisted_24$3 = ["disabled"];

  /* ****************************************************** */


  var script$o = {
    __name: 'modal-add-vs-host',
    props: {
    context: Object,
  },
    emits: ["add", "edit"],
    setup(__props, { expose, emit }) {

  /* Imports */
  const _i18n = (t) => i18n(t);



  /* Consts */
  const title = ref(i18n("hosts_stats.page_scan_hosts.add_host"));
  const no_host_feedback = ref(i18n("hosts_stats.page_scan_hosts.host_not_resolved"));
  const host_placeholder = i18n("hosts_stats.page_scan_hosts.host_placeholder");
  const cidr_placeholder = i18n("hosts_stats.page_scan_hosts.cidr_placeholder");
  const ports_placeholder = i18n("hosts_stats.page_scan_hosts.ports_placeholder");
  const note_list = [
    _i18n("hosts_stats.page_scan_hosts.notes.note_1"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_2"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_3"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_3_1"),
  ];
  const enterprise_note_list = [
    _i18n("hosts_stats.page_scan_hosts.notes.note_1"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_2"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_3"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_3_1"),
    _i18n("hosts_stats.page_scan_hosts.notes.note_4"),
  ];

  const modal_id = ref(null);
  const selected_scan_type = ref({});
  const selected_discovered_scan_types = ref([]); // array for hosts discovered scan types
  const hide_ports_placeholder = ref("");
  const row_to_edit_id = ref("");
  const activate_add_spinner = ref(false);
  const is_edit_page = ref(false);
  const scan_type_list = ref([]);
  const discovered_scan_type_list = ref([]);
  const ifid = ref(null);
  const host = ref(null);
  const ports = ref(null);
  const show_port_feedback = ref(false);
  const is_enterprise_l = ref(null);
  const is_port_correct = ref(true);
  const is_cidr_correct = ref(false);
  const is_netscan_ok = ref(true); // bool to be sure that on netscan at least one discovered hosts scan type is selected
  const is_host_correct = ref(false);
  const is_ipv4_netscan = ref(false);
  const scan_frequencies_list = ref([
    { id: "disabled", label: i18n("hosts_stats.page_scan_hosts.disabled") },
    { id: "1day", label: i18n("hosts_stats.page_scan_hosts.every_night") },
    { id: "1week", label: i18n("hosts_stats.page_scan_hosts.every_week") },
  ]);

  const CIDR_24 = 24;
  const CIDR_30 = 30;
  const CIDR_32 = 32;
  const CIDR_128 = 128;

  const selected_cidr = ref(null);
  const selected_scan_frequency = ref(scan_frequencies_list.value[0]);
  const is_data_not_ok = ref(false);
  const refresh_select_search = ref(false);
  /* ****************************************************** */

  /*
   * Reset fields in modal form
   */
  const reset_modal_form = function () {
    host.value = "";
    ports.value = "";
    selected_cidr.value = "";
    is_port_correct.value = true;
    is_cidr_correct.value = false;
    is_host_correct.value = false;
    activate_add_spinner.value = false;
    show_port_feedback.value = false;
    selected_scan_type.value = scan_type_list.value[0];
    selected_discovered_scan_types.value = [];
    row_to_edit_id.value = null;
    is_edit_page.value = false;
    is_data_not_ok.value = false;
    is_ipv4_netscan.value = false;
    is_netscan_ok.value = !is_ipv4_netscan.value;
  };

  /* ****************************************************** */

  /*
   * Set row to edit
   */
  const set_row_to_edit = (row) => {
    is_edit_page.value = true;

    /* Set host values */
    host.value = row.host;
    ports.value = row.ports;
    is_host_correct.value = true;
    is_port_correct.value = true;
    row_to_edit_id.value = row.id;

    /* Set the correct values if available */
    /* Scan Type */
    selected_scan_type.value = scan_type_list.value.find(
      (item) => item.id == row.scan_type
    );

    /* Sub Scans Types */
    if (row.discovered_host_scan_type != null) {
      const discovered_scan_type_ids_array = row.discovered_host_scan_type.split(",");
      let tmp_selected_scan_types = [];
      let tmp_found_scan_type;
      discovered_scan_type_ids_array.forEach((setted_scan_type) => {
        tmp_found_scan_type = discovered_scan_type_list.value.find((item) => item.id == setted_scan_type);
        tmp_selected_scan_types.push(tmp_found_scan_type);
      });
      selected_discovered_scan_types.value = tmp_selected_scan_types;
    }

    /* CIDR */
    if (check_is_network_address(host.value) || row.cidr == CIDR_128) {
      selected_cidr.value = row.cidr;
    } else {
      selected_cidr.value = CIDR_32;
    }

    is_cidr_correct.value = true;

    /* Scan Frequency */
    if (is_enterprise_l) {
      selected_scan_frequency.value = scan_frequencies_list.value.find(
        (item) => item.id == row.scan_frequency
      );
    }
  };

  /* ****************************************************** */

  /* This method is called whenever the modal is opened */
  const show = (row, _host) => {
    /* First of all reset all the data */
    reset_modal_form();
    title.value = i18n("hosts_stats.page_scan_hosts.add_host");
    if (!dataUtils.isEmptyOrNull(row)) {
      /* In case row is not null then an edit is requested */
      title.value = i18n("hosts_stats.page_scan_hosts.edit_host_title");
      set_row_to_edit(row);
    }

    if (!dataUtils.isEmptyOrNull(_host)) {
      host.value = _host;
      is_host_correct.value = true;
    }

    modal_id.value.show();
  };

  /* ****************************************************** */

  /* Function called when a new selected discovered scan type
     is added
  */
  const update_selected_discovered_scan_types = (items) => {
    selected_discovered_scan_types.value = items;
    is_netscan_ok.value = selected_discovered_scan_types.value.length > 0;
  };

  /* Function called when is removed a selected discovered scan type
  */
  const remove_selected_discovered_scan_types = (item_to_delete) => {
    selected_discovered_scan_types.value = selected_discovered_scan_types.value.filter((item) => item.id != item_to_delete.id);
    is_netscan_ok.value = selected_discovered_scan_types.value.length > 0; 
  };

  /* ****************************************************** */

  /* Function to set is_ipv4_netscan in order to disable cidr selectio
     only /24 (for now)
  */
  const set_is_ipv4_netscan = () => {
    if (selected_scan_type.value.id == 'ipv4_netscan') {
      // /24 
      selected_cidr.value = CIDR_24;
      // is_ipv4_netscan -> enable the discovered_hosts_scan_types multiselection
      is_ipv4_netscan.value = true;
      // is_netscan_ok -> disabled apply or add button because is necessary at least one discovered_hosts_scan_type
      is_netscan_ok.value = false;
    } else {
      // is_ipv4_netscan -> disable the discovered_hosts_scan_types multiselection
      is_ipv4_netscan.value = false;
      // is_netscan_ok -> enable the add or apply button because is not ipv4_netscan case
      is_netscan_ok.value = true;
    }

  };

  /* ****************************************************** */
  const check_is_network_address = (address) => {
    const addr_parts = address.split(".");
    if (addr_parts.length > 3) {
      return addr_parts[3] == 0;
    }
  };

  /* ****************************************************** */

  /* Regex to check if the host is correct or not */
  const check_host_regex = () => {
    const is_ipv4 = regexValidation.validateIPv4(host.value);
    const is_ipv6 = regexValidation.validateIPv6(host.value);
    const is_host_name = regexValidation.validateHostName(host.value);
    if (selected_scan_type.value.id == 'ipv4_netscan') {
      
      if (is_ipv4) {
        // the IP must be an IPv4
        /* IPv4 */
        is_host_correct.value = true;
        // the selected_discovered_scan_types must be an array with lenght more than 0
        is_netscan_ok.value = selected_discovered_scan_types.value && selected_discovered_scan_types.value.length > 0;
      }

      is_netscan_ok.value = true; // not ipv4_netscan case so is_netscan_ok is true
    } else {

      /* When it isn't the ipv4_netscan case the cidr selection is enabled */

      if (is_ipv4) {
        /* IPv4 */
        if (!check_is_network_address(host.value)) {
          /* In case the CIDR is wrong */
          selected_cidr.value = CIDR_32;
        } else {
          selected_cidr.value = CIDR_24;
        }
        is_host_correct.value = true;
        is_cidr_correct.value = true;
      } else if (is_ipv6) {
        /* IPv6 */
        is_host_correct.value = true;
        is_cidr_correct.value = true;
        /* In case the CIDR is wrong */
        selected_cidr.value = CIDR_128;
        /* IPv6 */

      } else if (is_host_name) {
        /* Host Name */
        is_host_correct.value = true;
        is_cidr_correct.value = true;
        /* In case the CIDR is wrong */
        selected_cidr.value = CIDR_32;
        
      } else {
        is_host_correct.value = false;
      }
    }
  };

  const check_cidr = () => {
    if (( selected_cidr.value >= CIDR_24 && selected_cidr.value <= CIDR_30) || 
          selected_cidr.value == CIDR_32 || selected_cidr.value == CIDR_128) {
      is_cidr_correct.value = true;
      return true;
    } 
    is_cidr_correct.value = false;
    return false;
  };

  /* ****************************************************** */

  /* Regex to check if ports list is correct or not */
  const check_ports = () => {
    if (
      !regexValidation.validatePortRange(ports.value) &&
      !regexValidation.validateCommaSeparatedPortList(ports.value) &&
      !dataUtils.isEmptyOrNull(ports.value)
    ) {
      is_port_correct.value = false;
    } else {
      /* Empty port is alright! */
      is_port_correct.value = true;
    }
  };

  /* ****************************************************** */

  /* Resolve hostname */
  async function resolve_host_name(host) {
    const resolve_host_name_url = `${http_prefix}/lua/rest/v2/get/host/resolve_host_name.lua`;
    const url = NtopUtils$1.buildURL(resolve_host_name_url, {
      host: host,
    });

    return await ntopng_utility.http_request(url);
  }

  /* ****************************************************** */

  /* Function called when the edit button is clicked */
  const edit_ = () => {
    add_(true);
  };

  /* ****************************************************** */

  /* Function called when the modal is closed */
  const close = () => {
    refresh_select_search.value = false;
    modal_id.value.close();
  };

  /* ****************************************************** */

  /* Function to add host to scan */
  const add_ = async (is_edit) => {
    const host_ports = ports.value;
    const host_scan_type = selected_scan_type.value.id;
    const emit_event = (is_edit === true) ? "edit" : "add";
    const row_id = (is_edit === true) ? row_to_edit_id.value : null;
    let new_host = host.value;
    let new_host_name_resolved = true;

    /* Activate the spinner to give the user a feedback */
    activate_add_spinner.value = true;

    /* Check if it's an IP or not, if not it means it's an hostname */
    if (!regexValidation.validateIP(host.value)) {
      /* During the validation disable the add button */
      is_host_correct.value = false;
      new_host = await resolve_host_name(host.value);
      if (new_host === "no_success") {
        /* The resolution failed! */
        new_host_name_resolved = false;
        no_host_feedback.value = host.value + " " + i18n("hosts_stats.page_scan_hosts.host_not_resolved");
        is_data_not_ok.value = true;
        /* Hide the message after 3 seconds */
        setTimeout(() => {
          is_data_not_ok.value = false;
        }, 4000);
      }
      /* Validation ended, re-enable the button */
      is_host_correct.value = true;
    }

    let tmp_second_scan_types = [];
    
    selected_discovered_scan_types.value.forEach((item) => {
      tmp_second_scan_types.push(item.id);
    });
    /* The discovered scan types are sent to the rest in comma separated string list */
    const tmp_second_scan_types_formatted = tmp_second_scan_types.join(",");

    /* If the resolution was ok or no resolution at all was done emit the event */
    activate_add_spinner.value = new_host_name_resolved;

    if (new_host_name_resolved) {
      /* Emit the event, only if the resolution 
      was ok or no resolution at all was needed */
      emit(emit_event, {
        host: new_host,
        scan_type: host_scan_type,
        scan_ports: host_ports,
        vs_cidr: selected_cidr.value,
        scan_frequency: is_enterprise_l ? selected_scan_frequency.value.id : null,
        scan_id: row_id,
        discovered_host_scan_type : tmp_second_scan_types_formatted
      });
    }

  };

  /* ****************************************************** */

  /* Load the available metrics */
  const metricsLoaded = async (_scan_type_list, _ifid, _is_enterprise_l) => {
    const scan_types = _scan_type_list.sort((a, b) =>
      a.label.localeCompare(b.label)
    );
    ifid.value = _ifid;
    scan_type_list.value = scan_types;
    discovered_scan_type_list.value = scan_types.filter((item) => (item.id != 'ipv4_netscan'));
    is_enterprise_l.value = _is_enterprise_l;
    selected_scan_type.value = scan_type_list.value[0];
  };

  /* ****************************************************** */
  /* ****************************************************** */

  /* Function called whenever the CIDR changes,
   * in case of a network the port is not needed
   */
  /* 

  <div class="form-group ms-2 me-2 mt-3 row">
    <div class="col-2"></div>
    <div class="col-10 d-flex align-items-center">
      <!--
        HIDDEN BUTTON FOR NOW
        <button
        type="button"
        @click="load_ports"
        :disabled="!is_host_correct || disable_load_ports"
        class="btn btn-primary"
      >
        {{ _i18n("hosts_stats.page_scan_hosts.load_ports") }}
      </button>
      -->
      <dd v-if="show_port_feedback" class="ms-2 mb-0 text-danger">
        {{ port_feedback }}
      </dd>
      <a class="ntopng-truncate"></a>
    </div>
  </div>

   -- Hidden function for now, it's not needed --

  const port_feedback = i18n("hosts_stats.page_scan_hosts.no_ports_detected");
  const server_ports = `${http_prefix}/lua/rest/v2/get/host/open_ports.lua`;
  const disable_load_ports = ref(false);

  function disable_ports() {
    if (selected_cidr.value.id != cidr_24) {
      disable_load_ports.value = false;
    } else {
      disable_load_ports.value = true;
    }
  }

  async function load_ports() {
    activate_spinner.value = true;
    /* In case the host is not empty, hide the placeholder */
  /*  if (dataUtils.isEmptyOrNull(host.value)) {
      hide_ports_placeholder.value = true;
    } else {
      hide_ports_placeholder.value = false;
    }

    /* Request for the available ports */
  /*  const url = NtopUtils.buildURL(server_ports, {
      host: host.value,
      ifid: ifid.value,
      clisrv: "server",
    });

    const result = await ntopng_utility.http_request(url);

    /* Show the results or empty if no data was found */
  /*  if (!dataUtils.isEmptyOrNull(result)) {
      ports.value = result.map((x) => x.key).join(",");
      show_port_feedback.value = false;
    } else {
      show_port_feedback.value = true;
      ports.value = "";
      /* Remove the message after 5 seconds! */
  /*    setTimeout(() => {
        show_port_feedback.value = false;
      }, 5000);
    }
    activate_spinner.value = false;
  }
  */


  expose({ show, close, metricsLoaded });

  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createCommentVNode(" Target information, here an IP is put "),
        createBaseVNode("div", _hoisted_1$k, [
          createBaseVNode("label", _hoisted_2$i, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.host_or_network")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$i, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((host).value = $event)),
              onInput: check_host_regex,
              disabled: is_edit_page.value,
              class: "form-control",
              type: "text",
              placeholder: unref(host_placeholder),
              required: ""
            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_4$h), [
              [vModelText, host.value]
            ])
          ]),
          _hoisted_5$e,
          createBaseVNode("div", _hoisted_6$7, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((selected_cidr).value = $event)),
              onInput: check_cidr,
              disabled: is_edit_page.value,
              class: "form-control",
              type: "text",
              placeholder: unref(cidr_placeholder),
              required: ""
            }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_7$6), [
              [vModelText, selected_cidr.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_8$6, [
          createBaseVNode("label", _hoisted_9$5, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.ports")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_10$5, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((ports).value = $event)),
              onFocusout: check_ports,
              class: normalizeClass(["form-control", hide_ports_placeholder.value === true ? 'ntopng-hide-placeholder' : ''
              ]),
              type: "text",
              placeholder: unref(ports_placeholder),
              required: ""
            }, null, 42 /* CLASS, PROPS, HYDRATE_EVENTS */, _hoisted_11$4), [
              [vModelText, ports.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_12$4, [
          createBaseVNode("label", _hoisted_13$4, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.scan_type")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_14$4, [
            createVNode(script$1I, {
              selected_option: selected_scan_type.value,
              "onUpdate:selected_option": _cache[3] || (_cache[3] = $event => ((selected_scan_type).value = $event)),
              options: scan_type_list.value,
              disabled: is_edit_page.value,
              onSelect_option: _cache[4] || (_cache[4] = $event => (set_is_ipv4_netscan()))
            }, null, 8 /* PROPS */, ["selected_option", "options", "disabled"])
          ])
        ]),
        (selected_scan_type.value.id == 'ipv4_netscan')
          ? (openBlock(), createElementBlock("div", _hoisted_15$4, [
              createBaseVNode("label", _hoisted_16$4, [
                createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.host_discovered_scan_type")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_17$4, [
                createVNode(script$1I, {
                  selected_options: selected_discovered_scan_types.value,
                  "onUpdate:selected_options": _cache[5] || (_cache[5] = $event => ((selected_discovered_scan_types).value = $event)),
                  onChange_selected_options: update_selected_discovered_scan_types,
                  onUnselect_option: remove_selected_discovered_scan_types,
                  options: discovered_scan_type_list.value,
                  multiple: true
                }, null, 8 /* PROPS */, ["selected_options", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        (is_enterprise_l.value == true)
          ? (openBlock(), createElementBlock("div", _hoisted_18$4, [
              createBaseVNode("label", _hoisted_19$4, [
                createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.periodicity")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_20$4, [
                createVNode(script$1I, {
                  selected_option: selected_scan_frequency.value,
                  "onUpdate:selected_option": _cache[6] || (_cache[6] = $event => ((selected_scan_frequency).value = $event)),
                  options: scan_frequencies_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_21$3, [
          (is_enterprise_l.value == false)
            ? (openBlock(), createBlock(script$1u, {
                key: 0,
                note_list: note_list
              }))
            : (openBlock(), createBlock(script$1u, {
                key: 1,
                note_list: enterprise_note_list
              }))
        ])
      ]),
      footer: withCtx(() => [
        (is_data_not_ok.value)
          ? (openBlock(), createElementBlock("div", _hoisted_22$3, toDisplayString(no_host_feedback.value), 1 /* TEXT */))
          : createCommentVNode("v-if", true),
        createBaseVNode("div", null, [
          createVNode(script$1v, {
            show: activate_add_spinner.value,
            size: "1rem",
            class: "me-2"
          }, null, 8 /* PROPS */, ["show"]),
          (is_edit_page.value == false)
            ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                onClick: add_,
                class: "btn btn-primary",
                disabled: !(is_cidr_correct.value && is_host_correct.value && is_port_correct.value && is_netscan_ok.value)
              }, toDisplayString(_i18n("add")), 9 /* TEXT, PROPS */, _hoisted_23$3))
            : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                onClick: edit_,
                class: "btn btn-primary",
                disabled: !(is_cidr_correct.value && is_host_correct.value && is_port_correct.value && is_netscan_ok.value)
              }, toDisplayString(_i18n("apply")), 9 /* TEXT, PROPS */, _hoisted_24$3))
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$o.__file = "http_src/vue/modal-add-vs-host.vue";

  const columns_formatter = (columns, scan_type_list, is_report, ifid) => {
    const visible_dict = {
          download: true,
          show_result: true
        };

    let map_columns = {
      "host": (host, row) => {
        return host_f(host,row);
      },
      "scan_type": (scan_type, row) => {
        return scan_type_f(scan_type, row, scan_type_list);
      },
      "last_scan": (last_scan, row) => {
        return last_scan_f(last_scan, row);
      },

      "duration": (last_scan, row) => {
        return duration_f(last_scan, row);
      },
      "scan_frequency" : (scan_frequency) => {
        return scan_frequency_f(scan_frequency);
      }, 
      "is_ok_last_scan": (is_ok_last_scan) => {
        return is_ok_last_scan_f(is_ok_last_scan);
        
      },
      "max_score_cve": (max_score_cve, row) => {
        return max_score_cve_f(max_score_cve, row);
      },
      "tcp_ports": (tcp_ports, row) => {
        return tcp_ports_f(tcp_ports, row);
        
      },
      "udp_ports": (udp_ports, row) => {
        return udp_ports_f(udp_ports, row);
      },
      "num_vulnerabilities_found": (num_vs, row) => {
        return num_vuln_found_f(num_vs,row);

      }
    };

    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];

      if (c.id == "actions") {
              
        c.button_def_array.forEach((b) => {
            
          b.f_map_class = (current_class, row) => { 
            current_class = current_class.filter((class_item) => class_item != "link-disabled");
            // FIX ME with UDP ports check
            if((row.is_ok_last_scan == 3 || row.is_ok_last_scan == null || (row.last_scan == null || ((row.last_scan != null && row.last_scan.time == null))) ) && visible_dict[b.id]) {
              current_class.push("link-disabled"); 
            }
            return current_class;
          };
        });
      }
    });
    
    return columns;
  };

  const num_vuln_found_f = (num_vuln_found, row) => {
    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null)) {
      return num_vuln_found;
    }
    return "";

  };
  const max_score_cve_f = (max_score_cve, row) => {
    let label = "";

    if (row.is_ok_last_scan == 1  && (row.last_scan != null && row.last_scan.time != null)) {
      const score = Number(max_score_cve);
      let font_color = "";
    
      if (max_score_cve != null) {
    
        if (score == 0) {
          font_color = "green";
        } else if(score < 3.9) {
          font_color = "grey";
        } else if(score < 7) {
          font_color = "yellow";
        } else  {
          font_color = "red";
        } 
    
        if (score != 0) {
          label = `<FONT COLOR=${font_color}>${max_score_cve}`;
        }
      }

    }
    


    return label;
  };


  const scan_type_f = (scan_type, from_report, row) => {
    if (from_report && row.is_down) {
      return '';
    }
    if (scan_type !== undefined) {
      let label = scan_type;
      const i18n_name = "hosts_stats.page_scan_hosts.scan_type_list."+scan_type;
      label = i18n(i18n_name);
      return label;
    }
  };

  const last_scan_f = (last_scan, row) => {
    if (row.is_ok_last_scan == 3) {
      return ``;
    }
    if (last_scan !== undefined && last_scan.time !== undefined) {
      return last_scan.time;
    } else if (last_scan !== undefined) {
      return last_scan;
    } else {
      return i18n("hosts_stats.page_scan_hosts.not_yet");
    }
  }; 

  const duration_f = (last_scan, row) => {
    if (row.is_ok_last_scan == 3 ) {
      return ``;
    }
    if (row.last_scan !== undefined && row.last_scan.duration !== undefined) {
      return row.last_scan.duration;
    } else {
      return i18n("hosts_stats.page_scan_hosts.not_yet");
    }
  };

  const scan_frequency_f = (scan_frequency) => {
    let label = "";
    if (scan_frequency == null || scan_frequency == "disabled") {
      return "";
    } else if (scan_frequency == "1day") {
      label =  i18n("hosts_stats.page_scan_hosts.daily");
    } else {
      label =  i18n("hosts_stats.page_scan_hosts.weekly");
    }
    return `<span class="badge bg-secondary" title="${label}">${label}</span>`;
  };

  const is_ok_last_scan_f = (is_ok_last_scan) => {
    let label = "";
    if (is_ok_last_scan == 2) {
      // scheduled
      label = i18n("hosts_stats.page_scan_hosts.scheduled");
      return `<span class="badge bg-dark" title="${label}">${label}</span>`;
    } else if (is_ok_last_scan == 4) {
      // not scanned
      label = i18n("hosts_stats.page_scan_hosts.scanning");
      return `<span class="badge bg-info" title="${label}">${label}</span>`; 
    } else if (is_ok_last_scan == 3 || is_ok_last_scan == null) {
      // not scanned
      label = i18n("hosts_stats.page_scan_hosts.not_scanned");
      return `<span class="badge bg-primary" title="${label}">${label}</span>`;
    } else if (is_ok_last_scan == 1) {
      // success
      label = i18n("hosts_stats.page_scan_hosts.success");
      return `<span class="badge bg-success" title="${label}">${label}</span>`;
    } else if (is_ok_last_scan == 0) {
      // error
      label = i18n("hosts_stats.page_scan_hosts.error");
      return `<span class="badge bg-danger" title="${label}">${label}</span>`;
    } else if (is_ok_last_scan == 5) {
      // warning -> failed
      label = i18n("hosts_stats.page_scan_hosts.failed");
      return `<span class="badge bg-warning" title="${label}">${label}</span>`;
    } 
  };

  const ports_list_string = (port_list) => {
    let ports_string = "";
    if (port_list != null) {
      port_list.forEach((item) => {
        if(ports_string == "") {
          ports_string = item;
        } else {
          ports_string += `, ${item}`;
        }
      });
    }

    return ports_string;
  };

  const get_num_open_ports_icon = (diff_case, unused_port_list, filtered_port_list) => {

    let label = null;
    switch(diff_case) {
      case 4: {
        let unused_port_list_string = ports_list_string(unused_port_list);
        label = ` <span class="badge bg-secondary"><i class="fa-solid fa-ghost" title='${unused_port_list_string}'></i></span></div>`;
      }
        break;
      case 3: {
        let filtered_ports_list_string = ports_list_string(filtered_port_list);
        label = ` <span class="badge bg-secondary"><i class="fa-solid fa-filter" title='${filtered_ports_list_string}'></i></span>`;
      }
        break;
    }

    return label;
  };

  const udp_ports_f = (udp_ports, row) => {
    if (udp_ports == 0 && row.udp_ports == 0 && row.scan_type.contains("udp")) {
      udp_ports = row.num_open_ports;
    }
    let label = "";

    if (udp_ports == null || udp_ports <= 0) {
      return label;
    }

    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null)) {
    
      label = `${udp_ports}`;

      if (row.host_in_mem) {

        const num_ports_icon = get_num_open_ports_icon(row.udp_ports_case,row.udp_ports_unused, row.udp_filtered_ports);
        if(num_ports_icon != null) {
          label += num_ports_icon;
        }
      }
    }

    return label;
  };


  const tcp_ports_f = (tcp_ports, row) => {
    if (tcp_ports == 0 && row.tcp_ports == 0 && row.scan_type.contains("tcp")) {
      tcp_ports = row.num_open_ports;
    }
    let label = "";

    if (tcp_ports == null || tcp_ports <= 0) {
      return label;
    }

    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null)) {

    
      label = `${tcp_ports}`;

      if (row.host_in_mem) {

        const num_ports_icon = get_num_open_ports_icon(row.tcp_ports_case,row.tcp_ports_unused, row.tcp_ports_filtered);
        if(num_ports_icon != null) {
          label += num_ports_icon;
        }
      }
    }

    return label;
  };

  const tcp_port_f = (port, row) => {
    let rsp = port;
    if (row.port_label != null && row.port_label != port) {
      rsp += ` (${row.port_label})`;
    }
    return rsp;
  };
  const find_badge = (port, row, ports_unused, ports_filtered) => {
    let result = '';
    if (ports_unused != null) {
      ports_unused.forEach((item) => {
        if(port == Number(item) ) {
          result = "unused";
        }
      });
    }

    if(result != '') {
      return result;
    }

    if (ports_filtered != null) {
      ports_filtered.forEach((item) => {
        if(port == Number(item)) {
          result = "filtered";
        }
      });
    }

    return result;
  };

  const get_icon_component = (item, row, ports_unused, ports_fitered) => {
    let port = item.split(" ")[0].split("/")[0];
    let port_badge = find_badge(Number(port), row, ports_unused, ports_fitered);
    let icon_comp = null;
    switch (port_badge) {
      case 'unused': 
          icon_comp = ` &nbsp;<span class="badge bg-secondary" title='${i18n('hosts_stats.page_scan_hosts.unused_port')}'><i class="fa-solid fa-ghost"></i></span>`;
        break;
      case 'filtered':
          icon_comp = ` &nbsp;<span class="badge bg-primary" title='${i18n('hosts_stats.page_scan_hosts.filtered_port')}'><i class="fa-solid fa-filter"></i></span>`;
        break;
    }

    return icon_comp;
  };

  const tcp_udp_ports_list_f = (tcp_ports_list,udp_ports_list, row) => {
    let ports_map = new Map();

    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null) && tcp_ports_list != null ) {
      const ports = tcp_ports_list.split(",");
      let label = "";
      let port_id = "";
      ports.forEach((item) => {
        if(item != null && item != '') {

          label = item;
          port_id = item;
          if (row.host_in_mem) {
            const icon_comp = get_icon_component(item, row, row.tcp_ports_unused, row.tcp_ports_filtered);
            if(icon_comp != null) {
              label += icon_comp;
            }
          }
          
          label = `<li>${label}</li>`;

          ports_map.set(item,  {port_label :label, port_id: Number(port_id.split("/")[0])});
        }
      });

      if (row.tcp_ports_filtered != null) {
        row.tcp_ports_filtered.forEach((item) => {

          item += `/tcp`;
          label = item;
          port_id = item;
          if (row.host_in_mem) {
            label += ` <span class="badge bg-primary" title='${i18n('hosts_stats.page_scan_hosts.filtered_port')}'><i class="fa-solid fa-filter"></i></span>`;
          }
          label = `<li>${label}</li>`;
          ports_map.set(item,  {port_label :label, port_id: Number(port_id.split("/")[0])});


        });
      }
      
    } 


    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null) && udp_ports_list != null) {
      const ports = udp_ports_list.split(",");

      let label = "";
      let port_id = "";
      ports.forEach((item) => {
        if(item != null && item != '') {

          label = item;
          port_id = item;
          if (row.host_in_mem) {
            const icon_comp = get_icon_component(item, row, row.udp_ports_unused, row.udp_ports_filtered);
            if(icon_comp != null) {
              label += icon_comp;
            }        
          }
          label = `<li>${label}</li>`;

          ports_map.set(item, {port_label :label, port_id: Number(port_id.split("/")[0])});
        }
      });

      if (row.udp_filtered_ports != null) {
        row.udp_ports_filtered.forEach((item) => {

          item += `/udp`;
          label = item;
          port_id = item;
          if (row.host_in_mem) {
            label += ` <span class="badge bg-primary" title='${i18n('hosts_stats.page_scan_hosts.filtered_port')}'><i class="fa-solid fa-filter"></i></span>`;
          }
          label = `<li>${item}</li>`;
          ports_map.set(item, {port_label: label, port_id : Number(port_id.split("/")[0])});
        });
      }
    }

    let content_label = "";
    ports_map = new Map([...ports_map.entries()].sort((a,b) => a[1].port_id-b[1].port_id));

    ports_map.forEach((values, keys) => {
      content_label += `${values.port_label}`;
    });


    return content_label;
  };

  const discoverd_hosts_list_f = (hosts_string) => {
    const hosts_list = hosts_string.split(",");
    let label = "";
    hosts_list.forEach((item) => {
      if (item != "")
        label += `<li>${item}</li>`;
    });
    return label;
  };
  const hosts_f = (hosts, row) => {

    const hosts_list = hosts.split(", ");
    let label = "";
    let hosts_map = new Map();
    hosts_list.forEach((item) => {
      let host_info = item.split("|");

      hosts_map.set(
        host_info.length > 5 && host_info[5] != null && host_info[5] != "" ? host_info[5] : host_info[0], 
        {
          scan_type: host_info[1],
          ip: host_info[0],
          date: host_info[2].replace(" ","_"),
          is_ipv4: host_info[3] == 'true',
          epoch: host_info[4]
        });
    });

    hosts_map = new Map([...hosts_map.entries()].sort());


    hosts_map.forEach((values, keys) => {
      let url = build_host_to_scan_report_url(values.ip, values.scan_type, values.date, values.epoch);

      if (values.is_ipv4) {
        label += `<li> <a href="${url}">${keys}</a></li>` ;
      } else {
        label += `<li> <a href="${url}">${keys} <span class="badge bg-secondary">${i18n('ipv6')}</span></a></li>` ;
      }
    });
    return label;
  };

  const build_host_to_scan_report_url = (host, scan_type, date, epoch) => {
    const active_monitoring_url = `${http_prefix}/lua/vulnerability_scan.lua`;

    let params = {
      host: host,
      scan_type: scan_type,
      scan_return_result: true,
      page: "show_result",
      scan_date: date,
      epoch: epoch

    };
    let url_params = ntopng_url_manager.obj_to_url_params(params);

    return `${active_monitoring_url}?${url_params}`;
  };

  const host_f = (host, row, ifid) => {
    let label = host;
    let host_not_reachable = row.is_ok_last_scan == 5 && row.is_down != null && row.is_down == true;
    if ((row.is_ok_last_scan == 1 || host_not_reachable) && (row.last_scan != null && row.last_scan.time != null)) {
      let url = build_host_to_scan_report_url(host, row.scan_type, row.last_scan.time.replace(" ","_"), row.last_scan.epoch);
      if (row.scan_type == 'ipv4_netscan') {
        // add cidr only for ipv4_netscan 
        const cidr = row.cidr != null ? "/" + row.cidr : "/24";
        host = host + cidr;
      }
      label = `<a href="${url}">${host}</a>`;
      if (host_not_reachable) {
        label = `<a href="${url}">${host} <i class=\"fas fa-exclamation-triangle\" style='color: #B94A48;'></i> </a>`;
      }
    }
    return label;
  };

  const cves_f = (cves, row) => {
    let label = "";
    let index = 0;
    if (row.is_ok_last_scan == 1 && (row.last_scan != null && row.last_scan.time != null) && cves != null) {

      let cves_map = new Map();

      // map to sort cves on score
      cves.forEach((item) => {
        let cve_details = item.split("|");
        let actual_score = 0;
        if (cve_details.length> 1) {
          actual_score = Number(cve_details[1]);
        }
    
        cves_map.set(
          cve_details[0], 
          actual_score);
      });
    
      cves_map = new Map([...cves_map.entries()].sort((a,b) => b[1] - a[1]));

      // return first 100
      cves_map.forEach((score, key) => {
        if (index < 100) {

            let badge_type = "";
            if (score == 0) {
              badge_type = "bg-success";
            } else if(score < 3.9) {
              badge_type = "bg-secondary";
            } else if(score < 7) {
              badge_type = "bg-warning";
            } else {
              badge_type = "bg-danger";
            }
            
            const url = ntopng_utility.get_cve_details_url(key, row.scan_type);
            label += `<li  title='${i18n("hosts_stats.page_scan_hosts.report.cves_title")}'>
                        <a href="${url}"><span class="badge ${badge_type}">${key} </span></a> 
                        (${score})
                    </li>`;

          
          index++;
        } else {
          return label;
        }
      });

    }


    return label;
  };

  const _hoisted_1$j = { class: "row" };
  const _hoisted_2$h = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$h = {
    key: 0,
    class: "alert alert-info alert-dismissable"
  };
  const _hoisted_4$g = { class: "card card-shadow" };
  const _hoisted_5$d = { class: "card-body" };
  const _hoisted_6$6 = {
    key: 0,
    class: "alert alert-info alert-dismissable"
  };
  const _hoisted_7$5 = /*#__PURE__*/createBaseVNode("span", { class: "spinner-border spinner-border-sm text-info me-1" }, null, -1 /* HOISTED */);
  const _hoisted_8$5 = {
    key: 1,
    class: "alert alert-success alert-dismissable"
  };
  const _hoisted_9$4 = /*#__PURE__*/createBaseVNode("span", { class: "text-success me-1" }, null, -1 /* HOISTED */);
  const _hoisted_10$4 = {
    key: 2,
    class: "alert alert-danger alert-dismissable"
  };
  const _hoisted_11$3 = /*#__PURE__*/createBaseVNode("span", { class: "text-danger me-1" }, null, -1 /* HOISTED */);
  const _hoisted_12$3 = {
    key: 3,
    class: "alert alert-warning alert-dismissable"
  };
  const _hoisted_13$3 = /*#__PURE__*/createBaseVNode("span", { class: "text-warning me-1" }, null, -1 /* HOISTED */);
  const _hoisted_14$3 = { id: "hosts_to_scan" };
  const _hoisted_15$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-plus" }, null, -1 /* HOISTED */);
  const _hoisted_16$3 = [
    _hoisted_15$3
  ];
  const _hoisted_17$3 = { class: "card-footer mt-3" };
  const _hoisted_18$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash" }, null, -1 /* HOISTED */);
  const _hoisted_19$3 = /*#__PURE__*/createBaseVNode("i", { class: "fas fa-clock-rotate-left" }, null, -1 /* HOISTED */);
  const _hoisted_20$3 = { class: "card-footer" };

  /* ******************************************************************** */

  /* Consts */

  var script$n = {
    __name: 'page-vulnerability-scan',
    props: {
    context: Object,
  },
    setup(__props) {

  const props = __props;

  /* Imports */
  const _i18n = (t) => i18n(t);

  const note = i18n(
    "hosts_stats.page_scan_hosts.notes.generic_notes_1"
  ).replaceAll("${http_prefix}", `${http_prefix}`);
  const note_list = [note];

  const insert_text = ref(i18n("scan_host_inserted"));
  const already_insert_text = ref(i18n("scan_host_already_inserted"));
  const not_found_hosts_text = ref(i18n("scan_net_not_found_hosts"));
  const in_progress_scan_text = ref("");
  const enable_clickhouse_text = ref(i18n("hosts_stats.page_scan_hosts.enable_clickhouse"));
  const title_delete = i18n("hosts_stats.page_scan_hosts.delete_host_title");
  const body_delete = i18n("hosts_stats.page_scan_hosts.delete_host_description");
  const title_update_periodicity_scan = i18n(
    "hosts_stats.page_scan_hosts.update_periodicity_title"
  );

  const add_host_url = `${http_prefix}/lua/rest/v2/add/host/to_scan.lua`;
  const edit_host_url = `${http_prefix}/lua/rest/v2/edit/host/update_va_scan_period.lua`;
  const remove_host_url = `${http_prefix}/lua/rest/v2/delete/host/delete_host_to_scan.lua`;
  const scan_host_url = `${http_prefix}/lua/rest/v2/exec/host/schedule_vulnerability_scan.lua`;
  const scan_type_list_url = `${http_prefix}/lua/rest/v2/get/host/vulnerability_scan_type_list.lua`;
  const active_monitoring_url = `${http_prefix}/lua/vulnerability_scan.lua`;
  const scan_result_url = `${http_prefix}/lua/rest/v2/get/host/vulnerability_scan_result.lua`;
  const check_status_url = `${http_prefix}/lua/rest/v2/get/host/vulnerability_scan_status.lua`;

  const table_id = ref("hosts_to_scan");
  const table_hosts_to_scan = ref();
  const modal_delete_confirm = ref();
  const modal_add = ref();
  const modal_update_perioditicy_scan = ref();
  const total_rows = ref(0);
  const in_progress_number = ref(null);
  const row_to_delete = ref({});
  const row_to_scan = ref({});
  const autorefresh = ref(false);
  const modal_opened = ref(false);
  const clickhouse_disabled = ref(false);
  const insert_with_success = ref(false);
  const already_inserted = ref(false);
  const not_found_hosts = ref(false);


  const rest_params = {
    csrf: props.context.csrf,
  };
  const context = ref({
    csrf: props.context.csrf,
    ifid: props.context.ifid,
    is_enterprise_l: props.context.is_enterprise_l,
  });

  let scan_type_list = [];
  let get_scan_type_list_v = null;

  /* ******************************************************************** */

  onBeforeMount(() => {
    get_scan_type_list_v = Promise.all([
      get_scan_type_list(),
      check_in_progress_status(),
    ]);
  });

  /* ******************************************************************** */

  onMounted(async () => {
    await get_scan_type_list_v;
    await modal_add.value.metricsLoaded(
      scan_type_list,
      props.context.ifid,
      props.context.is_enterprise_l
    );
    if (props.context.host != null) {
      modal_add.value.show(null, props.context.host);
    }

    clickhouse_disabled.value = !(props.context.is_clickhouse_enabled);

    /* Check the status periodically every 10 seconds */
    setInterval(check_autorefresh, 10000);
  });

  /* ******************************************************************** */

  /* Function to add a new host to scan */
  function add_host() {
    if (props.context.host != null && props.context.host != "")
      modal_add.value.show(null, props.context.host);
    else modal_add.value.show();
  }

  /* ******************************************************************** */

  /* Function to refresh table */
  function refresh_table(disable_loading) {
    /* It's important to set autorefresh to false, in this way when refreshed 
       all the entries are going to be checked and if all of them are not scanning it stays false
     */
    if (disable_loading != null)
      table_hosts_to_scan.value.refresh_table(disable_loading);
    else table_hosts_to_scan.value.refresh_table(true);
  }

  /* ******************************************************************** */

  const get_extra_params_obj = () => {
    let extra_params = ntopng_url_manager$1.get_url_object();
    return extra_params;
  };

  /* ******************************************************************** */

  /* Function to handle all buttons */
  function on_table_custom_event(event) {
    let events_managed = {
      click_button_edit_host: click_button_edit_host,
      click_button_delete: click_button_delete,
      click_button_scan: click_button_scan,
      click_button_download: click_button_download,
      click_button_show_result: click_button_show_result,
    };
    if (events_managed[event.event_id] == null) {
      return;
    }
    events_managed[event.event_id](event);
  }

  /* ******************************************************************** */

  /* Default sorting, by default default by IP in Asc order */
  function compare_by_host_ip(r0, r1) {
    return sortingFunctions.sortByIP(
      r0["host"],
      r1["host"],
      1 /* by default asc */
    );
  }

  /* ******************************************************************** */

  /* This function simply return the data of the exact column and row requested */
  function column_data(col, row) {
    let data = row[col.data.data_field];
    if (col.id == "duration") {
      data =
        row["last_scan"] === undefined
          ? -1
          : row["last_scan"]["duration_epoch"];
    } else if (col.id == "last_scan") {
      data =
        row["last_scan"] === undefined 
          ? 0
          : row["last_scan"]["epoch"];
    } else if (col.id == "is_ok_last_scan") {
      data = get_scan_status_value(data, row);
    } else if (col.id == "scan_frequency") {
      data = get_scan_frequency(data);
    } else if (col.id == "max_score_cve" || col.id == "num_vulnerabilities_found" || col.id == "tcp_ports" || col.id == "udp_ports")
      // to correctly sort also during scan.
      // because during scan the old value is present but not visible
      // status must not success and not failed
      if (row["is_ok_last_scan"] != 1 && row["is_ok_last_scan"] != 5) {
        data = 0;
      } 
    return data;
  }

  /* ******************************************************************** */

  /* Function used to sort the columns of the table */
  function columns_sorting(col, r0, r1) {
    if (col != null) {
      let r0_col = column_data(col, r0);
      let r1_col = column_data(col, r1);

      /* In case the values are the same, sort by IP */
      if (r0_col == r1_col) {
        return compare_by_host_ip(r0, r1);
      }
      if (col.id == "host") {
        return sortingFunctions.sortByIP(r0_col, r1_col, col.sort);
      } else if (col.id == "host_name") {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      } else if (col.id == "num_vulnerabilities_found") {
        const lower_value = 0;
        return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);

      } else if (col.id == "tcp_ports" || col.id == "udp_ports") {
        const lower_value = 0;
        return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);

      } else if (col.id == "duration") {
        const lower_value = -1;
        return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
      } else if (col.id == "last_scan") {
        const lower_value = 0;
        return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
      } else if (col.id == "is_ok_last_scan") {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      } else if (col.id == "max_score_cve") {
        const lower_value = 0;
        return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);

      } else if (col.id == "scan_frequency") {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      } else {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      }
    }

    return compare_by_host_ip(r0, r1);
  }

  /* ******************************************************************** */

  function get_scan_frequency(scan_frequency) {
    if (scan_frequency == "1day") {
      return i18n("hosts_stats.page_scan_hosts.daily");
    } else if (scan_frequency == "1week") {
      return i18n("hosts_stats.page_scan_hosts.weekly");
    } else {
      return "";
    }
  }

  /* ******************************************************************** */

  function get_scan_status_value(is_ok_last_scan, r) {
    let status = "";
    if (is_ok_last_scan == 2) {
      status = i18n("hosts_stats.page_scan_hosts.scheduled");
    } else if (is_ok_last_scan == 4) {
      status = i18n("hosts_stats.page_scan_hosts.scanning");
    } else if (is_ok_last_scan == 3 || is_ok_last_scan == null) {
      status = i18n("hosts_stats.page_scan_hosts.not_scanned");
    } else if (is_ok_last_scan == 1) {
      status = i18n("hosts_stats.page_scan_hosts.success");
    } else if (is_ok_last_scan == 5) {
      status = i18n("hosts_stats.page_scan_hosts.failed");
    } else {
      status = i18n("hosts_stats.page_scan_hosts.error");
    }
    return status + r.id;
  }

  /* ******************************************************************** */

  /* Function to handle delete button */
  function click_button_delete(event) {
    insert_with_success.value = false;
    already_inserted.value = false;
    not_found_hosts.value = false;
    refresh_feedback_messages();
    row_to_delete.value = event.row;
    modal_delete_confirm.value.show("delete_single_row", i18n("delete_vs_host"));
  }

  /* ******************************************************************** */

  /* Function to handle scan button */
  function click_button_scan(event) {
    insert_with_success.value = false;
    already_inserted.value = false;
    not_found_hosts.value = false;
    refresh_feedback_messages();
    row_to_scan.value = event.row;
    const scan_host_msg = `${i18n("scan_host")}`;
    modal_delete_confirm.value.show("scan_row", scan_host_msg);
  }

  /* ******************************************************************** */

  /* Function to handle edit button */
  function click_button_edit_host(event) {
    modal_add.value.show(event.row);
  }

  /* ******************************************************************** */

  /* Function to delete all entries */
  function delete_all_entries() {
    insert_with_success.value = false;
    already_inserted.value = false;
    not_found_hosts.value = false;
    refresh_feedback_messages();
    modal_delete_confirm.value.show("delete_all", i18n("delete_all_vs_hosts"));
  }

  /* ******************************************************************** */

  /* Function to edit host to scan */
  async function edit(params) {
    params.is_edit = true;
    await add_host_rest(params);
  }

  /* ******************************************************************** */

  /* Every 10 second check to disable feedbacks */
  function set_already_insert_or_insert_with_success() {
    if (insert_with_success.value === true) {
      insert_with_success.value = false;
    }

    if (already_inserted.value === true) {
      already_inserted.value = false;
    }

    if (not_found_hosts.value == true) {
      not_found_hosts.value = false;
    }
  }

  /* ******************************************************************** */

  /* Every 10 second check to disable autorefresh */
  function check_autorefresh() {
    check_in_progress_status();
  }

  /* ******************************************************************** */

  /* Get the number of rows of the table */
  function on_table_loaded() {
    total_rows.value = table_hosts_to_scan.value.get_rows_num();
  }

  /* ******************************************************************** */

  /* Function to map columns data */
  const map_table_def_columns = (columns) => {
    return columns_formatter(columns, scan_type_list, false, props.context.ifid);
  };

  /* ************************** REST Functions ************************** */

  /* Function to add a new host during edit */
  const add_host_rest = async function (params) {
    const url = NtopUtils.buildURL(add_host_url, {
      ...params,
    });

    const result = await ntopng_utility$1.http_post_request(url, rest_params);
    modal_add.value.close();
    if (result.rsp === 1) {
      params.vs_cidr != null
        ? (insert_text.value = i18n("scan_host_updated").replace(
            "%{host}",
            `${params.host}/${params.vs_cidr}`
          ))
        : (insert_text.value = i18n("scan_host_updated").replace(
            "%{host}",
            `${params.host}`
          ));

      insert_with_success.value = true;
      already_inserted.value = false;
      not_found_hosts.value = false;
      setTimeout(set_already_insert_or_insert_with_success, 10000);
      refresh_table(false);
    } else if (result.rsp === 2) {
      params.vs_cidr != null
        ? (already_insert_text.value = i18n("scan_host_already_inserted").replace(
            "%{host}",
            `${params.host}/${params.vs_cidr}`
          ))
        : (already_insert_text.value = i18n("scan_host_already_inserted").replace(
            "%{host}",
            `${params.host}`
          ));

      let scan_type_label = "";

      scan_type_list.forEach((item) => {
        if (item.id == params.scan_type) {
          scan_type_label = item.label;
        }
      });

      already_insert_text.value = i18n("scan_host_already_inserted").replace(
        "%{scan_type}",
        `${scan_type_label}`
      );
      already_inserted.value = true;
      insert_with_success.value = false;
      not_found_hosts.value = false;
      setTimeout(set_already_insert_or_insert_with_success, 10000);
    } else if (result.rsp === 3) {
      params.vs_cidr != null
        ? (not_found_hosts_text.value = i18n("scan_net_not_found_hosts").replace(
            "%{host}",
            `${params.host}/${params.vs_cidr}`
          ))
        : (not_found_hosts_text.value = i18n("scan_net_not_found_hosts").replace(
            "%{host}",
            `${params.host}`
          ));
      
      already_inserted.value = false;
      insert_with_success.value = false;
      not_found_hosts.value = true;
      setTimeout(set_already_insert_or_insert_with_success, 10000);
    }

    if (params.is_edit !== true) {
      refresh_table(false);
    }
  };

  /* ******************************************************************** */

  /* This function adds a feedback message on the page */
  const refresh_feedback_messages = function (in_progress) {
    /* In case a in_progress is a number, customize the feedback message */
    if (in_progress != null && in_progress != 0) {
      in_progress_scan_text.value = i18n("scan_in_progress").replace(
        "total",
        `${in_progress}`
      );
    }
  };

  /* ******************************************************************** */

  const update_all_scan_frequencies = async function (params) {
    const url = NtopUtils.buildURL(edit_host_url, {
      ...params,
    });

    await ntopng_utility$1.http_post_request(url, rest_params);

    insert_with_success.value = false;
    already_inserted.value = false;
    not_found_hosts.value = false;
    refresh_feedback_messages();
    refresh_table(false);
  };

  /* ******************************************************************** */

  /* Function to retrieve scan types list */
  const get_scan_type_list = async function () {
    const url = NtopUtils.buildURL(scan_type_list_url, {
      ...rest_params,
    });

    const result = await ntopng_utility$1.http_request(url);
    scan_type_list = result.rsp;
  };

  /* ******************************************************************** */

  /* Function to check if there is a scan in progress */
  const check_in_progress_status = async function () {
    const url = NtopUtils.buildURL(check_status_url, {
      ...rest_params,
    });

    const result = await ntopng_utility$1.http_request(url);
    insert_with_success.value = false;
    already_inserted.value = false;
    not_found_hosts.value = false;
    refresh_feedback_messages(result.rsp.total_in_progress);

    /* Get the number of scans currently in progress */
    /* In case the number changed, refresh the table */
    if (in_progress_number.value == null) {
      /* First time checking the number of scans, don't refresh the table */
      in_progress_number.value = result.rsp.total_in_progress;
    }

    const scans_ended =
      result.rsp.total_in_progress == 0 && in_progress_number.value > 0;
    in_progress_number.value = result.rsp.total_in_progress;
    autorefresh.value =
      in_progress_number.value > 0 && modal_opened.value === false;

    if (autorefresh.value === true) {
      /* Refresh the data, periodic update */
      setTimeout(function () {
        refresh_table(true);
      }, 2000);
    } else if (scans_ended) {
      /* Refresh the data, all scans ended */
      setTimeout(function () {
        refresh_table(true);
      }, 5000);
    }
  };

  /* ******************************************************************** */

  /* Function to confirm to start all scan */
  const confirm_scan_all_entries = function () {
    modal_delete_confirm.value.show("scan_all_rows", i18n("scan_all_hosts"));
    refresh_table(false);
  };

  /* ******************************************************************** */

  /* Function to update all scan  frequencies*/
  const update_all_periodicity = function () {
    modal_update_perioditicy_scan.value.show();
  };

  /* ******************************************************************** */

  /* Function to exec the vulnerability scan of a single host */
  const scan_row = async function () {
    const row = row_to_scan.value;
    await scan_row_rest(row.host, row.scan_type, row.ports, row.id, row.cidr);
    refresh_table(true /* Disable loading, annoying when enabling a scan */);
  };

  /* ******************************************************************** */

  const scan_row_rest = async function (host, scan_type, ports, id, cidr) {
    const url = NtopUtils.buildURL(scan_host_url, {
      host: host,
      scan_type: scan_type,
      scan_single_host: true,
      scan_ports: ports,
      scan_id: id,
      vs_cidr: cidr
    });
    await ntopng_utility$1.http_post_request(url, rest_params);
  };

  /* ******************************************************************** */

  /* Function to exec a vulnerability scan to all hosts set */
  async function scan_all_entries() {
    const url = NtopUtils.buildURL(scan_host_url, {
      scan_single_host: false,
    });
    await ntopng_utility$1.http_post_request(url, rest_params);
    refresh_table(false);
  }

  /* ******************************************************************** */

  /* Function to delete host to scan */
  const delete_row = async function () {
    const row = row_to_delete.value;
    const url = NtopUtils.buildURL(remove_host_url, {
      host: row.host,
      scan_type: row.scan_type,
      delete_all_scan_hosts: false,
      scan_id: row.id,
    });

    await ntopng_utility$1.http_post_request(url, rest_params);
    refresh_table(false);
  };

  /* ******************************************************************** */

  /* This function deletes all the rows */
  const delete_all_rows = async function () {
    const url = NtopUtils.buildURL(remove_host_url, {
      delete_all_scan_hosts: true,
    });

    await ntopng_utility$1.http_post_request(url, rest_params);
    refresh_table(false);
  };

  /* ******************************************************************** */

  /* Function to download last vulnerability scan result */
  function click_button_download(event) {
    const params = {
      host: event.row.host,
      scan_type: event.row.scan_type,
      epoch: event.row.last_scan.epoch
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);

    const url = `${scan_result_url}?${url_params}`;
    ntopng_utility$1.download_URI(url);
  }

  /* ******************************************************************** */

  /* Function to show last vulnerability scan result */
  function click_button_show_result(event) {
    const host = event.row.host;
    const date = event.row.last_scan.time.replace(" ", "_");

    const params = {
      host: host,
      scan_type: event.row.scan_type,
      scan_return_result: true,
      page: "show_result",
      epoch: event.row.last_scan.epoch,
      scan_date: date,
    };
    const url_params = ntopng_url_manager$1.obj_to_url_params(params);

    const url = `${active_monitoring_url}?${url_params}`;
    ntopng_url_manager$1.go_to_url(url);
  }

  /* ******************************************************************** */

  function update_modal_status(value) {
    /* update the modal_opened var used for disable/enable 
       autorefresh when modal is open/closed */
    modal_opened.value = value;
  }

  /* ******************************************************************** */

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$j, [
        createBaseVNode("div", _hoisted_2$h, [
          (clickhouse_disabled.value)
            ? (openBlock(), createElementBlock("div", _hoisted_3$h, [
                createBaseVNode("span", null, toDisplayString(enable_clickhouse_text.value), 1 /* TEXT */)
              ]))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_4$g, [
            createBaseVNode("div", _hoisted_5$d, [
              (autorefresh.value)
                ? (openBlock(), createElementBlock("div", _hoisted_6$6, [
                    _hoisted_7$5,
                    createBaseVNode("span", null, toDisplayString(in_progress_scan_text.value), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              (insert_with_success.value)
                ? (openBlock(), createElementBlock("div", _hoisted_8$5, [
                    _hoisted_9$4,
                    createBaseVNode("span", null, toDisplayString(insert_text.value), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              (already_inserted.value)
                ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
                    _hoisted_11$3,
                    createBaseVNode("span", null, toDisplayString(already_insert_text.value), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              (not_found_hosts.value)
                ? (openBlock(), createElementBlock("div", _hoisted_12$3, [
                    _hoisted_13$3,
                    createBaseVNode("span", null, toDisplayString(not_found_hosts_text.value), 1 /* TEXT */)
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", _hoisted_14$3, [
                createVNode(script$q, {
                  ref_key: "modal_delete_confirm",
                  ref: modal_delete_confirm,
                  title: unref(title_delete),
                  body: unref(body_delete),
                  onDelete: delete_row,
                  onDelete_all: delete_all_rows,
                  onScan_row: scan_row,
                  onScan_all_rows: scan_all_entries
                }, null, 8 /* PROPS */, ["title", "body"]),
                createVNode(script$p, {
                  ref_key: "modal_update_perioditicy_scan",
                  ref: modal_update_perioditicy_scan,
                  title: unref(title_update_periodicity_scan),
                  onUpdate: update_all_scan_frequencies
                }, null, 8 /* PROPS */, ["title"]),
                createVNode(script$1w, {
                  ref_key: "table_hosts_to_scan",
                  ref: table_hosts_to_scan,
                  table_id: table_id.value,
                  csrf: context.value.csrf,
                  f_map_columns: map_table_def_columns,
                  get_extra_params_obj: get_extra_params_obj,
                  f_sort_rows: columns_sorting,
                  onCustom_event: on_table_custom_event,
                  onRows_loaded: on_table_loaded
                }, {
                  custom_header: withCtx(() => [
                    createBaseVNode("button", {
                      class: "btn btn-link",
                      type: "button",
                      ref: "add_host",
                      onClick: add_host
                    }, _hoisted_16$3, 512 /* NEED_PATCH */)
                  ]),
                  _: 1 /* STABLE */
                }, 8 /* PROPS */, ["table_id", "csrf"])
              ])
            ]),
            createBaseVNode("div", _hoisted_17$3, [
              createBaseVNode("button", {
                type: "button",
                ref: "delete_all",
                onClick: delete_all_entries,
                class: normalizeClass(["btn btn-danger me-1", { disabled: total_rows.value == 0 }])
              }, [
                _hoisted_18$3,
                createTextVNode(" " + toDisplayString(_i18n("delete_all_entries")), 1 /* TEXT */)
              ], 2 /* CLASS */),
              createBaseVNode("button", {
                type: "button",
                ref: "scan_all",
                onClick: confirm_scan_all_entries,
                class: normalizeClass(["btn btn-primary me-1", { disabled: total_rows.value == 0 }])
              }, [
                _hoisted_19$3,
                createTextVNode(" " + toDisplayString(_i18n("hosts_stats.page_scan_hosts.schedule_all_scan")), 1 /* TEXT */)
              ], 2 /* CLASS */),
              (props.context.is_enterprise_l)
                ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    type: "button",
                    ref: "update_all",
                    onClick: update_all_periodicity,
                    class: normalizeClass(["btn btn-secondary me-1", { disabled: total_rows.value == 0 }])
                  }, toDisplayString(_i18n("hosts_stats.page_scan_hosts.update_periodicity_title")), 3 /* TEXT, CLASS */))
                : createCommentVNode("v-if", true)
            ]),
            createBaseVNode("div", _hoisted_20$3, [
              createVNode(script$1u, { note_list: note_list })
            ])
          ])
        ])
      ]),
      createVNode(script$o, {
        ref_key: "modal_add",
        ref: modal_add,
        context: context.value,
        onAdd: add_host_rest,
        onEdit: edit,
        onCloseModal: _cache[0] || (_cache[0] = $event => (update_modal_status(false))),
        onOpenModal: _cache[1] || (_cache[1] = $event => (update_modal_status(true))),
        onHidden: _cache[2] || (_cache[2] = $event => (update_modal_status(false)))
      }, null, 8 /* PROPS */, ["context"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$n.__file = "http_src/vue/page-vulnerability-scan.vue";

  const _hoisted_1$i = { class: "row" };
  const _hoisted_2$g = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$g = { class: "card card-shadow" };
  const _hoisted_4$f = ["innerHTML"];
  const _hoisted_5$c = ["innerHTML"];


  var script$m = {
    __name: 'page-host-vs-result',
    props: {
    context: Object,
  },
    setup(__props) {

  const props = __props;

  const scan_result_url = `${http_prefix}/lua/rest/v2/get/host/vulnerability_scan_result.lua`;

  ref(null);
  const loading = ref(false);


   
  const message = ref('');
  const message_html = ref('');
  const title_html = ref('');

  const title = ref('');
  ref([]);


  async function get_result(host, scan_type, date, epoch) {
    
    loading.value = true;
    let params = {
      host: host,
      scan_type: scan_type,
      scan_return_result: true,
      epoch: epoch

    };
    let url_params = ntopng_url_manager.obj_to_url_params(params);
    let url = `${scan_result_url}?${url_params}`;
    let result = await ntopng_utility.http_request(url);
    message.value = result.rsp;
    message_html.value = `<pre>${message.value}</pre>`;

    if (scan_type == 'ipv4_netscan') {
      host += "/24";
    }
    const host_href = props.context.is_in_mem === 'true' || props.context.is_in_mem == true ? `${host} <a href="${http_prefix}/lua/host_details.lua?host=${host}"><i class = "fas fa-laptop"></i></a>`: host;
    
    
    title.value = i18n("hosts_stats.page_scan_hosts.vs_result").replace("%{host}", host_href);
    if (date != null)
      date = date.replaceAll("_"," ");

    
    title.value = title.value.replace("%{date}",date);
    title_html.value = title.value;

    loading.value = false;
  }



  /* ******************************************************************** */ 

  onBeforeMount(async () => {
    await get_result(props.context.host, props.context.scan_type, props.context.date, props.context.epoch);
  });



  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$i, [
      createBaseVNode("div", _hoisted_2$g, [
        createBaseVNode("div", _hoisted_3$g, [
          createBaseVNode("h3", {
            class: "d-inline-block pt-3 ps-3",
            innerHTML: title_html.value
          }, null, 8 /* PROPS */, _hoisted_4$f),
          (loading.value)
            ? (openBlock(), createBlock(script$1z, { key: 0 }))
            : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass(["card-body", [loading.value ? 'ntopng-gray-out' : '']]),
            innerHTML: message_html.value
          }, null, 10 /* CLASS, PROPS */, _hoisted_5$c)
        ])
      ])
    ]))
  }
  }

  };

  script$m.__file = "http_src/vue/page-host-vs-result.vue";

  const _hoisted_1$h = { class: "row" };
  const _hoisted_2$f = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$f = { class: "card card-shadow" };
  const _hoisted_4$e = { class: "card-body" };
  const _hoisted_5$b = { id: "open_ports" };

  /* ******************************************************************** */ 

  /* Consts */ 

  var script$l = {
    __name: 'page-open-ports',
    props: {
    context: Object,
  },
    setup(__props) {

  const props = __props;



  const active_monitoring_url = `${http_prefix}/lua/vulnerability_scan.lua`;
   

  const table_id = ref('open_ports');
  const map_config = (config) => {
      return config;
  };

  const table_open_ports = ref();


  ({
    csrf: props.context.csrf
  });
  const context = ref({
    csrf: props.context.csrf,
    ifid: props.context.ifid,
    is_enterprise_l: props.context.is_enterprise_l
  });

  /* ******************************************************************** */ 



  /* ******************************************************************** */ 

  const get_extra_params_obj = () => {
    let extra_params = ntopng_url_manager$1.get_url_object();
    return extra_params;
  };

  /* ******************************************************************** */ 

  /* Function to handle all buttons */
  function on_table_custom_event(event) {
    
    let events_managed = {
      "click_button_show_hosts": click_button_show_hosts
    };
    if (events_managed[event.event_id] == null) {
      return;
    }
    events_managed[event.event_id](event);
  }


  function compare_by_port(r0,r1) {

    let col = {
        "data": {
            "title_i18n": "port",
            "data_field": "port",
            "sortable": true,
            "class": [
                "text-nowrap",
                "text-end"
            ]
        }
      };
    let r0_col = r0[col.data.data_field];
    let r1_col = r1[col.data.data_field];
      
    r0_col = format_num_ports_for_sort(r0_col);
    r1_col = format_num_ports_for_sort(r1_col);
    return r0_col - r1_col;
  }

  function columns_sorting(col, r0, r1) {

    if (col != null) {
      let r0_col = r0[col.data.data_field];
      let r1_col = r1[col.data.data_field];
      if(col.id == "port") {

        r0_col = format_num_ports_for_sort(r0_col);
        r1_col = format_num_ports_for_sort(r1_col);
        if (col.sort == 1) {
          return r0_col - r1_col;
        }
        return r1_col - r0_col;
      } else if(col.id == "count_host") {
        r0_col = format_cve_num(r0_col);
        r1_col = format_cve_num(r1_col);

        if (r0_col == r1_col) {
          return compare_by_port(r0,r1);
        }
        if (col.sort == 1) {
          return r0_col - r1_col;
        }
        return r1_col - r0_col;
      }
      else if(col.id == "cves") {
        r0_col = format_cve_num(r0_col);
        r1_col = format_cve_num(r1_col);

        if (r0_col == r1_col) {
          return compare_by_port(r0,r1);
        }
        if (col.sort == 1) {
          return r0_col - r1_col;
        }
        return r1_col - r0_col;
      }
      else if(col.id == "hosts") {
        /* It's an array */

        if (r0_col == r1_col) {
          return compare_by_port(r0,r1);
        }
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      } else {

        if (r0_col != null) ; else {
          r0_col = "";
        }

        if (r1_col != null) ; else {
          r1_col = "";
        }
        if (r0_col == r1_col) {
          return compare_by_port(r0,r1);
        }
        if (col.sort == 1) {
          return r0_col.localeCompare(r1_col);
        }
        return r1_col.localeCompare(r0_col);
      }
     
    } else {
      return compare_by_port(r0,r1);
    }
    
  }




  function format_cve_num(num) {
    let value = 0;
    if (num === "" || num === null || num === NaN || num === undefined) {
      value = 0;
    } else {
      num = num.split(',').join("");
      value = parseInt(num);
    }

    return value;
  }

  function format_num_ports_for_sort(num) {
    if (num == "" || num == null || num == NaN || num == undefined) 
      num = 0;

    num = parseInt(num);  return num;
  }




  /* ******************************************************************** */ 


  /* Function to map columns data */
  const map_table_def_columns = (columns) => {
    let map_columns = {
      "hosts": (hosts, row) => {
        let label = ``;
        const hosts_splited = hosts.split(", ");
        const length = hosts_splited.length;
        let i = 0;
        while ( i < 5 && i < length) {
          const host_splitted = hosts_splited[i].split("|");
          const host = host_splitted[0];
          const scan_type = host_splitted[1];
          const date = host_splitted[2].replace(" ","_");
          const is_ipv4 = host_splitted[3] === 'true';
          const epoch = host_splitted[4];

          let host_name = '';
          if (host_splitted.length > 5) {
            host_name = host_splitted[5];
          }

          let params = {
            host: host,
            scan_type: scan_type,
            scan_return_result: true,
            page: "show_result",
            epoch: epoch,
            scan_date: date

          };
          let url_params = ntopng_url_manager$1.obj_to_url_params(params);

          let url = `${active_monitoring_url}?${url_params}`;
          
          const host_label = host_name != ''? (is_ipv4 == false ? `${host_name}  <span class="badge bg-secondary">${i18n('ipv6')}</span>` : host_name) : host;
          
          if (label == ``)
            label += `<a href="${url}">${host_label}</a>`;  
          else
            label += `, <a href="${url}">${host_label}</a>`;  

          i++;
        }
        
        if (length > 5) {
          label += `...`;
        } 

        return label;

      }
    };
      

    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];
    });
    
    return columns;
  };

  /* ******************************************************************** */ 






  /* ************************** REST Functions ************************** */

  /* Function to show all hosts during edit */

  async function click_button_show_hosts(event) {
    let port = event.row.port_number;

    let params = {
      port: port,
    };

    let url_params = ntopng_url_manager$1.obj_to_url_params(params);

    let url = `${active_monitoring_url}?${url_params}`;
    ntopng_url_manager$1.go_to_url(url);
  }


  /* ******************************************************************** */ 


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$h, [
      createBaseVNode("div", _hoisted_2$f, [
        createBaseVNode("div", _hoisted_3$f, [
          createBaseVNode("div", _hoisted_4$e, [
            createBaseVNode("div", _hoisted_5$b, [
              createVNode(script$1w, {
                ref_key: "table_open_ports",
                ref: table_open_ports,
                table_id: table_id.value,
                csrf: context.value.csrf,
                f_map_columns: map_table_def_columns,
                get_extra_params_obj: get_extra_params_obj,
                f_sort_rows: columns_sorting,
                f_map_config: map_config,
                onCustom_event: on_table_custom_event
              }, null, 8 /* PROPS */, ["table_id", "csrf"])
            ])
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$l.__file = "http_src/vue/page-open-ports.vue";

  const _hoisted_1$g = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$e = { class: "col-form-label col-sm-2" };
  const _hoisted_3$e = { class: "col-sm-10" };
  const _hoisted_4$d = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_5$a = { class: "col-form-label col-sm-2" };
  const _hoisted_6$5 = { class: "col-sm-10" };
  const _hoisted_7$4 = { class: "mt-4" };
  const _hoisted_8$4 = ["disabled"];


  /* ****************************************************** */


  var script$k = {
    __name: 'modal-edit-vs-report',
    props: {
    context: Object,
  },
    emits: ["add", "edit"],
    setup(__props, { expose, emit }) {

  /* Imports */
  const _i18n = (t) => i18n(t);



  /* Consts */
  const title = ref(i18n("hosts_stats.page_scan_hosts.reports_page.edit_report"));

  const modal_id = ref(null);
  const report_date = ref(null);
  const report_name = ref(null);
  const row_to_edit = ref(null);

  const is_report_name_correct = ref(false);

  const note_list = [
    _i18n("hosts_stats.page_scan_hosts.reports_page.notes.note_1"),
  ];
  /* ****************************************************** */

  /*
   * Reset fields in modal form
   */
  const reset_modal_form = function () {
    report_date.value = "";
    report_name.value = "";
    row_to_edit.value = null;
    
  };

  /* ****************************************************** */

  /*
   * Set row to edit
   */
  const set_row_to_edit = (row) => {

    row_to_edit.value = row;
    /* Set host values */
    report_date.value = row.report_date;
    report_name.value = row.name;

  };

  /* ****************************************************** */

  /* This method is called whenever the modal is opened */
  const show = (row) => {
    /* First of all reset all the data */
    reset_modal_form();
    set_row_to_edit(row);

    modal_id.value.show();
  };

  /* ****************************************************** */


  /* ****************************************************** */

  /* Function called when the edit button is clicked */
  const edit_ = () => {
    const tmp_report_date = row_to_edit.value.epoch;
    const tmp_name = report_name.value.replaceAll(" ", "_");

    emit("edit", {
        report_title: tmp_name,
        epoch_end: tmp_report_date
      });
    
      modal_id.value.close();
  };

  /* ****************************************************** */

  /* Function called when the modal is closed */
  const close = () => {
    modal_id.value.close();
  };

  /* ****************************************************** */



  /* ****************************************************** */

  const check_title = () => {
    let report_name_splitted_by_spaces = report_name.value.split(" ");

    // with .every the loop stops when the condition is not met (like while)
    const isReportNameValid = report_name_splitted_by_spaces.every((single_word) =>
        regexValidation.validateSingleWord(single_word));

    is_report_name_correct.value = isReportNameValid;
  };



  expose({ show, close });

  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createCommentVNode(" Target information, here an IP is put "),
        createBaseVNode("div", _hoisted_1$g, [
          createBaseVNode("label", _hoisted_2$e, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.reports_page.date")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$e, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((report_date).value = $event)),
              disabled: true,
              class: "form-control",
              type: "text"
            }, null, 512 /* NEED_PATCH */), [
              [vModelText, report_date.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_4$d, [
          createBaseVNode("label", _hoisted_5$a, [
            createBaseVNode("b", null, toDisplayString(_i18n("hosts_stats.page_scan_hosts.reports_page.name")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_6$5, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((report_name).value = $event)),
              class: "form-control",
              type: "text",
              onInput: check_title,
              required: ""
            }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
              [vModelText, report_name.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_7$4, [
          createVNode(script$1u, { note_list: note_list })
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("div", null, [
          createBaseVNode("button", {
            type: "button",
            onClick: edit_,
            disabled: !(is_report_name_correct.value),
            class: "btn btn-primary"
          }, toDisplayString(_i18n("apply")), 9 /* TEXT, PROPS */, _hoisted_8$4)
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$k.__file = "http_src/vue/modal-edit-vs-report.vue";

  const _hoisted_1$f = { class: "row" };
  const _hoisted_2$d = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$d = { class: "card card-shadow" };
  const _hoisted_4$c = { class: "card-body" };
  const _hoisted_5$9 = { id: "vs_reports" };


  /* ******************************************************************** */

  /* Consts */

  var script$j = {
    __name: 'page-vulnerability-scan-report',
    props: {
    context: Object,
  },
    setup(__props) {

  const props = __props;

  /* Imports */
  const _i18n = (t) => i18n(t);

  i18n(
    "hosts_stats.page_scan_hosts.notes.generic_notes_1"
  ).replaceAll("${http_prefix}", `${http_prefix}`);

  const title_delete = _i18n("hosts_stats.page_scan_hosts.report_page.delete_title");
  const body_delete = _i18n("hosts_stats.page_scan_hosts.report_page.delete_description");


  const open_report_url = `${http_prefix}/lua/enterprise/vulnerability_scan_report.lua`;
  const remove_report_url = `${http_prefix}/lua/pro/rest/v2/delete/vs/report.lua`;
  const edit_report_url = `${http_prefix}/lua/pro/rest/v2/edit/vs/report.lua`;

  const table_id = ref("vs_reports");
  const table_vs_reports = ref();
  const modal_edit = ref();
  const modal_delete_confirm = ref();
  const total_rows = ref(0);
  const row_to_delete = ref({});


  const rest_params = {
    csrf: props.context.csrf,
  };
  const context = ref({
    csrf: props.context.csrf,
    ifid: props.context.ifid,
  });

  /* ******************************************************************** */

  /* Function to refresh table */
  function refresh_table() {
    table_vs_reports.value.refresh_table();
  }

  /* ******************************************************************** */

  const get_extra_params_obj = () => {
    let extra_params = ntopng_url_manager$1.get_url_object();
    return extra_params;
  };

  /* ******************************************************************** */

  /* Function to handle all buttons */
  function on_table_custom_event(event) {
    let events_managed = {
      click_button_edit: click_button_edit,
      click_button_delete: click_button_delete,
    };
    if (events_managed[event.event_id] == null) {
      return;
    }
    events_managed[event.event_id](event);
  }

  /* ******************************************************************** */

  /* This function simply return the data of the exact column and row requested */
  function column_data(col, row) {
    let data = row[col.data.data_field];

    if (col.data.data_field == 'report_date') {
      data = row['epoch'];
    }

    if (col.data.data_field == 'name') {
      data = format_report_name(row['name'], row['epoch']);
    }

    return data;
  }

  /* ******************************************************************** */

  /* Default sorting, by date in DESC order */
  function compare_by_report_date(r0, r1) {
    return sortingFunctions.sortByNumber(
      r0["epoch"],
      r1["epoch"],
      0 /* by default asc */
    );
  }

  /* Specific function for report name because could be "Report of date" (default) or a custom name */
  function format_report_name(report_name, epoch) {
    
    let formatted_report_name = report_name;
    
    if (report_name.startsWith("Report of")) {
      formatted_report_name = 'report_'+epoch;   
    }

    return formatted_report_name;

  }

  /* ******************************************************************** */

  /* Function used to sort the columns of the table */
  function columns_sorting(col, r0, r1) {
    if (col != null) {
      let r0_col = column_data(col, r0);
      let r1_col = column_data(col, r1);

      /* In case the values are the same, sort by IP */
      if (r0_col == r1_col) {
        return compare_by_report_date(r0, r1);
      }
      
      if (col.id == "report_date") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else if (col.id == "tcp_ports" || col.id == "udp_ports") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else if (col.id == "cves") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else if (col.id == "name") {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      } else if (col.id == "num_hosts") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else {
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      }
    }

    return compare_by_report_date(r0, r1);
  }


  /* ******************************************************************** */

  /* Function to handle delete button */
  function click_button_delete(event) {
    row_to_delete.value = event.row;
    modal_delete_confirm.value.show("delete_single_report");
  }



  /* ******************************************************************** */

  /* Function to handle edit button */
  function click_button_edit(event) {
    modal_edit.value.show(event.row);
  }

  /* ******************************************************************** */

  /* Function to edit report */
  async function edit(params) {
    await edit_report_rest(params);
  }

  const edit_report_rest = async function (params) {
    const url = NtopUtils.buildURL(edit_report_url, {
      ...params,
    });

    await ntopng_utility$1.http_post_request(url, rest_params);

    refresh_table();
  };

  /* ******************************************************************** */

  /* Get the number of rows of the table */
  function on_table_loaded() {
    total_rows.value = table_vs_reports.value.get_rows_num();
  }

  /* ******************************************************************** */

  /* Function to map columns data */
  const map_table_def_columns = (columns) => {


    let map_columns = {
      "report_date": (report_date, row) => {
          const url = NtopUtils.buildURL(open_report_url, {
          printable: false,
          epoch_end: row.epoch,
          epoch_begin: row.epoch
        });
      
      return `<a href="${url}">${report_date}</a>`;
      },
    };

    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];

      
    });
    
    return columns;
  };

  /* ************************** REST Functions ************************** */


  /* ******************************************************************** */

  /* Function to delete report */
  const delete_row = async function () {
    const row = row_to_delete.value;
    const url = NtopUtils.buildURL(remove_report_url, {
      epoch: row.epoch
    });
    debugger;
    await ntopng_utility$1.http_post_request(url, rest_params);
    refresh_table();
  };

  /* ******************************************************************** */

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$f, [
        createBaseVNode("div", _hoisted_2$d, [
          createBaseVNode("div", _hoisted_3$d, [
            createBaseVNode("div", _hoisted_4$c, [
              createBaseVNode("div", _hoisted_5$9, [
                createVNode(script$q, {
                  ref_key: "modal_delete_confirm",
                  ref: modal_delete_confirm,
                  title: unref(title_delete),
                  body: unref(body_delete),
                  onDelete: delete_row
                }, null, 8 /* PROPS */, ["title", "body"]),
                createVNode(script$1w, {
                  ref_key: "table_vs_reports",
                  ref: table_vs_reports,
                  table_id: table_id.value,
                  csrf: context.value.csrf,
                  f_map_columns: map_table_def_columns,
                  get_extra_params_obj: get_extra_params_obj,
                  f_sort_rows: columns_sorting,
                  onCustom_event: on_table_custom_event,
                  onRows_loaded: on_table_loaded
                }, null, 8 /* PROPS */, ["table_id", "csrf"])
              ])
            ])
          ])
        ])
      ]),
      createVNode(script$k, {
        ref_key: "modal_edit",
        ref: modal_edit,
        context: context.value,
        onEdit: edit
      }, null, 8 /* PROPS */, ["context"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$j.__file = "http_src/vue/page-vulnerability-scan-report.vue";

  const _hoisted_1$e = { class: "card h-100 overflow-hidden" };
  const _hoisted_2$c = {
    class: "m-2 mt-0",
    style: {"margin-bottom":""}
  };
  const _hoisted_3$c = { class: "m-2 mb-3" };
  const _hoisted_4$b = { class: "card-footer" };

  /* ************************************** */


  var script$i = {
    __name: 'page-snmp-usage',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;



  /* ************************************** */
  const time_preset_list = [
      { value: "10_min", label: i18n('show_alerts.presets.10_min'), currently_active: false },
      { value: "30_min", label: i18n('show_alerts.presets.30_min'), currently_active: true },
      { value: "hour", label: i18n('show_alerts.presets.hour'), currently_active: false },
      { value: "2_hours", label: i18n('show_alerts.presets.2_hours'), currently_active: false },
      { value: "6_hours", label: i18n('show_alerts.presets.6_hours'), currently_active: false },
      { value: "12_hours", label: i18n('show_alerts.presets.12_hours'), currently_active: false },
      { value: "day", label: i18n('show_alerts.presets.day'), currently_active: false },
      { value: "week", label: i18n('show_alerts.presets.week'), currently_active: false },
      { value: "month", label: i18n('show_alerts.presets.month'), currently_active: false },
      { value: "year", label: i18n('show_alerts.presets.year'), currently_active: false },
      { value: "custom", label: i18n('show_alerts.presets.custom'), currently_active: false, disabled: true, },
  ];

  const serie_name = "Congestion";
  const table_snmp_usage = ref(null);
  const date_time_picker = ref(null);
  const table_id = ref('snmp_usage');
  const chart_id = ref('snmp_usage_chart');
  const csrf = props.context.csrf;
  const system_interface_id = -1;
  const chart = ref(null);
  const chart_type = ref(ntopChartApex.typeChart.TS_LINE);
  const base_url = `${http_prefix}/lua/pro/rest/v2/get/snmp/metric/usage_chart.lua`;
  let id_date_time_picker = "date_time_picker";

  const note_list = [
      i18n('snmp.chart_congestion_rate_note'),
      i18n('snmp.chart_congestion_link'),
      i18n('snmp.chart_congestion_configuration'),
      i18n('snmp.chart_congestion_rate_color'),
  ];

  /* ************************************** */

  const map_table_def_columns = (columns) => {
      const formatter = formatterUtils.getFormatter("percentage");
      let map_columns = {
          "ip": (value, row) => {
              const url = `${http_prefix}/lua/pro/enterprise/snmp_device_details.lua?ip=${value}`;
              return `<a href=${url}>${value}</a>`
          },
          "interface": (value, row) => {
              const url = `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.ip}&snmp_port_idx=${row.ifid}`;
              return `<a href=${url}>${value}</a>`
          },
          "type": (type, row) => {
              if (type == 'uplink') {
                  return `${i18n('out_usage')} <i class="fa-solid fa-circle-arrow-up" style="color: #C6D9FD"></i>`
              } else {
                  return `${i18n('in_usage')} <i class="fa-solid fa-circle-arrow-down" style="color: #90EE90"></i>`
              }
          },
          "speed": (value, row) => {
              const formatted_speed = formatterUtils.getFormatter("speed")(value);
              return `${formatted_speed} <a target="_blank" href='${create_config_url_link(row)}'><i class="fas fa-cog"></i></a>`
          },
          "min": (value, row) => {
              return formatter(value);
          },
          "max": (value, row) => {
              return formatter(value);
          },
          "average": (value, row) => {
              return formatter(value);
          },
          "last_value": (value, row) => {
              return formatter(value);
          },
          "congestion_rate": (value, row) => {
              return formatter(value);
          }
      };
      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
          if (c.id == "actions") {
              const visible_dict = {
                  historical_data: props.show_historical,
              };
              c.button_def_array.forEach((b) => {
                  if (!visible_dict[b.id]) {
                      b.class.push("disabled");
                  }
              });
          }
      });

      return columns;
  };

  /* ************************************** */

  function columns_sorting(col, r0, r1) {
      if (col != null) {
          const r0_col = r0[col.data.data_field];
          const r1_col = r1[col.data.data_field];

          /* In case the values are the same, sort by IP */
          if (r0_col == r1_col) {
              return sortingFunctions.sortByName(r0.device, r1.device, col ? col.sort : null);
          }
          if (col.id == "device_name") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "ip") {
              return sortingFunctions.sortByIP(r0_col, r1_col, col.sort);
          } else if (col.id == "interface") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "type") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "speed") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "min") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "max") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "average") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "congestion_rate") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "last_value") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          }
      }

      return sortingFunctions.sortByName(r0.device, r1.device, col ? col.sort : null);
  }

  /* ************************************** */

  async function epoch_change() {
      if (table_snmp_usage.value) {
          table_snmp_usage.value.refresh_table(false);
      }

      if (chart.value) {
          const options = await get_chart_options();
          chart.value.update_chart_series(options?.data);
      }
  }

  /* ************************************** */

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager.get_url_object();
      return extra_params;
  };

  /* ************************************** */

  function create_config_url_link(row) {
      return `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.ip}&snmp_port_idx=${row.ifid}&page=config`
  }

  /* ************************************** */

  function click_button_timeseries(event) {
      const row = event.row;
      const epoch_begin = ntopng_url_manager.get_url_entry("epoch_begin");
      const epoch_end = ntopng_url_manager.get_url_entry("epoch_end");
      window.open(`${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.ip}&snmp_port_idx=${row.ifid}&page=historical&ifid=-1&epoch_end=${epoch_end}&epoch_begin=${epoch_begin}&timeseries_groups_mode=1_chart_x_metric&timeseries_groups=snmp_interface;-1%2B${row.ip}%2B${row.ifid};snmp_if:usage;uplink=true:false:false:false|downlink=true:false:false:false`);
  }

  /* ************************************** */

  function click_button_configuration(event) {
      const row = event.row;
      window.open(create_config_url_link(row));
  }

  /* ************************************** */

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_timeseries": click_button_timeseries,
          "click_button_configuration": click_button_configuration
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  /* *************************************************** */

  /* This function run the REST API with the data */
  async function get_chart_options() {
      let result = null;
      const post_params = {
          csrf: csrf,
          ifid: system_interface_id,
          epoch_begin: ntopng_url_manager.get_url_entry("epoch_begin"),
          epoch_end: ntopng_url_manager.get_url_entry("epoch_end"),
          host: ntopng_url_manager.get_url_entry("host"),
      };

      result = await ntopng_utility.http_post_request(base_url, post_params);
      /* Format the result in the format needed by Dygraph */
      const config = timeseriesUtils.formatSimpleSerie(result, serie_name, "bar", ["percentage"], [0, 100]);

      /* Custom options for this chart */
      config.title = '<div style="font-size:18px;">' + i18n('snmp.top_congested_devices') + '</div>';
      config.titleHeight = 48;
      config.axes.y.axisLabelWidth = 40;
      config.xAxisHeight = 6;
      config.axes.x.axisLabelWidth = 120;
      config.axes.x.pixelsPerLabel = 20;
      config.xRangePad = 50;

      localStorage.setItem(`${serie_name}_x_axis_label`, JSON.stringify(result.labels));
      localStorage.setItem(`${serie_name}_metadata`, JSON.stringify(result.metadata));
      config.axes.x.axisLabelFormatter = function (value, granularity, opts, dygraph) {
          return ''
      };

      config.axes.x.valueFormatter = function (value, granularity, opts, dygraph) {
          /* Sometimes happens that X values are approximated in DyGraph, e.g. 5 becomes 5.000001
           * In this case no label is found even if it's present, su round the value before checking the label
           */
          if (value != null) {
              const rounded_value = Number(value.toFixed(4));
              const labels_json = localStorage.getItem(`${serie_name}_x_axis_label`);
              const labels_array = JSON.parse(labels_json);
              const label = labels_array[rounded_value - 1];
              if (label)
                  return `<span style="white-space: pre-wrap">${label}</span>`

              return ''
          }
      };

      config.clickCallback = function (e, x, points) {
          // table_snmp_usage.value.search_value(x);
          const rounded_value = Number(x.toFixed(4));
          const metadata_json = localStorage.getItem(`${serie_name}_metadata`);
          const metadata_array = JSON.parse(metadata_json);
          const metadata = metadata_array[rounded_value - 1];
          if (metadata) {
              click_button_timeseries({ row: metadata });
          }
      };

      return config;
  }

  /* ************************************** */

  onMounted(async () => {
      await Promise.all([
          ntopng_sync.on_ready(id_date_time_picker),
      ]);
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$e, [
      createVNode(script$1E, {
        style: {"margin-top":"0.5rem"},
        class: "ms-1",
        id: unref(id_date_time_picker),
        enable_refresh: false,
        ref_key: "date_time_picker",
        ref: date_time_picker,
        onEpoch_change: epoch_change,
        custom_time_interval_list: time_preset_list
      }, null, 8 /* PROPS */, ["id"]),
      createBaseVNode("div", _hoisted_2$c, [
        createVNode(script$1k, {
          ref_key: "chart",
          ref: chart,
          id: chart_id.value,
          chart_type: chart_type.value,
          base_url_request: base_url,
          get_custom_chart_options: get_chart_options,
          register_on_status_change: false,
          disable_pointer_events: false
        }, null, 8 /* PROPS */, ["id", "chart_type"])
      ]),
      createBaseVNode("div", _hoisted_3$c, [
        createVNode(script$1w, {
          ref_key: "table_snmp_usage",
          ref: table_snmp_usage,
          table_id: table_id.value,
          csrf: unref(csrf),
          f_map_columns: map_table_def_columns,
          get_extra_params_obj: get_extra_params_obj,
          f_sort_rows: columns_sorting,
          onCustom_event: on_table_custom_event
        }, null, 8 /* PROPS */, ["table_id", "csrf"])
      ]),
      createBaseVNode("div", _hoisted_4$b, [
        createVNode(script$1u, { note_list: note_list })
      ])
    ]))
  }
  }

  };

  var css_248z$7 = "\n.dygraph-axis-label.dygraph-axis-label-x[data-v-da0f3f1a] {\n    font-size: 12px;\n    transform: rotate(-90deg) translate(-20px, 0);\n}\n";
  styleInject(css_248z$7);

  script$i.__scopeId = "data-v-da0f3f1a";
  script$i.__file = "http_src/vue/page-snmp-usage.vue";

  /*
    (C) 2013-24 - ntop.org
   */

  const os = [
     { name: "Unknown", icon: '' },
     { name: "Linux", icon: '<i class=\'fab fa-linux fa-lg\'></i>' },
     { name: "Windows", icon: '<i class=\'fab fa-windows fa-lg\'></i>' },
     { name: "MacOS", icon: '<i class=\'fab fa-apple fa-lg\'></i>' },
     { name: "iOS", icon: '<i class=\'fab fa-apple fa-lg\'></i>' },
     { name: "Android", icon: '<i class=\'fab fa-android fa-lg\'></i>' },
     { name: "LaserJET", icon: 'LasetJET' },
     { name: "AppleAirport", icon: 'Apple Airport' }
  ];

  const asset_icons = [
     { id: 'unknown', icon: '', name: i18n("device_types.unknown") },
     { id: 'printer', icon: '<i class="fas fa-print fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.printer") },
     { id: 'video', icon: '<i class="fas fa-video fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.video") },
     { id: 'workstation', icon: '<i class="fas fa-desktop fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.workstation") },
     { id: 'laptop', icon: '<i class="fas fa-laptop fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.laptop") },
     { id: 'tablet', icon: '<i class="fas fa-tablet fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.tablet") },
     { id: 'phone', icon: '<i class="fas fa-mobile fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.phone") },
     { id: 'tv', icon: '<i class="fas fa-tv fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.tv") },
     { id: 'networking', icon: '<i class="fas fa-arrows-alt fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.networking") },
     { id: 'wifi', icon: '<i class="fas fa-wifi fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.wifi") },
     { id: 'nas', icon: '<i class="fas fa-database fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.nas") },
     { id: 'multimedia', icon: '<i class="fas fa-music fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.multimedia") },
     { id: 'iot', icon: '<i class="fas fa-thermometer fa-lg devtype-icon" aria-hidden="true"></i>', name: i18n("device_types.iot") },
  ];

  const getOSList = () => {
     return icons;
  };

  const getAssetIconsList = () => {
     return asset_icons
  };

  const getOS = (value) => {
     return os[value] || os[0];
  };

  const getAssetIcon = (value) => {
     if(asset_icons[value] != null) {
        return asset_icons[value]["icon"];
     }
     return ''
  };

  const osUtils$1 = function () {
     return {
        getOSList,
        getAssetIconsList,
        getOS,
        getAssetIcon
     };
  }();

  const _hoisted_1$d = { class: "m-2 mb-3" };
  const _hoisted_2$b = { class: "dropdown me-3 d-inline-block" };
  const _hoisted_3$b = { class: "no-wrap d-flex align-items-center my-auto me-2 filters-label" };

  /* ************************************** */


  var script$h = {
    __name: 'page-hosts-list',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;



  /* ************************************** */

  const table_id = props.context?.has_vlans ? ref('hosts_list_with_vlans') : ref('hosts_list');
  const table_hosts_list = ref(null);
  const csrf = props.context.csrf;
  const filter_table_array = ref([]);
  ref([]);
  const child_safe_icon = "<font color='#5cb85c'><i class='fas fa-lg fa-child' aria-hidden='true' title='" + i18n("host_pools.children_safe") + "'></i></font>";
  const system_host_icon = "<i class='fas fa-flag' title='" + i18n("system_host") + "'></i>";
  const hidden_from_top_icon = "<i class='fas fa-eye-slash' title='" + i18n("hidden_from_top_talkers") + "'></i>";
  const dhcp_host_icon = '<i class="fa-solid fa-bolt" title="DHCP Host"></i>';
  const blacklisted_icon = "<i class='fas fa-ban fa-sm' title='" + i18n("hosts_stats.blacklisted") + "'></i>";
  const crawler_bot_scanner_host_icon = "<i class='fas fa-spider fa-sm' title='" + i18n("hosts_stats.crawler_bot_scanner") + "'></i>";
  const multicast_icon = "<abbr title='" + i18n("multicast") + "'><span class='badge bg-primary'>" + i18n("short_multicast") + "</span></abbr>";
  const localhost_icon = "<abbr title='" + i18n("details.label_local_host") + "'><span class='badge bg-success'>" + i18n("details.label_short_local_host") + "</span></abbr>";
  const remotehost_icon = "<abbr title='" + i18n("details.label_remote") + "'><span class='badge bg-secondary'>" + i18n("details.label_short_remote") + "</span></abbr>";
  const blackhole_icon = "<abbr title='" + i18n("details.label_blackhole") + "'><span class='badge bg-info'>" + i18n("details.label_short_blackhole") + "</span></abbr>";
  const blocking_quota_icon = "<i class='fas fa-hourglass' title='" + i18n("hosts_stats.blocking_traffic_policy_popup_msg") + "'></i>";
  const thpt_trend_icons = {
      1: "<i class='fas fa-arrow-up'></i>",
      2: "<i class='fas fa-arrow-down'></i>",
      3: "<i class='fas fa-minus'></i>",
  };

  /* ************************************** */

  const map_table_def_columns = (columns) => {
      let map_columns = {
          "ip_address": (value, row) => {
              const host = row.host;
              let ip_address = host.ip;
              let icons = '';
              const url = `${http_prefix}/lua/host_details.lua?host=${host.ip}&vlan=${host.vlan.id}`;

              if (!dataUtils.isEmptyOrNull(host.system_host)) {
                  icons = `${icons} ${system_host_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.os)) {
                  const os_icon = osUtils$1.getOS(host.os);
                  icons = `${icons} ${os_icon.icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.device_type)) {
                  icons = `${icons} ${osUtils$1.getAssetIcon(host.device_type) || ''}`;
              }
              if (!dataUtils.isEmptyOrNull(host.hidden_from_top)) {
                  icons = `${icons} ${hidden_from_top_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.child_safe)) {
                  icons = `${icons} ${child_safe_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.dhcp_host)) {
                  icons = `${icons} ${dhcp_host_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.blocking_traffic_policy)) {
                  icons = `${icons} ${blocking_quota_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.country)) {
                  icons = `${icons} <a href='${http_prefix}/lua/hosts_stats.lua?country=${host.country}'><img src='${http_prefix}/dist/images/blank.gif' class='flag flag-${host.country.toLowerCase()}'></a>`;
              }
              if (!dataUtils.isEmptyOrNull(host.is_blacklisted)) {
                  icons = `${icons} ${blacklisted_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.crawler_bot_scanner_host)) {
                  icons = `${icons} ${crawler_bot_scanner_host_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.is_multicast)) {
                  icons = `${icons} ${multicast_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.localhost)) {
                  icons = `${icons} ${localhost_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.remotehost)) {
                  icons = `${icons} ${remotehost_icon}`;
              }
              if (!dataUtils.isEmptyOrNull(host.is_blackhole)) {
                  icons = `${icons} ${blackhole_icon}`;
              }
              return `<a href=${url}>${ip_address}</a> ${icons}`
          },
          "num_flows": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "alerts": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value) + " <i class='fas fa-exclamation-triangle' style='color: #B94A48;'></i>"
              }
              return ''
          },
          "vlan": (value, row) => {
              const vlan = row.host.vlan;
              if (!dataUtils.isEmptyOrNull(vlan.name)) {
                  return vlan.name
              }
              if (!dataUtils.isEmptyOrNull(vlan.id)) {
                  return vlan.id
              }
              return ''
          },
          "num_cves": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "tcp_unresp_as_server": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "hostname": (hostname, row) => {
              let name = hostname.name;
              if (!dataUtils.isEmptyOrNull(hostname.alt_name)) {
                  name = hostname.alt_name;
                  if (hostname.alt_name != hostname.name && !dataUtils.isEmptyOrNull(hostname.name)) {
                      name = `${name} [${hostname.name}]`;
                  }
              }

              return name
          },
          "first_seen": (value, row) => {
              if (value > 0) {
                  return NtopUtils$1.secondsToTime((Math.round(new Date().getTime() / 1000)) - value)
              }
              return ''
          },
          "score": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "traffic_breakdown": (value, row) => {
              const sent_pctg = row.bytes.sent * 100 / row.bytes.total;
              const rcvd_pctg = row.bytes.rcvd * 100 / row.bytes.total;
              return NtopUtils$1.createBreakdown(sent_pctg, rcvd_pctg, i18n('sent'), i18n('rcvd'))
          },
          "throughput": (value, row) => {
              let return_value = '';
              if (value.type === 'bps' && !dataUtils.isEmptyOrNull(value.bps)) {
                  return_value = formatterUtils.getFormatter("bps")(value.bps);
              } else if (value.type === 'pps' && !dataUtils.isEmptyOrNull(value.pps)) {
                  return_value = formatterUtils.getFormatter("pps")(value.pps);
              }
              if (!dataUtils.isEmptyOrNull(return_value) && !dataUtils.isEmptyOrNull(value.trend)) {
                  return_value = `${return_value} ${thpt_trend_icons[value.trend]}`;
              }
              return return_value
          },
          "bytes": (value, row) => {
              if (!dataUtils.isEmptyOrNull(value.total)) {
                  return formatterUtils.getFormatter("bytes")(value.total)
              }
              return ''
          },
      };
      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
      });

      return columns;
  };

  /* ************************************** */

  function set_filter_array_label() {
      filter_table_array.value.forEach((el, index) => {
          /* Setting the basic label */
          if (el.basic_label == null) {
              el.basic_label = el.label;
          }

          /* Getting the currently selected filter */
          const url_entry = ntopng_url_manager.get_url_entry(el.id);
          el.options.forEach((option) => {
              if (option.value.toString() === url_entry) {
                  el.current_option = option;
              }
          });
      });
  }

  /* ************************************** */

  function change_filter_labels() {
      set_filter_array_label();
  }

  /* ************************************** */

  function add_table_filter(opt) {
      ntopng_url_manager.set_key_to_url(opt.key, `${opt.value}`);
      set_filter_array_label();
      table_hosts_list.value.refresh_table();
  }

  /* ************************************** */

  async function load_table_filters_array() {
      let extra_params = get_extra_params_obj();
      let url_params = ntopng_url_manager.obj_to_url_params(extra_params);
      const url = `${http_prefix}/lua/rest/v2/get/host/host_filters.lua?${url_params}`;
      let res = await ntopng_utility.http_request(url);
      return res.map((t) => {
          const key_in_url = ntopng_url_manager.get_url_entry(t.name);
          if(dataUtils.isEmptyOrNull(key_in_url)) {
              ntopng_url_manager.set_key_to_url(t.name, ``);
          }
          return {
              id: t.name,
              label: t.label,
              title: t.tooltip,
              options: t.value,
              hidden: (t.value.length == 1)
          };
      });
  }

  /* ************************************** */

  function columns_sorting(col, r0, r1) { }

  /* ************************************** */

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager.get_url_object();
      return extra_params;
  };

  /* ************************************** */

  function create_config_url_link(row) {
      return `${http_prefix}/lua/host_details.lua?host=${row.host.ip}&vlan=${row.host.vlan.id}&page=flows`
  }

  /* ************************************** */

  function click_button_live_flows(event) {
      const row = event.row;
      window.open(create_config_url_link(row));
  }

  /* ************************************** */

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_live_flows": click_button_live_flows,
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  function refresh_table() {
      table_hosts_list.value.refresh_table(true);
  }

  /* ************************************** */

  onMounted(async () => {
      setInterval(refresh_table, 10000);
      filter_table_array.value = await load_table_filters_array();
      set_filter_array_label();
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$d, [
      createVNode(script$1w, {
        ref_key: "table_hosts_list",
        ref: table_hosts_list,
        table_id: unref(table_id),
        csrf: unref(csrf),
        f_map_columns: map_table_def_columns,
        get_extra_params_obj: get_extra_params_obj,
        f_sort_rows: columns_sorting,
        onCustom_event: on_table_custom_event,
        onRows_loaded: change_filter_labels
      }, {
        custom_header: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (item) => {
            return (openBlock(), createElementBlock("div", _hoisted_2$b, [
              createBaseVNode("span", _hoisted_3$b, [
                createBaseVNode("b", null, toDisplayString(item["basic_label"]), 1 /* TEXT */)
              ]),
              createVNode(script$1I, {
                selected_option: item['current_option'],
                "onUpdate:selected_option": $event => ((item['current_option']) = $event),
                theme: "bootstrap-5",
                dropdown_size: "small",
                options: item['options'],
                onSelect_option: add_table_filter
              }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options"])
            ]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["table_id", "csrf"])
    ]))
  }
  }

  };

  script$h.__file = "http_src/vue/page-hosts-list.vue";

  /*
    (C) 2013-24 - ntop.org
   */

  const breed_icon = {
      Safe: "<i class='fas fa-thumbs-up'></i>",
      Acceptable: "<i class='fas fa-thumbs-up'></i>",
      Fun: "<i class='fas fa-smile'></i>",
      Unsafe: "<i class='fas fa-thumbs-down'></i>",
      Dangerous: "<i class='fas fa-exclamation-triangle'></i>"
  };

  const confidence_icons = [
      { id: -1, icon_class: "badge bg-warning" }, /* Unknown */
      { id: 0, icon_class: "badge bg-warning" }, /* Guessed */
      { id: 1, icon_class: "badge bg-success" }, /* DPI */
  ];

  const encrypted_icon = "<i class='fas fa-lock'></i>";

  /* *********************************** */

  const formatBreedIcon = function(breed, is_encrypted) {
      let icon = '';
      if(breed_icon[breed]) {
          icon = breed_icon[breed];
      }
      return is_encrypted ? `${icon} ${encrypted_icon}` : icon
  };

  /* *********************************** */

  const formatConfidence = function(confidence, confidence_id) {
      let confidence_string = '';
      confidence_icons.forEach((el) => {
          if(Number(el.id) === Number(confidence_id)) {
              confidence_string = `<span class="${el.icon_class}" title="${confidence}">${confidence}</span>`;
          }
      });
      return confidence_string
  };

  /* *********************************** */

  const protocolUtils = function () {
      return {
          formatBreedIcon,
          formatConfidence
      };
  }();

  /*
    (C) 2013-24 - ntop.org
   */

  const alert_severities = {
      none: {
          severity_id: 0,
          label: "bg-info",
          color: "#a8e4ef",
          icon: "",
          i18n_title: "alerts_dashboard.none",
          syslog_severity: 10,
      },
      debug: {
          severity_id: 1,
          label: "bg-info",
          icon: "fas fa-bug text-info",
          color: "#a8e4ef",
          i18n_title: "alerts_dashboard.debug",
          syslog_severity: 7,
          emoji: "\xE2\x84\xB9"
      },
      info: {
          severity_id: 2,
          label: "bg-info",
          icon: "fas fa-info-circle text-info",
          color: "#c1f0c1",
          i18n_title: "alerts_dashboard.info",
          syslog_severity: 6,
          used_by_alerts: true,
          emoji: "\xE2\x84\xB9"
      },
      notice: {
          severity_id: 3,
          label: "bg-info",
          icon: "fas fa-info-circle text-info",
          color: "#5cd65c",
          i18n_title: "alerts_dashboard.notice",
          syslog_severity: 5,
          used_by_alerts: true,
          emoji: "\xE2\x84\xB9"
      },
      warning: {
          severity_id: 4,
          label: "bg-warning",
          icon: "fas fa-exclamation-triangle text-warning",
          color: "#ffc007",
          i18n_title: "alerts_dashboard.warning",
          syslog_severity: 4,
          used_by_alerts: true,
          emoji: "\xE2\x9A\xA0"
      },
      error: {
          severity_id: 5,
          label: "bg-danger",
          icon: "fas fa-exclamation-triangle text-danger",
          color: "#ff3231",
          i18n_title: "alerts_dashboard.error",
          syslog_severity: 3,
          used_by_alerts: true,
          emoji: "\xE2\x9D\x97"
      },
      critical: {
          severity_id: 6,
          label: "bg-danger",
          icon: "fas fa-exclamation-triangle text-danger",
          color: "#fb6962",
          i18n_title: "alerts_dashboard.critical",
          syslog_severity: 2,
          emoji: "\xE2\x9D\x97"
      },
      emergency: {
          severity_id: 8,
          label: "bg-danger text-danger",
          icon: "fas fa-bomb text-danger",
          color: "#fb6962",
          i18n_title: "alerts_dashboard.emergency",
          syslog_severity: 0,
          emoji: "\xF0\x9F\x9A\xA9"
      }
  };

  /* *********************************** */

  const getSeverityIcon = function(severity_id) {
      for (const [_, value] of Object.entries(alert_severities)) {
          if(Number(severity_id) == Number(value.severity_id)) {
              return value.icon
          }
      }
  };

  /* *********************************** */

  const alertSeverities = function () {
      return {
          getSeverityIcon
      };
  }();

  const _hoisted_1$c = { class: "m-2 mb-3" };
  const _hoisted_2$a = { class: "dropdown me-3 d-inline-block" };
  const _hoisted_3$a = { class: "no-wrap d-flex align-items-center filters-label" };
  const _hoisted_4$a = { class: "d-flex justify-content-center align-items-center" };

  /* ************************************** */


  var script$g = {
    __name: 'page-flows-list',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);


  /* ************************************** */

  const table_id = props.context?.has_exporters ? ref('flows_list_with_exporters') : ref('flows_list');
  const table_flows_list = ref(null);
  const csrf = props.context.csrf;
  //const chart = ref(null);
  const filter_table_array = ref([]);
  const filters = ref([]);
  const refresh_rate = 10000;
  const host_details_url = `${http_prefix}/lua/host_details.lua`;
  const flow_exporter_url = `${http_prefix}/lua/pro/enterprise/flowdevice_details.lua`;
  const flow_exporter_icon = "<i class='fas fa-file-export'></i>";
  const host_details_icon = "<i class='fas fa-laptop'></i>";
  const child_safe_icon = "<font color='#5cb85c'><i class='fas fa-lg fa-child' aria-hidden='true' title='" + i18n("host_pools.children_safe") + "'></i></font>";
  const system_host_icon = "<i class='fas fa-flag' title='" + i18n("system_host") + "'></i>";
  const hidden_from_top_icon = "<i class='fas fa-eye-slash' title='" + i18n("hidden_from_top_talkers") + "'></i>";
  const dhcp_host_icon = '<i class="fa-solid fa-bolt" title="DHCP Host"></i>';
  const blacklisted_icon = "<i class='fas fa-ban fa-sm' title='" + i18n("hosts_stats.blacklisted") + "'></i>";
  const crawler_bot_scanner_host_icon = "<i class='fas fa-spider fa-sm' title='" + i18n("hosts_stats.crawler_bot_scanner") + "'></i>";
  const multicast_icon = "<abbr title='" + i18n("multicast") + "'><span class='badge bg-primary'>" + i18n("short_multicast") + "</span></abbr>";
  const localhost_icon = "<abbr title='" + i18n("details.label_local_host") + "'><span class='badge bg-success'>" + i18n("details.label_short_local_host") + "</span></abbr>";
  const remotehost_icon = "<abbr title='" + i18n("details.label_remote") + "'><span class='badge bg-secondary'>" + i18n("details.label_short_remote") + "</span></abbr>";
  const blackhole_icon = "<abbr title='" + i18n("details.label_blackhole") + "'><span class='badge bg-info'>" + i18n("details.label_short_blackhole") + "</span></abbr>";
  const blocking_quota_icon = "<i class='fas fa-hourglass' title='" + i18n("hosts_stats.blocking_traffic_policy_popup_msg") + "'></i>";
  const thpt_trend_icons = {
      1: "<i class='fas fa-arrow-up'></i>",
      2: "<i class='fas fa-arrow-down'></i>",
      3: "<i class='fas fa-minus'></i>",
  };
  const loading = ref(false);
  const interval_id = ref(null);

  /* ************************************** */

  const format_host = function (value) {
      let icons = '';
      let port_name = ` : ${value.port}`;
      let process = '';
      let container = '';
      const url = `${host_details_url}?host=${value.ip}&vlan=${value.vlan || ''}`;

      if (!dataUtils.isEmptyOrNull(value.system_host)) {
          icons = `${icons} ${system_host_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.os)) {
          const os_icon = osUtils.getOS(value.os);
          icons = `${icons} ${os_icon.icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.device_type)) {
          icons = `${icons} ${osUtils.getAssetIcon(value.device_type) || ''}`;
      }
      if (!dataUtils.isEmptyOrNull(value.hidden_from_top)) {
          icons = `${icons} ${hidden_from_top_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.child_safe)) {
          icons = `${icons} ${child_safe_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.dhcp_host)) {
          icons = `${icons} ${dhcp_host_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.blocking_traffic_policy)) {
          icons = `${icons} ${blocking_quota_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.country)) {
          icons = `${icons} <a href='${http_prefix}/lua/hosts_stats.lua?country=${value.country}'><img src='${http_prefix}/dist/images/blank.gif' class='flag flag-${value.country.toLowerCase()}'></a>`;
      }
      if (!dataUtils.isEmptyOrNull(value.is_blacklisted)) {
          icons = `${icons} ${blacklisted_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.crawler_bot_scanner_host)) {
          icons = `${icons} ${crawler_bot_scanner_host_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.is_multicast)) {
          icons = `${icons} ${multicast_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.localhost)) {
          icons = `${icons} ${localhost_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.remotehost)) {
          icons = `${icons} ${remotehost_icon}`;
      }
      if (!dataUtils.isEmptyOrNull(value.is_blackhole)) {
          icons = `${icons} ${blackhole_icon}`;
      }
      if (value.port !== 0) {
          port_name = ` : <a href="#" class="tableFilter" tag-filter="port" tag-value="${value.port}">${value.service_port || value.port}</a>`;
      } else {
          port_name = '';
      }
      if (!dataUtils.isEmptyOrNull(value.process.name)) {
          process = ` <a href="${http_prefix}/lua/process_details.lua?host=${value.ip}&vlan=${value.vlan}&pid_name=${value.process.pid_name}&pid=${value.process.pid}"><i class='fas fa-terminal'></i> ${value.process.process_name}</a>`;
      }
      if (!dataUtils.isEmptyOrNull(value.container.id)) {
          container = ` <a href="${http_prefix}/lua/flows_stats.lua?container=${value.container.id}"><i class='fas fa-ship'></i> ${value.container.name}</a>`;
      }
      if (props.context.is_viewed) {
          return `<a href="#" class="tableFilter" tag-filter="flowhosts_type" tag-value="${value.ip}@${value.vlan || 0}">${value.name}</a> ${icons}${port_name}${process}${container}`
      } else {
          return `<a href="#" class="tableFilter" tag-filter="flowhosts_type" tag-value="${value.ip}@${value.vlan || 0}">${value.name}</a> ${icons} <a href=${url}>${host_details_icon}</a>${port_name}${process}${container}`
      }
  };

  const map_table_def_columns = (columns) => {
      let map_columns = {
          "flow": (value, row) => {
              const client = format_host(row.client);
              const server = format_host(row.server);
              return `${client} <i class="fas fa-exchange-alt fa-lg" aria-hidden="true"></i> ${server}`
          },
          "protocol": (value, row) => {
              value = row.application;
              const name = row.verdict ? ` <strike>${value.name}</strike>` : `${value.name}`;
              const l7_proto_id = (dataUtils.isEmptyOrNull(value.master_id) || value.master_id === value.app_id) ? value.app_id : `${value.master_id}.${value.app_id}`;
              const application = `<a href="#" class="tableFilter" tag-filter="application" tag-value="${l7_proto_id}">${name} ${protocolUtils.formatBreedIcon(value.breed, value.encrypted)}</a> ${protocolUtils.formatConfidence(value.confidence, value.confidence_id)}`;
              value = row.l4_proto;
              let proto = "";
              if (value && value.name) {
                  proto = row.verdict ? ` <strike>${value.name}</strike>` : `${value.name}`;
              }
              proto = `<a href="#" class="tableFilter" tag-filter="l4proto" tag-value="${value.id}">${proto}</a>`;
              return `${proto}:${application}`
          },
          "proto": (value, row) => {
              if (value) {
                  const name = row.verdict ? ` <strike>${value}</strike>` : `${value}`;
                  return name
              }
              return ""
          },
          "first_seen": (value, row) => {
              if (value > 0) {
                  return NtopUtils$1.secondsToTime((Math.round(new Date().getTime() / 1000)) - value)
              }
              return ''
          },
          "last_seen": (value, row) => {
              if (value > 0) {
                  return NtopUtils$1.secondsToTime((Math.round(new Date().getTime() / 1000)) - value)
              }
              return ''
          },
          "score": (value, row) => {
              if (value > 0) {
                  let danger_icon = '';
                  if (!dataUtils.isEmptyOrNull(row.predominant_alert)) {
                      danger_icon = ` <i class="${alertSeverities.getSeverityIcon(row.predominant_alert.severity_id)}" title="${row.predominant_alert.name}"></i>`;
                  }
                  return `${formatterUtils.getFormatter("full_number")(value)}${danger_icon}`
              }
              return ''
          },
          "traffic_breakdown": (value, row) => {
              const cli_bytes_pctg = row.bytes.cli_bytes * 100 / row.bytes.total;
              const srv_bytes_pctg = (row.bytes.total - row.bytes.cli_bytes) * 100 / row.bytes.total;
              return NtopUtils$1.createBreakdown(cli_bytes_pctg, srv_bytes_pctg, i18n('client'), i18n('server'))
          },
          "throughput": (value, row) => {
              let return_value = '';
              if (value.type === 'bps' && !dataUtils.isEmptyOrNull(value.bps)) {
                  return_value = formatterUtils.getFormatter("bps")(value.bps);
              } else if (value.type === 'pps' && !dataUtils.isEmptyOrNull(value.pps)) {
                  return_value = formatterUtils.getFormatter("pps")(value.pps);
              }
              if (!dataUtils.isEmptyOrNull(return_value) && !dataUtils.isEmptyOrNull(value.trend)) {
                  return_value = `${return_value} ${thpt_trend_icons[value.trend]}`;
              }
              return return_value
          },
          "bytes": (value, row) => {
              if (!dataUtils.isEmptyOrNull(value.total)) {
                  return formatterUtils.getFormatter("bytes")(value.total)
              }
              return ''
          },
          "info": (value, row) => {
              let info = '';
              if (!dataUtils.isEmptyOrNull(value)) {
                  info = value;
                  const periodic_map_url = `${http_prefix}/lua/pro/enterprise/network_maps.lua?map=periodicity_map&page=table`;
                  if (row.periodic_flow) {
                      const address = row.client.mac ? row.client.mac : row.client.host;
                      info = `${value} <a href="${periodic_map_url}&host=${address}&l7proto=${row.application.name}"><span class="badge bg-warning text-dark">${i18n("periodic_flow")}</span></a>`;
                  }
                  if (row.application.http_method) {
                      let span_mode = "warning";
                      let color_class = "badge bg-danger";
                      if (row.application.http_method == "GET") {
                          span_mode = "success";
                      }
                      if (row.application.return_code < 400) {
                          color_class = "badge bg-success";
                      }
                      info = `<span class="badge bg-${span_mode}">${row.application.http_method}</span> <span class="${color_class}">${row.application.rsp_status_code}</span> ${info}`;
                  }
              }
              return info
          },
          "flow_exporter": (value) => {
              if (!dataUtils.isEmptyOrNull(value)) {
                  let ifid = '';
                  let ifid_name = '';
                  let tag_filter2 = '';
                  if(value.seen_on_interface) {
                      ifid = `&ifid=${value.seen_on_interface.id}`;
                      ifid_name = ` [${value.seen_on_interface.name}]`;
                      tag_filter2 = ` tag-filter2="interface_filter" tag-value2="${value.seen_on_interface.id}" `;
                  }
                  return `<a href="${flow_exporter_url}?ip=${value.device.ip}${ifid}">${flow_exporter_icon}</a> <a href="#" class="tableFilter" tag-filter="deviceIP" tag-value="${value.device.ip}" ${tag_filter2}>${value.device.name}${ifid_name}</a>`
              }
              return ''
          },
          "in_index": (value, row) => {
              if (!dataUtils.isEmptyOrNull(row.flow_exporter)) {
                  let ifid = '';
                  let tag_filter3 = '';
                  let name = row.flow_exporter.in_port.name;
                  if (name !== row.flow_exporter.in_port.index) {
                      name = `${name} [${row.flow_exporter.in_port.index}]`;
                  }
                  if(row.flow_exporter.seen_on_interface) {
                      ifid = `&ifid=${row.flow_exporter.seen_on_interface.id}`;
                      tag_filter3 = ` tag-filter3="interface_filter" tag-value3="${row.flow_exporter.seen_on_interface.id}" `;
                  }
                  return `<a href="${flow_exporter_url}?ip=${row.flow_exporter.device.ip}&snmp_port_idx=${row.flow_exporter.in_port.index}"${ifid}>${flow_exporter_icon}</a> <a href="#" class="tableFilter" tag-filter="inIfIdx" tag-filter2="deviceIP" tag-value="${row.flow_exporter.in_port.index}" tag-value2="${row.flow_exporter.device.ip}"${tag_filter3}>${name}</a>`
              }
              return ''
          },
          "out_index": (value, row) => {
              if (!dataUtils.isEmptyOrNull(row.flow_exporter)) {
                  let ifid = '';
                  let tag_filter3 = '';
                  let name = row.flow_exporter.out_port.name;
                  if (name !== row.flow_exporter.out_port.index) {
                      name = `${name} [${row.flow_exporter.out_port.index}]`;
                  }
                  if(row.flow_exporter.seen_on_interface) {
                      ifid = `&ifid=${row.flow_exporter.seen_on_interface.id}`;
                      tag_filter3 = ` tag-filter3="interface_filter" tag-value3="${row.flow_exporter.seen_on_interface.id}" `;
                  }
                  return `<a href="${flow_exporter_url}?ip=${row.flow_exporter.device.ip}&snmp_port_idx=${row.flow_exporter.out_port.index}"${ifid}>${flow_exporter_icon}</a> <a href="#" class="tableFilter" tag-filter="outIfIdx" tag-filter2="deviceIP" tag-value="${row.flow_exporter.out_port.index}" tag-value2="${row.flow_exporter.device.ip}"${tag_filter3}>${name}</a>`
              }
              return ''
          },
      };
      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
      });

      return columns;
  };

  /* ************************************** */

  function set_filter_array_label() {
      filter_table_array.value.forEach((el, index) => {
          /* Setting the basic label */
          if (el.basic_label == null) {
              el.basic_label = el.label;
          }

          /* Getting the currently selected filter */
          const url_entry = ntopng_url_manager.get_url_entry(el.id);
          el.options.forEach((option) => {
              if (option.value.toString() === url_entry) {
                  el.current_option = option;
              }
          });
      });
  }

  /* ************************************** */

  function add_filter_from_table_element(e) {
      const value = e.target.getAttribute("tag-value");
      const filter = e.target.getAttribute("tag-filter");
      const value2 = e.target.getAttribute("tag-value2");
      const filter2 = e.target.getAttribute("tag-filter2");
      const value3 = e.target.getAttribute("tag-value3");
      const filter3 = e.target.getAttribute("tag-filter3");
      add_table_filter({
          key: filter,
          value: value
      }, (filter2) ? {
          key: filter2,
          value: value2
      } : null, (filter3) ? {
          key: filter3,
          value: value3
      } : null);
  }

  /* ************************************** */

  function add_filters_to_rows() {
      const filters = document.querySelectorAll('.tableFilter');
      filters.forEach(filter => {
          filter.addEventListener('click', add_filter_from_table_element);
      });
  }

  /* ************************************** */

  function change_filter_labels() {
      add_filters_to_rows();
  }

  /* ************************************** */

  function add_table_filter(opt, opt2, opt3) {
      ntopng_url_manager.set_key_to_url(opt.key, `${opt.value}`);
      if (opt2) {
          ntopng_url_manager.set_key_to_url(opt2.key, `${opt2.value}`);
      }
      if (opt3) {
          ntopng_url_manager.set_key_to_url(opt3.key, `${opt3.value}`);
      }
      table_flows_list.value.refresh_table();
      load_table_filters_array();
  }

  /* ************************************** */

  function set_filters_list(res) {
      if (!res) {
          filter_table_array.value = filters.value.filter((t) => {
              if (t.show_with_key) {
                  const key = ntopng_url_manager.get_url_entry(t.show_with_key);
                  if (key !== t.show_with_value) {
                      return false
                  }
              }
              return true
          });
      } else {
          filters.value = res.map((t) => {
              const key_in_url = ntopng_url_manager.get_url_entry(t.name);
              if (key_in_url === null) {
                  ntopng_url_manager.set_key_to_url(t.name, ``);
              }
              return {
                  id: t.name,
                  label: t.label,
                  title: t.tooltip,
                  options: t.value,
                  show_with_key: t.show_with_key,
                  show_with_value: t.show_with_value,
              };
          });
          set_filters_list();
          return;
      }
      set_filter_array_label();
  }

  /* ************************************** */

  async function load_table_filters_array() {
      /* Clear the interval 2 times just in case, being this function async, 
          it could happen some strange behavior */
      clearInterval(interval_id.value);
      loading.value = true;
      let extra_params = get_extra_params_obj();
      let url_params = ntopng_url_manager.obj_to_url_params(extra_params);
      const url = `${http_prefix}/lua/rest/v2/get/flow/flow_filters.lua?${url_params}`;
      const res = await ntopng_utility.http_request(url);
      set_filters_list(res);
      loading.value = false;
      clearInterval(interval_id.value);
      interval_id.value = setInterval(refresh_table, refresh_rate);
  }

  /*
  const reset_piety = async function () {
      await chart.value.reset();
      await chart.value.update(application_thpt_url + "?" + ntopng_url_manager.get_url_params());
  }
  */

  /* ************************************** */

  function reset_filters() {
      filter_table_array.value.forEach((el, index) => {
          /* Getting the currently selected filter */
          ntopng_url_manager.set_key_to_url(el.id, ``);
      });
      load_table_filters_array();
      table_flows_list.value.refresh_table();
  }

  /* ************************************** */

  function columns_sorting(col, r0, r1) { }

  /* ************************************** */

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager.get_url_object();
      return extra_params;
  };

  /* ************************************** */

  function create_config_url_link(row) {
      return `${http_prefix}/lua/flow_details.lua?flow_key=${row.key}&flow_hash_id=${row.hash_id}`
  }

  /* ************************************** */

  function click_button_live_flows(event) {
      const row = event.row;
      window.open(create_config_url_link(row));
  }

  /* ************************************** */

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_live_flows": click_button_live_flows,
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  /* ************************************** */

  function refresh_table() {
      //    chart.value.update(application_thpt_url + "?" + ntopng_url_manager.get_url_params());
      table_flows_list.value.refresh_table(true);
  }

  /* ************************************** */

  onBeforeMount(() => {
      load_table_filters_array();
  });

  /* ************************************** */

  onMounted(() => {
      clearInterval(interval_id.value);
      interval_id.value = setInterval(refresh_table, refresh_rate);
      //    chart.value.update(application_thpt_url + "?" + ntopng_url_manager.get_url_params());
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$c, [
      createCommentVNode("    <div class=\"d-flex justify-content-center align-items-center\">\n            <div class=\"col-12\">\n                <PietyChart ref=\"chart\" :id=\"piety_id\" :refresh_rate=\"refresh_rate\">\n                </PietyChart>\n            </div>\n        </div>\n"),
      createVNode(script$1w, {
        ref_key: "table_flows_list",
        ref: table_flows_list,
        table_id: unref(table_id),
        csrf: unref(csrf),
        f_map_columns: map_table_def_columns,
        get_extra_params_obj: get_extra_params_obj,
        f_sort_rows: columns_sorting,
        onCustom_event: on_table_custom_event,
        onRows_loaded: change_filter_labels
      }, {
        custom_header: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (item) => {
            return (openBlock(), createElementBlock("div", _hoisted_2$a, [
              createBaseVNode("span", _hoisted_3$a, [
                createBaseVNode("b", null, toDisplayString(item["basic_label"]), 1 /* TEXT */)
              ]),
              createVNode(script$1I, {
                selected_option: item['current_option'],
                "onUpdate:selected_option": $event => ((item['current_option']) = $event),
                theme: "bootstrap-5",
                dropdown_size: "small",
                disabled: loading.value,
                options: item['options'],
                onSelect_option: add_table_filter
              }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "disabled", "options"])
            ]))
          }), 256 /* UNKEYED_FRAGMENT */)),
          createBaseVNode("div", _hoisted_4$a, [
            createBaseVNode("div", {
              class: "btn btn-sm btn-primary mt-2 me-3",
              type: "button",
              onClick: reset_filters
            }, toDisplayString(_i18n('reset')), 1 /* TEXT */),
            createVNode(script$1v, {
              show: loading.value,
              size: "1rem",
              class: "me-1"
            }, null, 8 /* PROPS */, ["show"])
          ])
        ]),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["table_id", "csrf"])
    ]))
  }
  }

  };

  script$g.__file = "http_src/vue/page-flows-list.vue";

  const _hoisted_1$b = { class: "m-2 mb-3" };
  const _hoisted_2$9 = ["title"];
  const _hoisted_3$9 = ["onClick", "title"];
  const _hoisted_4$9 = { class: "card-footer" };

  /* ************************************** */


  var script$f = {
    __name: 'page-snmp-interfaces',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;



  /* ************************************** */

  /* The same exact page is used for both, the interfaces page for all SNMP devices
   * and the interfaces page for a specific device. Having different columns, simply switch between 
   * those two tables.
   */
  const table_id = props.context?.inside_a_device ? ref('snmp_device_interfaces') : ref('snmp_interfaces');
  const table_snmp_interfaces = ref(null);
  const csrf = props.context.csrf;
  const filter_table_array = ref([]);
  const filter_table_dropdown_array = ref([]);

  const note_list = [
      i18n("snmp.snmp_note_periodic_interfaces_polling"),
      i18n("snmp.snmp_note_thpt_calc"),
      i18n("snmp.snmp_note_avg_usage")
  ];
  const interface_status = {
      ["1"]: "<font color=green>" + i18n("snmp.status_up") + "</font>",
      ["101"]: "<font color=green>" + i18n("snmp.status_up_in_use") + "</font>",
      ["2"]: "<font color=red>" + i18n("snmp.status_down") + "</font>",
      ["3"]: i18n("snmp.testing"),
      ["4"]: i18n("snmp.status_unknown"),
      ["5"]: i18n("snmp.status_dormant"),
      ["6"]: i18n("status_notpresent"),
      ["7"]: "<font color=red>" + i18n("snmp.status_lowerlayerdown") + "</font>",
  };
  const duplex_status = {
      ["1"]: i18n("unknown"),
      ["2"]: "<font color=orange>" + i18n("flow_devices.half_duplex") + "</font>",
      ["3"]: "<font color=green>" + i18n("flow_devices.full_duplex") + "</font>"
  };

  /* ************************************** */

  const map_table_def_columns = (columns) => {
      formatterUtils.getFormatter("percentage");
      let map_columns = {
          "device_name": (value, row) => {
              const url = `${http_prefix}/lua/pro/enterprise/snmp_device_details.lua?ip=${row.device_ip}`;
              return `<a href=${url}>${value}</a>`
          },
          "interface_name": (value, row) => {
              const url = `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.device_ip}&snmp_port_idx=${row.interface_id}`;
              return `<a href=${url}>${value}</a>`
          },
          "vlan": (value, row) => {
              let vlan_name = '';
              if (row.vlan_name != '') {
                  vlan_name = '[' + row.vlan_name + ']';
              }
              return `${value} ${vlan_name}`
          },
          "admin_status": (value, row) => {
              return `${interface_status[value] || ''}`
          },
          "status": (value, row) => {
              return `${interface_status[value] || ''}`
          },
          "duplex_status": (value, row) => {
              return `${duplex_status[value] || ''}`
          },
          "num_macs": (value, row) => {
              if (value > 0) {
                  const url = `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.device_ip}&snmp_port_idx=${row.interface_id}&page=layer_2`;
                  return `<a href=${url}>${value}</a>`
              }
              return ''
          },
          "in_bytes": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("bytes")(value)
              }
              return ''
          },
          "out_bytes": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("bytes")(value)
              }
              return ''
          },
          "in_errors": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "in_discards": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("full_number")(value)
              }
              return ''
          },
          "throughput": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("bps")(value)
              }
              return ''
          },
          "uplink_speed": (value, row) => {
              const formatted_speed = formatterUtils.getFormatter("speed")(value);
              return `${formatted_speed} <a href='${create_config_url_link(row, true)}'><i class="fas fa-cog"></i></a>`
          },
          "downlink_speed": (value, row) => {
              const formatted_speed = formatterUtils.getFormatter("speed")(value);
              return `${formatted_speed} <a href='${create_config_url_link(row, true)}'><i class="fas fa-cog"></i></a>`
          },
          "last_in_usage": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("percentage")(value)
              }
              return ''
          },
          "last_out_usage": (value, row) => {
              if (value > 0) {
                  return formatterUtils.getFormatter("percentage")(value)
              }
              return ''
          },
          "last_change": (value, row) => {
              return row.last_change_string
          },
      };
      columns.forEach((c) => {
          c.render_func = map_columns[c.data_field];
          if (c.id == "actions") {
              const visible_dict = {
                  historical_data: props.show_historical,
              };
              c.button_def_array.forEach((b) => {
                  if (!visible_dict[b.id]) {
                      b.class.push("disabled");
                  }
              });
          }
      });

      return columns;
  };

  /* ************************************** */

  function set_filter_array_label() {
      filter_table_array.value.forEach((el, index) => {
          if (el.basic_label == null) {
              el.basic_label = el.label;
          }

          const url_entry = ntopng_url_manager.get_url_entry(el.id);
          if (url_entry != null) {
              el.options.forEach((option) => {
                  if (option.value.toString() === url_entry) {
                      el.label = `${el.basic_label}: ${option.label || option.value}`;
                  }
              });
          }
      });
  }

  /* ************************************** */

  function add_table_filter(opt, event) {
      event.stopPropagation();
      ntopng_url_manager.set_key_to_url(opt.key, `${opt.value}`);
      set_filter_array_label();
      table_snmp_interfaces.value.refresh_table();
  }

  /* ************************************** */

  const get_open_filter_table_dropdown = (filter, filter_index) => {
      return (_) => {
          load_table_filters(filter, filter_index);
      };
  };

  /* ************************************** */

  async function load_table_filters(filter, filter_index) {
      filter.show_spinner = true;
      await nextTick();
      filter.options = filter_table_array.value.find((t) => t.id == filter.id).options;
      await nextTick();
      let dropdown = filter_table_dropdown_array.value[filter_index];
      dropdown.load_menu();
      filter.show_spinner = false;
  }

  /* ************************************** */

  async function load_table_filters_array() {
      let extra_params = get_extra_params_obj();
      let url_params = ntopng_url_manager.obj_to_url_params(extra_params);
      const url = `${http_prefix}/lua/pro/rest/v2/get/snmp/metric/interfaces_filters.lua?${url_params}`;
      let res = await ntopng_utility.http_request(url);
      return res.map((t) => {
          return {
              id: t.name,
              label: t.label,
              title: t.tooltip,
              options: t.value,
              hidden: (t.value.length == 1)
          };
      });
  }

  /* ************************************** */

  function columns_sorting(col, r0, r1) {
      if (col != null) {
          const r0_col = r0[col.data.data_field];
          const r1_col = r1[col.data.data_field];

          /* In case the values are the same, sort by IP */
          if (r0_col == r1_col) {
              return sortingFunctions.sortByName(r0.device, r1.device, col ? col.sort : null);
          }
          if (col.id == "device_name") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "ip") {
              return sortingFunctions.sortByIP(r0_col, r1_col, col.sort);
          } else if (col.id == "interface") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "type") {
              return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
          } else if (col.id == "speed") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "min") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "max") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "average") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "congestion_rate") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          } else if (col.id == "last_value") {
              const lower_value = -1;
              return sortingFunctions.sortByNumberWithNormalizationValue(r0_col, r1_col, col.sort, lower_value);
          }
      }

      return sortingFunctions.sortByName(r0.device, r1.device, col ? col.sort : null);
  }

  /* ************************************** */

  const get_extra_params_obj = () => {
      let extra_params = ntopng_url_manager.get_url_object();
      return extra_params;
  };

  /* ************************************** */

  function create_config_url_link(row, add_interface) {
      if (add_interface) {
          return `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.device_ip}&snmp_port_idx=${row.interface_id}&page=config`
      } else {
          return `${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.device_ip}&page=config`
      }
  }

  /* ************************************** */

  function click_button_timeseries(event) {
      const row = event.row;
      const epoch_begin = ntopng_url_manager.get_url_entry("epoch_begin");
      const epoch_end = ntopng_url_manager.get_url_entry("epoch_end");
      window.open(`${http_prefix}/lua/pro/enterprise/snmp_interface_details.lua?host=${row.ip}&snmp_port_idx=${row.ifid}&page=historical&ifid=-1&epoch_end=${epoch_end}&epoch_begin=${epoch_begin}&timeseries_groups_mode=1_chart_x_metric&timeseries_groups=snmp_interface;-1%2B${row.ip}%2B${row.ifid};snmp_if:usage;uplink=true:false:false:false|downlink=true:false:false:false`);
  }

  /* ************************************** */

  function click_button_configuration(event) {
      const row = event.row;
      window.open(create_config_url_link(row, true));
  }

  /* ************************************** */

  function on_table_custom_event(event) {
      let events_managed = {
          "click_button_timeseries": click_button_timeseries,
          "click_button_configuration": click_button_configuration
      };
      if (events_managed[event.event_id] == null) {
          return;
      }
      events_managed[event.event_id](event);
  }

  /* ************************************** */

  onMounted(async () => {
      filter_table_array.value = await load_table_filters_array();
  });


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$b, [
        createVNode(script$1w, {
          ref_key: "table_snmp_interfaces",
          ref: table_snmp_interfaces,
          table_id: unref(table_id),
          csrf: unref(csrf),
          f_map_columns: map_table_def_columns,
          get_extra_params_obj: get_extra_params_obj,
          f_sort_rows: columns_sorting,
          onCustom_event: on_table_custom_event
        }, {
          custom_header: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(filter_table_array.value, (t, t_index) => {
              return (openBlock(), createBlock(script$1J, {
                f_on_open: get_open_filter_table_dropdown(t, t_index),
                ref_for: true,
                ref: el => { filter_table_dropdown_array.value[t_index] = el; },
                hidden: t.hidden
              }, {
                title: withCtx(() => [
                  createVNode(script$1v, {
                    show: t.show_spinner,
                    size: "1rem",
                    class: "me-1"
                  }, null, 8 /* PROPS */, ["show"]),
                  createBaseVNode("a", {
                    class: "ntopng-truncate",
                    title: t.title
                  }, toDisplayString(t.label), 9 /* TEXT, PROPS */, _hoisted_2$9)
                ]),
                menu: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(t.options, (opt) => {
                    return (openBlock(), createElementBlock("a", {
                      style: {"cursor":"pointer","display":"block"},
                      onClick: $event => (add_table_filter(opt, $event)),
                      class: "ntopng-truncate tag-filter",
                      title: opt.value
                    }, [
                      (opt.count == null)
                        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(opt.label), 1 /* TEXT */)
                          ], 64 /* STABLE_FRAGMENT */))
                        : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(opt.label + " (" + opt.count + ")"), 1 /* TEXT */)
                          ], 64 /* STABLE_FRAGMENT */))
                    ], 8 /* PROPS */, _hoisted_3$9))
                  }), 256 /* UNKEYED_FRAGMENT */))
                ]),
                _: 2 /* DYNAMIC */
              }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["f_on_open", "hidden"]))
            }), 256 /* UNKEYED_FRAGMENT */))
          ]),
          _: 1 /* STABLE */
        }, 8 /* PROPS */, ["table_id", "csrf"])
      ]),
      createBaseVNode("div", _hoisted_4$9, [
        createVNode(script$1u, { note_list: note_list })
      ])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  script$f.__file = "http_src/vue/page-snmp-interfaces.vue";

  const _hoisted_1$a = { class: "row" };
  const _hoisted_2$8 = { class: "col-md-12 col-lg-12" };
  const _hoisted_3$8 = { class: "card card-shadow" };
  const _hoisted_4$8 = { class: "card-body" };
  const _hoisted_5$8 = { class: "card-footer" };

  /* ******************************************************************** */

  /* Consts */

  var script$e = {
    __name: 'page-topology',
    props: {
    context: Object,
  },
    setup(__props) {

  const props = __props;

  /* Imports */
  const _i18n = (t) => i18n(t);

  const note_list = [
    _i18n("snmp.snmp_note_periodic_interfaces_polling"),
    _i18n("snmp.snmp_note_thpt_calc"),
    _i18n("snmp.snmp_lldp_cdp_descr")
  ];

  const table_id = ref("topology");
  const table_topology = ref();
  const total_rows = ref(0);


  const context = ref({
    csrf: props.context.csrf,
    ifid: props.context.ifid,
  });



  const get_extra_params_obj = () => {
    let extra_params = ntopng_url_manager$1.get_url_object();
    return extra_params;
  };


  /* This function simply return the data of the exact column and row requested */
  function column_data(col, row) {
    let data = row[col.data.data_field];
    if (col.data.data_field == "port_id") {
      return Number(data.split(">")[1].split("<")[0]);
    }
    return data;
  }


  /* Function used to sort the columns of the table */
  function columns_sorting(col, r0, r1) {
    if (col != null) {
      let r0_col = column_data(col, r0);
      let r1_col = column_data(col, r1);

      
      if (col.id == "port_id") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else if (col.id == "port_thpt_value") {
        return sortingFunctions.sortByNumber(r0_col, r1_col, col.sort);
      } else {  
        return sortingFunctions.sortByName(r0_col, r1_col, col.sort);
      }
    }

  }

  /* Get the number of rows of the table */
  function on_table_loaded() {
    total_rows.value = table_topology.value.get_rows_num();
  }

  /* ******************************************************************** */

  /* Function to map columns data */
  const map_table_def_columns = (columns) => {
    let map_columns = {
      "uplink_speed": (data, row) => {
        return NtopUtils$1.bitsToSize(data);
      },
      "downlink_speed": (data, row) => {
        return NtopUtils$1.bitsToSize(data);
      },
      "port_thpt_value": (data, row) => {
        if (data == null) data = 0;
        return NtopUtils$1.bitsToSize(data);
      }
    };
    columns.forEach((c) => {
      c.render_func = map_columns[c.data_field];
    });
    
    return columns;
  };


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$a, [
      createBaseVNode("div", _hoisted_2$8, [
        createBaseVNode("div", _hoisted_3$8, [
          createBaseVNode("div", _hoisted_4$8, [
            createVNode(script$1w, {
              ref_key: "table_topology",
              ref: table_topology,
              table_id: table_id.value,
              csrf: context.value.csrf,
              f_map_columns: map_table_def_columns,
              get_extra_params_obj: get_extra_params_obj,
              f_sort_rows: columns_sorting,
              onRows_loaded: on_table_loaded
            }, null, 8 /* PROPS */, ["table_id", "csrf"])
          ]),
          createBaseVNode("div", _hoisted_5$8, [
            createVNode(script$1u, { note_list: note_list })
          ])
        ])
      ])
    ]))
  }
  }

  };

  script$e.__file = "http_src/vue/page-topology.vue";

  const _hoisted_1$9 = { style: {"min-height":"8.5rem"} };
  const _hoisted_2$7 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_3$7 = { class: "col-form-label col-sm-4" };
  const _hoisted_4$7 = { class: "col-sm-6" };
  const _hoisted_5$7 = ["pattern"];
  const _hoisted_6$4 = ["disabled"];


  var script$d = {
    __name: 'modal-file-save',
    props: {
      csrf: String,
      title: String,
      get_suggested_file_name: Function,
      store_file: Function,
      allow_spaces: Boolean
  },
    emits: ['file_stored'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const showed = () => {};
  const file_name = ref("");
  ref("date"); // name / date





  let pattern = NtopUtils.REGEXES.singleword;

  const disable_add = computed$1(() => {
      let rg = new RegExp(pattern);
      return !rg.test(file_name.value);
  });

  const show = () => {
      init();
      modal_id.value.show();
  };

  async function init() {
      file_name.value = props.get_suggested_file_name();
  }

  const store_file = async () => {
      props.store_file(file_name.value);
      emit('file_stored', file_name.value);
      close();
  };

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });

  onMounted(() => {
      if (props.allow_spaces) {
          pattern = NtopUtils.REGEXES.multiword;
      } else {
          pattern = NtopUtils.REGEXES.singleword;
      }
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[1] || (_cache[1] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$9, [
          createBaseVNode("div", _hoisted_2$7, [
            createBaseVNode("label", _hoisted_3$7, [
              createBaseVNode("b", null, toDisplayString(_i18n("name")) + ":", 1 /* TEXT */)
            ]),
            createBaseVNode("div", _hoisted_4$7, [
              withDirectives(createBaseVNode("input", {
                pattern: unref(pattern),
                placeholder: "",
                required: "",
                type: "text",
                class: "form-control",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((file_name).value = $event))
              }, null, 8 /* PROPS */, _hoisted_5$7), [
                [vModelText, file_name.value]
              ])
            ])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: store_file,
          disabled: unref(disable_add),
          class: "btn btn-primary"
        }, toDisplayString(_i18n("save")), 9 /* TEXT, PROPS */, _hoisted_6$4)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$6 = "\ninput[data-v-87fda19e]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-87fda19e] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$6);

  script$d.__scopeId = "data-v-87fda19e";
  script$d.__file = "http_src/vue/modal-file-save.vue";

  const _hoisted_1$8 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$6 = { class: "col-form-label col-sm-4" };
  const _hoisted_3$6 = { class: "col-sm-8" };
  const _hoisted_4$6 = { value: "name" };
  const _hoisted_5$6 = { value: "date" };
  const _hoisted_6$3 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_7$3 = { class: "col-form-label col-sm-4" };
  const _hoisted_8$3 = { class: "col-sm-8" };
  const _hoisted_9$3 = ["disabled"];
  const _hoisted_10$3 = ["disabled"];


  var script$c = {
    __name: 'modal-file-open',
    props: {
      csrf: String,
      title: String,
      file_title: String,
      list_files: Function,
      open_file: Function,
      delete_file: Function,
  },
    emits: ['file_deleted'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const showed = () => {};
  const file_selected = ref({});
  const file_name = ref("");
  const files = ref([]);
  const order_by = ref("date"); // name / date





  NtopUtils.REGEXES.singleword;

  const disable_select = computed$1(() => {
      return file_selected.value == "";
  });

  const show = () => {
      init();
      modal_id.value.show();
  };

  function display_name(file) {
      let utc_ms = file.epoch * 1000;
      let date = ntopng_utility.from_utc_to_server_date_format(utc_ms, "DD/MM/YYYY");
      return `${file.name} (${date})`
  }

  function sort_files_by() {
      files.value = files.value.sort((a, b) => {
  	if (order_by.value == "name") {
              /* Name asc */
  	    return a.name.localeCompare(b.name);
  	} else {
              /* Date desc (last first) */
  	    return b.epoch - a.epoch;
          }
      });
      if (files.value.length > 0) {
  	file_selected.value = files.value[0];
      }
  }

  async function init() {
      file_name.value = "";
      files.value = await props.list_files();
      files.value.forEach((f) => f.label = display_name(f));
      sort_files_by();
      if (files.value.length > 0) {
  	file_selected.value = files.value[0];
      }
  }

  const select_file = () => {
      close();
      props.open_file(file_selected.value.name);
  };

  const delete_file = async (delete_all) => {
      let name = file_selected.value.name;
      if (delete_all == true) { name = "*"; }
      if (props.delete_file(name)) {
          emit('file_deleted', name);
      }
      close();
  };

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[4] || (_cache[4] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$8, [
          createBaseVNode("label", _hoisted_2$6, [
            createBaseVNode("b", null, toDisplayString(_i18n("order_by")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$6, [
            withDirectives(createBaseVNode("select", {
              class: "form-select",
              onChange: _cache[0] || (_cache[0] = $event => (sort_files_by())),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((order_by).value = $event))
            }, [
              createBaseVNode("option", _hoisted_4$6, toDisplayString(_i18n("name")), 1 /* TEXT */),
              createBaseVNode("option", _hoisted_5$6, toDisplayString(_i18n("date")), 1 /* TEXT */)
            ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
              [vModelSelect, order_by.value]
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_6$3, [
          createBaseVNode("label", _hoisted_7$3, [
            createBaseVNode("b", null, toDisplayString(__props.file_title), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_8$3, [
            createVNode(script$1I, {
              selected_option: file_selected.value,
              "onUpdate:selected_option": _cache[2] || (_cache[2] = $event => ((file_selected).value = $event)),
              options: files.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          onClick: _cache[3] || (_cache[3] = $event => (delete_file(true))),
          type: "button",
          style: {"text-align":"left","margin-left":"0px"},
          class: "btn btn-danger start-0 position-absolute ms-3"
        }, toDisplayString(_i18n("delete_all_entries")), 1 /* TEXT */),
        createBaseVNode("button", {
          type: "button",
          onClick: delete_file,
          disabled: unref(disable_select),
          class: "btn btn-danger"
        }, toDisplayString(_i18n("delete")), 9 /* TEXT, PROPS */, _hoisted_9$3),
        createBaseVNode("button", {
          type: "button",
          onClick: select_file,
          disabled: unref(disable_select),
          class: "btn btn-primary"
        }, toDisplayString(_i18n("open")), 9 /* TEXT, PROPS */, _hoisted_10$3)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$5 = "\ninput[data-v-1976657e]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-1976657e] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$5);

  script$c.__scopeId = "data-v-1976657e";
  script$c.__file = "http_src/vue/modal-file-open.vue";

  const _withScopeId$2 = n => (pushScopeId("data-v-9db8ba96"),n=n(),popScopeId(),n);
  const _hoisted_1$7 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$5 = { class: "col-form-label col-sm-4" };
  const _hoisted_3$5 = { class: "col-sm-8" };
  const _hoisted_4$5 = /*#__PURE__*/ _withScopeId$2(() => /*#__PURE__*/createBaseVNode("span", null, " ", -1 /* HOISTED */));
  const _hoisted_5$5 = ["disabled"];


  var script$b = {
    __name: 'modal-file-upload',
    props: {
      csrf: String,
      title: String,
      file_title: String,
      upload_file: Function,
  },
    emits: ['file_uploaded'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const showed = () => {};
  const file_content = ref("");
  const file_name = ref("");
  const file_input = ref(null);





  const show = () => {
      init();
      modal_id.value.show();
  };

  async function init() {
      file_name.value = "";
      file_content.value = "";
  }

  function on_pick_file () {
      file_input.value.click();
  }

  function on_file_picked (event) {
      const files = event.target.files;

      file_name.value = files[0].name;

      const fileReader = new FileReader();
      fileReader.addEventListener('load', () => {
          file_content.value = fileReader.result;
      });
      fileReader.readAsText(files[0]);

      emit('file_uploaded', file_name.value);
  }

  const select_file = () => {
      close();
      props.upload_file(file_content.value);
  };

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[0] || (_cache[0] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$7, [
          createBaseVNode("label", _hoisted_2$5, [
            createBaseVNode("b", null, toDisplayString(__props.file_title), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$5, [
            createBaseVNode("button", {
              type: "button",
              onClick: on_pick_file,
              class: "btn btn-primary"
            }, toDisplayString(_i18n("upload")), 1 /* TEXT */),
            _hoisted_4$5,
            withDirectives(createBaseVNode("small", null, "No file selected", 512 /* NEED_PATCH */), [
              [vShow, !file_content.value]
            ]),
            withDirectives(createBaseVNode("small", null, toDisplayString(file_name.value), 513 /* TEXT, NEED_PATCH */), [
              [vShow, file_name.value]
            ]),
            createBaseVNode("input", {
              ref_key: "file_input",
              ref: file_input,
              type: "file",
              accept: "application/JSON",
              onChange: on_file_picked,
              style: {"display":"none"}
            }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */)
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          onClick: select_file,
          disabled: !file_content.value,
          class: "btn btn-primary"
        }, toDisplayString(_i18n("open")), 9 /* TEXT, PROPS */, _hoisted_5$5)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$4 = "\ninput[data-v-9db8ba96]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-9db8ba96] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$4);

  script$b.__scopeId = "data-v-9db8ba96";
  script$b.__file = "http_src/vue/modal-file-upload.vue";

  const _hoisted_1$6 = {
    class: "form-group ms-2 me-2 mt-3 row",
    style: {"overflow-y":"scroll","height":"45vh"}
  };
  const _hoisted_2$4 = ["onClick"];
  const _hoisted_3$4 = { class: "card-body" };
  const _hoisted_4$4 = { class: "form-group wizard-form-group" };
  const _hoisted_5$4 = { class: "form-text text-muted" };


  var script$a = {
    __name: 'modal-select-component',
    props: {
      csrf: String,
      title: String,
      list_components: Function,
      add_component: Function
  },
    emits: [],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  const showed = () => {};
  const selected_component = ref({});
  const components = ref([]);
  ref("date"); // name / date





  const show = () => {
      init();
      modal_id.value.show();
  };

  async function init() {
      components.value = await props.list_components();
      if (components.value.length > 0) {
          selected_component.value = components.value[0];
      }
  }

  function get_component_type_icon(component_type) {
      switch (component_type) {
        case 'pie':
          return "fa-solid fa-chart-pie";
        case 'table':
          return "fa-solid fa-table";
        case 'timeseries':
          return "fa-solid fa-chart-line";
        default:
          return "";
      }
  }

  function onModalChange(e) {
      close();
      props.add_component(selected_component.value);
  }

  const close = () => {
      modal_id.value.close();
  };

  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[0] || (_cache[0] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(__props.title), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createBaseVNode("div", _hoisted_1$6, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(components.value, (c) => {
            return (openBlock(), createElementBlock("div", {
              class: normalizeClass(["card w-100 wizard-card", { 'wizard-selected': selected_component.value == c }])
            }, [
              createBaseVNode("a", {
                class: "wizard-link",
                href: "#",
                onClick: $event => {selected_component.value = c; onModalChange();}
              }, [
                createBaseVNode("div", _hoisted_3$4, [
                  createBaseVNode("div", _hoisted_4$4, [
                    createBaseVNode("h5", null, [
                      createBaseVNode("i", {
                        class: normalizeClass(get_component_type_icon(c.component))
                      }, null, 2 /* CLASS */),
                      createTextVNode(" " + toDisplayString(_i18n(c.i18n_name)), 1 /* TEXT */)
                    ]),
                    createBaseVNode("small", _hoisted_5$4, toDisplayString(_i18n(c.i18n_descr)), 1 /* TEXT */)
                  ])
                ])
              ], 8 /* PROPS */, _hoisted_2$4)
            ], 2 /* CLASS */))
          }), 256 /* UNKEYED_FRAGMENT */))
        ])
      ]),
      footer: withCtx(() => []),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z$3 = "\ninput[data-v-16713f39]:invalid {\n  border-color: #ff0000;\n}\n.not-allowed[data-v-16713f39] {\n  cursor: not-allowed;\n}\n";
  styleInject(css_248z$3);

  script$a.__scopeId = "data-v-16713f39";
  script$a.__file = "http_src/vue/modal-select-component.vue";

  const _hoisted_1$5 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_2$3 = { class: "col-sm-2 mt-2" };
  const _hoisted_3$3 = { class: "col-sm-10" };
  const _hoisted_4$3 = { class: "form-group ms-2 me-2 mt-4 row" };
  const _hoisted_5$3 = { class: "col-sm-2 mt-3" };
  const _hoisted_6$2 = { class: "col-sm-6 mt-2" };
  const _hoisted_7$2 = { class: "range" };
  const _hoisted_8$2 = { class: "sliderticks" };
  const _hoisted_9$2 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_10$2 = { class: "col-sm-2 mt-2" };
  const _hoisted_11$2 = { class: "col-sm-9 mt-2" };
  const _hoisted_12$2 = { class: "range" };
  const _hoisted_13$2 = { class: "sliderticks" };
  const _hoisted_14$2 = {
    key: 0,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_15$2 = { class: "col-sm-2 mt-2" };
  const _hoisted_16$2 = { class: "col-sm-5" };
  const _hoisted_17$2 = { class: "form-group ms-2 me-2 mt-3 row" };
  const _hoisted_18$2 = { class: "col-sm-2 mt-2" };
  const _hoisted_19$2 = { class: "col-sm-5" };
  const _hoisted_20$2 = { class: "ms-2 mb-3 mt-4 row" };
  const _hoisted_21$2 = {
    class: "col-form-label col-sm-3 pe-0",
    id: "advanced-view"
  };
  const _hoisted_22$2 = { class: "col-sm-2 ps-0" };
  const _hoisted_23$2 = {
    class: "form-check form-switch mt-2",
    id: "advanced-view"
  };
  const _hoisted_24$2 = {
    key: 1,
    class: "form-group ms-2 me-2 mt-3 row"
  };
  const _hoisted_25$2 = { class: "col-sm-12" };
  const _hoisted_26$2 = {
    key: 0,
    style: {"color":"rgba(255, 0, 0, 0.797)"}
  };
  const _hoisted_27$2 = ["disabled"];
  /* **************************************************************************** */

  /* Function to retrieve the local word */

  var script$9 = {
    __name: 'modal-edit-component',
    props: {
      csrf: String,
  },
    emits: ["edit"],
    setup(__props, { expose, emit }) {


  /* Imports */
  const _i18n = (t) => i18n(t);

  /* Events Emitted */


  /* Modal Properties */


  /* Consts */
  const title = ref(i18n("dashboard.edit_component"));
  const modal_id = ref(null);
  const slider_values = [
      { id: 1, size_component_value: 4  },
      { id: 2, size_component_value: 6  },
      { id: 3, size_component_value: 12 },
      { id: 4, size_component_value: -1 }
  ];

  /* Time Window options */
  const time_window_list = ref([
      { value:'current', label: _i18n("dashboard.current_time"), default: true },    
      { value:'5_min', label: _i18n("dashboard.time_window_list.5_min")  },
      { value:'30_min', label: _i18n("dashboard.time_window_list.30_min") },
      { value:'hour', label: _i18n("dashboard.time_window_list.hour") },
      { value:'2_hours', label: _i18n("dashboard.time_window_list.2_hours") },
      { value:'12_hours', label: _i18n("dashboard.time_window_list.12_hours") },
      { value:'day', label: _i18n("dashboard.time_window_list.day") },
      { value:'week', label: _i18n("dashboard.time_window_list.week") },
      { value:'month', label: _i18n("dashboard.time_window_list.month") },
      { value:'year', label: _i18n("dashboard.time_window_list.year") },
  ]);

  /* Time Offset options */
  const time_offset_list = ref([
      { value:'current', label: _i18n("dashboard.current_time"), default: true }, 
      { value:'hour', label: _i18n("dashboard.time_offset_list.hour") },
      { value:'day', label: _i18n("dashboard.time_offset_list.day") },
      { value:'week', label: _i18n("dashboard.time_offset_list.week") },
      { value:'month', label: _i18n("dashboard.time_offset_list.month") },
      { value:'year', label: _i18n("dashboard.time_offset_list.year") },
  ]);

  /* Modal Ref Consts */
  const old_component_to_edit = ref(null);
  const component_title = ref(null);
  const width_selected = ref(null);
  const height_selected = ref(null);
  const params_json_data = ref(null);
  const selected_time_window = ref(null);
  const selected_time_offset = ref(null);
  const show_advanced_settings = ref(false); // bool used to enable the advanced view
  const isNotJsonParamsValid = ref(false); // bool used to validate the REST Params in textarea
  const hiddenOnReport = ref(false); // bool used to hide time_window when the page is report

  /* **************************************************************************** */

  /**
   * 
   * @brief This method change the value of the show_advanced_settings
   *        in order to enable the advanced view or disable it.
   */
  const updateAdvancedSettingsView = function() {
      show_advanced_settings.value = !show_advanced_settings.value;
  };

  /**
   * 
   * @brief This method changes the value of the show_advanced_settings 
   *        boolean to enable or disable the advanced view.
   */
  const formatJson = function() {
      
      isNotJsonParamsValid.value = false;
      try {
          params_json_data.value = JSON.stringify(JSON.parse(params_json_data.value), null, 2);
      } catch (e) {
          isNotJsonParamsValid.value = true;
      }
      return params_json_data.value;
  };

  /**
   * 
   * @brief This method selects from the time_array 
   *        (either time_offset_list or time_window_list) 
   *        the object with a value equal to time_value (the old values). 
   *        In case time_value is empty or null, 
   *        the method returns the default object ('Current').
   * @param time_value The time value (5_min, hour, ...) to search for
   * @param time_array The array of time objects 
   *                   (either from time_offset_list or time_window_list).
   */
  const find_time_object = function(time_value, time_array) {
      if (dataUtils.isEmptyOrNull(time_value)) {
          return time_array.find((t) => t.default);
      } else {
          return time_array.find((t) => t.value == time_value);
      }
  };

  /**
   * 
   *  @brief This method is called to reset the modal ref constants.
   *  */ 
  const reset_modal_form = function (hidden) {
      old_component_to_edit.value = null;
      isNotJsonParamsValid.value = false;
      hiddenOnReport.value = hidden;
      component_title.value = "";
      height_selected.value = 1;
      width_selected.value = 1;
  };

  /* **************************************************************************** */

  /**
   * 
   *  @brief This method is called to set the old data of the selected component 
   *         for editing.
   *  @param old_component_to_edit selected component to edit
   *  */ 
  const set_old_component_values = (old_component) => {
      old_component_to_edit.value = old_component;

      component_title.value = old_component.custom_name;
      width_selected.value = convert_size_to_slider_value(old_component.width);
      height_selected.value = convert_size_to_slider_value(old_component.height);
      
      selected_time_window.value = find_time_object(old_component.time_window,time_window_list.value);
      selected_time_offset.value = find_time_object(old_component.time_offset, time_offset_list.value);

      params_json_data.value = JSON.stringify(old_component.params, null, 2);
  };

  /* **************************************************************************** */

  /**
   * 
   *  @brief This method is called whenever the modal is opened 
   *  @param old_component_to_edit selected component to edit
   *  */ 
  const show = (old_component_to_edit, hiddenOnReport) => {
      /* First of all reset all the data */
      reset_modal_form(hiddenOnReport);
      /* Set the old data of the component */
      set_old_component_values(old_component_to_edit);
      modal_id.value.show();
  };

  /* **************************************************************************** */

  /**
   * 
   *  @brief Convert a slider value           (1 (Small), 2 (Medium), 3 (Large),   4 (Auto)) 
   *                 to component size value  (4 (Small), 6 (Medium), 12 (Large), -1 (Auto))
   *  @param s_v slider value 
   *  */ 
  const convert_slider_value_to_size = (s_v) => {
      return slider_values.find((c) => c.id == Number(s_v)).size_component_value;
  }; 

  /**
   * 
   *  @brief Convert a component size value (4 (Small), 6 (Medium), 12 (Large), -1(Auto))
   *         to slider value                (1 (Small), 2 (Medium), 3 (Large),  4 (Auto))  
   *  @param size component size value 
   *  */ 
  const convert_size_to_slider_value = (size) => {
      return slider_values.find((c) => c.size_component_value == Number(size)).id;
  }; 

  /* **************************************************************************** */

  /**
   * 
   *  @brief Function called when the 'Apply' button is clicked 
   *         to emit an 'edit' event and close the modal.
   *  */ 
  const edit_ = () => {
      const new_width     = convert_slider_value_to_size(width_selected.value);
      const new_height    = convert_slider_value_to_size(height_selected.value);
      const new_params    = `${params_json_data.value}`;

      emit("edit", {
          id: old_component_to_edit.value.id,
          title: component_title.value,
          height: new_height,
          width: new_width,
          time_offset: selected_time_offset.value.value,
          time_window: selected_time_window.value.value,
          rest_params: new_params
      });
      modal_id.value.close();
  };

  /* **************************************************************************** */

  expose({ show });

  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(title.value), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        createCommentVNode(" Title "),
        createBaseVNode("div", _hoisted_1$5, [
          createBaseVNode("label", _hoisted_2$3, [
            createBaseVNode("b", null, toDisplayString(_i18n("dashboard.component_title")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_3$3, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((component_title).value = $event)),
              class: "form-control",
              type: "text",
              required: ""
            }, null, 512 /* NEED_PATCH */), [
              [vModelText, component_title.value]
            ])
          ])
        ]),
        createCommentVNode(" Width "),
        createBaseVNode("div", _hoisted_4$3, [
          createBaseVNode("label", _hoisted_5$3, [
            createBaseVNode("b", null, toDisplayString(_i18n("dashboard.component_width")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_6$2, [
            createBaseVNode("div", _hoisted_7$2, [
              withDirectives(createBaseVNode("input", {
                type: "range",
                id: "slider",
                "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ((width_selected).value = $event)),
                style: {"width":"100%"},
                min: "1",
                max: "3",
                step: "1"
              }, null, 512 /* NEED_PATCH */), [
                [vModelText, width_selected.value]
              ]),
              createBaseVNode("div", _hoisted_8$2, [
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.small")), 1 /* TEXT */),
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.medium")), 1 /* TEXT */),
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.large")), 1 /* TEXT */)
              ])
            ])
          ])
        ]),
        createCommentVNode(" Height "),
        createBaseVNode("div", _hoisted_9$2, [
          createBaseVNode("label", _hoisted_10$2, [
            createBaseVNode("b", null, toDisplayString(_i18n("dashboard.component_height")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_11$2, [
            createBaseVNode("div", _hoisted_12$2, [
              withDirectives(createBaseVNode("input", {
                type: "range",
                id: "slider",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((height_selected).value = $event)),
                style: {"width":"100%"},
                min: "1",
                max: "4",
                step: "1"
              }, null, 512 /* NEED_PATCH */), [
                [vModelText, height_selected.value]
              ]),
              createBaseVNode("div", _hoisted_13$2, [
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.small")), 1 /* TEXT */),
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.medium")), 1 /* TEXT */),
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.large")), 1 /* TEXT */),
                createBaseVNode("p", null, toDisplayString(_i18n("dashboard.component_sizes.auto")), 1 /* TEXT */)
              ])
            ])
          ])
        ]),
        createCommentVNode(" Time Window "),
        (!hiddenOnReport.value)
          ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
              createBaseVNode("label", _hoisted_15$2, [
                createBaseVNode("b", null, toDisplayString(_i18n("dashboard.time_window")), 1 /* TEXT */)
              ]),
              createBaseVNode("div", _hoisted_16$2, [
                createVNode(script$1I, {
                  selected_option: selected_time_window.value,
                  "onUpdate:selected_option": _cache[3] || (_cache[3] = $event => ((selected_time_window).value = $event)),
                  options: time_window_list.value
                }, null, 8 /* PROPS */, ["selected_option", "options"])
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Time Offset "),
        createBaseVNode("div", _hoisted_17$2, [
          createBaseVNode("label", _hoisted_18$2, [
            createBaseVNode("b", null, toDisplayString(_i18n("dashboard.time_offset")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_19$2, [
            createVNode(script$1I, {
              selected_option: selected_time_offset.value,
              "onUpdate:selected_option": _cache[4] || (_cache[4] = $event => ((selected_time_offset).value = $event)),
              options: time_offset_list.value
            }, null, 8 /* PROPS */, ["selected_option", "options"])
          ])
        ]),
        createCommentVNode(" Advanced Settings "),
        createBaseVNode("div", _hoisted_20$2, [
          createBaseVNode("label", _hoisted_21$2, [
            createBaseVNode("b", null, toDisplayString(_i18n("dashboard.advanced_settings")), 1 /* TEXT */)
          ]),
          createBaseVNode("div", _hoisted_22$2, [
            createBaseVNode("div", _hoisted_23$2, [
              createBaseVNode("input", {
                name: "show_advanced_settings",
                class: "form-check-input",
                type: "checkbox",
                onInput: updateAdvancedSettingsView,
                role: "switch"
              }, null, 32 /* HYDRATE_EVENTS */)
            ])
          ])
        ]),
        createCommentVNode(" REST Params "),
        (show_advanced_settings.value)
          ? (openBlock(), createElementBlock("div", _hoisted_24$2, [
              createBaseVNode("div", _hoisted_25$2, [
                (isNotJsonParamsValid.value)
                  ? (openBlock(), createElementBlock("p", _hoisted_26$2, toDisplayString(_i18n("dashboard.component_json_error")), 1 /* TEXT */))
                  : createCommentVNode("v-if", true),
                withDirectives(createBaseVNode("textarea", {
                  class: "highlighted-json",
                  "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((params_json_data).value = $event)),
                  onFocusout: formatJson,
                  style: {"width":"100%","height":"100%"},
                  rows: "16",
                  cols: "10"
                }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                  [vModelText, params_json_data.value]
                ])
              ])
            ]))
          : createCommentVNode("v-if", true)
      ]),
      footer: withCtx(() => [
        createBaseVNode("div", null, [
          createBaseVNode("button", {
            type: "button",
            onClick: edit_,
            disabled: isNotJsonParamsValid.value,
            class: "btn btn-primary"
          }, toDisplayString(_i18n("apply")), 9 /* TEXT, PROPS */, _hoisted_27$2)
        ])
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  script$9.__file = "http_src/vue/modal-edit-component.vue";

  const _hoisted_1$4 = {
    class: "mb-1 me-3",
    style: {"position":"absolute","bottom":"0px","right":"0px"}
  };


  var script$8 = {
    __name: 'dashboard-box',
    props: {
    color: String,
    width: Number,
    height: Number,
  },
    setup(__props) {

  const props = __props;



  const width_class = computed$1(() => {
    return `col-${props.width || 4}`;
  });

  const height_class = computed$1(() => {
    let color_class = ``;

    if (props.color) {
      /* Accepted colors: primary, secondary, success, danger, warning, info, light, dark, white */
      color_class = `bg-${props.color}`;
    }

    return `row-${props.height || 4} ${color_class}`;
  });

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", {
      class: normalizeClass([unref(width_class), "widget-box-main-dashboard"])
    }, [
      createBaseVNode("div", {
        class: normalizeClass([unref(height_class), "widget-box"]),
        style: {"position":"relative"}
      }, [
        createCommentVNode(" title "),
        renderSlot(_ctx.$slots, "box_title"),
        createCommentVNode(" content "),
        renderSlot(_ctx.$slots, "box_content"),
        createCommentVNode(" footer "),
        createBaseVNode("div", _hoisted_1$4, [
          renderSlot(_ctx.$slots, "box_footer")
        ])
      ], 2 /* CLASS */)
    ], 2 /* CLASS */))
  }
  }

  };

  script$8.__file = "http_src/vue/dashboard-box.vue";

  var script$7 = {
    __name: 'dashboard-empty',
    props: {
      id: String,          /* Component ID */
      i18n_title: String,  /* Title (i18n) */
      ifid: String,        /* Interface ID */
      epoch_begin: Number, /* Time interval begin */
      epoch_end: Number,   /* Time interval end */
      max_width: Number,   /* Component Width (4, 8, 12) */
      max_height: Number,  /* Component Hehght (4, 8, 12)*/
      params: Object,      /* Component-specific parameters from the JSON template definition */
      get_component_data: Function, /* Callback to request data (REST) */
      filters: Object
  },
    setup(__props) {

  const props = __props;



  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
      refresh_component();
  }, { flush: 'pre', deep: true });

  onBeforeMount(() => {
      init();
  });

  onMounted(() => {
  });

  function init() {
      refresh_component();
  }

  async function refresh_component() {
      /* Refresh component */
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div"))
  }
  }

  };

  script$7.__file = "http_src/vue/dashboard-empty.vue";

  const _hoisted_1$3 = {
    class: "table-responsive",
    style: {"margin-left":"-1rem","margin-right":"-1rem"}
  };


  var script$6 = {
    __name: 'dashboard-table',
    props: {
      id: String,          /* Component ID */
      i18n_title: String,  /* Title (i18n) */
      ifid: String,        /* Interface ID */
      epoch_begin: Number, /* Time interval begin */
      epoch_end: Number,   /* Time interval end */
      max_width: Number,   /* Component Width (4, 8, 12) */
      max_height: Number,  /* Component Hehght (4, 8, 12)*/
      params: Object,      /* Component-specific parameters from the JSON template definition */
      get_component_data: Function, /* Callback to request data (REST) */
      filters: Object
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const table_id = ref('simple_table');
  const table_rows = ref([]);



  const columns = computed$1(() => {
      let columns = props.params.columns.map((c) => {
          if (!c.style && c.data_type) {
              if (c.data_type == "bytes" || c.data_type == "date") {
                  c.style = "text-align: right";
              } else  if (c.data_type == "count_score") {
                  c.style = "text-align: center";
              }
          }

  	return {
  	    ...c,
  	};
      });

      columns[0].class = (columns[0].class ? (columns[0].class + " ") : "") 
        + "first-col-width";

      return columns;
  });

  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
      refresh_table();
  }, { flush: 'pre', deep: true });

  onBeforeMount(() => {
      init();
  });

  onMounted(() => {
  });

  function init() {
      refresh_table();
  }

  const render_column = function (column) {
    if (column.i18n_name) { return _i18n(column.i18n_name); }
    return "";
  };

  const row_render_functions = {
    /* Render function for 'throughput' table type */
    throughput: function (column, row) {
      if (column.id == 'name') {
        if (row['url'])
          return `<a href='${row.url}'>${row.name}</a>`;
        else
          return row.name;
      } else if (column.id == 'throughput') {
        if (row['throughput_type'] && row['throughput_type'] == 'pps') {
          return NtopUtils$1.fpackets(row[column.id]);
        } else if (row['throughput_type'] && row['throughput_type'] == 'bps') {
          return NtopUtils$1.bitsToSize(row[column.id]);
        } else {
          return row['throughput'];
        }
      } else {
        return "";
      }
    },

    /* Render function for 'db_search' table type */
    db_search: function (column, row) {
      if (column.data_type == 'host') {
        return NtopUtils$1.formatHost(row[column.id], row, (column.id == 'cli_ip'));
      } else if (column.data_type == 'network') {
        return NtopUtils$1.formatNetwork(row[column.id], row);
      } else if (column.data_type == 'asn') {
        return NtopUtils$1.formatASN(row[column.id], row);
      } else if (column.data_type == 'country') {
        return NtopUtils$1.formatCountry(row[column.id], row);
      } else if (formatterUtils.types[column.data_type]) {
        // 'bytes', 'bps', 'pps', ...
        let formatter = formatterUtils.getFormatter(column.data_type);
        return formatter(row[column.id]);
      } else if (typeof row[column.id] === 'object') {
        return NtopUtils$1.formatGenericObj(row[column.id], row);
      } else {
        return row[column.id];
      }
    },

    vs_scan_result: function(column, row) {
      if(column.id == "host") {
        return host_f(row[column.id], row, props.ifid);
      } else if(column.id == "last_scan") {
        return last_scan_f(row[column.id], row);
      } else if(column.id == "duration") {
        return duration_f(row[column.id], row);
      } else if(column.id == "scan_frequency") {
        return scan_frequency_f(row[column.id]);
      } else if(column.id == "is_ok_last_scan") {
        return is_ok_last_scan_f(row[column.id]);
      } else if(column.id == "tcp_ports") {
        return tcp_ports_f(row[column.id], row);
      } else if(column.id == "udp_ports") {
        return udp_ports_f(row[column.id], row);
      }  else if(column.id == "scan_type") {
        return scan_type_f(row[column.id], true, row);
      } else if (column.id == "hosts") {
        return hosts_f(row[column.id]);
      } else if (column.id == "cve" || column.id == "cve_list") {
        return cves_f(row[column.id], row);
      } else if (column.id == "port") {
        return tcp_port_f(row[column.id],row);
      } else if (column.id == "max_score_cve") {
        return max_score_cve_f(row[column.id],row);
      } else if (column.id == "num_vulnerabilities_found") {
        return num_vuln_found_f(row[column.id],row);
      } else if (column.id == "tcp_udp_ports_list") {
        return tcp_udp_ports_list_f(row["tcp_ports_list"], row["udp_ports_list"], row);
      } else if (column.id == "discovered_hosts") {
        return discoverd_hosts_list_f(row[column.id]);
      } else {
        return row[column.id];
      }
    }
  };

  const render_row = function (column, row) {
    if (props.params && 
        props.params.table_type && 
        row_render_functions[props.params.table_type]) {
      const render_func = row_render_functions[props.params.table_type];
      return render_func(column, row);
    } else if (row[column.id]) {
      return row[column.id];
    } else {
      return "";
    }
  };

  async function refresh_table() {
    const url_params = {
       ifid: props.ifid,
       epoch_begin: props.epoch_begin,
       epoch_end: props.epoch_end,
       ...props.params.url_params,
          ...props.filters
    };
    const query_params = ntopng_url_manager.obj_to_url_params(url_params);
   
    //let data = await ntopng_utility.http_request(`${http_prefix}${props.params.url}?${query_params}`);
    let data = await props.get_component_data(`${http_prefix}${props.params.url}`, query_params);

    let rows = [];
    if (props.params.table_type == 'db_search') {
      rows = data.records; /* db_search: read data from data.records */
    } else {
      rows = data; /* default: data is the array of records */
    }

    if ( props.params.table_type != 'vs_scan_result') {
      const max_rows = props.max_height ? ((props.max_height/4) * 6) : 6;
      rows = rows.slice(0, max_rows);
    } 

    table_rows.value = rows;
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$3, [
      createVNode(script$1f, {
        id: table_id.value,
        columns: unref(columns),
        rows: table_rows.value,
        print_html_column: render_column,
        print_html_row: render_row,
        wrap_columns: true
      }, null, 8 /* PROPS */, ["id", "columns", "rows"])
    ]))
  }
  }

  };

  var css_248z$2 = "\n.first-col-width {\n    /* max-width: 100% !important; */\n}\n@media print and (max-width: 210mm) {\ntd.first-col-width {\n\tmax-width: 55mm !important;\n}\n}\n@media print and (min-width: 211mm) {\ntd.first-col-width {\n\tmax-width: 95mm !important;\n}\n}\n\n/* @media print and (max-width: 148mm){ */\n/* } */\n\n";
  styleInject(css_248z$2);

  script$6.__file = "http_src/vue/dashboard-table.vue";

  const _hoisted_1$2 = { class: "d-flex align-items-center justify-content-between" };
  const _hoisted_2$2 = ["href"];
  const _hoisted_3$2 = { class: "fw-normal text-white" };
  const _hoisted_4$2 = { class: "subtitle text-white text-sm text mb-0 h5" };
  const _hoisted_5$2 = { class: "flex-shrink-0 ms-3" };


  var script$5 = {
    __name: 'dashboard-badge',
    props: {
      id: String,          /* Component ID */
      i18n_title: String,  /* Title (i18n) */
      ifid: String,        /* Interface ID */
      epoch_begin: Number, /* Time interval begin */
      epoch_end: Number,   /* Time interval end */
      max_width: Number,   /* Component Width (4, 8, 12) */
      max_height: Number,  /* Component Hehght (4, 8, 12)*/
      params: Object,      /* Component-specific parameters from the JSON template definition */
      get_component_data: Function, /* Callback to request data (REST) */
      set_component_attr: Function, /* Callback to set component attributes (e.g. Box active color) */
      filters: Object
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);

  const counter = ref('');
  const name = ref('');
  const icon = ref('');
  const link_url = ref('#');



  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
    refresh_component();
  }, { flush: 'pre', deep: true });

  onBeforeMount(() => {
    init();
  });

  onMounted(() => {
  });

  function init() {
    if (props.params.i18n_name) {
      name.value = _i18n(props.params.i18n_name);
    }

    if (props.params.icon) {
      icon.value = props.params.icon + ' fa-2xl';
    }

    refresh_component();
  }

  async function refresh_component() {
    /* Refresh component */

    if (props.params.url) {

      const url_params = {
        ifid: props.ifid,
        epoch_begin: props.epoch_begin,
        epoch_end: props.epoch_end,
        ...props.params.url_params,
        ...props.filters
      };
      const query_params = ntopng_url_manager.obj_to_url_params(url_params);

      // let data = await ntopng_utility.http_request(`${http_prefix}${props.params.url}?${query_params}`);
      let data = await props.get_component_data(`${http_prefix}${props.params.url}`, query_params);

      /* TODO handle dot-separated path for non-flat json */
      let counter_value = data[props.params.counter_path];

      let counter_formatter = data[props.params.counter_formatter];
      if (!counter_formatter) {
        counter_formatter = "number";
      }

      let formatCounter = formatterUtils.getFormatter(counter_formatter);
      counter.value = formatCounter(counter_value);

      if (counter_value) {
          props.set_component_attr('active', true);
      }

      if (props.params.link) {
        const link_url_params = {
          ifid: props.ifid,
          epoch_begin: props.epoch_begin,
          epoch_end: props.epoch_end,
          ...props.params.link.url_params
        };

        const link_query_params = ntopng_url_manager.obj_to_url_params(link_url_params);
        link_url.value = `${http_prefix}${props.params.link.url}?${link_query_params}`;
      }
    }
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", _hoisted_1$2, [
      createBaseVNode("div", null, [
        createBaseVNode("a", { href: link_url.value }, [
          createBaseVNode("h4", _hoisted_3$2, toDisplayString(counter.value), 1 /* TEXT */),
          createBaseVNode("p", _hoisted_4$2, toDisplayString(name.value), 1 /* TEXT */)
        ], 8 /* PROPS */, _hoisted_2$2)
      ]),
      createBaseVNode("div", _hoisted_5$2, [
        createBaseVNode("i", {
          class: normalizeClass(["text-white", icon.value])
        }, null, 2 /* CLASS */)
      ])
    ]))
  }
  }

  };

  script$5.__file = "http_src/vue/dashboard-badge.vue";

  var script$4 = {
    __name: 'dashboard-pie',
    props: {
      id: String,          /* Component ID */
      i18n_title: String,  /* Title (i18n) */
      ifid: String,        /* Interface ID */
      epoch_begin: Number, /* Time interval begin */
      epoch_end: Number,   /* Time interval end */
      max_width: Number,   /* Component Width (4, 8, 12) */
      max_height: Number,  /* Component Hehght (4, 8, 12)*/
      params: Object,      /* Component-specific parameters from the JSON template definition */
      get_component_data: Function, /* Callback to request data (REST) */
      filters: Object
  },
    setup(__props) {

  const props = __props;

  const chart_type = ref(ntopChartApex.typeChart.DONUT);
  const chart = ref(null);



  const base_url = computed$1(() => {
      return `${http_prefix}${props.params.url}`;
  });

  const get_url_params = () => {
      const url_params = {
          ifid: props.ifid,
          epoch_begin: props.epoch_begin,
          epoch_end: props.epoch_end,
          new_charts: true,
          ...props.params.url_params,
          ...props.filters
      };
      let query_params = ntopng_url_manager.obj_to_url_params(url_params);

      /* Push ifid to the parameters (e.g. "ts_query=ifid:$IFID$" */
      query_params = query_params.replaceAll("%24IFID%24" /* $IFID$ */, props.ifid);

      return query_params;
  };

  function get_chart_options() {
      const url = base_url.value;
      const url_params = get_url_params();
      return props.get_component_data(url, url_params);
  }

  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
      refresh_chart();
  }, { flush: 'pre', deep: true });

  onBeforeMount(() => {
  });

  onMounted(() => {
  });

  async function refresh_chart() {
      chart.value.update_chart();
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", null, [
      createVNode(script$1F, {
        ref_key: "chart",
        ref: chart,
        id: __props.id,
        chart_type: chart_type.value,
        base_url_request: unref(base_url),
        get_custom_chart_options: get_chart_options,
        register_on_status_change: false
      }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
    ]))
  }
  }

  };

  script$4.__file = "http_src/vue/dashboard-pie.vue";

  /* *************************************************** */


  var script$3 = {
    __name: 'dashboard-timeseries',
    props: {
    id: String,          /* Component ID */
    i18n_title: String,  /* Title (i18n) */
    ifid: String,        /* Interface ID */
    epoch_begin: Number, /* Time interval begin */
    epoch_end: Number,   /* Time interval end */
    max_width: Number,   /* Component Width (4, 8, 12) */
    max_height: Number,  /* Component Hehght (4, 8, 12)*/
    params: Object,      /* Component-specific parameters from the JSON template definition */
    get_component_data: Function, /* Callback to request data (REST) */
    csrf: String,
    filters: Object,
  },
    setup(__props) {

  const props = __props;

  const height_per_row = 62.5; /* px */
  const chart_type = ref(ntopChartApex.typeChart.TS_LINE);
  const chart = ref(null);
  const timeseries_groups = ref([]);
  const group_option_mode = timeseriesUtils.getGroupOptionMode('1_chart_x_yaxis');
  const height = ref(null);
  const ts_request = ref([]);

  /* *************************************************** */



  /* *************************************************** */

  /* Return the base url of the REST API */
  const base_url = computed$1(() => {
    return `${http_prefix}${props.params.url}`;
  });

  /* *************************************************** */

  function substitute_ifid(params_to_format, current_ifid) {
    let new_formatted_params = {};
    for (const param in (params_to_format)) {
      if (params_to_format[param].contains('$IFID$')) {
        /* Contains $IFID$, substitute with the interface id */
        new_formatted_params[param] = params_to_format[param].replace('$IFID$', current_ifid);
      } else {
        /* does NOT Contains $IFID$, add the plain param */
        new_formatted_params[param] = params_to_format[param];
      }
    }

    return new_formatted_params;
  }

  /* *************************************************** */

  function substitute_exporter(params_to_format, current_exporter) {
    let new_formatted_params = {};
    for (const param in (params_to_format)) {
      if (params_to_format[param].contains('$EXPORTER$')) {
        /* Contains $EXPORTER$, substitute with the interface id */
        new_formatted_params[param] = params_to_format[param].replace('$EXPORTER$', current_exporter);
      } else {
        /* does NOT Contains $EXPORTER$, add the plain param */
        new_formatted_params[param] = params_to_format[param];
      }
    }

    return new_formatted_params;
  }

  /* *************************************************** */

  function substitute_network(params_to_format, current_network) {
    let new_formatted_params = {};
    for (const param in (params_to_format)) {
      if (params_to_format[param].contains('$NETWORK$')) {
        /* Contains $NETWORK$, substitute with the interface id */
        new_formatted_params[param] = params_to_format[param].replace('$NETWORK$', current_network);
      } else {
        /* does NOT Contains $NETWORK$, add the plain param */
        new_formatted_params[param] = params_to_format[param];
      }
    }

    return new_formatted_params;
  }

  /* *************************************************** */

  /* This function is used to substitute to the $IFID$ found in the
   * configuration the correct interface id
   */
  async function format_ifids(params_to_format) {
    if (ts_request.value.length > 0) {
      /* Already populated, return */
      return;
    }
    const ifid_url = "lua/rest/v2/get/ntopng/interfaces.lua";
    const ifid_list = await ntopng_utility.http_request(`${http_prefix}/${ifid_url}`) || [];
    ifid_list.forEach((iface) => {
      let new_formatted_params = substitute_ifid(params_to_format, iface.ifid);
      new_formatted_params.source_def = [iface.ifid];
      ts_request.value.push(new_formatted_params);
    });
  }

  /* *************************************************** */

  /* This function is used to substitute to the $EXPORTER$ found in the
   * configuration the correct flow exporter
   */
  async function format_exporters(params_to_format) {
    if (ts_request.value.length > 0) {
      /* Already populated, return */
      return;
    }
    const exporters_url = "lua/pro/rest/v2/get/flowdevices/stats.lua";
    const exporters_list = await ntopng_utility.http_request(`${http_prefix}/${exporters_url}?ifid=${props.ifid}&gui=true`) || [];
    if (exporters_list) {
      exporters_list.forEach((exporter) => {
        if (exporter) {
          let new_formatted_params = substitute_exporter(params_to_format, exporter.probe_ip);
          new_formatted_params = substitute_ifid(new_formatted_params, exporter.ifid);
          new_formatted_params.source_def = [exporter.ifid, exporter.probe_ip];
          ts_request.value.push(new_formatted_params);
        }
      });
    }
  }

  /* *************************************************** */

  /* This function is used to substitute to the $NETWORK$ found in the
   * configuration in the correct networks
   */
  async function format_networks(params_to_format) {
    if (ts_request.value.length > 0) {
      /* Already populated, return */
      return;
    }
    const networks_url = "lua/rest/v2/get/network/networks.lua";
    const networks_list = await ntopng_utility.http_request(`${http_prefix}/${networks_url}?ifid=${props.ifid}`) || [];
    if (networks_list) {
      networks_list.forEach((network) => {
        if (network) {
          let new_formatted_params = substitute_network(params_to_format, network.id);
          new_formatted_params = substitute_ifid(new_formatted_params, props.ifid);
          new_formatted_params.source_def = [props.ifid, network.id];
          ts_request.value.push(new_formatted_params);
        }
      });
    }
  }

  /* *************************************************** */

  /* This function is used to transform the $ANY$ params in the 
   * correct value (e.g. $ANY_IFID$ -> list of all ifid)
   */
  async function resolve_any_params() {
    /* Clear the Array */
    ts_request.value = [];
    /* Here possible ANY, can be found in the post_params */
    const params = props.params.post_params?.ts_requests;
    for (const any_param in (params || {})) {
      switch (any_param) {
        case '$ANY_IFID$':
          await format_ifids(params[any_param]);
          break;
        case '$ANY_EXPORTER$':
          await format_exporters(params[any_param]);
          break;
        case '$ANY_NETWORK$':
          await format_networks(params[any_param]);
          break;
        default:
          let new_formatted_params = substitute_ifid(params[any_param], props.ifid);
          new_formatted_params.source_def = [props.ifid];
          ts_request.value.push(new_formatted_params);
          break;
      }
    }
  }

  /* *************************************************** */

  /* The source_type can be found on the json and the source_array is automatically generated
   * by using the source_type
   */
  async function get_timeseries_groups_from_metric(metric_schema, source_def) {
    const status = {
      epoch_begin: props.epoch_begin,
      epoch_end: props.epoch_end,
    };
    const source_type = metricsManager.get_source_type_from_id(props.params?.source_type);
    const source_array = await metricsManager.get_source_array_from_value_array(http_prefix, source_type, source_def);
    const metric = await metricsManager.get_metric_from_schema(http_prefix, source_type, source_array, metric_schema, null, status);
    const ts_group = metricsManager.get_ts_group(source_type, source_array, metric, { past: false });
    return ts_group;
  }

  /* *************************************************** */

  async function retrieve_basic_info() {
    /* Return the timeseries group, info found in the json */
    if (timeseries_groups.value.length == 0) {
      for (const value of ts_request.value) {
        const metric_schema = value?.ts_schema;
        const source_def = value.source_def;
        delete value.source_def; /* Remove the property otherwise it's going to be added to the REST */
        const group = await get_timeseries_groups_from_metric(metric_schema, source_def);
        timeseries_groups.value.push(group);
      }
    }
  }

  /* *************************************************** */

  /* Remove the property otherwise it's going to be added to the REST */
  function remove_extra_params() {
    for (const value of ts_request.value) {
      if (value.source_def) {
        delete value.source_def;
      }
    }
  }

  /* *************************************************** */

  /* This function run the REST API with the data */
  async function get_chart_options() {
    await resolve_any_params();
    await retrieve_basic_info();
    remove_extra_params();
    const url = base_url.value;
    const post_params = {
      csrf: props.csrf,
      ifid: props.ifid,
      epoch_begin: props.epoch_begin,
      epoch_end: props.epoch_end,
      ...props.params.post_params,
      ...{
        ts_requests: ts_request.value
      }
    };
    /* Have to be used this get_component_data, in order to create report too */
    let result = await props.get_component_data(url, '', post_params);
    /* Format the result in the format needed by Dygraph */
    result = timeseriesUtils.tsArrayToOptionsArray(result, timeseries_groups.value, group_option_mode, '');
    if (result[0]) {
      result[0].height = height.value;
    }
    return result?.[0];
  }

  /* *************************************************** */

  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
    refresh_chart();
  }, { flush: 'pre', deep: true });

  /* *************************************************** */

  /* Run the init here */
  onBeforeMount(async () => {
    await init();
  });

  /* *************************************************** */

  onMounted(async () => { });

  /* *************************************************** */

  /* Defining the needed info by the get_chart_options function */
  async function init() {
    height.value = (props.max_height || 4) * height_per_row;
  }

  /* *************************************************** */

  /* Refresh function */
  async function refresh_chart() {
    if (chart.value) {
      const result = await get_chart_options();
      chart.value.update_chart_series(result.data);
    }
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", null, [
      createVNode(script$1k, {
        ref_key: "chart",
        ref: chart,
        id: __props.id,
        chart_type: chart_type.value,
        base_url_request: unref(base_url),
        get_custom_chart_options: get_chart_options,
        register_on_status_change: false,
        disable_pointer_events: false
      }, null, 8 /* PROPS */, ["id", "chart_type", "base_url_request"])
    ]))
  }
  }

  };

  script$3.__file = "http_src/vue/dashboard-timeseries.vue";

  var script$2 = {
    __name: 'dashboard-sankey',
    props: {
      id: String,          /* Component ID */
      i18n_title: String,  /* Title (i18n) */
      ifid: String,        /* Interface ID */
      epoch_begin: Number, /* Time interval begin */
      epoch_end: Number,   /* Time interval end */
      max_width: Number,   /* Component Width (4, 8, 12) */
      max_height: Number,  /* Component Hehght (4, 8, 12)*/
      params: Object,      /* Component-specific parameters from the JSON template definition */
      get_component_data: Function, /* Callback to request data (REST) */
      filters: Object
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const no_data_message = _i18n('ports_analysis.no_data');

  const sankey_chart = ref(null);
  const sankey_data = ref({});
  const body_div = ref(null);
  const width = ref(null);
  const height = ref(null);
  const height_per_row = 62.5; /* px */



  /* Watch - detect changes on epoch_begin / epoch_end and refresh the component */
  watch(() => [props.epoch_begin, props.epoch_end, props.filters], (cur_value, old_value) => {
      update_sankey();
  }, { flush: 'pre', deep: true });

  onBeforeMount(() => {
  });

  onMounted(() => {
      update_height();
      update_width();

      init();
  });

  function init() {
      update_sankey();
  }

  const update_sankey = function() {
    set_sankey_data();
  };

  async function set_sankey_data() {
      let data = await get_sankey_data();    
      sankey_data.value = data;
  }

  async function get_sankey_data() {
      const url = `${http_prefix}${props.params.url}`;

      const query_params = {
          ifid: props.ifid,
           epoch_begin: props.epoch_begin,
           epoch_end: props.epoch_end,
           sankey_version: 3,
           ...props.params.url_params,
          ...props.filters
      };
      let url_params = ntopng_url_manager.obj_to_url_params(query_params);

      let graph = await props.get_component_data(url, url_params);

      graph = make_complete_graph(graph);

      const sankey_data = get_sankey_data_from_rest_data(graph);
      
      /* In case no data is returned, show the No Data message */
      (sankey_data.links.length > 0 && sankey_data.nodes.length > 0) ? 
          sankey_chart.value.set_no_data_flag(false) : 
          sankey_chart.value.set_no_data_flag(true);
    
      return sankey_data;
  }

  // remove all links with a not existing node
  function make_complete_graph(graph) {
      let f_log_link = (l) => console.error(`link (source: ${l.source_node_id}, target: ${l.target_node_id}) removed for not existing source/target node`);    
      let links = get_links_with_existing_node(graph, f_log_link);
      return { nodes: graph.nodes, links };
  }

  function get_links_with_existing_node(graph, f_log) {
      let node_dict = {};
      graph.nodes.forEach((n) => node_dict[n.node_id] = true);
      let f_filter = (l) => node_dict[l.source_node_id] != null && node_dict[l.target_node_id] != null;    
      let links = filter_log(graph.links, f_filter, f_log);
      return links;
  }

  // log elements deleted if f_log != null
  function filter_log(elements, f_filter, f_log) {
      return elements.filter((e) => {
  	const take_element = f_filter(e);
  	if (take_element == false && f_log != null) {
  	    f_log(e);
  	}
  	return take_element;
      });
  }

  function get_sankey_data_from_rest_data(res) {
      let node_dict = {}, link_to_nodes_dict = {};
      // create a node dict
      res.nodes.forEach((node) => node_dict[node.node_id] = node);
      
      let f_get_link_node_id = (link) => {
  	return `${link.source_node_id}_${link.label}`; 
      };
      // merge all links by label
      res.links.forEach((link) => {
  	let link_node_id = f_get_link_node_id(link);
  	let link_to_nodes = link_to_nodes_dict[link_node_id];
  	if (link_to_nodes == null) {
  	    link_to_nodes = {
  		id: link_node_id,
  		label: link.label,
      link: link.optional_info.link,
  		node_links: [],		
  	    };
  	    link_to_nodes_dict[link_node_id] = link_to_nodes;
  	}
  	link_to_nodes.node_links.push({
  	    source: node_dict[link.source_node_id],
  	    target: node_dict[link.target_node_id],
  	    value: link.value,
  	});	
      });
      
      // create nodes and links
      let nodes = res.nodes.map((n) => n), links = [];
      for (let link_node_id in link_to_nodes_dict) {
  	let link_to_nodes = link_to_nodes_dict[link_node_id];
  	let link_node = {
  	    node_id: link_to_nodes.id,
  	    label: link_to_nodes.label,
        link: link_to_nodes.link,
  	};
  	nodes.push(link_node);
  	link_to_nodes.node_links.forEach((link) => {
  	    links.push({
  		source_node_id: link.source.node_id,
  		target_node_id: link_node.node_id,
  		label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
  		value: link.value,
  	    });
  	    links.push({
  		source_node_id: link_node.node_id,
  		target_node_id: link.target.node_id,
  		label: `${link.source.label} - ${link.target.label}: ${link_node.label}`,
  		value: link.value,
  	    });
  	});
      }
      let sankey_nodes = nodes.map((n, index) => {
  	return { index, label: n.label, data: n };
      });
      let sankey_node_dict = {};    
      sankey_nodes.forEach((sn, index) => sankey_node_dict[sn.data.node_id] = sn);
      let sankey_links = links.map((l) => {
  	let source_index = sankey_node_dict[l.source_node_id].index;
  	let target_index = sankey_node_dict[l.target_node_id].index;
  	return {
  	    source: source_index,
  	    target: target_index,
  	    value: l.value,
  	    label: l.label,
  	};
      });
      return { nodes: sankey_nodes, links: sankey_links };
  }

  function on_node_click(node) {
      if (node.is_link_node == true) { return; }
      if (node.link) { ntopng_url_manager.go_to_url(node.link); }
  }

  function update_height() {
      height.value = height_per_row * props.max_height;
  }

  function update_width() {
      width.value = $(body_div.value).width();
  }

  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock("div", {
      ref_key: "body_div",
      ref: body_div
    }, [
      createVNode(script$V, {
        ref_key: "sankey_chart",
        ref: sankey_chart,
        width: width.value,
        height: height.value,
        no_data_message: unref(no_data_message),
        sankey_data: sankey_data.value,
        onNode_click: on_node_click
      }, null, 8 /* PROPS */, ["width", "height", "no_data_message", "sankey_data"])
    ], 512 /* NEED_PATCH */))
  }
  }

  };

  script$2.__file = "http_src/vue/dashboard-sankey.vue";

  const _withScopeId$1 = n => (pushScopeId("data-v-c360f212"),n=n(),popScopeId(),n);
  const _hoisted_1$1 = { class: "row" };
  const _hoisted_2$1 = { class: "me-2" };
  const _hoisted_3$1 = ["title"];
  const _hoisted_4$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-floppy-disk" }, null, -1 /* HOISTED */));
  const _hoisted_5$1 = [
    _hoisted_4$1
  ];
  const _hoisted_6$1 = ["title"];
  const _hoisted_7$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-folder-open" }, null, -1 /* HOISTED */));
  const _hoisted_8$1 = [
    _hoisted_7$1
  ];
  const _hoisted_9$1 = ["title"];
  const _hoisted_10$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-file-arrow-down" }, null, -1 /* HOISTED */));
  const _hoisted_11$1 = [
    _hoisted_10$1
  ];
  const _hoisted_12$1 = ["title"];
  const _hoisted_13$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-file-arrow-up" }, null, -1 /* HOISTED */));
  const _hoisted_14$1 = [
    _hoisted_13$1
  ];
  const _hoisted_15$1 = ["title"];
  const _hoisted_16$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-print" }, null, -1 /* HOISTED */));
  const _hoisted_17$1 = [
    _hoisted_16$1
  ];
  const _hoisted_18$1 = ["title"];
  const _hoisted_19$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-folder-plus" }, null, -1 /* HOISTED */));
  const _hoisted_20$1 = [
    _hoisted_19$1
  ];
  const _hoisted_21$1 = ["title"];
  const _hoisted_22$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-pen-to-square" }, null, -1 /* HOISTED */));
  const _hoisted_23$1 = [
    _hoisted_22$1
  ];
  const _hoisted_24$1 = { class: "dropdown me-3 d-inline-block" };
  const _hoisted_25$1 = { class: "ms-1 my-auto me-2 filters-label" };
  const _hoisted_26$1 = {
    key: 0,
    class: "d-flex justify-content-center align-items-center"
  };
  const _hoisted_27$1 = { class: "me-2" };
  const _hoisted_28$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("div", null, [
    /*#__PURE__*/createBaseVNode("label", { class: "my-auto me-2" })
  ], -1 /* HOISTED */));
  const _hoisted_29$1 = { class: "mt-4" };
  const _hoisted_30$1 = {
    key: 1,
    class: "me-auto mt-2 flex-wrap d-flex"
  };
  const _hoisted_31$1 = ["title"];
  const _hoisted_32$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-square-plus" }, null, -1 /* HOISTED */));
  const _hoisted_33$1 = [
    _hoisted_32$1
  ];
  const _hoisted_34$1 = ["title"];
  const _hoisted_35$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-trash-can" }, null, -1 /* HOISTED */));
  const _hoisted_36$1 = [
    _hoisted_35$1
  ];
  const _hoisted_37$1 = {
    class: "text-warning",
    style: {"margin-top":"0.5rem","margin-left":"1rem"}
  };
  const _hoisted_38$1 = {
    key: 2,
    class: "mt-3",
    style: {"margin-bottom":"-0.5rem","display":"inline"}
  };
  const _hoisted_39$1 = { style: {"text-align":"center"} };
  const _hoisted_40$1 = { key: 0 };
  const _hoisted_41$1 = ["title"];
  const _hoisted_42$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-file-arrow-down" }, null, -1 /* HOISTED */));
  const _hoisted_43$1 = [
    _hoisted_42$1
  ];
  const _hoisted_44$1 = ["title"];
  const _hoisted_45$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fa-solid fa-file-arrow-up" }, null, -1 /* HOISTED */));
  const _hoisted_46$1 = [
    _hoisted_45$1
  ];
  const _hoisted_47$1 = ["title"];
  const _hoisted_48$1 = /*#__PURE__*/ _withScopeId$1(() => /*#__PURE__*/createBaseVNode("i", { class: "fas fa-print" }, null, -1 /* HOISTED */));
  const _hoisted_49$1 = [
    _hoisted_48$1
  ];
  const _hoisted_50 = {
    key: 0,
    class: "col-sm mt-1"
  };
  const _hoisted_51 = { class: "alert alert-warning" };
  const _hoisted_52 = {
    key: 1,
    class: "col-sm mt-1"
  };
  const _hoisted_53 = {
    class: "alert alert-secondary sm-1 text-center",
    style: {"width":"40%","margin":"auto","margin-top":"5vh","margin-bottom":"5vh"}
  };
  const _hoisted_54 = { class: "alert-heading" };
  const _hoisted_55 = { class: "mb-0" };
  const _hoisted_56 = {
    key: 0,
    class: "dashboard-component-title modal-header"
  };
  const _hoisted_57 = { class: "modal-title" };
  const _hoisted_58 = { style: {"color":"gray"} };
  const _hoisted_59 = {
    key: 0,
    class: "modal-close"
  };
  const _hoisted_60 = { class: "btn-group" };
  const _hoisted_61 = ["data-component-id"];
  const _hoisted_62 = ["data-component-id"];
  const _hoisted_63 = {
    key: 0,
    style: {"color":"lightgray","font-size":"12px"}
  };


  var script$1 = {
    __name: 'dashboard',
    props: {
      context: Object,
  },
    setup(__props) {

  const props = __props;

  const _i18n = (t) => i18n(t);
  const timeframes_dict = ntopng_utility$1.get_timeframes_dict();



  const components_dict = {
      "badge": script$5,
      "empty": script$7,
      "pie": script$4,
      "timeseries": script$3,
      "table": script$6,
      "sankey": script$2,
  };

  const loading = ref(true);
  const loading_filters = ref(false);
  const second_load = ref(false);
  const show_loading = props.context.show_loading || false;
  const allow_edit = props.context.allow_edit || false;
  const report_box = ref(null);

  const modal_store_report = ref(null);
  const modal_open_report = ref(null);
  const modal_upload_report = ref(null);

  const modal_add_template_component = ref(null);
  const modal_edit_template_component = ref(null);
  const modal_delete_template = ref(null);

  const main_epoch_interval = ref(null);

  const components = ref([]);
  const components_loaded = ref(false);

  const selected_filters = ref({});
  const all_available_filters = ref({});
  const filtered_filters = ref({});
  const filters_to_show = ref([]);
  const template_filters = ref([]);

  const reports_templates = ref([]);
  const selected_report_template = ref({});

  const warning_message = ref("");

  let components_info = {};
  let data_from_backup = false;
  let printable = false;

  const edit_mode = ref(false);
  let template_sortable = null;
  const modal_new_template = ref(null);

  const is_live = computed$1(() => {
      return props.context.page != "report" && props.context.page != "vs-report";
  });

  const enable_date_time_range_picker = computed$1(() => {
      return props.context.page == "report"
          && !printable;
  });

  const enable_small_picker = computed$1(() => {
      return props.context.page == "vs-report";
  });

  const enable_small_picker_actions = computed$1(() => {
      return true; // Set to false for hiding open/save actions in the small picker
  });

  const disable_date = computed$1(() => {
      return selected_report_template.value?.toolbox?.time?.hide == true;
  });

  const disable_date_time_picker = computed$1(() => {
      const disabled = selected_report_template.value.is_open_report == true
          || disable_date.value;
      return disabled;
  });

  const enable_report_title = computed$1(() => {
      const enable = selected_report_template.value.is_open_report == true
          || props.context.page == "vs-report";
      return enable;
  });

  const report_title = computed$1(() => {
      let title = "";

      if (selected_report_template.value.is_open_report) {
          title = `Report: ${selected_report_template.value.value}`;
      } else if (props.context.title) {
          title = props.context.title;
      }

      return title;
  });

  const component_custom_style = computed$1(() => {
      return (c) => {
          if (c.params.custom_style != null && (!printable || c.params.custom_print_style)) {
              return c.params.custom_style;
          } else if (c.params.custom_print_style && printable == true) {
              return c.params.custom_print_style;
          }
          return "";
      };
  });

  const component_interval = computed$1(() => {
      return (c) => {
          const time_interval_string = get_time_interval_string(c.epoch_begin, c.epoch_end);
          return time_interval_string;
      };
  });

  /* Param report_template is optional (uses url report_template or props.context.template otherwise) */
  async function set_template(report_template) {
      let epoch_interval = null;

      printable = ntopng_url_manager$1.get_url_entry("printable") == "true";

      if (props.context.page == "report" || props.context.page == "vs-report") {
          if (props.context.page == "report") {
              epoch_interval = ntopng_utility$1.check_and_set_default_time_interval(undefined, undefined, true, "min");
          } else if (props.context.page == "vs-report") {
              epoch_interval = ntopng_utility$1.check_and_set_default_time_interval(undefined, undefined, true);
          }
          main_epoch_interval.value = epoch_interval;
      }

      await set_templates_list(report_template);

      let report_name = ntopng_url_manager$1.get_url_entry("report_name");
      if (report_name != null && report_name != "") {
          /* Report name provided - open a report backup */
          await open_report(report_name);
      } else {
          /* Load a template and build a new report */
          await load_components(epoch_interval, selected_report_template.value.value);
      }
      if (printable == true) {
          set_report_title();
          // await nextTick();
          // ntopng_sync.ready("print_report");
      }

      components_loaded.value = true;
  }

  onBeforeMount(async () => {
      set_template();
  });

  onMounted(async () => {
      if (props.context.page == "dashboard") {
          start_dashboard_refresh_loop();
      }
      // if (printable == true) {
      //     await ntopng_sync.on_ready("print_report");
      // }
  });

  async function set_templates_list(report_template) {
      const url_request = props.context.template_list_endpoint;
      let res = await ntopng_utility$1.http_request(url_request);
      if (res?.list == null) { return; }

      let templates_list = res.list.map((t) => {
          return {
              value: t.name,
              label: t.label,
              disabled: false,
              toolbox: t.toolbox,
              is_open_report: false,
              allow_edit: t.allow_edit,
          };
      });

      templates_list.sort((a, b) => a.label.toUpperCase().localeCompare(b.label.toUpperCase()));

      reports_templates.value = templates_list;

      const report_template_value = report_template ||
          ntopng_url_manager$1.get_url_entry("report_template") ||
          props.context.template;

      props.context.template = report_template_value;
      selected_report_template.value = reports_templates.value.find((t) => t.value == report_template_value);

      if (selected_report_template.value == null) {
          selected_report_template.value = reports_templates.value[0];
      }

      if (!selected_report_template.value.allow_edit && edit_mode.value) {
          toggle_edit_mode();
      }
  }

  /* Dashboard update interval/frequency */
  const loop_interval = 10 * 1000;

  function start_dashboard_refresh_loop() {
      setInterval(() => {
          set_components_epoch_interval();
      }, loop_interval);
  }

  function set_components_filter(filter_id, filter_value) {
      if (filter_value) { filter_value = filter_value + ";eq"; }
      ntopng_url_manager$1.set_key_to_url(filter_id, filter_value);
      components.value.forEach((c, i) => {
          update_component_filters(c, filter_id, filter_value);
      });
  }

  function set_components_epoch_interval(epoch_interval) {
      if (epoch_interval) {
          main_epoch_interval.value = epoch_interval;
      }

      components.value.forEach((c, i) => {
          update_component_epoch_interval(c, epoch_interval);
      });
  }

  /* This is used to reset the filters putting all of them to the ALL value */
  async function reset_filters() {
      /* Iterate all the filters available */
      for (const [filter, value] of Object.entries(all_available_filters.value)) {
          /* Set each filter to the ALL value (first value) */
          set_components_filter(filter, value[0].value);
          selected_filters.value[filter] = value[0];
          /* Hide all the needed filters */
      }
      filters_to_show.value = await load_filters(template_filters.value, null, true);
  }

  /* This function loads the filters */
  async function load_filters(filters_available, res, show_second_load) {
      (!show_second_load) ? loading_filters.value = true : second_load.value = true;
      const added_filters_list = [];
      if (!res && `${props.context.report_filters_endpoint}`) {
          let retrieve_filters = '';
          let extra_params = '';
          let tmp = {};
          filters_available.forEach((element) => {
              if (element.show_only_if_selected) {
                  const selected = ntopng_url_manager$1.get_url_entry(element.show_only_if_selected);
                  if (selected !== '') {
                      retrieve_filters = `${retrieve_filters}${element.name},`;
                      tmp[element.show_only_if_selected] = selected;
                  }
              } else {
                  retrieve_filters = `${retrieve_filters}${element.name},`;
              }
          });
          for (const [key, value] of Object.entries(tmp)) {
              extra_params = `${key}=${value}&${extra_params}`;
          }
          retrieve_filters = retrieve_filters.slice(0, -1);
          res = await ntopng_utility$1.http_request(`${props.context.report_filters_endpoint}?hide_exporters_name=true&filters_to_display=${retrieve_filters}&${extra_params}`);
      }
      filters_available.forEach((element) => {
          const id = element?.name || "";
          const filter_options = res.find((el) => el.id == id)?.options;
          /* Check the filters available, if no filter or only 1 filter is provided, hide the dropdown */
          if (filter_options && filter_options.length > 1) {
              const selected = ntopng_url_manager$1.get_url_entry(id);
              let all_label = i18n('db_search.all.' + id);
              if (dataUtils.isEmptyOrNull(all_label)) {
                  all_label = i18n('all') + " " + i18n('db_search.' + id);
              }
              /* Add the 'All' filter */
              /* To be safe, add a default name */
              filter_options.unshift({
                  value: null,
                  label: all_label,
                  display_more_filters: filter_options[0].display_more_filters
              });

              if (selected && selected !== '') {
                  const tmp_value = filter_options.find((el) => selected.startsWith(el.value));
                  selected_filters.value[id] = tmp_value;
              } else {
                  selected_filters.value[id] = filter_options[0];
              }
              
              all_available_filters.value[id] = filter_options;
              filtered_filters.value[id] = filter_options;
              added_filters_list.push(id);
          }
      });
      (!show_second_load) ? loading_filters.value = false : second_load.value = false;
      return added_filters_list;
  }

  async function load_components(epoch_interval, template_name) {
      /* Enable REST calls */
      data_from_backup = false;

      let url_request = `${props.context.template_endpoint}?template=${template_name}`;
      let res = await ntopng_utility$1.http_request(url_request);
      components.value = res.list.filter((c) => components_dict[c.component] != null)
          .map((c, index) => {
              let c_ext = {
                  filters: {},
                  component_id: `auto_${c.id}_${index}`,
                  ...c
              };
              update_component_epoch_interval(c_ext, epoch_interval);
              return c_ext;
          });
      reset_filters();
      if (res.filters) {
          template_filters.value = res.filters;
          filters_to_show.value = await load_filters(res.filters);
      }
      await nextTick();
  }

  function update_component_epoch_interval(c, epoch_interval) {
      const interval_seconds = timeframes_dict[c.time_window || "5_min"];
      if (epoch_interval == null) {
          const epoch_end = ntopng_utility$1.get_utc_seconds();
          epoch_interval = { epoch_begin: epoch_end - interval_seconds, epoch_end: epoch_end };
      }
      const utc_offset = timeframes_dict[c.time_offset] || 0;
      c.epoch_begin = epoch_interval.epoch_begin - utc_offset;
      c.epoch_end = epoch_interval.epoch_end - utc_offset;
  }

  function update_component_filters(c, filter_id, filter_value) {
      c.filters[filter_id] = filter_value;
  }

  /* ********************************************* */

  /* This function is called whenever a filter is clicked */
  async function select_filter(option, filter_id) {
      /* Set the filter, ready for the rest */
      set_components_filter(filter_id, option.value);
      if (option.display_more_filters) {
          filters_to_show.value = await load_filters(template_filters.value, null, true);
      }
  }

  /* ********************************************* */

  function select_report_template() {
      if (!selected_report_template.value.allow_edit && edit_mode.value) {
          toggle_edit_mode();
      }

      if (printable == true) {
          set_report_title();
      }
      if (selected_report_template.value.is_open_report == true) {
          return;
      }
      components_info = {};
      update_templates_list();
      const global_status = ntopng_status_manager$1.get_status(true);
      let epoch_interval = { epoch_begin: global_status.epoch_begin, epoch_end: global_status.epoch_end };
      if (data_from_backup == true) { // last report selected it was a saved report and then we must to restore default timestamp
          epoch_interval = ntopng_utility$1.set_default_time_interval(undefined, "min");
          ntopng_events_manager$1.emit_event(ntopng_events.EPOCH_CHANGE, epoch_interval, props.context.page);
      }
      load_components(epoch_interval, selected_report_template.value.value);
  }

  function show_store_report_modal() {
      modal_store_report.value.show();
  }

  function show_open_report_modal() {
      modal_open_report.value.show();
  }

  function show_upload_report_modal() {
      modal_upload_report.value.show();
  }

  function get_suggested_report_name() {
      let name = "report";
      if (props.context.page == "vs-report") {
          name = props.context.title;
      } else if (main_epoch_interval.value &&
          main_epoch_interval.value.epoch_end) {
          name += "-" + ntopng_utility$1.from_utc_to_server_date_format(main_epoch_interval.value.epoch_end * 1000, 'DD-MM-YYYY');
      }
      return name;
  }

  const upload_report = async (content_string) => {
      let content = JSON.parse(content_string);
      set_report(content, content.name);
      ntopng_url_manager$1.delete_key_from_url("report_name");
  };

  function set_report(content, name) {
      update_templates_list(name);
      const epoch_status = { epoch_begin: content.epoch_begin, epoch_end: content.epoch_end };
      ntopng_events_manager$1.emit_event(ntopng_events.EPOCH_CHANGE, epoch_status, props.context.page);
      load_report(content);
  }

  const list_reports = async () => {
      let url = `${props.context.report_list_endpoint}?ifid=${props.context.ifid}`;
      let files_obj = await ntopng_utility$1.http_request(url);
      let files = ntopng_utility$1.object_to_array(files_obj);

      /* Return array of [{ name: String, epoch: Number }, ...] */

      return files;
  };

  const load_report = async (content) => {
      let tmp_epoch_interval = {
          epoch_begin: content.epoch_begin,
          epoch_end: content.epoch_end
      };
      let tmp_template = content.template;
      let tmp_components_data = content.data;

      let tmp_components_info = {};
      for (let key in tmp_components_data) {
          let info = {
              data: tmp_components_data[key],
          };
          tmp_components_info[key] = info;
      }

      /* Disable REST calls */
      data_from_backup = true;

      /* Set the cached data from the backup */
      components_info = tmp_components_info;

      /* Change the components (template) from the backup */
      components.value = tmp_template;

      /* Change the time interval on components */
      set_components_epoch_interval(tmp_epoch_interval);
  };

  const open_report = async (file_name) => {
      let url = `${props.context.report_open_endpoint}?ifid=${props.context.ifid}&report_name=${file_name}`;
      let content = await ntopng_utility$1.http_request(url);
      if (content) {
          set_report(content, file_name);
          warning_message.value = "";
      } else {
          warning_message.value = _i18n("report.unable_to_open");
      }
  };

  function update_templates_list(report_name_to_open) {
      reports_templates.value = reports_templates.value.filter((t) => t.is_open_report == false);
      if (report_name_to_open == null) { // in this case is selected a report_template
          ntopng_url_manager$1.set_key_to_url("report_template", selected_report_template.value.value);
          props.context.template = selected_report_template.value.value;
          ntopng_url_manager$1.delete_key_from_url("report_name");
          return;
      }

      let t_entry = {
          value: report_name_to_open,
          label: _i18n("dashboard.custom"),
          disabled: false,
          toolbox: null,
          is_open_report: true,
          allow_edit: false
      };
      reports_templates.value.push(t_entry);
      selected_report_template.value = t_entry;
      props.context.template = report_name_to_open;
      ntopng_url_manager$1.set_key_to_url("report_name", selected_report_template.value.value);
      ntopng_url_manager$1.delete_key_from_url("report_template");
  }

  const delete_report = async (file_name) => {
      let success = false;

      let params = {
          csrf: props.context.csrf,
          ifid: props.context.ifid,
          report_name: file_name
      };

      let url = `${props.context.report_delete_endpoint}`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          success = true;
      } catch (err) {
          console.error(err);
      }

      return success;
  };

  /* Dump report content - keep in sync with dashboard_utils.build_report (lua) */
  const serialize_report = async (name) => {

      let components_data = {};
      for (var key in components_info) {
          components_data[key] = await components_info[key].data;
      }

      let content = {
          version: "1.0", // Report dump version
          name: name,
          template: components.value,
          data: components_data
      };

      if (main_epoch_interval.value &&
          main_epoch_interval.value.epoch_begin &&
          main_epoch_interval.value.epoch_end) {
          content.epoch_begin = main_epoch_interval.value.epoch_begin;
          content.epoch_end = main_epoch_interval.value.epoch_end;
      }

      return JSON.stringify(content);
  };

  const store_report = async (file_name) => {
      let success = false;

      let data = {
          csrf: props.context.csrf,
          ifid: props.context.ifid,
          report_name: file_name,
          content: await serialize_report(file_name)
      };

      let url = `${props.context.report_store_endpoint}`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(data) });
          success = true;
      } catch (err) {
          console.error(err);
      }

      return success;
  };

  async function download_report() {
      var name = get_suggested_report_name();
      var filename = name + '.json';
      var content = await serialize_report(name);
      var element = document.createElement('a');
      element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(content));
      element.setAttribute('download', filename);
      element.style.display = 'none';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
  }

  function print_report() {
      if (printable == true) {
          window.print();
          return false;
      }

      let url_params_obj = ntopng_url_manager$1.get_url_object();
      url_params_obj.printable = true;
      const params = ntopng_url_manager$1.obj_to_url_params(url_params_obj);

      let url = `${window.location.origin}${window.location.pathname}?${params}`;

      //const print_key = "printable";
      //ntopng_url_manager.set_key_to_url(print_key, true);

      ntopng_url_manager$1.open_new_window(url);

      //ntopng_url_manager.delete_key_from_url(print_key);
      // $(report_box.value).print({mediaPrint: true, timeout: 1000}); 
      // $(report_box.value).print();
  }

  function get_time_interval_string(epoch_begin, epoch_end) {
      if (disable_date.value == true) { return ""; }

      const epoch_begin_msec = epoch_begin * 1000;
      const epoch_end_msec = epoch_end * 1000;

      const begin_date = ntopng_utility$1.from_utc_to_server_date_format(epoch_begin_msec, 'DD/MM/YYYY');
      const begin_time = ntopng_utility$1.from_utc_to_server_date_format(epoch_begin_msec, 'HH:mm:ss');

      const end_date = ntopng_utility$1.from_utc_to_server_date_format(epoch_end_msec, 'DD/MM/YYYY');
      const end_time = ntopng_utility$1.from_utc_to_server_date_format(epoch_end_msec, 'HH:mm:ss');

      const begin = `${begin_date} ${begin_time}`;
      const end = (begin_date == end_date) ? `${end_time}` : `${end_date} ${end_time}`;
      return `${begin} - ${end}`;
  }

  function set_report_title() {
      const epoch_interval = ntopng_status_manager$1.get_status(true);
      const time_interval_string = get_time_interval_string(epoch_interval.epoch_begin, epoch_interval.epoch_end);
      let title = `ntopng - Report ${selected_report_template.value.label} ${time_interval_string}`;
      document.title = title;
  }

  /* Callback to request REST data from components */
  function get_component_data_func(component) {
      const get_component_data = async (url, url_params, post_params) => {
          let info = {};
          if (data_from_backup) {
              // backward compatibility (component_id was not defined)
              if (component.component_id == null) component.component_id = component.id;

              if (!components_info[component.component_id]) { /* Safety check */

                  console.error("No data for " + component.component_id);
                  info.data = {};
              } else {
                  info = components_info[component.component_id];
              }
              loading.value = false;
          } else {

              /* Check if there is already a promise for the same request */
              if (components_info[component.component_id]) {
                  info = components_info[component.component_id];
                  if (info.data) {
                      await info.data; /* wait in case of previous pending requests */
                  }
              }

              const data_url = `${url}?${url_params}`;

              loading.value = true;
              if (post_params) {
                  info.data = ntopng_utility$1.http_post_request(data_url, post_params);
              } else {
                  info.data = ntopng_utility$1.http_request(data_url);
              }
              info.data.then(() => {
                  loading.value = false;
              });

              components_info[component.component_id] = info;
          }
          return info.data;
      };
      return get_component_data
  }

  /* Callback to request REST data from components */
  function set_component_attr_func(component) {
      const set_component_attr = async (attr, value) => {
          component[attr] = value;
      };
      return set_component_attr;
  }

  /* ********************************************* */
  /* ************** Template Editor ************** */

  function show_new_template_modal() {
      modal_new_template.value.show();
  }

  function get_suggested_template_name() {
      let name = "New Template";
      return name;
  }

  const new_template = async (template_name) => {
      let success = false;

      let data = {
          csrf: props.context.csrf,
          template_name: template_name,
      };

      let url = `${props.context.template_add_endpoint}`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          let res = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(data) });

          if (res && res.template_id) {
              await set_template(res.template_id);
          }

          success = true;
      } catch (err) {
          console.error(err);
      }

      return success;
  };

  async function commit_template_change(e) {

      let components_ids = components.value.map((c) => { return c.id; });

      let data = {
          csrf: props.context.csrf,
          template: selected_report_template.value.value,
          components: components_ids.toString()
      };

      let success = false;
      let url = `${props.context.template_edit_endpoint}`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          let res = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(data) });
          success = true;
      } catch (err) {
          console.error(err);
      }

      return success;
  }

  async function component_dragged(e) {

      /* console.log(template_sortable.toArray().toString()); */

      let new_components = template_sortable.toArray().map((id) => {
          return components.value.find((c) => c.id == id);
      });

      unset_sortable_template();

      components.value = new_components;

      await nextTick();
      set_sortable_template();

      commit_template_change();
  }

  function set_sortable_template() {
      if (template_sortable) {
          return;
      }

      var drag_zone = document.getElementById('drag-zone');
      template_sortable = window.Sortable.create(drag_zone, {
          draggable: ".drag-item",
          dataIdAttr: "id",
          onUpdate: component_dragged
      });

      //console.log("Sortable ON");
  }

  function unset_sortable_template() {
      if (template_sortable) {
          template_sortable.destroy();
          template_sortable = null;
          //console.log("Sortable OFF");
      }
  }

  function toggle_edit_mode() {
      edit_mode.value = !edit_mode.value;

      if (edit_mode.value) {
          set_sortable_template();
      } else {
          unset_sortable_template();
      }
  }

  const list_template_components = async () => {
      let url = `${props.context.template_list_widgets_endpoint}`;
      let res = await ntopng_utility$1.http_request(url);
      if (res?.list == null) { return {}; }
      let widgets = res.list;

      widgets.sort((a, b) => _i18n(a.i18n_name).toUpperCase().localeCompare(_i18n(b.i18n_name).toUpperCase()));

      return widgets;
  };

  function show_add_template_component_modal() {
      modal_add_template_component.value.show();
  }

  function show_delete_template_modal() {
      modal_delete_template.value.show();
  }

  const add_template_component = async (c) => {
      unset_sortable_template();

      let url = `${props.context.template_component_add_endpoint}`;
      let params = {
          csrf: props.context.csrf,
          template: props.context.template,
          component: c.id
      };
      let headers = {
          'Content-Type': 'application/json'
      };
      try {
          let content = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          warning_message.value = "";
          await set_template(selected_report_template.value.value);
      } catch (err) {
          warning_message.value = _i18n("report.unable_to_open");
      }

      await nextTick();
      set_sortable_template();
  };

  async function remove_template_component(e) {
      unset_sortable_template();

      const component_id = e.target.dataset.componentId;
      components.value = components.value.filter(c => c.id !== component_id);

      await nextTick();
      set_sortable_template();

      commit_template_change();
  }

  /**
   * @brief The method used to open the edit component modal 
   *        involves triggering a click event on the 'Edit' (pencil icon) button.
   * @param e event object
   */
  function show_edit_template_component(e) {
      const component_id = e.target.dataset.componentId;
      const component = components.value.find(c => c.id === component_id);
      const is_report_page = props.context.page == 'report';
      modal_edit_template_component.value.show(component, is_report_page);
  }

  /**
   * 
   * @brief The method used to update the selected component with new settings 
   *        involves making a REST call.
   * @param new_component An object with new settings for the component to edit. 
   */
  async function edit_template_component(new_component) {
      unset_sortable_template();

      let url = `${props.context.template_component_edit_endpoint}`;
      let params = {
          csrf: props.context.csrf,
          template: props.context.template,
          component: new_component.id,
          component_title: new_component.title,
          component_height: new_component.height,
          component_width: new_component.width,
          component_time_offset: new_component.time_offset,
          component_time_window: new_component.time_window,
          component_params: new_component.rest_params
      };

      let headers = {
          'Content-Type': 'application/json'
      };
      try {
          let content = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(params) });
          warning_message.value = "";
          await set_template(selected_report_template.value.value);
      } catch (err) {
          warning_message.value = _i18n("report.unable_to_open");
      }

      await nextTick();
      set_sortable_template();
  }

  async function delete_template() {
      let success = false;

      let data = {
          csrf: props.context.csrf,
          template: selected_report_template.value.value,
      };

      let url = `${props.context.template_delete_endpoint}`;
      try {
          let headers = {
              'Content-Type': 'application/json'
          };
          let res = await ntopng_utility$1.http_request(url, { method: 'post', headers, body: JSON.stringify(data) });

          await set_template();

          success = true;
      } catch (err) {
          console.error(err);
      }

      return success;
  }

  /* ********************************************* */


  return (_ctx, _cache) => {
    return (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", _hoisted_1$1, [
        createCommentVNode(" <Dropdown v-for=\"(t, t_index) in top_table_array\" "),
        createCommentVNode("           :ref=\"el => { top_table_dropdown_array[t_index] = el }\"> "),
        createCommentVNode("   <template v-slot:title> "),
        createCommentVNode("     <Spinner :show=\"t.show_spinner\" size=\"1rem\" class=\"me-1\"></Spinner> "),
        createCommentVNode("     <a class=\"ntopng-truncate\" :title=\"t.title\">{{ t.label }}</a> "),
        createCommentVNode("   </template> "),
        createCommentVNode("   <template v-slot:menu> "),
        createCommentVNode("     <a v-for=\"opt in t.options\" style=\"cursor:pointer; display: block;\" "),
        createCommentVNode("        @click=\"add_top_table_filter(opt, $event)\" class=\"ntopng-truncate tag-filter \" "),
        createCommentVNode("        :title=\"opt.value\">{{ opt.label }}</a> "),
        createCommentVNode("   </template>     "),
        createCommentVNode(" </Dropdown> "),
        (unref(enable_date_time_range_picker))
          ? (openBlock(), createBlock(script$1E, {
              key: 0,
              class: "dontprint",
              disabled_date_picker: unref(disable_date_time_picker),
              id: "dashboard-date-time-picker",
              round_time: true,
              min_time_interval_id: "min",
              onEpoch_change: set_components_epoch_interval
            }, {
              begin: withCtx(() => [
                createBaseVNode("div", _hoisted_2$1, [
                  createVNode(script$1I, {
                    selected_option: selected_report_template.value,
                    "onUpdate:selected_option": _cache[0] || (_cache[0] = $event => ((selected_report_template).value = $event)),
                    options: reports_templates.value,
                    onSelect_option: select_report_template
                  }, null, 8 /* PROPS */, ["selected_option", "options"])
                ])
              ]),
              extra_buttons: withCtx(() => [
                createBaseVNode("button", {
                  class: "btn btn-link btn-sm",
                  type: "button",
                  onClick: show_store_report_modal,
                  title: _i18n('dashboard.store')
                }, _hoisted_5$1, 8 /* PROPS */, _hoisted_3$1),
                createBaseVNode("button", {
                  class: "btn btn-link btn-sm",
                  type: "button",
                  onClick: show_open_report_modal,
                  title: _i18n('dashboard.open')
                }, _hoisted_8$1, 8 /* PROPS */, _hoisted_6$1),
                createBaseVNode("button", {
                  class: "btn btn-link btn-sm",
                  type: "button",
                  onClick: download_report,
                  title: _i18n('download')
                }, _hoisted_11$1, 8 /* PROPS */, _hoisted_9$1),
                createBaseVNode("button", {
                  class: "btn btn-link btn-sm",
                  type: "button",
                  onClick: show_upload_report_modal,
                  title: _i18n('upload')
                }, _hoisted_14$1, 8 /* PROPS */, _hoisted_12$1),
                createBaseVNode("button", {
                  class: "btn btn-link btn-sm",
                  type: "button",
                  onClick: print_report,
                  title: _i18n('dashboard.print')
                }, _hoisted_17$1, 8 /* PROPS */, _hoisted_15$1),
                (unref(allow_edit))
                  ? (openBlock(), createElementBlock("button", {
                      key: 0,
                      class: "btn btn-link btn-sm",
                      type: "button",
                      onClick: show_new_template_modal,
                      title: _i18n('dashboard.new_template')
                    }, _hoisted_20$1, 8 /* PROPS */, _hoisted_18$1))
                  : createCommentVNode("v-if", true),
                (unref(allow_edit) && selected_report_template.value.allow_edit)
                  ? (openBlock(), createElementBlock("button", {
                      key: 1,
                      class: normalizeClass(["btn btn-link btn-sm", edit_mode.value ? 'text-warning' : '']),
                      type: "button",
                      onClick: toggle_edit_mode,
                      title: _i18n('dashboard.edit_mode')
                    }, _hoisted_23$1, 10 /* CLASS, PROPS */, _hoisted_21$1))
                  : createCommentVNode("v-if", true)
              ]),
              _: 1 /* STABLE */
            }, 8 /* PROPS */, ["disabled_date_picker"]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Filters "),
        createBaseVNode("div", {
          class: normalizeClass(["form-group d-flex align-items-end", [loading_filters.value ? 'justify-content-center align-items-center' : '']])
        }, [
          createVNode(script$1v, {
            show: loading_filters.value,
            size: "1rem",
            class: "me-1"
          }, null, 8 /* PROPS */, ["show"]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(filters_to_show.value, (filter_id) => {
            return (openBlock(), createElementBlock("div", _hoisted_24$1, [
              createBaseVNode("label", _hoisted_25$1, [
                createBaseVNode("b", null, toDisplayString(_i18n('db_search.' + filter_id)), 1 /* TEXT */)
              ]),
              createVNode(script$1I, {
                selected_option: selected_filters.value[filter_id],
                "onUpdate:selected_option": $event => ((selected_filters.value[filter_id]) = $event),
                options: filtered_filters.value[filter_id],
                disabled: second_load.value,
                style: 'width: 50%;',
                theme: "bootstrap-5",
                dropdown_size: "small",
                onSelect_option: $event => (select_filter(selected_filters.value[filter_id], filter_id))
              }, null, 8 /* PROPS */, ["selected_option", "onUpdate:selected_option", "options", "disabled", "onSelect_option"])
            ]))
          }), 256 /* UNKEYED_FRAGMENT */)),
          (Object.keys(filters_to_show.value).length > 0)
            ? (openBlock(), createElementBlock("div", _hoisted_26$1, [
                createBaseVNode("div", _hoisted_27$1, [
                  _hoisted_28$1,
                  createBaseVNode("button", {
                    type: "button",
                    class: "btn btn-sm btn-primary",
                    onClick: reset_filters
                  }, toDisplayString(_i18n('reset')), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_29$1, [
                  createVNode(script$1v, {
                    show: second_load.value,
                    size: "1rem",
                    class: "me-1"
                  }, null, 8 /* PROPS */, ["show"])
                ])
              ]))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */),
        createCommentVNode(" Template Editor Toolbox "),
        (edit_mode.value)
          ? (openBlock(), createElementBlock("div", _hoisted_30$1, [
              createBaseVNode("button", {
                class: "btn btn-lg btn-link text-warning",
                type: "button",
                onClick: show_add_template_component_modal,
                title: _i18n('dashboard.add_component')
              }, _hoisted_33$1, 8 /* PROPS */, _hoisted_31$1),
              createBaseVNode("button", {
                class: "btn btn-lg btn-link text-warning",
                type: "button",
                onClick: show_delete_template_modal,
                title: _i18n('dashboard.del_template')
              }, _hoisted_36$1, 8 /* PROPS */, _hoisted_34$1),
              createBaseVNode("h2", _hoisted_37$1, toDisplayString(_i18n('dashboard.edit_mode')), 1 /* TEXT */),
              createCommentVNode("\n            <div style=\"margin: auto\"></div>\n            <h4><span class=\"badge bg-warning\">{{ _i18n('dashboard.edit_mode') }}</span></h4>\n            ")
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Report Title and small buttons "),
        (unref(enable_report_title))
          ? (openBlock(), createElementBlock("div", _hoisted_38$1, [
              createBaseVNode("h3", _hoisted_39$1, [
                createTextVNode(toDisplayString(unref(report_title)) + " ", 1 /* TEXT */),
                (unref(enable_small_picker))
                  ? (openBlock(), createElementBlock("span", _hoisted_40$1, [
                      (unref(enable_small_picker_actions))
                        ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createBaseVNode("button", {
                              class: "btn btn-link btn-sm",
                              type: "button",
                              onClick: download_report,
                              title: _i18n('download')
                            }, _hoisted_43$1, 8 /* PROPS */, _hoisted_41$1),
                            createBaseVNode("button", {
                              class: "btn btn-link btn-sm",
                              type: "button",
                              onClick: show_upload_report_modal,
                              title: _i18n('upload')
                            }, _hoisted_46$1, 8 /* PROPS */, _hoisted_44$1)
                          ], 64 /* STABLE_FRAGMENT */))
                        : createCommentVNode("v-if", true),
                      createBaseVNode("button", {
                        class: "btn btn-link btn-sm",
                        type: "button",
                        onClick: print_report,
                        title: _i18n('dashboard.print')
                      }, _hoisted_49$1, 8 /* PROPS */, _hoisted_47$1)
                    ]))
                  : createCommentVNode("v-if", true)
              ])
            ]))
          : createCommentVNode("v-if", true),
        createCommentVNode(" Report/Dashboard Content "),
        (openBlock(), createElementBlock("div", {
          ref_key: "report_box",
          ref: report_box,
          id: "drag-zone",
          class: "row",
          key: components.value
        }, [
          createCommentVNode(" Warning Message "),
          (warning_message.value)
            ? (openBlock(), createElementBlock("div", _hoisted_50, [
                createBaseVNode("div", _hoisted_51, toDisplayString(warning_message.value), 1 /* TEXT */)
              ]))
            : createCommentVNode("v-if", true),
          createCommentVNode(" Empty template message "),
          (components_loaded.value && !components.value.length && !edit_mode.value)
            ? (openBlock(), createElementBlock("div", _hoisted_52, [
                createBaseVNode("div", _hoisted_53, [
                  createBaseVNode("h4", _hoisted_54, toDisplayString(_i18n("dashboard.empty_template")), 1 /* TEXT */),
                  createBaseVNode("p", _hoisted_55, toDisplayString(_i18n("dashboard.empty_template_note")), 1 /* TEXT */)
                ])
              ]))
            : createCommentVNode("v-if", true),
          createCommentVNode(" Rendered Components "),
          (openBlock(true), createElementBlock(Fragment, null, renderList(components.value, (c) => {
            return (openBlock(), createBlock(script$8, {
              style: {"min-width":"20rem"},
              color: (c.active && c.color) || c.inactive_color,
              width: c.width,
              height: c.height,
              id: c.id,
              class: "drag-item"
            }, {
              box_title: withCtx(() => [
                (c.i18n_name)
                  ? (openBlock(), createElementBlock("div", _hoisted_56, [
                      createBaseVNode("h4", _hoisted_57, [
                        createTextVNode(toDisplayString(c.custom_name ? c.custom_name : _i18n(c.i18n_name)) + " ", 1 /* TEXT */),
                        createBaseVNode("span", _hoisted_58, toDisplayString(c.time_offset ? _i18n('dashboard.' + (unref(is_live) ? 'time_ago' : 'time_offset_list')
              + '.' + c.time_offset) : ''), 1 /* TEXT */)
                      ]),
                      (edit_mode.value)
                        ? (openBlock(), createElementBlock("div", _hoisted_59, [
                            createBaseVNode("div", _hoisted_60, [
                              createBaseVNode("button", {
                                type: "button",
                                class: "btn-close btn-edit me-1",
                                "data-component-id": c.id,
                                onClick: show_edit_template_component
                              }, null, 8 /* PROPS */, _hoisted_61),
                              createBaseVNode("button", {
                                type: "button",
                                class: "btn-close",
                                "data-component-id": c.id,
                                onClick: remove_template_component
                              }, null, 8 /* PROPS */, _hoisted_62)
                            ])
                          ]))
                        : createCommentVNode("v-if", true)
                    ]))
                  : createCommentVNode("v-if", true)
              ]),
              box_content: withCtx(() => [
                (loading.value && unref(show_loading))
                  ? (openBlock(), createBlock(script$1z, {
                      key: 0,
                      styles: 'margin-top: 2rem !important;'
                    }))
                  : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass([(loading.value && unref(show_loading)) ? 'ntopng-gray-out' : ''])
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(components_dict[c.component]), {
                    id: c.id,
                    style: normalizeStyle(unref(component_custom_style)(c)),
                    epoch_begin: c.epoch_begin,
                    epoch_end: c.epoch_end,
                    i18n_title: c.i18n_name,
                    ifid: c.ifid ? c.ifid.toString() : __props.context.ifid.toString(),
                    max_width: c.width,
                    max_height: c.height,
                    params: c.params,
                    get_component_data: get_component_data_func(c),
                    set_component_attr: set_component_attr_func(c),
                    csrf: __props.context.csrf,
                    filters: c.filters
                  }, null, 8 /* PROPS */, ["id", "style", "epoch_begin", "epoch_end", "i18n_title", "ifid", "max_width", "max_height", "params", "get_component_data", "set_component_attr", "csrf", "filters"]))
                ], 2 /* CLASS */)
              ]),
              box_footer: withCtx(() => [
                (c.component != 'empty' && c.i18n_name && !unref(disable_date))
                  ? (openBlock(), createElementBlock("span", _hoisted_63, toDisplayString(unref(component_interval)(c)), 1 /* TEXT */))
                  : createCommentVNode("v-if", true)
              ]),
              _: 2 /* DYNAMIC */
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["color", "width", "height", "id"]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ]))
      ]),
      createCommentVNode(" div row "),
      createVNode(script$d, {
        ref_key: "modal_store_report",
        ref: modal_store_report,
        get_suggested_file_name: get_suggested_report_name,
        store_file: store_report,
        csrf: __props.context.csrf,
        title: _i18n('dashboard.store')
      }, null, 8 /* PROPS */, ["csrf", "title"]),
      createVNode(script$c, {
        ref_key: "modal_open_report",
        ref: modal_open_report,
        list_files: list_reports,
        open_file: open_report,
        delete_file: delete_report,
        csrf: __props.context.csrf,
        title: _i18n('dashboard.open'),
        file_title: _i18n('report.report_name')
      }, null, 8 /* PROPS */, ["csrf", "title", "file_title"]),
      createVNode(script$b, {
        ref_key: "modal_upload_report",
        ref: modal_upload_report,
        upload_file: upload_report,
        title: _i18n('upload'),
        file_title: _i18n('report.file')
      }, null, 8 /* PROPS */, ["title", "file_title"]),
      createVNode(script$d, {
        ref_key: "modal_new_template",
        ref: modal_new_template,
        get_suggested_file_name: get_suggested_template_name,
        store_file: new_template,
        allow_spaces: true,
        csrf: __props.context.csrf,
        title: _i18n('dashboard.new_template')
      }, null, 8 /* PROPS */, ["csrf", "title"]),
      createVNode(script$a, {
        ref_key: "modal_add_template_component",
        ref: modal_add_template_component,
        list_components: list_template_components,
        add_component: add_template_component,
        csrf: __props.context.csrf,
        title: _i18n('dashboard.add_component')
      }, null, 8 /* PROPS */, ["csrf", "title"]),
      createVNode(script$9, {
        ref_key: "modal_edit_template_component",
        ref: modal_edit_template_component,
        csrf: __props.context.csrf,
        onEdit: edit_template_component
      }, null, 8 /* PROPS */, ["csrf"]),
      createVNode(script$1c, {
        ref_key: "modal_delete_template",
        ref: modal_delete_template,
        title: _i18n('dashboard.del_template'),
        body: _i18n('dashboard.del_template_confirm'),
        onDelete: delete_template
      }, null, 8 /* PROPS */, ["title", "body"])
    ], 64 /* STABLE_FRAGMENT */))
  }
  }

  };

  var css_248z$1 = "\n@media print {\n.dontprint[data-v-c360f212] {\n        display: none;\n}\n.pagebreak-begin[data-v-c360f212] {\n        page-break-before: always;\n}\n.pagebreak-end[data-v-c360f212] {\n        page-break-after: always !important;\n}\n.print-element-class[data-v-c360f212] {\n        page-break-inside: avoid !important;\n        page-break-after: auto\n}\n}\n\n/* @media print and (orientation: portrait) and (max-width: 297mm){ */\n/*     .col-4 { */\n/*         width: 50% !important; */\n/*         flex: 0 0 auto; */\n/*     } */\n/* } */\n@page {\n    /* size: A3 landscape; */\n    /* position:absolute; width:100%; top:0;left:0;right:0;bottom:0; padding:0; margin:-1px; */\n}\n\n/* Print on A4 */\n@media print and (max-width: 297mm) and (min-width: 210mm) {\n\n    /* .row { */\n    /*         padding-left: 0; */\n    /*         padding-right: 0; */\n    /*         margin-left: -10rem; */\n    /*         margin-right: 0; */\n    /* } */\n.col-4[data-v-c360f212] {\n        width: 50% !important;\n        flex: 0 0 auto;\n}\n}\n\n/* Print on A5 (commented out as this is not working on Chrome/Safari) */\n\n/* @media print and (max-width: 148mm){ */\n/*     .col-4 { */\n/*         width: 100% !important; */\n/*         flex: 0 0 auto; */\n/*     } */\n/*     .col-6 { */\n/*         width: 100% !important; */\n/*         flex: 0 0 auto; */\n/*     } */\n/* } */\n.align-center[data-v-c360f212] {}\n";
  styleInject(css_248z$1);

  script$1.__scopeId = "data-v-c360f212";
  script$1.__file = "http_src/vue/dashboard.vue";

  const _withScopeId = n => (pushScopeId("data-v-7e5acce0"),n=n(),popScopeId(),n);
  const _hoisted_1 = { class: "mb-3 row" };
  const _hoisted_2 = { class: "col-form-label col-sm-4" };
  const _hoisted_3 = { class: "col-sm-6" };
  const _hoisted_4 = {
    class: "btn-group btn-group-toggle",
    "data-bs-toggle": "buttons"
  };
  const _hoisted_5 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createBaseVNode("hr", null, null, -1 /* HOISTED */));
  const _hoisted_6 = { class: "host-alert-fields" };
  const _hoisted_7 = { class: "mb-3 row" };
  const _hoisted_8 = { class: "col-form-label col-sm-4" };
  const _hoisted_9 = { class: "col-sm-6" };
  const _hoisted_10 = { value: "" };
  const _hoisted_11 = { value: "0" };
  const _hoisted_12 = { disabled: "" };
  const _hoisted_13 = ["value"];
  const _hoisted_14 = { class: "flow-alert-fields" };
  const _hoisted_15 = { class: "mb-3 row" };
  const _hoisted_16 = { class: "col-form-label col-sm-4" };
  const _hoisted_17 = { class: "col-sm-6" };
  const _hoisted_18 = { value: "" };
  const _hoisted_19 = { value: "0" };
  const _hoisted_20 = { disabled: "" };
  const _hoisted_21 = ["value"];
  const _hoisted_22 = {
    key: 0,
    class: "ip-fields"
  };
  const _hoisted_23 = { class: "mb-3 row" };
  const _hoisted_24 = { class: "col-form-label col-sm-4" };
  const _hoisted_25 = { class: "col-sm-6" };
  const _hoisted_26 = ["pattern"];
  const _hoisted_27 = {
    key: 1,
    class: "network-fields"
  };
  const _hoisted_28 = { class: "mb-3 row" };
  const _hoisted_29 = { class: "col-form-label col-sm-4" };
  const _hoisted_30 = { class: "col-sm-4 pr-0" };
  const _hoisted_31 = ["pattern"];
  const _hoisted_32 = { class: "col-sm-2 ps-4 pe-0" };
  const _hoisted_33 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createBaseVNode("span", { class: "me-2" }, "/", -1 /* HOISTED */));
  const _hoisted_34 = { class: "mb-3 row" };
  const _hoisted_35 = { class: "col-form-label col-sm-4" };
  const _hoisted_36 = { class: "col-sm-6" };
  const _hoisted_37 = { class: "mb-3 row" };
  const _hoisted_38 = { class: "col-form-label col-sm-4" };
  const _hoisted_39 = { key: 0 };
  const _hoisted_40 = { key: 1 };
  const _hoisted_41 = { class: "col-sm-6" };
  const _hoisted_42 = ["pattern"];
  const _hoisted_43 = ["pattern"];
  const _hoisted_44 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/createBaseVNode("hr", { class: "separator mt-5" }, null, -1 /* HOISTED */));
  const _hoisted_45 = { class: "form-group row" };
  const _hoisted_46 = { class: "col-form-label" };
  const _hoisted_47 = { class: "mt-1" };
  const _hoisted_48 = ["placeholder"];
  const _hoisted_49 = ["disabled"];


  var script = {
    __name: 'modal-add-check-exclusion',
    props: {
      alert_exclusions_page: String,
      host_alert_types: Array,
      flow_alert_types: Array,    
  },
    emits: ['add'],
    setup(__props, { expose, emit }) {

  const props = __props;

  const modal_id = ref(null);
  ref(null);
  const exclude_type = ref("ip");
  const input_ip = ref("");
  const input_network = ref("");
  const input_vlan = ref(0);
  const input_text = ref("");
  const host_selected = ref("");
  const flow_selected = ref("");
  const netmask = ref("");
  const comment = ref(null);
  const comment_placeholder = i18n("details.comment_placeholder");
  const is_edit = ref(null);
  const row_to_delete = ref(null);


  //s.split(",").every((a) => {return /.+=.+/.test(a)})
  function get_data_pattern(value_type) {
      if (value_type == "text") {
  	return NtopUtils.REGEXES.non_quoted_text;
      } else if (value_type == "ip") {
  	let r_ipv4 = NtopUtils.REGEXES.ipv4;
  	let r_ipv4_vlan = r_ipv4.replaceAll("$", "@[0-9]{0,5}$");
  	let r_ipv6 = NtopUtils.REGEXES.ipv6;
  	let r_ipv6_vlan = r_ipv6.replaceAll("$", "@[0-9]{0,5}$");
  	return `(${r_ipv4})|(${r_ipv4_vlan})|(${r_ipv6})|(${r_ipv6_vlan})`;
      } else if (value_type == "hostname") {
  	return `${NtopUtils.REGEXES.singleword}|[a-zA-Z0-9._-]{3,250}@[0-9]{0,5}$`;
      } else if (value_type == "certificate") {
  	return NtopUtils.REGEXES.tls_certificate;
      }
      return NtopUtils.REGEXES[value_type];
  }



  let pattern_ip = get_data_pattern("ip");
  get_data_pattern("text");
  let pattern_certificate = get_data_pattern("certificate");
  let pattern_domain = get_data_pattern("domain_name_not_strict");

  const set_exclude_type = (type) => {
      exclude_type.value = type;
  };

  const check_disable_apply = () => {
      let regex = null;
      let disable_apply = true;
      if (props.alert_exclusions_page == 'hosts') {
  	regex = new RegExp(pattern_ip);
  	if (exclude_type.value == "ip") {
  	    disable_apply = (input_ip.value == null || input_ip.value == "") || (regex.test(input_ip.value) == false) || (host_selected.value == "" && flow_selected.value == "");
  	} else {
  	    disable_apply = (input_network.value == null || input_network.value == "")
  		|| (regex.test(input_network.value) == false)
  		|| (host_selected.value == "" && flow_selected.value == "")
  		|| (netmask.value == null || netmask.value == "" || parseInt(netmask.value) < 1 || parseInt(netmask.value) > 127);
  	}
      } else if (props.alert_exclusions_page == 'domain_names') {
  	regex = new RegExp(pattern_domain);
  	disable_apply = (input_text.value == null || input_text.value == "") || (regex.test(input_text.value) == false);
  	
      } else if (props.alert_exclusions_page == 'tls_certificate') {
  	regex = new RegExp(pattern_certificate);
  	disable_apply = (input_text.value == null || input_text.value == "") || (regex.test(input_text.value) == false);
      }
      return disable_apply;
  };

  const showed = () => {};

  const show = (row) => {
      //debugger;
      if(row) {
        is_edit.value = true;
        row_to_delete.value = row;

        comment.value = row.label;
        
        if(row.type == 'host') {
          let network_details = row.alert_addr.split("/");
          let vlan_split = row.alert_addr.split("@");

          if(network_details.length > 1) {
            exclude_type.value = "network";
            input_network.value = network_details[0];
            netmask.value = network_details[1];
            input_ip.value = "";
          } else {
            exclude_type.value = "ip";
            input_ip.value = vlan_split[0];
            input_network.value = "";
            netmask.value = "";
          } 

          if(vlan_split.length > 1 ) {
            input_vlan.value = vlan_split[1];
          } else {
            input_vlan.value = 0;
          }

          if(row.host_alert_key != null) 
            host_selected.value = ''+row.host_alert_key;
          else 
            host_selected.value = "";
        
          if(row.flow_alert_key != null) 
            flow_selected.value = ''+row.flow_alert_key;
          else 
            flow_selected.value = "";

        } else if(row.type == 'domain') {
          input_text.value = row.alert_domain;
        } else {
          input_text.value = row.alert_certificate;
        }
              
      } else {

        exclude_type.value = "ip";
        input_ip.value = "";
        input_network.value = "";
        input_vlan.value = 0;
        host_selected.value = "0";
        flow_selected.value = "";
        netmask.value = "";
        input_text.value = "";
        comment.value = "";
      }

      modal_id.value.show();
  };

  const close = () => {
      modal_id.value.close();
  };

  const normalize_alert_key_value = (alert_key) => {
    if (alert_key == "") return -1;
    return alert_key;
  }; 

  const add = () => {
      let params;
      let alert_addr = input_ip.value;
      if (props.alert_exclusions_page == "hosts") {
  	if (exclude_type.value == "network") {
  	    alert_addr = `${input_network.value}/${netmask.value}`;
  	}
          if (input_vlan.value != null && input_vlan.value != 0) {
  	    alert_addr = `${alert_addr}@${input_vlan.value}`;
          }
  	params = { alert_addr, host_alert_key: normalize_alert_key_value(host_selected.value), flow_alert_key: normalize_alert_key_value(flow_selected.value) };
      } else if (props.alert_exclusions_page == "domain_names") {
  	params = { alert_domain: input_text.value };
      } else if (props.alert_exclusions_page == "tls_certificate") {
  	params = { alert_certificate: input_text.value };
      }
      params.label = comment.value;
      if(is_edit.value) {
        params.old_type = row_to_delete.value.type;
        params.old_subdir = row_to_delete.value.subdir;
        params.old_alert_domain = row_to_delete.value.alert_domain;
        params.old_alert_certificate = row_to_delete.value.alert_certificate;
        params.old_alert_addr = row_to_delete.value.alert_addr;
        params.old_flow_alert_key = row_to_delete.value.flow_alert_key;
        params.old_host_alert_key = row_to_delete.value.host_alert_key;
      }
      emit('add', params);
      close();
   
  };

  expose({ show, close });

  onMounted(() => {
  });

  const _i18n = (t) => i18n(t);


  return (_ctx, _cache) => {
    return (openBlock(), createBlock(script$1D, {
      onShowed: _cache[11] || (_cache[11] = $event => (showed())),
      ref_key: "modal_id",
      ref: modal_id
    }, {
      title: withCtx(() => [
        createTextVNode(toDisplayString(_i18n("check_exclusion.add_exclusion")), 1 /* TEXT */)
      ]),
      body: withCtx(() => [
        (__props.alert_exclusions_page == 'hosts')
          ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" modal hosts "),
              createBaseVNode("div", _hoisted_1, [
                createBaseVNode("label", _hoisted_2, [
                  createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.member_type")), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_3, [
                  createBaseVNode("div", _hoisted_4, [
                    createBaseVNode("label", {
                      class: normalizeClass([{'active': exclude_type.value == 'ip'}, "btn btn-secondary"])
                    }, [
                      createBaseVNode("input", {
                        class: "btn-check",
                        type: "radio",
                        name: "member_type",
                        value: "ip",
                        onClick: _cache[0] || (_cache[0] = $event => (set_exclude_type('ip')))
                      }),
                      createTextVNode(" " + toDisplayString(_i18n("check_exclusion.ip_address")), 1 /* TEXT */)
                    ], 2 /* CLASS */),
                    createBaseVNode("label", {
                      class: normalizeClass([{'active': exclude_type.value == 'network'}, "btn btn-secondary"])
                    }, [
                      createBaseVNode("input", {
                        onClick: _cache[1] || (_cache[1] = $event => (set_exclude_type('network'))),
                        class: "btn-check",
                        type: "radio",
                        name: "member_type",
                        value: "network"
                      }),
                      createTextVNode(" " + toDisplayString(_i18n("check_exclusion.network")), 1 /* TEXT */)
                    ], 2 /* CLASS */)
                  ])
                ])
              ]),
              _hoisted_5,
              createBaseVNode("div", _hoisted_6, [
                createBaseVNode("div", _hoisted_7, [
                  createBaseVNode("label", _hoisted_8, [
                    createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.host_alert_type")), 1 /* TEXT */)
                  ]),
                  createBaseVNode("div", _hoisted_9, [
                    withDirectives(createBaseVNode("select", {
                      name: "value",
                      class: "form-select alert-select",
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => ((host_selected).value = $event))
                    }, [
                      createBaseVNode("option", _hoisted_10, toDisplayString(_i18n("check_exclusion.none")), 1 /* TEXT */),
                      createBaseVNode("option", _hoisted_11, toDisplayString(_i18n("check_exclusion.exclude_all_alerts")), 1 /* TEXT */),
                      createBaseVNode("option", _hoisted_12, toDisplayString(_i18n("check_exclusion.spacing_bar")), 1 /* TEXT */),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.host_alert_types, (item) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          (item != null)
                            ? (openBlock(), createElementBlock("option", {
                                key: 0,
                                value: item.alert_id
                              }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_13))
                            : createCommentVNode("v-if", true)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ], 512 /* NEED_PATCH */), [
                      [vModelSelect, host_selected.value]
                    ])
                  ])
                ])
              ]),
              createBaseVNode("div", _hoisted_14, [
                createBaseVNode("div", _hoisted_15, [
                  createBaseVNode("label", _hoisted_16, [
                    createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.flow_alert_type")), 1 /* TEXT */)
                  ]),
                  createBaseVNode("div", _hoisted_17, [
                    withDirectives(createBaseVNode("select", {
                      id: "flow-alert-select",
                      name: "value",
                      class: "form-select alert-select",
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ((flow_selected).value = $event))
                    }, [
                      createBaseVNode("option", _hoisted_18, toDisplayString(_i18n("check_exclusion.none")), 1 /* TEXT */),
                      createBaseVNode("option", _hoisted_19, toDisplayString(_i18n("check_exclusion.exclude_all_alerts")), 1 /* TEXT */),
                      createBaseVNode("option", _hoisted_20, toDisplayString(_i18n("check_exclusion.spacing_bar")), 1 /* TEXT */),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(__props.flow_alert_types, (item) => {
                        return (openBlock(), createElementBlock(Fragment, null, [
                          (item != null)
                            ? (openBlock(), createElementBlock("option", {
                                key: 0,
                                value: item.alert_id
                              }, toDisplayString(item.label), 9 /* TEXT, PROPS */, _hoisted_21))
                            : createCommentVNode("v-if", true)
                        ], 64 /* STABLE_FRAGMENT */))
                      }), 256 /* UNKEYED_FRAGMENT */))
                    ], 512 /* NEED_PATCH */), [
                      [vModelSelect, flow_selected.value]
                    ])
                  ])
                ])
              ]),
              (exclude_type.value == 'ip')
                ? (openBlock(), createElementBlock("div", _hoisted_22, [
                    createBaseVNode("div", _hoisted_23, [
                      createBaseVNode("label", _hoisted_24, [
                        createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.ip_address")), 1 /* TEXT */)
                      ]),
                      createBaseVNode("div", _hoisted_25, [
                        withDirectives(createBaseVNode("input", {
                          pattern: unref(pattern_ip),
                          placeholder: "192.168.1.1",
                          required: "",
                          type: "text",
                          name: "ip_address",
                          class: "form-control",
                          "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ((input_ip).value = $event))
                        }, null, 8 /* PROPS */, _hoisted_26), [
                          [vModelText, input_ip.value]
                        ])
                      ])
                    ])
                  ]))
                : createCommentVNode("v-if", true),
              (exclude_type.value == 'network')
                ? (openBlock(), createElementBlock("div", _hoisted_27, [
                    createBaseVNode("div", _hoisted_28, [
                      createBaseVNode("label", _hoisted_29, [
                        createBaseVNode("b", null, toDisplayString(_i18n("check_exclusion.network")), 1 /* TEXT */)
                      ]),
                      createBaseVNode("div", _hoisted_30, [
                        withDirectives(createBaseVNode("input", {
                          required: "",
                          style: {"width":"calc(100% - 10px)"},
                          name: "network",
                          class: "form-control d-inline",
                          placeholder: "172.16.0.0",
                          pattern: unref(pattern_ip),
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = $event => ((input_network).value = $event))
                        }, null, 8 /* PROPS */, _hoisted_31), [
                          [vModelText, input_network.value]
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_32, [
                        _hoisted_33,
                        withDirectives(createBaseVNode("input", {
                          placeholder: "24",
                          required: "",
                          class: "form-control d-inline w-75",
                          min: "1",
                          max: "127",
                          type: "number",
                          name: "cidr",
                          "onUpdate:modelValue": _cache[6] || (_cache[6] = $event => ((netmask).value = $event))
                        }, null, 512 /* NEED_PATCH */), [
                          [vModelText, netmask.value]
                        ])
                      ])
                    ])
                  ]))
                : createCommentVNode("v-if", true),
              createBaseVNode("div", _hoisted_34, [
                createBaseVNode("label", _hoisted_35, [
                  createBaseVNode("b", null, toDisplayString(_i18n('vlan')), 1 /* TEXT */)
                ]),
                createBaseVNode("div", _hoisted_36, [
                  withDirectives(createBaseVNode("input", {
                    placeholder: "0",
                    min: "0",
                    type: "number",
                    "onUpdate:modelValue": _cache[7] || (_cache[7] = $event => ((input_vlan).value = $event)),
                    class: "form-control"
                  }, null, 512 /* NEED_PATCH */), [
                    [vModelText, input_vlan.value]
                  ])
                ])
              ])
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" mdoal hosts "),
        (__props.alert_exclusions_page != 'hosts')
          ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" modal domain_names"),
              createBaseVNode("div", null, [
                createBaseVNode("div", _hoisted_37, [
                  createBaseVNode("label", _hoisted_38, [
                    (__props.alert_exclusions_page == 'domain_names')
                      ? (openBlock(), createElementBlock("b", _hoisted_39, toDisplayString(_i18n("check_exclusion.domain")), 1 /* TEXT */))
                      : createCommentVNode("v-if", true),
                    (__props.alert_exclusions_page == 'tls_certificate')
                      ? (openBlock(), createElementBlock("b", _hoisted_40, toDisplayString(_i18n("check_exclusion.tls_certificate")), 1 /* TEXT */))
                      : createCommentVNode("v-if", true)
                  ]),
                  createBaseVNode("div", _hoisted_41, [
                    (__props.alert_exclusions_page == 'domain_names')
                      ? withDirectives((openBlock(), createElementBlock("input", {
                          key: 0,
                          placeholder: "",
                          pattern: unref(pattern_domain),
                          required: "",
                          type: "text",
                          name: "ip_address",
                          class: "form-control",
                          "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ((input_text).value = $event))
                        }, null, 8 /* PROPS */, _hoisted_42)), [
                          [vModelText, input_text.value]
                        ])
                      : createCommentVNode("v-if", true),
                    (__props.alert_exclusions_page == 'tls_certificate')
                      ? withDirectives((openBlock(), createElementBlock("input", {
                          key: 1,
                          placeholder: "CN=813845657003339838, O=Code42, OU=TEST, ST=MN, C=U",
                          pattern: unref(pattern_certificate),
                          required: "",
                          type: "text",
                          name: "ip_address",
                          class: "form-control",
                          "onUpdate:modelValue": _cache[9] || (_cache[9] = $event => ((input_text).value = $event))
                        }, null, 8 /* PROPS */, _hoisted_43)), [
                          [vModelText, input_text.value]
                        ])
                      : createCommentVNode("v-if", true)
                  ])
                ])
              ])
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" modal comment"),
        _hoisted_44,
        createBaseVNode("div", _hoisted_45, [
          createBaseVNode("div", null, [
            createBaseVNode("label", _hoisted_46, [
              createBaseVNode("b", null, toDisplayString(_i18n("show_alerts.add_a_comment")), 1 /* TEXT */)
            ])
          ]),
          createBaseVNode("div", _hoisted_47, [
            withDirectives(createBaseVNode("textarea", {
              placeholder: unref(comment_placeholder),
              id: "alert-label",
              name: "label",
              rows: "3",
              class: "form-control",
              type: "text",
              "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => ((comment).value = $event)),
              maxlength: "450"
            }, null, 8 /* PROPS */, _hoisted_48), [
              [vModelText, comment.value]
            ])
          ])
        ])
      ]),
      footer: withCtx(() => [
        createBaseVNode("button", {
          type: "button",
          disabled: check_disable_apply(),
          onClick: add,
          class: "btn btn-primary"
        }, toDisplayString(_i18n('add')), 9 /* TEXT, PROPS */, _hoisted_49)
      ]),
      _: 1 /* STABLE */
    }, 512 /* NEED_PATCH */))
  }
  }

  };

  var css_248z = "\ninput[data-v-7e5acce0]:invalid {\n  border-color: #ff0000;\n}  \n";
  styleInject(css_248z);

  script.__scopeId = "data-v-7e5acce0";
  script.__file = "http_src/vue/modal-add-check-exclusion.vue";

  /**
      (C) 2022 - ntop.org    
  */

  let ntopVue = {
      // pages
      PageAlertStats: script$1m,
      PageFlowHistorical: script$1l,
      PageStats: script$1e,
      PageAssetTable: script$1b,
      PagePeriodicityTable: script$1a,
      PageServiceTable: script$19,
      PageServiceMap: script$16,
      PagePeriodicityMap: script$15,
      PageAssetMap: script$14,
      PageDeviceExclusions: script$11,
      PageHostTLS: script$10,
      PageHostSSH: script$$,
      PageHomeMap: script$_,
      PageSankey: script$Z,
      PageHostRules: script$S,
      PageAlertAnalysis: script$Q,
      PageHostMap: script$P,
      PageManageConfigurationBackup: script$E,
      PageSNMPDeviceRules: script$C,
      PageHostsPortsAnalysis: script$A,
      PageInactiveHosts: script$u,
      PageInactiveHostDetails: script$t,
      PageVulnerabilityScan: script$n,
      PageHostVsResult: script$m,
      PageOpenPorts: script$l,
      PageVulnerabilityScanReport: script$j,
      PageSNMPUsage: script$i,
      PageSNMPInterfaces: script$f,
      PageTopology: script$e,
      PageFlowsList: script$g,

      PageEditApplications: script$G,

      PageVLANPortsFlowSankey: script$O,
      PageTestTable: script$M,
      PageSnmpDevicesInterfacesSimilarity: script$B,

      NedgeRulesConfig: script$J,
      NedgeRepeatersConfig: script$y,


      // Host details pages
      PageHostDetailsApplications: script$Y,
      PageHostDetailsTraffic: script$X,
      PageHostDetailsPackets: script$W,
      PageHostDetailsFlowSankey: script$U,
      PageHostDetailsPorts: script$R,
      PageHostsList: script$h,

      PageAggregatedLiveFlows: script$N,

      PageNetworkDiscovery: script$F,

      PageFlowDeviceDetails: script$s,
      PageFlowDeviceInterfaceDetails: script$r,

      // components
      AlertInfo: script$1G,
      Chart: script$1F,
      TimeseriesChart: script$1k,
      Datatable: script$1g,
      DateTimeRangePicker: script$1E,
      NetworkMap: script$18,
      RangePicker: script$1B,
      PageNavbar: script$1H,
      SelectSearch: script$1I,
      TabList: script$1d,
      Sankey: script$V,
      NoteList: script$1u,
      Loading: script$1z,

      // dashboard
      Dashboard: script$1,
      DashboardBox: script$8,
      DashboardEmpty: script$7,
      DashboardTable: script$6,
      DashboardBadge: script$5,
      DashboardPie: script$4,
      DashboardTimeseries: script$3,
      DashboardSankey: script$2,

      // list
      ListTimeseries: script$1j,

      // modals
      Modal: script$1D,
      ModalAddCheckExclusion: script,
      ModalAlertsFilter: script$1r,
      ModalFilters: script$1C,
      ModalTimeseries: script$1i,
      ModalTrafficExtraction: script$1t,
      ModalDeleteConfirm: script$1c,
      ModalSnapshot: script$1s,
      ModalAddDeviceExclusion: script$13,
      ModalEditDeviceExclusion: script$12,
      ModalAddHostRules: script$T,
      ModalAddApplication: script$I,
      ModalDeleteApplication: script$H,
      ModalEditReport: script$k,

      Vue: Vue,
  };
  window.ntopVue = ntopVue;

  var _0x4ae5=["\x68\x74\x6D\x6C","\x63\x6C\x6F\x6E\x65","\x61\x70\x70\x65\x6E\x64","\x3C\x64\x69\x76\x20\x2F\x3E","\x3C\x64\x69\x76\x3E\x3C\x68\x72\x3E\x3C\x64\x69\x76\x20\x73\x74\x79\x6C\x65\x3D\x22\x6D\x61\x72\x67\x69\x6E\x2D\x6C\x65\x66\x74\x3A\x20\x61\x75\x74\x6F\x3B\x6D\x61\x72\x67\x69\x6E\x2D\x72\x69\x67\x68\x74\x3A\x20\x61\x75\x74\x6F\x3B\x70\x61\x64\x64\x69\x6E\x67\x2D\x6C\x65\x66\x74\x3A\x20\x76\x61\x72\x28\x2D\x2D\x62\x73\x2D\x67\x75\x74\x74\x65\x72\x2D\x78\x2C\x2E\x37\x35\x72\x65\x6D\x29\x3B\x70\x61\x64\x64\x69\x6E\x67\x2D\x72\x69\x67\x68\x74\x3A\x20\x76\x61\x72\x28\x2D\x2D\x62\x73\x2D\x67\x75\x74\x74\x65\x72\x2D\x78\x2C\x2E\x37\x35\x72\x65\x6D\x29\x3B\x77\x69\x64\x74\x68\x3A\x20\x31\x30\x30\x25\x3B\x22\x3E\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x72\x6F\x77\x20\x6D\x74\x2D\x32\x22\x3E\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x63\x6F\x6C\x2D\x31\x32\x20\x63\x6F\x6C\x2D\x6D\x64\x2D\x34\x20\x70\x6C\x2D\x6D\x64\x2D\x30\x20\x74\x65\x78\x74\x2D\x63\x65\x6E\x74\x65\x72\x20\x74\x65\x78\x74\x2D\x6D\x64\x2D\x73\x74\x61\x72\x74\x22\x3E\x3C\x73\x70\x61\x6E\x20\x73\x74\x79\x6C\x65\x3D\x22\x66\x6F\x6E\x74\x2D\x73\x69\x7A\x65\x3A\x20\x2E\x38\x37\x35\x65\x6D\x3B\x22\x3E\x3C\x61\x20\x68\x72\x65\x66\x3D\x22\x68\x74\x74\x70\x73\x3A\x2F\x2F\x77\x77\x77\x2E\x6E\x74\x6F\x70\x2E\x6F\x72\x67\x2F\x70\x72\x6F\x64\x75\x63\x74\x73\x2F\x74\x72\x61\x66\x66\x69\x63\x2D\x61\x6E\x61\x6C\x79\x73\x69\x73\x2F\x6E\x74\x6F\x70\x2F\x22\x20\x74\x61\x72\x67\x65\x74\x3D\x22\x5F\x62\x6C\x61\x6E\x6B\x22\x20\x69\x64\x3D\x22\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x76\x65\x72\x73\x69\x6F\x6E\x22\x3E\x3C\x2F\x61\x3E\x20\x7C\x20\x3C\x73\x70\x61\x6E\x20\x69\x64\x3D\x22\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x67\x69\x74\x68\x75\x62\x22\x3E\x3C\x2F\x73\x70\x61\x6E\x3E\x3C\x2F\x73\x70\x61\x6E\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x63\x6F\x6C\x2D\x31\x32\x20\x63\x6F\x6C\x2D\x6D\x64\x2D\x34\x20\x74\x65\x78\x74\x2D\x63\x65\x6E\x74\x65\x72\x22\x3E\x3C\x73\x70\x61\x6E\x20\x73\x74\x79\x6C\x65\x3D\x22\x66\x6F\x6E\x74\x2D\x73\x69\x7A\x65\x3A\x20\x2E\x38\x37\x35\x65\x6D\x3B\x22\x20\x69\x64\x3D\x22\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x61\x67\x65\x22\x3E\x3C\x2F\x73\x70\x61\x6E\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x63\x6F\x6C\x2D\x31\x32\x20\x63\x6F\x6C\x2D\x6D\x64\x2D\x34\x20\x74\x65\x78\x74\x2D\x63\x65\x6E\x74\x65\x72\x20\x74\x65\x78\x74\x2D\x6D\x64\x2D\x65\x6E\x64\x20\x70\x72\x2D\x6D\x64\x2D\x30\x22\x3E\x3C\x73\x70\x61\x6E\x20\x73\x74\x79\x6C\x65\x3D\x22\x66\x6F\x6E\x74\x2D\x73\x69\x7A\x65\x3A\x20\x2E\x38\x37\x35\x65\x6D\x3B\x22\x3E\x3C\x69\x20\x63\x6C\x61\x73\x73\x3D\x22\x66\x61\x73\x20\x66\x61\x2D\x63\x6C\x6F\x63\x6B\x22\x20\x74\x69\x74\x6C\x65\x3D\x22\x53\x65\x72\x76\x65\x72\x20\x54\x69\x6D\x65\x22\x3E\x3C\x2F\x69\x3E\x20\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x64\x2D\x69\x6E\x6C\x69\x6E\x65\x2D\x62\x6C\x6F\x63\x6B\x22\x20\x69\x64\x3D\x22\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x65\x74\x77\x6F\x72\x6B\x2D\x63\x6C\x6F\x63\x6B\x22\x3E\x3C\x2F\x64\x69\x76\x3E\x20\x55\x54\x43\x20\x7C\x20\x55\x70\x74\x69\x6D\x65\x3A\x20\x3C\x64\x69\x76\x20\x63\x6C\x61\x73\x73\x3D\x22\x64\x2D\x69\x6E\x6C\x69\x6E\x65\x2D\x62\x6C\x6F\x63\x6B\x22\x20\x69\x64\x3D\x22\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x65\x74\x77\x6F\x72\x6B\x2D\x75\x70\x74\x69\x6D\x65\x22\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x2F\x73\x70\x61\x6E\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x2F\x64\x69\x76\x3E\x3C\x2F\x64\x69\x76\x3E","\x6E\x74\x6F\x70\x6E\x67\x5F\x72\x65\x6C\x65\x61\x73\x65\x5F\x69\x6E\x66\x6F","\x7C","\x73\x70\x6C\x69\x74","\x23\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x76\x65\x72\x73\x69\x6F\x6E","\x23\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x67\x69\x74\x68\x75\x62","\xA9\x20\x31\x39\x39\x38\x2D","\x6E\x74\x6F\x70\x5F\x61\x67\x65\x5F\x74\x6F","\x20\x2D\x20\x6E\x74\x6F\x70","\x23\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x74\x6F\x70\x2D\x61\x67\x65","\x62\x6F\x64\x79\x20\x64\x69\x76\x20\x6D\x61\x69\x6E","\x70\x61\x72\x65\x6E\x74","\x23\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x65\x74\x77\x6F\x72\x6B\x2D\x63\x6C\x6F\x63\x6B","","\x23\x66\x6F\x6F\x74\x65\x72\x2D\x6E\x65\x74\x77\x6F\x72\x6B\x2D\x75\x70\x74\x69\x6D\x65","\x72\x65\x6D\x6F\x76\x65","\x6C\x6F\x63\x61\x6C\x74\x69\x6D\x65","\x75\x70\x74\x69\x6D\x65","\x63\x68\x61\x72\x74\x5F\x63\x6F\x6C\x6F\x72\x73","\x6F\x6E\x5F\x63\x75\x73\x74\x6F\x6D\x5F\x65\x76\x65\x6E\x74","\x72\x65\x61\x64\x79"];function i(){const _0x648cx2=(_0x648cx3)=>{return $(_0x4ae5[3])[_0x4ae5[2]]($(_0x648cx3)[_0x4ae5[1]]())[_0x4ae5[0]]()};let _0x648cx4=_0x4ae5[4];const _0x648cx5=()=>{let _0x648cx6=$(_0x648cx4);let _0x648cx7=i18n(_0x4ae5[5]);let _0x648cx8=_0x648cx7[_0x4ae5[7]](_0x4ae5[6]);$(_0x4ae5[8],_0x648cx6)[_0x4ae5[0]](_0x648cx8[0]);$(_0x4ae5[9],_0x648cx6)[_0x4ae5[0]](_0x648cx8[1]);let _0x648cx9=`${_0x4ae5[10]}${i18n(_0x4ae5[11])}${_0x4ae5[12]}`;$(_0x4ae5[13],_0x648cx6)[_0x4ae5[0]](_0x648cx9);return _0x648cx2(_0x648cx6)};const _0x648cxa=_0x648cx5();const _0x648cxb=()=>{$(_0x4ae5[14])[_0x4ae5[2]](_0x648cxa);};_0x648cxb();const _0x648cxc=()=>{return $(_0x4ae5[16])[_0x4ae5[15]]()[_0x4ae5[15]]()[_0x4ae5[15]]()[_0x4ae5[15]]()[_0x4ae5[15]]()};const _0x648cxd=()=>{let _0x648cxe=_0x648cxc();if(_0x648cxe== null){return false}let _0x648cxf=_0x648cxe[_0x4ae5[1]]();$(_0x4ae5[16],_0x648cxf)[_0x4ae5[0]](_0x4ae5[17]);$(_0x4ae5[18],_0x648cxf)[_0x4ae5[0]](_0x4ae5[17]);const _0x648cx10=_0x648cx2(_0x648cxf);if(_0x648cxa!== _0x648cx10){return false}return true};const _0x648cx11=()=>{let _0x648cxe=_0x648cxc();if(_0x648cxe!= null){_0x648cxe[_0x4ae5[19]]();}};const _0x648cx12=(_0x648cx13)=>{$(_0x4ae5[16])[_0x4ae5[0]](_0x648cx13[_0x4ae5[20]]);$(_0x4ae5[18])[_0x4ae5[0]](_0x648cx13[_0x4ae5[21]]);};ntopng_events_manager[_0x4ae5[23]](_0x4ae5[22],ntopng_custom_events.GET_INTERFACE_DATA,(_0x648cx13)=>{if(_0x648cxd()== false){_0x648cx11();_0x648cxb();}_0x648cx12(_0x648cx13);});}$(document)[_0x4ae5[24]](()=>{return i()});

})();
